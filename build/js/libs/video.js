/**
 * @license
 * Video.js 6.2.8 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/master/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/master/LICENSE>
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.videojs = factory());
}(this, (function () {

var version = "6.2.8";

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};





function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof commonjsGlobal !== "undefined") {
    win = commonjsGlobal;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

var window_1 = win;

var empty = {};


var empty$1 = (Object.freeze || Object)({
	'default': empty
});

var minDoc = ( empty$1 && empty ) || empty$1;

var topLevel = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal :
    typeof window !== 'undefined' ? window : {};


var doccy;

if (typeof document !== 'undefined') {
    doccy = document;
} else {
    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }
}

var document_1 = doccy;

/**
 * @file browser.js
 * @module browser
 */
var USER_AGENT = window_1.navigator && window_1.navigator.userAgent || '';
var webkitVersionMap = /AppleWebKit\/([\d.]+)/i.exec(USER_AGENT);
var appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;

/*
 * Device is an iPhone
 *
 * @type {Boolean}
 * @constant
 * @private
 */
var IS_IPAD = /iPad/i.test(USER_AGENT);

// The Facebook app's UIWebView identifies as both an iPhone and iPad, so
// to identify iPhones, we need to exclude iPads.
// http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/
var IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
var IS_IPOD = /iPod/i.test(USER_AGENT);
var IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;

var IOS_VERSION = function () {
  var match = USER_AGENT.match(/OS (\d+)_/i);

  if (match && match[1]) {
    return match[1];
  }
  return null;
}();

var IS_ANDROID = /Android/i.test(USER_AGENT);
var ANDROID_VERSION = function () {
  // This matches Android Major.Minor.Patch versions
  // ANDROID_VERSION is Major.Minor as a Number, if Minor isn't available, then only Major is returned
  var match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);

  if (!match) {
    return null;
  }

  var major = match[1] && parseFloat(match[1]);
  var minor = match[2] && parseFloat(match[2]);

  if (major && minor) {
    return parseFloat(match[1] + '.' + match[2]);
  } else if (major) {
    return major;
  }
  return null;
}();

// Old Android is defined as Version older than 2.3, and requiring a webkit version of the android browser
var IS_OLD_ANDROID = IS_ANDROID && /webkit/i.test(USER_AGENT) && ANDROID_VERSION < 2.3;
var IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;

var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
var IS_EDGE = /Edge/i.test(USER_AGENT);
var IS_CHROME = !IS_EDGE && /Chrome/i.test(USER_AGENT);
var CHROME_VERSION = function () {
  var match = USER_AGENT.match(/Chrome\/(\d+)/);

  if (match && match[1]) {
    return parseFloat(match[1]);
  }
  return null;
}();
var IS_IE8 = /MSIE\s8\.0/.test(USER_AGENT);
var IE_VERSION = function () {
  var result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
  var version = result && parseFloat(result[1]);

  if (!version && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
    // IE 11 has a different user agent string than other IE versions
    version = 11.0;
  }

  return version;
}();

var IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
var IS_ANY_SAFARI = IS_SAFARI || IS_IOS;

var TOUCH_ENABLED = isReal() && ('ontouchstart' in window_1 || window_1.DocumentTouch && window_1.document instanceof window_1.DocumentTouch);

var BACKGROUND_SIZE_SUPPORTED = isReal() && 'backgroundSize' in window_1.document.createElement('video').style;

var browser = (Object.freeze || Object)({
	IS_IPAD: IS_IPAD,
	IS_IPHONE: IS_IPHONE,
	IS_IPOD: IS_IPOD,
	IS_IOS: IS_IOS,
	IOS_VERSION: IOS_VERSION,
	IS_ANDROID: IS_ANDROID,
	ANDROID_VERSION: ANDROID_VERSION,
	IS_OLD_ANDROID: IS_OLD_ANDROID,
	IS_NATIVE_ANDROID: IS_NATIVE_ANDROID,
	IS_FIREFOX: IS_FIREFOX,
	IS_EDGE: IS_EDGE,
	IS_CHROME: IS_CHROME,
	CHROME_VERSION: CHROME_VERSION,
	IS_IE8: IS_IE8,
	IE_VERSION: IE_VERSION,
	IS_SAFARI: IS_SAFARI,
	IS_ANY_SAFARI: IS_ANY_SAFARI,
	TOUCH_ENABLED: TOUCH_ENABLED,
	BACKGROUND_SIZE_SUPPORTED: BACKGROUND_SIZE_SUPPORTED
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};











var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};











var taggedTemplateLiteralLoose = function (strings, raw) {
  strings.raw = raw;
  return strings;
};

/**
 * @file obj.js
 * @module obj
 */

/**
 * @callback obj:EachCallback
 *
 * @param {Mixed} value
 *        The current key for the object that is being iterated over.
 *
 * @param {string} key
 *        The current key-value for object that is being iterated over
 */

/**
 * @callback obj:ReduceCallback
 *
 * @param {Mixed} accum
 *        The value that is accumulating over the reduce loop.
 *
 * @param {Mixed} value
 *        The current key for the object that is being iterated over.
 *
 * @param {string} key
 *        The current key-value for object that is being iterated over
 *
 * @return {Mixed}
 *         The new accumulated value.
 */
var toString = Object.prototype.toString;

/**
 * Get the keys of an Object
 *
 * @param {Object}
 *        The Object to get the keys from
 *
 * @return {string[]}
 *         An array of the keys from the object. Returns an empty array if the
 *         object passed in was invalid or had no keys.
 *
 * @private
 */
var keys = function keys(object) {
  return isObject(object) ? Object.keys(object) : [];
};

/**
 * Array-like iteration for objects.
 *
 * @param {Object} object
 *        The object to iterate over
 *
 * @param {obj:EachCallback} fn
 *        The callback function which is called for each key in the object.
 */
function each(object, fn) {
  keys(object).forEach(function (key) {
    return fn(object[key], key);
  });
}

/**
 * Array-like reduce for objects.
 *
 * @param {Object} object
 *        The Object that you want to reduce.
 *
 * @param {Function} fn
 *         A callback function which is called for each key in the object. It
 *         receives the accumulated value and the per-iteration value and key
 *         as arguments.
 *
 * @param {Mixed} [initial = 0]
 *        Starting value
 *
 * @return {Mixed}
 *         The final accumulated value.
 */
function reduce(object, fn) {
  var initial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  return keys(object).reduce(function (accum, key) {
    return fn(accum, object[key], key);
  }, initial);
}

/**
 * Object.assign-style object shallow merge/extend.
 *
 * @param  {Object} target
 * @param  {Object} ...sources
 * @return {Object}
 */
function assign(target) {
  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  if (Object.assign) {
    return Object.assign.apply(Object, [target].concat(sources));
  }

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    each(source, function (value, key) {
      target[key] = value;
    });
  });

  return target;
}

/**
 * Returns whether a value is an object of any kind - including DOM nodes,
 * arrays, regular expressions, etc. Not functions, though.
 *
 * This avoids the gotcha where using `typeof` on a `null` value
 * results in `'object'`.
 *
 * @param  {Object} value
 * @return {Boolean}
 */
function isObject(value) {
  return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
}

/**
 * Returns whether an object appears to be a "plain" object - that is, a
 * direct instance of `Object`.
 *
 * @param  {Object} value
 * @return {Boolean}
 */
function isPlain(value) {
  return isObject(value) && toString.call(value) === '[object Object]' && value.constructor === Object;
}

/**
 * @file log.js
 * @module log
 */
var log = void 0;

// This is the private tracking variable for logging level.
var level = 'all';

// This is the private tracking variable for the logging history.
var history = [];

/**
 * Log messages to the console and history based on the type of message
 *
 * @private
 * @param  {string} type
 *         The name of the console method to use.
 *
 * @param  {Array} args
 *         The arguments to be passed to the matching console method.
 *
 * @param  {boolean} [stringify]
 *         By default, only old IEs should get console argument stringification,
 *         but this is exposed as a parameter to facilitate testing.
 */
var logByType = function logByType(type, args) {
  var stringify = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !!IE_VERSION && IE_VERSION < 11;

  var lvl = log.levels[level];
  var lvlRegExp = new RegExp('^(' + lvl + ')$');

  if (type !== 'log') {

    // Add the type to the front of the message when it's not "log".
    args.unshift(type.toUpperCase() + ':');
  }

  // Add a clone of the args at this point to history.
  if (history) {
    history.push([].concat(args));
  }

  // Add console prefix after adding to history.
  args.unshift('VIDEOJS:');

  // If there's no console then don't try to output messages, but they will
  // still be stored in history.
  //
  // Was setting these once outside of this function, but containing them
  // in the function makes it easier to test cases where console doesn't exist
  // when the module is executed.
  var fn = window_1.console && window_1.console[type];

  // Bail out if there's no console or if this type is not allowed by the
  // current logging level.
  if (!fn || !lvl || !lvlRegExp.test(type)) {
    return;
  }

  // IEs previous to 11 log objects uselessly as "[object Object]"; so, JSONify
  // objects and arrays for those less-capable browsers.
  if (stringify) {
    args = args.map(function (a) {
      if (isObject(a) || Array.isArray(a)) {
        try {
          return JSON.stringify(a);
        } catch (x) {
          return String(a);
        }
      }

      // Cast to string before joining, so we get null and undefined explicitly
      // included in output (as we would in a modern console).
      return String(a);
    }).join(' ');
  }

  // Old IE versions do not allow .apply() for console methods (they are
  // reported as objects rather than functions).
  if (!fn.apply) {
    fn(args);
  } else {
    fn[Array.isArray(args) ? 'apply' : 'call'](window_1.console, args);
  }
};

/**
 * Logs plain debug messages. Similar to `console.log`.
 *
 * @class
 * @param    {Mixed[]} args
 *           One or more messages or objects that should be logged.
 */
log = function log() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  logByType('log', args);
};

/**
 * Enumeration of available logging levels, where the keys are the level names
 * and the values are `|`-separated strings containing logging methods allowed
 * in that logging level. These strings are used to create a regular expression
 * matching the function name being called.
 *
 * Levels provided by video.js are:
 *
 * - `off`: Matches no calls. Any value that can be cast to `false` will have
 *   this effect. The most restrictive.
 * - `all` (default): Matches only Video.js-provided functions (`log`,
 *   `log.warn`, and `log.error`).
 * - `warn`: Matches `log.warn` and `log.error` calls.
 * - `error`: Matches only `log.error` calls.
 *
 * @type {Object}
 */
log.levels = {
  all: 'log|warn|error',
  error: 'error',
  off: '',
  warn: 'warn|error',
  DEFAULT: level
};

/**
 * Get or set the current logging level. If a string matching a key from
 * {@link log.levels} is provided, acts as a setter. Regardless of argument,
 * returns the current logging level.
 *
 * @param  {string} [lvl]
 *         Pass to set a new logging level.
 *
 * @return {string}
 *         The current logging level.
 */
log.level = function (lvl) {
  if (typeof lvl === 'string') {
    if (!log.levels.hasOwnProperty(lvl)) {
      throw new Error('"' + lvl + '" in not a valid log level');
    }
    level = lvl;
  }
  return level;
};

/**
 * Returns an array containing everything that has been logged to the history.
 *
 * This array is a shallow clone of the internal history record. However, its
 * contents are _not_ cloned; so, mutating objects inside this array will
 * mutate them in history.
 *
 * @return {Array}
 */
log.history = function () {
  return history ? [].concat(history) : [];
};

/**
 * Clears the internal history tracking, but does not prevent further history
 * tracking.
 */
log.history.clear = function () {
  if (history) {
    history.length = 0;
  }
};

/**
 * Disable history tracking if it is currently enabled.
 */
log.history.disable = function () {
  if (history !== null) {
    history.length = 0;
    history = null;
  }
};

/**
 * Enable history tracking if it is currently disabled.
 */
log.history.enable = function () {
  if (history === null) {
    history = [];
  }
};

/**
 * Logs error messages. Similar to `console.error`.
 *
 * @param {Mixed[]} args
 *        One or more messages or objects that should be logged as an error
 */
log.error = function () {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return logByType('error', args);
};

/**
 * Logs warning messages. Similar to `console.warn`.
 *
 * @param {Mixed[]} args
 *        One or more messages or objects that should be logged as a warning.
 */
log.warn = function () {
  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  return logByType('warn', args);
};

var log$1 = log;

function clean (s) {
  return s.replace(/\n\r?\s*/g, '')
}


var tsml = function tsml (sa) {
  var s = ''
    , i = 0;

  for (; i < arguments.length; i++)
    s += clean(sa[i]) + (arguments[i + 1] || '');

  return s
};

/**
 * @file computed-style.js
 * @module computed-style
 */
/**
 * A safe getComputedStyle with an IE8 fallback.
 *
 * This is needed because in Firefox, if the player is loaded in an iframe with
 * `display:none`, then `getComputedStyle` returns `null`, so, we do a null-check to
 * make sure  that the player doesn't break in these cases.
 *
 * @param {Element} el
 *        The element you want the computed style of
 *
 * @param {string} prop
 *        The property name you want
 *
 * @see https://bugzilla.mozilla.org/show_bug.cgi?id=548397
 *
 * @static
 * @const
 */
function computedStyle(el, prop) {
  if (!el || !prop) {
    return '';
  }

  if (typeof window_1.getComputedStyle === 'function') {
    var cs = window_1.getComputedStyle(el);

    return cs ? cs[prop] : '';
  }

  return el.currentStyle[prop] || '';
}

var _templateObject = taggedTemplateLiteralLoose(['Setting attributes in the second argument of createEl()\n                has been deprecated. Use the third argument instead.\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.'], ['Setting attributes in the second argument of createEl()\n                has been deprecated. Use the third argument instead.\n                createEl(type, properties, attributes). Attempting to set ', ' to ', '.']);

/**
 * @file dom.js
 * @module dom
 */
/**
 * Detect if a value is a string with any non-whitespace characters.
 *
 * @param {string} str
 *        The string to check
 *
 * @return {boolean}
 *         - True if the string is non-blank
 *         - False otherwise
 *
 */
function isNonBlankString(str) {
  return typeof str === 'string' && /\S/.test(str);
}

/**
 * Throws an error if the passed string has whitespace. This is used by
 * class methods to be relatively consistent with the classList API.
 *
 * @param {string} str
 *         The string to check for whitespace.
 *
 * @throws {Error}
 *         Throws an error if there is whitespace in the string.
 *
 */
function throwIfWhitespace(str) {
  if (/\s/.test(str)) {
    throw new Error('class has illegal whitespace characters');
  }
}

/**
 * Produce a regular expression for matching a className within an elements className.
 *
 * @param {string} className
 *         The className to generate the RegExp for.
 *
 * @return {RegExp}
 *         The RegExp that will check for a specific `className` in an elements
 *         className.
 */
function classRegExp(className) {
  return new RegExp('(^|\\s)' + className + '($|\\s)');
}

/**
 * Whether the current DOM interface appears to be real.
 *
 * @return {Boolean}
 */
function isReal() {
  return (

    // Both document and window will never be undefined thanks to `global`.
    document_1 === window_1.document &&

    // In IE < 9, DOM methods return "object" as their type, so all we can
    // confidently check is that it exists.
    typeof document_1.createElement !== 'undefined'
  );
}

/**
 * Determines, via duck typing, whether or not a value is a DOM element.
 *
 * @param {Mixed} value
 *        The thing to check
 *
 * @return {boolean}
 *         - True if it is a DOM element
 *         - False otherwise
 */
function isEl(value) {
  return isObject(value) && value.nodeType === 1;
}

/**
 * Creates functions to query the DOM using a given method.
 *
 * @param {string} method
 *         The method to create the query with.
 *
 * @return {Function}
 *         The query method
 */
function createQuerier(method) {
  return function (selector, context) {
    if (!isNonBlankString(selector)) {
      return document_1[method](null);
    }
    if (isNonBlankString(context)) {
      context = document_1.querySelector(context);
    }

    var ctx = isEl(context) ? context : document_1;

    return ctx[method] && ctx[method](selector);
  };
}

/**
 * Creates an element and applies properties.
 *
 * @param {string} [tagName='div']
 *         Name of tag to be created.
 *
 * @param {Object} [properties={}]
 *         Element properties to be applied.
 *
 * @param {Object} [attributes={}]
 *         Element attributes to be applied.
 *
 * @param {String|Element|TextNode|Array|Function} [content]
 *         Contents for the element (see: {@link dom:normalizeContent})
 *
 * @return {Element}
 *         The element that was created.
 */
function createEl() {
  var tagName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';
  var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var content = arguments[3];

  var el = document_1.createElement(tagName);

  Object.getOwnPropertyNames(properties).forEach(function (propName) {
    var val = properties[propName];

    // See #2176
    // We originally were accepting both properties and attributes in the
    // same object, but that doesn't work so well.
    if (propName.indexOf('aria-') !== -1 || propName === 'role' || propName === 'type') {
      log$1.warn(tsml(_templateObject, propName, val));
      el.setAttribute(propName, val);

      // Handle textContent since it's not supported everywhere and we have a
      // method for it.
    } else if (propName === 'textContent') {
      textContent(el, val);
    } else {
      el[propName] = val;
    }
  });

  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
    el.setAttribute(attrName, attributes[attrName]);
  });

  if (content) {
    appendContent(el, content);
  }

  return el;
}

/**
 * Injects text into an element, replacing any existing contents entirely.
 *
 * @param {Element} el
 *        The element to add text content into
 *
 * @param {string} text
 *        The text content to add.
 *
 * @return {Element}
 *         The element with added text content.
 */
function textContent(el, text) {
  if (typeof el.textContent === 'undefined') {
    el.innerText = text;
  } else {
    el.textContent = text;
  }
  return el;
}

/**
 * Insert an element as the first child node of another
 *
 * @param {Element} child
 *        Element to insert
 *
 * @param {Element} parent
 *        Element to insert child into
 */
function prependTo(child, parent) {
  if (parent.firstChild) {
    parent.insertBefore(child, parent.firstChild);
  } else {
    parent.appendChild(child);
  }
}

/**
 * Check if an element has a CSS class
 *
 * @param {Element} element
 *        Element to check
 *
 * @param {string} classToCheck
 *        Class name to check for
 *
 * @return {boolean}
 *         - True if the element had the class
 *         - False otherwise.
 *
 * @throws {Error}
 *         Throws an error if `classToCheck` has white space.
 */
function hasClass(element, classToCheck) {
  throwIfWhitespace(classToCheck);
  if (element.classList) {
    return element.classList.contains(classToCheck);
  }
  return classRegExp(classToCheck).test(element.className);
}

/**
 * Add a CSS class name to an element
 *
 * @param {Element} element
 *        Element to add class name to.
 *
 * @param {string} classToAdd
 *        Class name to add.
 *
 * @return {Element}
 *         The dom element with the added class name.
 */
function addClass(element, classToAdd) {
  if (element.classList) {
    element.classList.add(classToAdd);

    // Don't need to `throwIfWhitespace` here because `hasElClass` will do it
    // in the case of classList not being supported.
  } else if (!hasClass(element, classToAdd)) {
    element.className = (element.className + ' ' + classToAdd).trim();
  }

  return element;
}

/**
 * Remove a CSS class name from an element
 *
 * @param {Element} element
 *        Element to remove a class name from.
 *
 * @param {string} classToRemove
 *        Class name to remove
 *
 * @return {Element}
 *         The dom element with class name removed.
 */
function removeClass(element, classToRemove) {
  if (element.classList) {
    element.classList.remove(classToRemove);
  } else {
    throwIfWhitespace(classToRemove);
    element.className = element.className.split(/\s+/).filter(function (c) {
      return c !== classToRemove;
    }).join(' ');
  }

  return element;
}

/**
 * The callback definition for toggleElClass.
 *
 * @callback Dom~PredicateCallback
 * @param {Element} element
 *        The DOM element of the Component.
 *
 * @param {string} classToToggle
 *        The `className` that wants to be toggled
 *
 * @return {boolean|undefined}
 *         - If true the `classToToggle` will get added to `element`.
 *         - If false the `classToToggle` will get removed from `element`.
 *         - If undefined this callback will be ignored
 */

/**
 * Adds or removes a CSS class name on an element depending on an optional
 * condition or the presence/absence of the class name.
 *
 * @param {Element} element
 *        The element to toggle a class name on.
 *
 * @param {string} classToToggle
 *        The class that should be toggled
 *
 * @param {boolean|PredicateCallback} [predicate]
 *        See the return value for {@link Dom~PredicateCallback}
 *
 * @return {Element}
 *         The element with a class that has been toggled.
 */
function toggleClass(element, classToToggle, predicate) {

  // This CANNOT use `classList` internally because IE does not support the
  // second parameter to the `classList.toggle()` method! Which is fine because
  // `classList` will be used by the add/remove functions.
  var has = hasClass(element, classToToggle);

  if (typeof predicate === 'function') {
    predicate = predicate(element, classToToggle);
  }

  if (typeof predicate !== 'boolean') {
    predicate = !has;
  }

  // If the necessary class operation matches the current state of the
  // element, no action is required.
  if (predicate === has) {
    return;
  }

  if (predicate) {
    addClass(element, classToToggle);
  } else {
    removeClass(element, classToToggle);
  }

  return element;
}

/**
 * Apply attributes to an HTML element.
 *
 * @param {Element} el
 *        Element to add attributes to.
 *
 * @param {Object} [attributes]
 *        Attributes to be applied.
 */
function setAttributes(el, attributes) {
  Object.getOwnPropertyNames(attributes).forEach(function (attrName) {
    var attrValue = attributes[attrName];

    if (attrValue === null || typeof attrValue === 'undefined' || attrValue === false) {
      el.removeAttribute(attrName);
    } else {
      el.setAttribute(attrName, attrValue === true ? '' : attrValue);
    }
  });
}

/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributes are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 *
 * @param {Element} tag
 *        Element from which to get tag attributes.
 *
 * @return {Object}
 *         All attributes of the element.
 */
function getAttributes(tag) {
  var obj = {};

  // known boolean attributes
  // we can check for matching boolean properties, but older browsers
  // won't know about HTML5 boolean attributes that we still read from
  var knownBooleans = ',' + 'autoplay,controls,playsinline,loop,muted,default,defaultMuted' + ',';

  if (tag && tag.attributes && tag.attributes.length > 0) {
    var attrs = tag.attributes;

    for (var i = attrs.length - 1; i >= 0; i--) {
      var attrName = attrs[i].name;
      var attrVal = attrs[i].value;

      // check for known booleans
      // the matching element property will return a value for typeof
      if (typeof tag[attrName] === 'boolean' || knownBooleans.indexOf(',' + attrName + ',') !== -1) {
        // the value of an included boolean attribute is typically an empty
        // string ('') which would equal false if we just check for a false value.
        // we also don't want support bad code like autoplay='false'
        attrVal = attrVal !== null ? true : false;
      }

      obj[attrName] = attrVal;
    }
  }

  return obj;
}

/**
 * Get the value of an element's attribute
 *
 * @param {Element} el
 *        A DOM element
 *
 * @param {string} attribute
 *        Attribute to get the value of
 *
 * @return {string}
 *         value of the attribute
 */
function getAttribute(el, attribute) {
  return el.getAttribute(attribute);
}

/**
 * Set the value of an element's attribute
 *
 * @param {Element} el
 *        A DOM element
 *
 * @param {string} attribute
 *        Attribute to set
 *
 * @param {string} value
 *        Value to set the attribute to
 */
function setAttribute(el, attribute, value) {
  el.setAttribute(attribute, value);
}

/**
 * Remove an element's attribute
 *
 * @param {Element} el
 *        A DOM element
 *
 * @param {string} attribute
 *        Attribute to remove
 */
function removeAttribute(el, attribute) {
  el.removeAttribute(attribute);
}

/**
 * Attempt to block the ability to select text while dragging controls
 */
function blockTextSelection() {
  document_1.body.focus();
  document_1.onselectstart = function () {
    return false;
  };
}

/**
 * Turn off text selection blocking
 */
function unblockTextSelection() {
  document_1.onselectstart = function () {
    return true;
  };
}

/**
 * Identical to the native `getBoundingClientRect` function, but ensures that
 * the method is supported at all (it is in all browsers we claim to support)
 * and that the element is in the DOM before continuing.
 *
 * This wrapper function also shims properties which are not provided by some
 * older browsers (namely, IE8).
 *
 * Additionally, some browsers do not support adding properties to a
 * `ClientRect`/`DOMRect` object; so, we shallow-copy it with the standard
 * properties (except `x` and `y` which are not widely supported). This helps
 * avoid implementations where keys are non-enumerable.
 *
 * @param  {Element} el
 *         Element whose `ClientRect` we want to calculate.
 *
 * @return {Object|undefined}
 *         Always returns a plain
 */
function getBoundingClientRect(el) {
  if (el && el.getBoundingClientRect && el.parentNode) {
    var rect = el.getBoundingClientRect();
    var result = {};

    ['bottom', 'height', 'left', 'right', 'top', 'width'].forEach(function (k) {
      if (rect[k] !== undefined) {
        result[k] = rect[k];
      }
    });

    if (!result.height) {
      result.height = parseFloat(computedStyle(el, 'height'));
    }

    if (!result.width) {
      result.width = parseFloat(computedStyle(el, 'width'));
    }

    return result;
  }
}

/**
 * The postion of a DOM element on the page.
 *
 * @typedef {Object} module:dom~Position
 *
 * @property {number} left
 *           Pixels to the left
 *
 * @property {number} top
 *           Pixels on top
 */

/**
 * Offset Left.
 * getBoundingClientRect technique from
 * John Resig
 *
 * @see http://ejohn.org/blog/getboundingclientrect-is-awesome/
 *
 * @param {Element} el
 *        Element from which to get offset
 *
 * @return {module:dom~Position}
 *         The position of the element that was passed in.
 */
function findPosition(el) {
  var box = void 0;

  if (el.getBoundingClientRect && el.parentNode) {
    box = el.getBoundingClientRect();
  }

  if (!box) {
    return {
      left: 0,
      top: 0
    };
  }

  var docEl = document_1.documentElement;
  var body = document_1.body;

  var clientLeft = docEl.clientLeft || body.clientLeft || 0;
  var scrollLeft = window_1.pageXOffset || body.scrollLeft;
  var left = box.left + scrollLeft - clientLeft;

  var clientTop = docEl.clientTop || body.clientTop || 0;
  var scrollTop = window_1.pageYOffset || body.scrollTop;
  var top = box.top + scrollTop - clientTop;

  // Android sometimes returns slightly off decimal values, so need to round
  return {
    left: Math.round(left),
    top: Math.round(top)
  };
}

/**
 * x and y coordinates for a dom element or mouse pointer
 *
 * @typedef {Object} Dom~Coordinates
 *
 * @property {number} x
 *           x coordinate in pixels
 *
 * @property {number} y
 *           y coordinate in pixels
 */

/**
 * Get pointer position in element
 * Returns an object with x and y coordinates.
 * The base on the coordinates are the bottom left of the element.
 *
 * @param {Element} el
 *        Element on which to get the pointer position on
 *
 * @param {EventTarget~Event} event
 *        Event object
 *
 * @return {Dom~Coordinates}
 *         A Coordinates object corresponding to the mouse position.
 *
 */
function getPointerPosition(el, event) {
  var position = {};
  var box = findPosition(el);
  var boxW = el.offsetWidth;
  var boxH = el.offsetHeight;

  var boxY = box.top;
  var boxX = box.left;
  var pageY = event.pageY;
  var pageX = event.pageX;

  if (event.changedTouches) {
    pageX = event.changedTouches[0].pageX;
    pageY = event.changedTouches[0].pageY;
  }

  position.y = Math.max(0, Math.min(1, (boxY - pageY + boxH) / boxH));
  position.x = Math.max(0, Math.min(1, (pageX - boxX) / boxW));

  return position;
}

/**
 * Determines, via duck typing, whether or not a value is a text node.
 *
 * @param {Mixed} value
 *        Check if this value is a text node.
 *
 * @return {boolean}
 *         - True if it is a text node
 *         - False otherwise
 */
function isTextNode(value) {
  return isObject(value) && value.nodeType === 3;
}

/**
 * Empties the contents of an element.
 *
 * @param {Element} el
 *        The element to empty children from
 *
 * @return {Element}
 *         The element with no children
 */
function emptyEl(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
  return el;
}

/**
 * Normalizes content for eventual insertion into the DOM.
 *
 * This allows a wide range of content definition methods, but protects
 * from falling into the trap of simply writing to `innerHTML`, which is
 * an XSS concern.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * @param {String|Element|TextNode|Array|Function} content
 *        - String: Normalized into a text node.
 *        - Element/TextNode: Passed through.
 *        - Array: A one-dimensional array of strings, elements, nodes, or functions
 *          (which return single strings, elements, or nodes).
 *        - Function: If the sole argument, is expected to produce a string, element,
 *          node, or array as defined above.
 *
 * @return {Array}
 *         All of the content that was passed in normalized.
 */
function normalizeContent(content) {

  // First, invoke content if it is a function. If it produces an array,
  // that needs to happen before normalization.
  if (typeof content === 'function') {
    content = content();
  }

  // Next up, normalize to an array, so one or many items can be normalized,
  // filtered, and returned.
  return (Array.isArray(content) ? content : [content]).map(function (value) {

    // First, invoke value if it is a function to produce a new value,
    // which will be subsequently normalized to a Node of some kind.
    if (typeof value === 'function') {
      value = value();
    }

    if (isEl(value) || isTextNode(value)) {
      return value;
    }

    if (typeof value === 'string' && /\S/.test(value)) {
      return document_1.createTextNode(value);
    }
  }).filter(function (value) {
    return value;
  });
}

/**
 * Normalizes and appends content to an element.
 *
 * @param {Element} el
 *        Element to append normalized content to.
 *
 *
 * @param {String|Element|TextNode|Array|Function} content
 *        See the `content` argument of {@link dom:normalizeContent}
 *
 * @return {Element}
 *         The element with appended normalized content.
 */
function appendContent(el, content) {
  normalizeContent(content).forEach(function (node) {
    return el.appendChild(node);
  });
  return el;
}

/**
 * Normalizes and inserts content into an element; this is identical to
 * `appendContent()`, except it empties the element first.
 *
 * @param {Element} el
 *        Element to insert normalized content into.
 *
 * @param {String|Element|TextNode|Array|Function} content
 *        See the `content` argument of {@link dom:normalizeContent}
 *
 * @return {Element}
 *         The element with inserted normalized content.
 *
 */
function insertContent(el, content) {
  return appendContent(emptyEl(el), content);
}

/**
 * Finds a single DOM element matching `selector` within the optional
 * `context` of another DOM element (defaulting to `document`).
 *
 * @param {string} selector
 *        A valid CSS selector, which will be passed to `querySelector`.
 *
 * @param {Element|String} [context=document]
 *        A DOM element within which to query. Can also be a selector
 *        string in which case the first matching element will be used
 *        as context. If missing (or no element matches selector), falls
 *        back to `document`.
 *
 * @return {Element|null}
 *         The element that was found or null.
 */
var $ = createQuerier('querySelector');

/**
 * Finds a all DOM elements matching `selector` within the optional
 * `context` of another DOM element (defaulting to `document`).
 *
 * @param {string} selector
 *           A valid CSS selector, which will be passed to `querySelectorAll`.
 *
 * @param {Element|String} [context=document]
 *           A DOM element within which to query. Can also be a selector
 *           string in which case the first matching element will be used
 *           as context. If missing (or no element matches selector), falls
 *           back to `document`.
 *
 * @return {NodeList}
 *         A element list of elements that were found. Will be empty if none were found.
 *
 */
var $$ = createQuerier('querySelectorAll');



var Dom = (Object.freeze || Object)({
	isReal: isReal,
	isEl: isEl,
	createEl: createEl,
	textContent: textContent,
	prependTo: prependTo,
	hasClass: hasClass,
	addClass: addClass,
	removeClass: removeClass,
	toggleClass: toggleClass,
	setAttributes: setAttributes,
	getAttributes: getAttributes,
	getAttribute: getAttribute,
	setAttribute: setAttribute,
	removeAttribute: removeAttribute,
	blockTextSelection: blockTextSelection,
	unblockTextSelection: unblockTextSelection,
	getBoundingClientRect: getBoundingClientRect,
	findPosition: findPosition,
	getPointerPosition: getPointerPosition,
	isTextNode: isTextNode,
	emptyEl: emptyEl,
	normalizeContent: normalizeContent,
	appendContent: appendContent,
	insertContent: insertContent,
	$: $,
	$$: $$
});

/**
 * @file guid.js
 * @module guid
 */

/**
 * Unique ID for an element or function
 * @type {Number}
 */
var _guid = 1;

/**
 * Get a unique auto-incrementing ID by number that has not been returned before.
 *
 * @return {number}
 *         A new unique ID.
 */
function newGUID() {
  return _guid++;
}

/**
 * @file dom-data.js
 * @module dom-data
 */
/**
 * Element Data Store.
 *
 * Allows for binding data to an element without putting it directly on the
 * element. Ex. Event listeners are stored here.
 * (also from jsninja.com, slightly modified and updated for closure compiler)
 *
 * @type {Object}
 * @private
 */
var elData = {};

/*
 * Unique attribute name to store an element's guid in
 *
 * @type {String}
 * @constant
 * @private
 */
var elIdAttr = 'vdata' + new Date().getTime();

/**
 * Returns the cache object where data for an element is stored
 *
 * @param {Element} el
 *        Element to store data for.
 *
 * @return {Object}
 *         The cache object for that el that was passed in.
 */
function getData(el) {
  var id = el[elIdAttr];

  if (!id) {
    id = el[elIdAttr] = newGUID();
  }

  if (!elData[id]) {
    elData[id] = {};
  }

  return elData[id];
}

/**
 * Returns whether or not an element has cached data
 *
 * @param {Element} el
 *        Check if this element has cached data.
 *
 * @return {boolean}
 *         - True if the DOM element has cached data.
 *         - False otherwise.
 */
function hasData(el) {
  var id = el[elIdAttr];

  if (!id) {
    return false;
  }

  return !!Object.getOwnPropertyNames(elData[id]).length;
}

/**
 * Delete data for the element from the cache and the guid attr from getElementById
 *
 * @param {Element} el
 *        Remove cached data for this element.
 */
function removeData(el) {
  var id = el[elIdAttr];

  if (!id) {
    return;
  }

  // Remove all stored data
  delete elData[id];

  // Remove the elIdAttr property from the DOM node
  try {
    delete el[elIdAttr];
  } catch (e) {
    if (el.removeAttribute) {
      el.removeAttribute(elIdAttr);
    } else {
      // IE doesn't appear to support removeAttribute on the document element
      el[elIdAttr] = null;
    }
  }
}

/**
 * @file events.js. An Event System (John Resig - Secrets of a JS Ninja http://jsninja.com/)
 * (Original book version wasn't completely usable, so fixed some things and made Closure Compiler compatible)
 * This should work very similarly to jQuery's events, however it's based off the book version which isn't as
 * robust as jquery's, so there's probably some differences.
 *
 * @module events
 */

/**
 * Clean up the listener cache and dispatchers
 *
 * @param {Element|Object} elem
 *        Element to clean up
 *
 * @param {string} type
 *        Type of event to clean up
 */
function _cleanUpEvents(elem, type) {
  var data = getData(elem);

  // Remove the events of a particular type if there are none left
  if (data.handlers[type].length === 0) {
    delete data.handlers[type];
    // data.handlers[type] = null;
    // Setting to null was causing an error with data.handlers

    // Remove the meta-handler from the element
    if (elem.removeEventListener) {
      elem.removeEventListener(type, data.dispatcher, false);
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + type, data.dispatcher);
    }
  }

  // Remove the events object if there are no types left
  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
    delete data.handlers;
    delete data.dispatcher;
    delete data.disabled;
  }

  // Finally remove the element data if there is no data left
  if (Object.getOwnPropertyNames(data).length === 0) {
    removeData(elem);
  }
}

/**
 * Loops through an array of event types and calls the requested method for each type.
 *
 * @param {Function} fn
 *        The event method we want to use.
 *
 * @param {Element|Object} elem
 *        Element or object to bind listeners to
 *
 * @param {string} type
 *        Type of event to bind to.
 *
 * @param {EventTarget~EventListener} callback
 *        Event listener.
 */
function _handleMultipleEvents(fn, elem, types, callback) {
  types.forEach(function (type) {
    // Call the event method for each one of the types
    fn(elem, type, callback);
  });
}

/**
 * Fix a native event to have standard property values
 *
 * @param {Object} event
 *        Event object to fix.
 *
 * @return {Object}
 *         Fixed event object.
 */
function fixEvent(event) {

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  }

  // Test if fixing up is needed
  // Used to check if !event.stopPropagation instead of isPropagationStopped
  // But native events return true for stopPropagation, but don't have
  // other expected methods like isPropagationStopped. Seems to be a problem
  // with the Javascript Ninja code. So we're just overriding all events now.
  if (!event || !event.isPropagationStopped) {
    var old = event || window_1.event;

    event = {};
    // Clone the old object so that we can modify the values event = {};
    // IE8 Doesn't like when you mess with native event properties
    // Firefox returns false for event.hasOwnProperty('type') and other props
    //  which makes copying more difficult.
    // TODO: Probably best to create a whitelist of event props
    for (var key in old) {
      // Safari 6.0.3 warns you if you try to copy deprecated layerX/Y
      // Chrome warns you if you try to copy deprecated keyboardEvent.keyLocation
      // and webkitMovementX/Y
      if (key !== 'layerX' && key !== 'layerY' && key !== 'keyLocation' && key !== 'webkitMovementX' && key !== 'webkitMovementY') {
        // Chrome 32+ warns if you try to copy deprecated returnValue, but
        // we still want to if preventDefault isn't supported (IE8).
        if (!(key === 'returnValue' && old.preventDefault)) {
          event[key] = old[key];
        }
      }
    }

    // The event occurred on this element
    if (!event.target) {
      event.target = event.srcElement || document_1;
    }

    // Handle which other element the event is related to
    if (!event.relatedTarget) {
      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
    }

    // Stop the default browser action
    event.preventDefault = function () {
      if (old.preventDefault) {
        old.preventDefault();
      }
      event.returnValue = false;
      old.returnValue = false;
      event.defaultPrevented = true;
    };

    event.defaultPrevented = false;

    // Stop the event from bubbling
    event.stopPropagation = function () {
      if (old.stopPropagation) {
        old.stopPropagation();
      }
      event.cancelBubble = true;
      old.cancelBubble = true;
      event.isPropagationStopped = returnTrue;
    };

    event.isPropagationStopped = returnFalse;

    // Stop the event from bubbling and executing other handlers
    event.stopImmediatePropagation = function () {
      if (old.stopImmediatePropagation) {
        old.stopImmediatePropagation();
      }
      event.isImmediatePropagationStopped = returnTrue;
      event.stopPropagation();
    };

    event.isImmediatePropagationStopped = returnFalse;

    // Handle mouse position
    if (event.clientX !== null && event.clientX !== undefined) {
      var doc = document_1.documentElement;
      var body = document_1.body;

      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }

    // Handle key presses
    event.which = event.charCode || event.keyCode;

    // Fix button for mouse clicks:
    // 0 == left; 1 == middle; 2 == right
    if (event.button !== null && event.button !== undefined) {

      // The following is disabled because it does not pass videojs-standard
      // and... yikes.
      /* eslint-disable */
      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
      /* eslint-enable */
    }
  }

  // Returns fixed-up instance
  return event;
}

/**
 * Whether passive event listeners are supported
 */
var _supportsPassive = false;

(function () {
  try {
    var opts = Object.defineProperty({}, 'passive', {
      get: function get() {
        _supportsPassive = true;
      }
    });

    window_1.addEventListener('test', null, opts);
  } catch (e) {
    // disregard
  }
})();

/**
 * Touch events Chrome expects to be passive
 */
var passiveEvents = ['touchstart', 'touchmove'];

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 *
 * @param {Element|Object} elem
 *        Element or object to bind listeners to
 *
 * @param {string|string[]} type
 *        Type of event to bind to.
 *
 * @param {EventTarget~EventListener} fn
 *        Event listener.
 */
function on(elem, type, fn) {
  if (Array.isArray(type)) {
    return _handleMultipleEvents(on, elem, type, fn);
  }

  var data = getData(elem);

  // We need a place to store all our handler data
  if (!data.handlers) {
    data.handlers = {};
  }

  if (!data.handlers[type]) {
    data.handlers[type] = [];
  }

  if (!fn.guid) {
    fn.guid = newGUID();
  }

  data.handlers[type].push(fn);

  if (!data.dispatcher) {
    data.disabled = false;

    data.dispatcher = function (event, hash) {

      if (data.disabled) {
        return;
      }

      event = fixEvent(event);

      var handlers = data.handlers[event.type];

      if (handlers) {
        // Copy handlers so if handlers are added/removed during the process it doesn't throw everything off.
        var handlersCopy = handlers.slice(0);

        for (var m = 0, n = handlersCopy.length; m < n; m++) {
          if (event.isImmediatePropagationStopped()) {
            break;
          } else {
            try {
              handlersCopy[m].call(elem, event, hash);
            } catch (e) {
              log$1.error(e);
            }
          }
        }
      }
    };
  }

  if (data.handlers[type].length === 1) {
    if (elem.addEventListener) {
      var options = false;

      if (_supportsPassive && passiveEvents.indexOf(type) > -1) {
        options = { passive: true };
      }
      elem.addEventListener(type, data.dispatcher, options);
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + type, data.dispatcher);
    }
  }
}

/**
 * Removes event listeners from an element
 *
 * @param {Element|Object} elem
 *        Object to remove listeners from.
 *
 * @param {string|string[]} [type]
 *        Type of listener to remove. Don't include to remove all events from element.
 *
 * @param {EventTarget~EventListener} [fn]
 *        Specific listener to remove. Don't include to remove listeners for an event
 *        type.
 */
function off(elem, type, fn) {
  // Don't want to add a cache object through getElData if not needed
  if (!hasData(elem)) {
    return;
  }

  var data = getData(elem);

  // If no events exist, nothing to unbind
  if (!data.handlers) {
    return;
  }

  if (Array.isArray(type)) {
    return _handleMultipleEvents(off, elem, type, fn);
  }

  // Utility function
  var removeType = function removeType(t) {
    data.handlers[t] = [];
    _cleanUpEvents(elem, t);
  };

  // Are we removing all bound events?
  if (!type) {
    for (var t in data.handlers) {
      removeType(t);
    }
    return;
  }

  var handlers = data.handlers[type];

  // If no handlers exist, nothing to unbind
  if (!handlers) {
    return;
  }

  // If no listener was provided, remove all listeners for type
  if (!fn) {
    removeType(type);
    return;
  }

  // We're only removing a single handler
  if (fn.guid) {
    for (var n = 0; n < handlers.length; n++) {
      if (handlers[n].guid === fn.guid) {
        handlers.splice(n--, 1);
      }
    }
  }

  _cleanUpEvents(elem, type);
}

/**
 * Trigger an event for an element
 *
 * @param {Element|Object} elem
 *        Element to trigger an event on
 *
 * @param {EventTarget~Event|string} event
 *        A string (the type) or an event object with a type attribute
 *
 * @param {Object} [hash]
 *        data hash to pass along with the event
 *
 * @return {boolean|undefined}
 *         - Returns the opposite of `defaultPrevented` if default was prevented
 *         - Otherwise returns undefined
 */
function trigger(elem, event, hash) {
  // Fetches element data and a reference to the parent (for bubbling).
  // Don't want to add a data object to cache for every parent,
  // so checking hasElData first.
  var elemData = hasData(elem) ? getData(elem) : {};
  var parent = elem.parentNode || elem.ownerDocument;
  // type = event.type || event,
  // handler;

  // If an event name was passed as a string, creates an event out of it
  if (typeof event === 'string') {
    event = { type: event, target: elem };
  }
  // Normalizes the event properties.
  event = fixEvent(event);

  // If the passed element has a dispatcher, executes the established handlers.
  if (elemData.dispatcher) {
    elemData.dispatcher.call(elem, event, hash);
  }

  // Unless explicitly stopped or the event does not bubble (e.g. media events)
  // recursively calls this function to bubble the event up the DOM.
  if (parent && !event.isPropagationStopped() && event.bubbles === true) {
    trigger.call(null, parent, event, hash);

    // If at the top of the DOM, triggers the default action unless disabled.
  } else if (!parent && !event.defaultPrevented) {
    var targetData = getData(event.target);

    // Checks if the target has a default action for this event.
    if (event.target[event.type]) {
      // Temporarily disables event dispatching on the target as we have already executed the handler.
      targetData.disabled = true;
      // Executes the default action.
      if (typeof event.target[event.type] === 'function') {
        event.target[event.type]();
      }
      // Re-enables event dispatching.
      targetData.disabled = false;
    }
  }

  // Inform the triggerer if the default was prevented by returning false
  return !event.defaultPrevented;
}

/**
 * Trigger a listener only once for an event
 *
 * @param {Element|Object} elem
 *        Element or object to bind to.
 *
 * @param {string|string[]} type
 *        Name/type of event
 *
 * @param {Event~EventListener} fn
 *        Event Listener function
 */
function one(elem, type, fn) {
  if (Array.isArray(type)) {
    return _handleMultipleEvents(one, elem, type, fn);
  }
  var func = function func() {
    off(elem, type, func);
    fn.apply(this, arguments);
  };

  // copy the guid to the new function so it can removed using the original function's ID
  func.guid = fn.guid = fn.guid || newGUID();
  on(elem, type, func);
}

var Events = (Object.freeze || Object)({
	fixEvent: fixEvent,
	on: on,
	off: off,
	trigger: trigger,
	one: one
});

/**
 * @file setup.js - Functions for setting up a player without
 * user interaction based on the data-setup `attribute` of the video tag.
 *
 * @module setup
 */
var _windowLoaded = false;
var videojs$2 = void 0;

/**
 * Set up any tags that have a data-setup `attribute` when the player is started.
 */
var autoSetup = function autoSetup() {

  // Protect against breakage in non-browser environments.
  if (!isReal()) {
    return;
  }

  // One day, when we stop supporting IE8, go back to this, but in the meantime...*hack hack hack*
  // var vids = Array.prototype.slice.call(document.getElementsByTagName('video'));
  // var audios = Array.prototype.slice.call(document.getElementsByTagName('audio'));
  // var mediaEls = vids.concat(audios);

  // Because IE8 doesn't support calling slice on a node list, we need to loop
  // through each list of elements to build up a new, combined list of elements.
  var vids = document_1.getElementsByTagName('video');
  var audios = document_1.getElementsByTagName('audio');
  var mediaEls = [];

  if (vids && vids.length > 0) {
    for (var i = 0, e = vids.length; i < e; i++) {
      mediaEls.push(vids[i]);
    }
  }

  if (audios && audios.length > 0) {
    for (var _i = 0, _e = audios.length; _i < _e; _i++) {
      mediaEls.push(audios[_i]);
    }
  }

  // Check if any media elements exist
  if (mediaEls && mediaEls.length > 0) {

    for (var _i2 = 0, _e2 = mediaEls.length; _i2 < _e2; _i2++) {
      var mediaEl = mediaEls[_i2];

      // Check if element exists, has getAttribute func.
      // IE seems to consider typeof el.getAttribute == 'object' instead of
      // 'function' like expected, at least when loading the player immediately.
      if (mediaEl && mediaEl.getAttribute) {

        // Make sure this player hasn't already been set up.
        if (mediaEl.player === undefined) {
          var options = mediaEl.getAttribute('data-setup');

          // Check if data-setup attr exists.
          // We only auto-setup if they've added the data-setup attr.
          if (options !== null) {
            // Create new video.js instance.
            videojs$2(mediaEl);
          }
        }

        // If getAttribute isn't defined, we need to wait for the DOM.
      } else {
        autoSetupTimeout(1);
        break;
      }
    }

    // No videos were found, so keep looping unless page is finished loading.
  } else if (!_windowLoaded) {
    autoSetupTimeout(1);
  }
};

/**
 * Wait until the page is loaded before running autoSetup. This will be called in
 * autoSetup if `hasLoaded` returns false.
 *
 * @param {number} wait
 *        How long to wait in ms
 *
 * @param {module:videojs} [vjs]
 *        The videojs library function
 */
function autoSetupTimeout(wait, vjs) {
  if (vjs) {
    videojs$2 = vjs;
  }

  window_1.setTimeout(autoSetup, wait);
}

if (isReal() && document_1.readyState === 'complete') {
  _windowLoaded = true;
} else {
  /**
   * Listen for the load event on window, and set _windowLoaded to true.
   *
   * @listens load
   */
  one(window_1, 'load', function () {
    _windowLoaded = true;
  });
}

/**
 * @file stylesheet.js
 * @module stylesheet
 */
/**
 * Create a DOM syle element given a className for it.
 *
 * @param {string} className
 *        The className to add to the created style element.
 *
 * @return {Element}
 *         The element that was created.
 */
var createStyleElement = function createStyleElement(className) {
  var style = document_1.createElement('style');

  style.className = className;

  return style;
};

/**
 * Add text to a DOM element.
 *
 * @param {Element} el
 *        The Element to add text content to.
 *
 * @param {string} content
 *        The text to add to the element.
 */
var setTextContent = function setTextContent(el, content) {
  if (el.styleSheet) {
    el.styleSheet.cssText = content;
  } else {
    el.textContent = content;
  }
};

/**
 * @file fn.js
 * @module fn
 */
/**
 * Bind (a.k.a proxy or Context). A simple method for changing the context of a function
 * It also stores a unique id on the function so it can be easily removed from events.
 *
 * @param {Mixed} context
 *        The object to bind as scope.
 *
 * @param {Function} fn
 *        The function to be bound to a scope.
 *
 * @param {number} [uid]
 *        An optional unique ID for the function to be set
 *
 * @return {Function}
 *         The new function that will be bound into the context given
 */
var bind = function bind(context, fn, uid) {
  // Make sure the function has a unique ID
  if (!fn.guid) {
    fn.guid = newGUID();
  }

  // Create the new function that changes the context
  var bound = function bound() {
    return fn.apply(context, arguments);
  };

  // Allow for the ability to individualize this function
  // Needed in the case where multiple objects might share the same prototype
  // IF both items add an event listener with the same function, then you try to remove just one
  // it will remove both because they both have the same guid.
  // when using this, you need to use the bind method when you remove the listener as well.
  // currently used in text tracks
  bound.guid = uid ? uid + '_' + fn.guid : fn.guid;

  return bound;
};

/**
 * Wraps the given function, `fn`, with a new function that only invokes `fn`
 * at most once per every `wait` milliseconds.
 *
 * @param  {Function} fn
 *         The function to be throttled.
 *
 * @param  {Number}   wait
 *         The number of milliseconds by which to throttle.
 *
 * @return {Function}
 */
var throttle = function throttle(fn, wait) {
  var last = Date.now();

  var throttled = function throttled() {
    var now = Date.now();

    if (now - last >= wait) {
      fn.apply(undefined, arguments);
      last = now;
    }
  };

  return throttled;
};

/**
 * @file src/js/event-target.js
 */
/**
 * `EventTarget` is a class that can have the same API as the DOM `EventTarget`. It
 * adds shorthand functions that wrap around lengthy functions. For example:
 * the `on` function is a wrapper around `addEventListener`.
 *
 * @see [EventTarget Spec]{@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget}
 * @class EventTarget
 */
var EventTarget = function EventTarget() {};

/**
 * A Custom DOM event.
 *
 * @typedef {Object} EventTarget~Event
 * @see [Properties]{@link https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent}
 */

/**
 * All event listeners should follow the following format.
 *
 * @callback EventTarget~EventListener
 * @this {EventTarget}
 *
 * @param {EventTarget~Event} event
 *        the event that triggered this function
 *
 * @param {Object} [hash]
 *        hash of data sent during the event
 */

/**
 * An object containing event names as keys and booleans as values.
 *
 * > NOTE: If an event name is set to a true value here {@link EventTarget#trigger}
 *         will have extra functionality. See that function for more information.
 *
 * @property EventTarget.prototype.allowedEvents_
 * @private
 */
EventTarget.prototype.allowedEvents_ = {};

/**
 * Adds an `event listener` to an instance of an `EventTarget`. An `event listener` is a
 * function that will get called when an event with a certain name gets triggered.
 *
 * @param {string|string[]} type
 *        An event name or an array of event names.
 *
 * @param {EventTarget~EventListener} fn
 *        The function to call with `EventTarget`s
 */
EventTarget.prototype.on = function (type, fn) {
  // Remove the addEventListener alias before calling Events.on
  // so we don't get into an infinite type loop
  var ael = this.addEventListener;

  this.addEventListener = function () {};
  on(this, type, fn);
  this.addEventListener = ael;
};

/**
 * An alias of {@link EventTarget#on}. Allows `EventTarget` to mimic
 * the standard DOM API.
 *
 * @function
 * @see {@link EventTarget#on}
 */
EventTarget.prototype.addEventListener = EventTarget.prototype.on;

/**
 * Removes an `event listener` for a specific event from an instance of `EventTarget`.
 * This makes it so that the `event listener` will no longer get called when the
 * named event happens.
 *
 * @param {string|string[]} type
 *        An event name or an array of event names.
 *
 * @param {EventTarget~EventListener} fn
 *        The function to remove.
 */
EventTarget.prototype.off = function (type, fn) {
  off(this, type, fn);
};

/**
 * An alias of {@link EventTarget#off}. Allows `EventTarget` to mimic
 * the standard DOM API.
 *
 * @function
 * @see {@link EventTarget#off}
 */
EventTarget.prototype.removeEventListener = EventTarget.prototype.off;

/**
 * This function will add an `event listener` that gets triggered only once. After the
 * first trigger it will get removed. This is like adding an `event listener`
 * with {@link EventTarget#on} that calls {@link EventTarget#off} on itself.
 *
 * @param {string|string[]} type
 *        An event name or an array of event names.
 *
 * @param {EventTarget~EventListener} fn
 *        The function to be called once for each event name.
 */
EventTarget.prototype.one = function (type, fn) {
  // Remove the addEventListener alialing Events.on
  // so we don't get into an infinite type loop
  var ael = this.addEventListener;

  this.addEventListener = function () {};
  one(this, type, fn);
  this.addEventListener = ael;
};

/**
 * This function causes an event to happen. This will then cause any `event listeners`
 * that are waiting for that event, to get called. If there are no `event listeners`
 * for an event then nothing will happen.
 *
 * If the name of the `Event` that is being triggered is in `EventTarget.allowedEvents_`.
 * Trigger will also call the `on` + `uppercaseEventName` function.
 *
 * Example:
 * 'click' is in `EventTarget.allowedEvents_`, so, trigger will attempt to call
 * `onClick` if it exists.
 *
 * @param {string|EventTarget~Event|Object} event
 *        The name of the event, an `Event`, or an object with a key of type set to
 *        an event name.
 */
EventTarget.prototype.trigger = function (event) {
  var type = event.type || event;

  if (typeof event === 'string') {
    event = { type: type };
  }
  event = fixEvent(event);

  if (this.allowedEvents_[type] && this['on' + type]) {
    this['on' + type](event);
  }

  trigger(this, event);
};

/**
 * An alias of {@link EventTarget#trigger}. Allows `EventTarget` to mimic
 * the standard DOM API.
 *
 * @function
 * @see {@link EventTarget#trigger}
 */
EventTarget.prototype.dispatchEvent = EventTarget.prototype.trigger;

/**
 * @file mixins/evented.js
 * @module evented
 */
/**
 * Returns whether or not an object has had the evented mixin applied.
 *
 * @param  {Object} object
 *         An object to test.
 *
 * @return {boolean}
 *         Whether or not the object appears to be evented.
 */
var isEvented = function isEvented(object) {
  return object instanceof EventTarget || !!object.eventBusEl_ && ['on', 'one', 'off', 'trigger'].every(function (k) {
    return typeof object[k] === 'function';
  });
};

/**
 * Whether a value is a valid event type - non-empty string or array.
 *
 * @private
 * @param  {string|Array} type
 *         The type value to test.
 *
 * @return {boolean}
 *         Whether or not the type is a valid event type.
 */
var isValidEventType = function isValidEventType(type) {
  return (
    // The regex here verifies that the `type` contains at least one non-
    // whitespace character.
    typeof type === 'string' && /\S/.test(type) || Array.isArray(type) && !!type.length
  );
};

/**
 * Validates a value to determine if it is a valid event target. Throws if not.
 *
 * @private
 * @throws {Error}
 *         If the target does not appear to be a valid event target.
 *
 * @param  {Object} target
 *         The object to test.
 */
var validateTarget = function validateTarget(target) {
  if (!target.nodeName && !isEvented(target)) {
    throw new Error('Invalid target; must be a DOM node or evented object.');
  }
};

/**
 * Validates a value to determine if it is a valid event target. Throws if not.
 *
 * @private
 * @throws {Error}
 *         If the type does not appear to be a valid event type.
 *
 * @param  {string|Array} type
 *         The type to test.
 */
var validateEventType = function validateEventType(type) {
  if (!isValidEventType(type)) {
    throw new Error('Invalid event type; must be a non-empty string or array.');
  }
};

/**
 * Validates a value to determine if it is a valid listener. Throws if not.
 *
 * @private
 * @throws {Error}
 *         If the listener is not a function.
 *
 * @param  {Function} listener
 *         The listener to test.
 */
var validateListener = function validateListener(listener) {
  if (typeof listener !== 'function') {
    throw new Error('Invalid listener; must be a function.');
  }
};

/**
 * Takes an array of arguments given to `on()` or `one()`, validates them, and
 * normalizes them into an object.
 *
 * @private
 * @param  {Object} self
 *         The evented object on which `on()` or `one()` was called. This
 *         object will be bound as the `this` value for the listener.
 *
 * @param  {Array} args
 *         An array of arguments passed to `on()` or `one()`.
 *
 * @return {Object}
 *         An object containing useful values for `on()` or `one()` calls.
 */
var normalizeListenArgs = function normalizeListenArgs(self, args) {

  // If the number of arguments is less than 3, the target is always the
  // evented object itself.
  var isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;
  var target = void 0;
  var type = void 0;
  var listener = void 0;

  if (isTargetingSelf) {
    target = self.eventBusEl_;

    // Deal with cases where we got 3 arguments, but we are still listening to
    // the evented object itself.
    if (args.length >= 3) {
      args.shift();
    }

    type = args[0];
    listener = args[1];
  } else {
    target = args[0];
    type = args[1];
    listener = args[2];
  }

  validateTarget(target);
  validateEventType(type);
  validateListener(listener);

  listener = bind(self, listener);

  return { isTargetingSelf: isTargetingSelf, target: target, type: type, listener: listener };
};

/**
 * Adds the listener to the event type(s) on the target, normalizing for
 * the type of target.
 *
 * @private
 * @param  {Element|Object} target
 *         A DOM node or evented object.
 *
 * @param  {string} method
 *         The event binding method to use ("on" or "one").
 *
 * @param  {string|Array} type
 *         One or more event type(s).
 *
 * @param  {Function} listener
 *         A listener function.
 */
var listen = function listen(target, method, type, listener) {
  validateTarget(target);

  if (target.nodeName) {
    Events[method](target, type, listener);
  } else {
    target[method](type, listener);
  }
};

/**
 * Contains methods that provide event capabilites to an object which is passed
 * to {@link module:evented|evented}.
 *
 * @mixin EventedMixin
 */
var EventedMixin = {

  /**
   * Add a listener to an event (or events) on this object or another evented
   * object.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  on: function on$$1() {
    var _this = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _normalizeListenArgs = normalizeListenArgs(this, args),
        isTargetingSelf = _normalizeListenArgs.isTargetingSelf,
        target = _normalizeListenArgs.target,
        type = _normalizeListenArgs.type,
        listener = _normalizeListenArgs.listener;

    listen(target, 'on', type, listener);

    // If this object is listening to another evented object.
    if (!isTargetingSelf) {

      // If this object is disposed, remove the listener.
      var removeListenerOnDispose = function removeListenerOnDispose() {
        return _this.off(target, type, listener);
      };

      // Use the same function ID as the listener so we can remove it later it
      // using the ID of the original listener.
      removeListenerOnDispose.guid = listener.guid;

      // Add a listener to the target's dispose event as well. This ensures
      // that if the target is disposed BEFORE this object, we remove the
      // removal listener that was just added. Otherwise, we create a memory leak.
      var removeRemoverOnTargetDispose = function removeRemoverOnTargetDispose() {
        return _this.off('dispose', removeListenerOnDispose);
      };

      // Use the same function ID as the listener so we can remove it later
      // it using the ID of the original listener.
      removeRemoverOnTargetDispose.guid = listener.guid;

      listen(this, 'on', 'dispose', removeListenerOnDispose);
      listen(target, 'on', 'dispose', removeRemoverOnTargetDispose);
    }
  },


  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will only be called once and then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  one: function one$$1() {
    var _this2 = this;

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var _normalizeListenArgs2 = normalizeListenArgs(this, args),
        isTargetingSelf = _normalizeListenArgs2.isTargetingSelf,
        target = _normalizeListenArgs2.target,
        type = _normalizeListenArgs2.type,
        listener = _normalizeListenArgs2.listener;

    // Targeting this evented object.


    if (isTargetingSelf) {
      listen(target, 'one', type, listener);

      // Targeting another evented object.
    } else {
      var wrapper = function wrapper() {
        for (var _len3 = arguments.length, largs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          largs[_key3] = arguments[_key3];
        }

        _this2.off(target, type, wrapper);
        listener.apply(null, largs);
      };

      // Use the same function ID as the listener so we can remove it later
      // it using the ID of the original listener.
      wrapper.guid = listener.guid;
      listen(target, 'one', type, wrapper);
    }
  },


  /**
   * Removes listener(s) from event(s) on an evented object.
   *
   * @param  {string|Array|Element|Object} [targetOrType]
   *         If this is a string or array, it represents the event type(s).
   *
   *         Another evented object can be passed here instead, in which case
   *         ALL 3 arguments are _required_.
   *
   * @param  {string|Array|Function} [typeOrListener]
   *         If the first argument was a string or array, this may be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function; otherwise, _all_ listeners bound to the
   *         event type(s) will be removed.
   */
  off: function off$$1(targetOrType, typeOrListener, listener) {

    // Targeting this evented object.
    if (!targetOrType || isValidEventType(targetOrType)) {
      off(this.eventBusEl_, targetOrType, typeOrListener);

      // Targeting another evented object.
    } else {
      var target = targetOrType;
      var type = typeOrListener;

      // Fail fast and in a meaningful way!
      validateTarget(target);
      validateEventType(type);
      validateListener(listener);

      // Ensure there's at least a guid, even if the function hasn't been used
      listener = bind(this, listener);

      // Remove the dispose listener on this evented object, which was given
      // the same guid as the event listener in on().
      this.off('dispose', listener);

      if (target.nodeName) {
        off(target, type, listener);
        off(target, 'dispose', listener);
      } else if (isEvented(target)) {
        target.off(type, listener);
        target.off('dispose', listener);
      }
    }
  },


  /**
   * Fire an event on this evented object, causing its listeners to be called.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash]
   *          An additional object to pass along to listeners.
   *
   * @returns {boolean}
   *          Whether or not the default behavior was prevented.
   */
  trigger: function trigger$$1(event, hash) {
    return trigger(this.eventBusEl_, event, hash);
  }
};

/**
 * Applies {@link module:evented~EventedMixin|EventedMixin} to a target object.
 *
 * @param  {Object} target
 *         The object to which to add event methods.
 *
 * @param  {Object} [options={}]
 *         Options for customizing the mixin behavior.
 *
 * @param  {String} [options.eventBusKey]
 *         By default, adds a `eventBusEl_` DOM element to the target object,
 *         which is used as an event bus. If the target object already has a
 *         DOM element that should be used, pass its key here.
 *
 * @return {Object}
 *         The target object.
 */
function evented(target) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var eventBusKey = options.eventBusKey;

  // Set or create the eventBusEl_.

  if (eventBusKey) {
    if (!target[eventBusKey].nodeName) {
      throw new Error('The eventBusKey "' + eventBusKey + '" does not refer to an element.');
    }
    target.eventBusEl_ = target[eventBusKey];
  } else {
    target.eventBusEl_ = createEl('span', { className: 'vjs-event-bus' });
  }

  assign(target, EventedMixin);

  // When any evented object is disposed, it removes all its listeners.
  target.on('dispose', function () {
    return target.off();
  });

  return target;
}

/**
 * @file mixins/stateful.js
 * @module stateful
 */
/**
 * Contains methods that provide statefulness to an object which is passed
 * to {@link module:stateful}.
 *
 * @mixin StatefulMixin
 */
var StatefulMixin = {

  /**
   * A hash containing arbitrary keys and values representing the state of
   * the object.
   *
   * @type {Object}
   */
  state: {},

  /**
   * Set the state of an object by mutating its
   * {@link module:stateful~StatefulMixin.state|state} object in place.
   *
   * @fires   module:stateful~StatefulMixin#statechanged
   * @param   {Object|Function} stateUpdates
   *          A new set of properties to shallow-merge into the plugin state.
   *          Can be a plain object or a function returning a plain object.
   *
   * @returns {Object|undefined}
   *          An object containing changes that occurred. If no changes
   *          occurred, returns `undefined`.
   */
  setState: function setState(stateUpdates) {
    var _this = this;

    // Support providing the `stateUpdates` state as a function.
    if (typeof stateUpdates === 'function') {
      stateUpdates = stateUpdates();
    }

    var changes = void 0;

    each(stateUpdates, function (value, key) {

      // Record the change if the value is different from what's in the
      // current state.
      if (_this.state[key] !== value) {
        changes = changes || {};
        changes[key] = {
          from: _this.state[key],
          to: value
        };
      }

      _this.state[key] = value;
    });

    // Only trigger "statechange" if there were changes AND we have a trigger
    // function. This allows us to not require that the target object be an
    // evented object.
    if (changes && isEvented(this)) {

      /**
       * An event triggered on an object that is both
       * {@link module:stateful|stateful} and {@link module:evented|evented}
       * indicating that its state has changed.
       *
       * @event    module:stateful~StatefulMixin#statechanged
       * @type     {Object}
       * @property {Object} changes
       *           A hash containing the properties that were changed and
       *           the values they were changed `from` and `to`.
       */
      this.trigger({
        changes: changes,
        type: 'statechanged'
      });
    }

    return changes;
  }
};

/**
 * Applies {@link module:stateful~StatefulMixin|StatefulMixin} to a target
 * object.
 *
 * If the target object is {@link module:evented|evented} and has a
 * `handleStateChanged` method, that method will be automatically bound to the
 * `statechanged` event on itself.
 *
 * @param   {Object} target
 *          The object to be made stateful.
 *
 * @param   {Object} [defaultState]
 *          A default set of properties to populate the newly-stateful object's
 *          `state` property.
 *
 * @returns {Object}
 *          Returns the `target`.
 */
function stateful(target, defaultState) {
  assign(target, StatefulMixin);

  // This happens after the mixing-in because we need to replace the `state`
  // added in that step.
  target.state = assign({}, target.state, defaultState);

  // Auto-bind the `handleStateChanged` method of the target object if it exists.
  if (typeof target.handleStateChanged === 'function' && isEvented(target)) {
    target.on('statechanged', target.handleStateChanged);
  }

  return target;
}

/**
 * @file to-title-case.js
 * @module to-title-case
 */

/**
 * Uppercase the first letter of a string.
 *
 * @param {string} string
 *        String to be uppercased
 *
 * @return {string}
 *         The string with an uppercased first letter
 */
function toTitleCase(string) {
  if (typeof string !== 'string') {
    return string;
  }

  return string.charAt(0).toUpperCase() + string.slice(1);
}

/**
 * Compares the TitleCase versions of the two strings for equality.
 *
 * @param {string} str1
 *        The first string to compare
 *
 * @param {string} str2
 *        The second string to compare
 *
 * @return {boolean}
 *         Whether the TitleCase versions of the strings are equal
 */
function titleCaseEquals(str1, str2) {
  return toTitleCase(str1) === toTitleCase(str2);
}

/**
 * @file merge-options.js
 * @module merge-options
 */
/**
 * Deep-merge one or more options objects, recursively merging **only** plain
 * object properties.
 *
 * @param   {Object[]} sources
 *          One or more objects to merge into a new object.
 *
 * @returns {Object}
 *          A new object that is the merged result of all sources.
 */
function mergeOptions() {
  var result = {};

  for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }

  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    each(source, function (value, key) {
      if (!isPlain(value)) {
        result[key] = value;
        return;
      }

      if (!isPlain(result[key])) {
        result[key] = {};
      }

      result[key] = mergeOptions(result[key], value);
    });
  });

  return result;
}

/**
 * Player Component - Base class for all UI objects
 *
 * @file component.js
 */
/**
 * Base class for all UI Components.
 * Components are UI objects which represent both a javascript object and an element
 * in the DOM. They can be children of other components, and can have
 * children themselves.
 *
 * Components can also use methods from {@link EventTarget}
 */

var Component = function () {

  /**
   * A callback that is called when a component is ready. Does not have any
   * paramters and any callback value will be ignored.
   *
   * @callback Component~ReadyCallback
   * @this Component
   */

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Object[]} [options.children]
   *        An array of children objects to intialize this component with. Children objects have
   *        a name property that will be used if more than one component of the same type needs to be
   *        added.
   *
   * @param {Component~ReadyCallback} [ready]
   *        Function that gets called when the `Component` is ready.
   */
  function Component(player, options, ready) {
    classCallCheck(this, Component);


    // The component might be the player itself and we can't pass `this` to super
    if (!player && this.play) {
      this.player_ = player = this; // eslint-disable-line
    } else {
      this.player_ = player;
    }

    // Make a copy of prototype.options_ to protect against overriding defaults
    this.options_ = mergeOptions({}, this.options_);

    // Updated options with supplied options
    options = this.options_ = mergeOptions(this.options_, options);

    // Get ID from options or options element if one is supplied
    this.id_ = options.id || options.el && options.el.id;

    // If there was no ID from the options, generate one
    if (!this.id_) {
      // Don't require the player ID function in the case of mock players
      var id = player && player.id && player.id() || 'no_player';

      this.id_ = id + '_component_' + newGUID();
    }

    this.name_ = options.name || null;

    // Create element if one wasn't provided in options
    if (options.el) {
      this.el_ = options.el;
    } else if (options.createEl !== false) {
      this.el_ = this.createEl();
    }

    // Make this an evented object and use `el_`, if available, as its event bus
    evented(this, { eventBusKey: this.el_ ? 'el_' : null });
    stateful(this, this.constructor.defaultState);

    this.children_ = [];
    this.childIndex_ = {};
    this.childNameIndex_ = {};

    // Add any child components in options
    if (options.initChildren !== false) {
      this.initChildren();
    }

    this.ready(ready);
    // Don't want to trigger ready here or it will before init is actually
    // finished for all children that run this constructor

    if (options.reportTouchActivity !== false) {
      this.enableTouchActivity();
    }
  }

  /**
   * Dispose of the `Component` and all child components.
   *
   * @fires Component#dispose
   */


  Component.prototype.dispose = function dispose() {

    /**
     * Triggered when a `Component` is disposed.
     *
     * @event Component#dispose
     * @type {EventTarget~Event}
     *
     * @property {boolean} [bubbles=false]
     *           set to false so that the close event does not
     *           bubble up
     */
    this.trigger({ type: 'dispose', bubbles: false });

    // Dispose all children.
    if (this.children_) {
      for (var i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i].dispose) {
          this.children_[i].dispose();
        }
      }
    }

    // Delete child references
    this.children_ = null;
    this.childIndex_ = null;
    this.childNameIndex_ = null;

    if (this.el_) {
      // Remove element from DOM
      if (this.el_.parentNode) {
        this.el_.parentNode.removeChild(this.el_);
      }

      removeData(this.el_);
      this.el_ = null;
    }
  };

  /**
   * Return the {@link Player} that the `Component` has attached to.
   *
   * @return {Player}
   *         The player that this `Component` has attached to.
   */


  Component.prototype.player = function player() {
    return this.player_;
  };

  /**
   * Deep merge of options objects with new options.
   * > Note: When both `obj` and `options` contain properties whose values are objects.
   *         The two properties get merged using {@link module:mergeOptions}
   *
   * @param {Object} obj
   *        The object that contains new options.
   *
   * @return {Object}
   *         A new object of `this.options_` and `obj` merged together.
   *
   * @deprecated since version 5
   */


  Component.prototype.options = function options(obj) {
    log$1.warn('this.options() has been deprecated and will be moved to the constructor in 6.0');

    if (!obj) {
      return this.options_;
    }

    this.options_ = mergeOptions(this.options_, obj);
    return this.options_;
  };

  /**
   * Get the `Component`s DOM element
   *
   * @return {Element}
   *         The DOM element for this `Component`.
   */


  Component.prototype.el = function el() {
    return this.el_;
  };

  /**
   * Create the `Component`s DOM element.
   *
   * @param {string} [tagName]
   *        Element's DOM node type. e.g. 'div'
   *
   * @param {Object} [properties]
   *        An object of properties that should be set.
   *
   * @param {Object} [attributes]
   *        An object of attributes that should be set.
   *
   * @return {Element}
   *         The element that gets created.
   */


  Component.prototype.createEl = function createEl$$1(tagName, properties, attributes) {
    return createEl(tagName, properties, attributes);
  };

  /**
   * Localize a string given the string in english.
   *
   * If tokens are provided, it'll try and run a simple token replacement on the provided string.
   * The tokens it loooks for look like `{1}` with the index being 1-indexed into the tokens array.
   *
   * If a `defaultValue` is provided, it'll use that over `string`,
   * if a value isn't found in provided language files.
   * This is useful if you want to have a descriptive key for token replacement
   * but have a succinct localized string and not require `en.json` to be included.
   *
   * Currently, it is used for the progress bar timing.
   * ```js
   * {
   *   "progress bar timing: currentTime={1} duration={2}": "{1} of {2}"
   * }
   * ```
   * It is then used like so:
   * ```js
   * this.localize('progress bar timing: currentTime={1} duration{2}',
   *               [this.player_.currentTime(), this.player_.duration()],
   *               '{1} of {2}');
   * ```
   *
   * Which outputs something like: `01:23 of 24:56`.
   *
   *
   * @param {string} string
   *        The string to localize and the key to lookup in the language files.
   * @param {string[]} [tokens]
   *        If the current item has token replacements, provide the tokens here.
   * @param {string} [defaultValue]
   *        Defaults to `string`. Can be a default value to use for token replacement
   *        if the lookup key is needed to be separate.
   *
   * @return {string}
   *         The localized string or if no localization exists the english string.
   */


  Component.prototype.localize = function localize(string, tokens) {
    var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : string;

    var code = this.player_.language && this.player_.language();
    var languages = this.player_.languages && this.player_.languages();
    var language = languages && languages[code];
    var primaryCode = code && code.split('-')[0];
    var primaryLang = languages && languages[primaryCode];

    var localizedString = defaultValue;

    if (language && language[string]) {
      localizedString = language[string];
    } else if (primaryLang && primaryLang[string]) {
      localizedString = primaryLang[string];
    }

    if (tokens) {
      localizedString = localizedString.replace(/\{(\d+)\}/g, function (match, index) {
        var value = tokens[index - 1];
        var ret = value;

        if (typeof value === 'undefined') {
          ret = match;
        }

        return ret;
      });
    }

    return localizedString;
  };

  /**
   * Return the `Component`s DOM element. This is where children get inserted.
   * This will usually be the the same as the element returned in {@link Component#el}.
   *
   * @return {Element}
   *         The content element for this `Component`.
   */


  Component.prototype.contentEl = function contentEl() {
    return this.contentEl_ || this.el_;
  };

  /**
   * Get this `Component`s ID
   *
   * @return {string}
   *         The id of this `Component`
   */


  Component.prototype.id = function id() {
    return this.id_;
  };

  /**
   * Get the `Component`s name. The name gets used to reference the `Component`
   * and is set during registration.
   *
   * @return {string}
   *         The name of this `Component`.
   */


  Component.prototype.name = function name() {
    return this.name_;
  };

  /**
   * Get an array of all child components
   *
   * @return {Array}
   *         The children
   */


  Component.prototype.children = function children() {
    return this.children_;
  };

  /**
   * Returns the child `Component` with the given `id`.
   *
   * @param {string} id
   *        The id of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The child `Component` with the given `id` or undefined.
   */


  Component.prototype.getChildById = function getChildById(id) {
    return this.childIndex_[id];
  };

  /**
   * Returns the child `Component` with the given `name`.
   *
   * @param {string} name
   *        The name of the child `Component` to get.
   *
   * @return {Component|undefined}
   *         The child `Component` with the given `name` or undefined.
   */


  Component.prototype.getChild = function getChild(name) {
    if (!name) {
      return;
    }

    name = toTitleCase(name);

    return this.childNameIndex_[name];
  };

  /**
   * Add a child `Component` inside the current `Component`.
   *
   *
   * @param {string|Component} child
   *        The name or instance of a child to add.
   *
   * @param {Object} [options={}]
   *        The key/value store of options that will get passed to children of
   *        the child.
   *
   * @param {number} [index=this.children_.length]
   *        The index to attempt to add a child into.
   *
   * @return {Component}
   *         The `Component` that gets added as a child. When using a string the
   *         `Component` will get created by this process.
   */


  Component.prototype.addChild = function addChild(child) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.children_.length;

    var component = void 0;
    var componentName = void 0;

    // If child is a string, create component with options
    if (typeof child === 'string') {
      componentName = toTitleCase(child);

      var componentClassName = options.componentClass || componentName;

      // Set name through options
      options.name = componentName;

      // Create a new object & element for this controls set
      // If there's no .player_, this is a player
      var ComponentClass = Component.getComponent(componentClassName);

      if (!ComponentClass) {
        throw new Error('Component ' + componentClassName + ' does not exist');
      }

      // data stored directly on the videojs object may be
      // misidentified as a component to retain
      // backwards-compatibility with 4.x. check to make sure the
      // component class can be instantiated.
      if (typeof ComponentClass !== 'function') {
        return null;
      }

      component = new ComponentClass(this.player_ || this, options);

      // child is a component instance
    } else {
      component = child;
    }

    this.children_.splice(index, 0, component);

    if (typeof component.id === 'function') {
      this.childIndex_[component.id()] = component;
    }

    // If a name wasn't used to create the component, check if we can use the
    // name function of the component
    componentName = componentName || component.name && toTitleCase(component.name());

    if (componentName) {
      this.childNameIndex_[componentName] = component;
    }

    // Add the UI object's element to the container div (box)
    // Having an element is not required
    if (typeof component.el === 'function' && component.el()) {
      var childNodes = this.contentEl().children;
      var refNode = childNodes[index] || null;

      this.contentEl().insertBefore(component.el(), refNode);
    }

    // Return so it can stored on parent object if desired.
    return component;
  };

  /**
   * Remove a child `Component` from this `Component`s list of children. Also removes
   * the child `Component`s element from this `Component`s element.
   *
   * @param {Component} component
   *        The child `Component` to remove.
   */


  Component.prototype.removeChild = function removeChild(component) {
    if (typeof component === 'string') {
      component = this.getChild(component);
    }

    if (!component || !this.children_) {
      return;
    }

    var childFound = false;

    for (var i = this.children_.length - 1; i >= 0; i--) {
      if (this.children_[i] === component) {
        childFound = true;
        this.children_.splice(i, 1);
        break;
      }
    }

    if (!childFound) {
      return;
    }

    this.childIndex_[component.id()] = null;
    this.childNameIndex_[component.name()] = null;

    var compEl = component.el();

    if (compEl && compEl.parentNode === this.contentEl()) {
      this.contentEl().removeChild(component.el());
    }
  };

  /**
   * Add and initialize default child `Component`s based upon options.
   */


  Component.prototype.initChildren = function initChildren() {
    var _this = this;

    var children = this.options_.children;

    if (children) {
      // `this` is `parent`
      var parentOptions = this.options_;

      var handleAdd = function handleAdd(child) {
        var name = child.name;
        var opts = child.opts;

        // Allow options for children to be set at the parent options
        // e.g. videojs(id, { controlBar: false });
        // instead of videojs(id, { children: { controlBar: false });
        if (parentOptions[name] !== undefined) {
          opts = parentOptions[name];
        }

        // Allow for disabling default components
        // e.g. options['children']['posterImage'] = false
        if (opts === false) {
          return;
        }

        // Allow options to be passed as a simple boolean if no configuration
        // is necessary.
        if (opts === true) {
          opts = {};
        }

        // We also want to pass the original player options
        // to each component as well so they don't need to
        // reach back into the player for options later.
        opts.playerOptions = _this.options_.playerOptions;

        // Create and add the child component.
        // Add a direct reference to the child by name on the parent instance.
        // If two of the same component are used, different names should be supplied
        // for each
        var newChild = _this.addChild(name, opts);

        if (newChild) {
          _this[name] = newChild;
        }
      };

      // Allow for an array of children details to passed in the options
      var workingChildren = void 0;
      var Tech = Component.getComponent('Tech');

      if (Array.isArray(children)) {
        workingChildren = children;
      } else {
        workingChildren = Object.keys(children);
      }

      workingChildren
      // children that are in this.options_ but also in workingChildren  would
      // give us extra children we do not want. So, we want to filter them out.
      .concat(Object.keys(this.options_).filter(function (child) {
        return !workingChildren.some(function (wchild) {
          if (typeof wchild === 'string') {
            return child === wchild;
          }
          return child === wchild.name;
        });
      })).map(function (child) {
        var name = void 0;
        var opts = void 0;

        if (typeof child === 'string') {
          name = child;
          opts = children[name] || _this.options_[name] || {};
        } else {
          name = child.name;
          opts = child;
        }

        return { name: name, opts: opts };
      }).filter(function (child) {
        // we have to make sure that child.name isn't in the techOrder since
        // techs are registerd as Components but can't aren't compatible
        // See https://github.com/videojs/video.js/issues/2772
        var c = Component.getComponent(child.opts.componentClass || toTitleCase(child.name));

        return c && !Tech.isTech(c);
      }).forEach(handleAdd);
    }
  };

  /**
   * Builds the default DOM class name. Should be overriden by sub-components.
   *
   * @return {string}
   *         The DOM class name for this object.
   *
   * @abstract
   */


  Component.prototype.buildCSSClass = function buildCSSClass() {
    // Child classes can include a function that does:
    // return 'CLASS NAME' + this._super();
    return '';
  };

  /**
   * Bind a listener to the component's ready state.
   * Different from event listeners in that if the ready event has already happened
   * it will trigger the function immediately.
   *
   * @return {Component}
   *         Returns itself; method can be chained.
   */


  Component.prototype.ready = function ready(fn) {
    var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (fn) {
      if (this.isReady_) {
        if (sync) {
          fn.call(this);
        } else {
          // Call the function asynchronously by default for consistency
          this.setTimeout(fn, 1);
        }
      } else {
        this.readyQueue_ = this.readyQueue_ || [];
        this.readyQueue_.push(fn);
      }
    }
  };

  /**
   * Trigger all the ready listeners for this `Component`.
   *
   * @fires Component#ready
   */


  Component.prototype.triggerReady = function triggerReady() {
    this.isReady_ = true;

    // Ensure ready is triggerd asynchronously
    this.setTimeout(function () {
      var readyQueue = this.readyQueue_;

      // Reset Ready Queue
      this.readyQueue_ = [];

      if (readyQueue && readyQueue.length > 0) {
        readyQueue.forEach(function (fn) {
          fn.call(this);
        }, this);
      }

      // Allow for using event listeners also
      /**
       * Triggered when a `Component` is ready.
       *
       * @event Component#ready
       * @type {EventTarget~Event}
       */
      this.trigger('ready');
    }, 1);
  };

  /**
   * Find a single DOM element matching a `selector`. This can be within the `Component`s
   * `contentEl()` or another custom context.
   *
   * @param {string} selector
   *        A valid CSS selector, which will be passed to `querySelector`.
   *
   * @param {Element|string} [context=this.contentEl()]
   *        A DOM element within which to query. Can also be a selector string in
   *        which case the first matching element will get used as context. If
   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
   *        nothing it falls back to `document`.
   *
   * @return {Element|null}
   *         the dom element that was found, or null
   *
   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
   */


  Component.prototype.$ = function $$$1(selector, context) {
    return $(selector, context || this.contentEl());
  };

  /**
   * Finds all DOM element matching a `selector`. This can be within the `Component`s
   * `contentEl()` or another custom context.
   *
   * @param {string} selector
   *        A valid CSS selector, which will be passed to `querySelectorAll`.
   *
   * @param {Element|string} [context=this.contentEl()]
   *        A DOM element within which to query. Can also be a selector string in
   *        which case the first matching element will get used as context. If
   *        missing `this.contentEl()` gets used. If  `this.contentEl()` returns
   *        nothing it falls back to `document`.
   *
   * @return {NodeList}
   *         a list of dom elements that were found
   *
   * @see [Information on CSS Selectors](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Getting_Started/Selectors)
   */


  Component.prototype.$$ = function $$$$1(selector, context) {
    return $$(selector, context || this.contentEl());
  };

  /**
   * Check if a component's element has a CSS class name.
   *
   * @param {string} classToCheck
   *        CSS class name to check.
   *
   * @return {boolean}
   *         - True if the `Component` has the class.
   *         - False if the `Component` does not have the class`
   */


  Component.prototype.hasClass = function hasClass$$1(classToCheck) {
    return hasClass(this.el_, classToCheck);
  };

  /**
   * Add a CSS class name to the `Component`s element.
   *
   * @param {string} classToAdd
   *        CSS class name to add
   */


  Component.prototype.addClass = function addClass$$1(classToAdd) {
    addClass(this.el_, classToAdd);
  };

  /**
   * Remove a CSS class name from the `Component`s element.
   *
   * @param {string} classToRemove
   *        CSS class name to remove
   */


  Component.prototype.removeClass = function removeClass$$1(classToRemove) {
    removeClass(this.el_, classToRemove);
  };

  /**
   * Add or remove a CSS class name from the component's element.
   * - `classToToggle` gets added when {@link Component#hasClass} would return false.
   * - `classToToggle` gets removed when {@link Component#hasClass} would return true.
   *
   * @param  {string} classToToggle
   *         The class to add or remove based on (@link Component#hasClass}
   *
   * @param  {boolean|Dom~predicate} [predicate]
   *         An {@link Dom~predicate} function or a boolean
   */


  Component.prototype.toggleClass = function toggleClass$$1(classToToggle, predicate) {
    toggleClass(this.el_, classToToggle, predicate);
  };

  /**
   * Show the `Component`s element if it is hidden by removing the
   * 'vjs-hidden' class name from it.
   */


  Component.prototype.show = function show() {
    this.removeClass('vjs-hidden');
  };

  /**
   * Hide the `Component`s element if it is currently showing by adding the
   * 'vjs-hidden` class name to it.
   */


  Component.prototype.hide = function hide() {
    this.addClass('vjs-hidden');
  };

  /**
   * Lock a `Component`s element in its visible state by adding the 'vjs-lock-showing'
   * class name to it. Used during fadeIn/fadeOut.
   *
   * @private
   */


  Component.prototype.lockShowing = function lockShowing() {
    this.addClass('vjs-lock-showing');
  };

  /**
   * Unlock a `Component`s element from its visible state by removing the 'vjs-lock-showing'
   * class name from it. Used during fadeIn/fadeOut.
   *
   * @private
   */


  Component.prototype.unlockShowing = function unlockShowing() {
    this.removeClass('vjs-lock-showing');
  };

  /**
   * Get the value of an attribute on the `Component`s element.
   *
   * @param {string} attribute
   *        Name of the attribute to get the value from.
   *
   * @return {string|null}
   *         - The value of the attribute that was asked for.
   *         - Can be an empty string on some browsers if the attribute does not exist
   *           or has no value
   *         - Most browsers will return null if the attibute does not exist or has
   *           no value.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute}
   */


  Component.prototype.getAttribute = function getAttribute$$1(attribute) {
    return getAttribute(this.el_, attribute);
  };

  /**
   * Set the value of an attribute on the `Component`'s element
   *
   * @param {string} attribute
   *        Name of the attribute to set.
   *
   * @param {string} value
   *        Value to set the attribute to.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute}
   */


  Component.prototype.setAttribute = function setAttribute$$1(attribute, value) {
    setAttribute(this.el_, attribute, value);
  };

  /**
   * Remove an attribute from the `Component`s element.
   *
   * @param {string} attribute
   *        Name of the attribute to remove.
   *
   * @see [DOM API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute}
   */


  Component.prototype.removeAttribute = function removeAttribute$$1(attribute) {
    removeAttribute(this.el_, attribute);
  };

  /**
   * Get or set the width of the component based upon the CSS styles.
   * See {@link Component#dimension} for more detailed information.
   *
   * @param {number|string} [num]
   *        The width that you want to set postfixed with '%', 'px' or nothing.
   *
   * @param {boolean} [skipListeners]
   *        Skip the componentresize event trigger
   *
   * @return {number|string}
   *         The width when getting, zero if there is no width. Can be a string
   *           postpixed with '%' or 'px'.
   */


  Component.prototype.width = function width(num, skipListeners) {
    return this.dimension('width', num, skipListeners);
  };

  /**
   * Get or set the height of the component based upon the CSS styles.
   * See {@link Component#dimension} for more detailed information.
   *
   * @param {number|string} [num]
   *        The height that you want to set postfixed with '%', 'px' or nothing.
   *
   * @param {boolean} [skipListeners]
   *        Skip the componentresize event trigger
   *
   * @return {number|string}
   *         The width when getting, zero if there is no width. Can be a string
   *         postpixed with '%' or 'px'.
   */


  Component.prototype.height = function height(num, skipListeners) {
    return this.dimension('height', num, skipListeners);
  };

  /**
   * Set both the width and height of the `Component` element at the same time.
   *
   * @param  {number|string} width
   *         Width to set the `Component`s element to.
   *
   * @param  {number|string} height
   *         Height to set the `Component`s element to.
   */


  Component.prototype.dimensions = function dimensions(width, height) {
    // Skip componentresize listeners on width for optimization
    this.width(width, true);
    this.height(height);
  };

  /**
   * Get or set width or height of the `Component` element. This is the shared code
   * for the {@link Component#width} and {@link Component#height}.
   *
   * Things to know:
   * - If the width or height in an number this will return the number postfixed with 'px'.
   * - If the width/height is a percent this will return the percent postfixed with '%'
   * - Hidden elements have a width of 0 with `window.getComputedStyle`. This function
   *   defaults to the `Component`s `style.width` and falls back to `window.getComputedStyle`.
   *   See [this]{@link http://www.foliotek.com/devblog/getting-the-width-of-a-hidden-element-with-jquery-using-width/}
   *   for more information
   * - If you want the computed style of the component, use {@link Component#currentWidth}
   *   and {@link {Component#currentHeight}
   *
   * @fires Component#componentresize
   *
   * @param {string} widthOrHeight
   8        'width' or 'height'
   *
   * @param  {number|string} [num]
   8         New dimension
   *
   * @param  {boolean} [skipListeners]
   *         Skip componentresize event trigger
   *
   * @return {number}
   *         The dimension when getting or 0 if unset
   */


  Component.prototype.dimension = function dimension(widthOrHeight, num, skipListeners) {
    if (num !== undefined) {
      // Set to zero if null or literally NaN (NaN !== NaN)
      if (num === null || num !== num) {
        num = 0;
      }

      // Check if using css width/height (% or px) and adjust
      if (('' + num).indexOf('%') !== -1 || ('' + num).indexOf('px') !== -1) {
        this.el_.style[widthOrHeight] = num;
      } else if (num === 'auto') {
        this.el_.style[widthOrHeight] = '';
      } else {
        this.el_.style[widthOrHeight] = num + 'px';
      }

      // skipListeners allows us to avoid triggering the resize event when setting both width and height
      if (!skipListeners) {
        /**
         * Triggered when a component is resized.
         *
         * @event Component#componentresize
         * @type {EventTarget~Event}
         */
        this.trigger('componentresize');
      }

      return;
    }

    // Not setting a value, so getting it
    // Make sure element exists
    if (!this.el_) {
      return 0;
    }

    // Get dimension value from style
    var val = this.el_.style[widthOrHeight];
    var pxIndex = val.indexOf('px');

    if (pxIndex !== -1) {
      // Return the pixel value with no 'px'
      return parseInt(val.slice(0, pxIndex), 10);
    }

    // No px so using % or no style was set, so falling back to offsetWidth/height
    // If component has display:none, offset will return 0
    // TODO: handle display:none and no dimension style using px
    return parseInt(this.el_['offset' + toTitleCase(widthOrHeight)], 10);
  };

  /**
   * Get the width or the height of the `Component` elements computed style. Uses
   * `window.getComputedStyle`.
   *
   * @param {string} widthOrHeight
   *        A string containing 'width' or 'height'. Whichever one you want to get.
   *
   * @return {number}
   *         The dimension that gets asked for or 0 if nothing was set
   *         for that dimension.
   */


  Component.prototype.currentDimension = function currentDimension(widthOrHeight) {
    var computedWidthOrHeight = 0;

    if (widthOrHeight !== 'width' && widthOrHeight !== 'height') {
      throw new Error('currentDimension only accepts width or height value');
    }

    if (typeof window_1.getComputedStyle === 'function') {
      var computedStyle = window_1.getComputedStyle(this.el_);

      computedWidthOrHeight = computedStyle.getPropertyValue(widthOrHeight) || computedStyle[widthOrHeight];
    }

    // remove 'px' from variable and parse as integer
    computedWidthOrHeight = parseFloat(computedWidthOrHeight);

    // if the computed value is still 0, it's possible that the browser is lying
    // and we want to check the offset values.
    // This code also runs on IE8 and wherever getComputedStyle doesn't exist.
    if (computedWidthOrHeight === 0) {
      var rule = 'offset' + toTitleCase(widthOrHeight);

      computedWidthOrHeight = this.el_[rule];
    }

    return computedWidthOrHeight;
  };

  /**
   * An object that contains width and height values of the `Component`s
   * computed style. Uses `window.getComputedStyle`.
   *
   * @typedef {Object} Component~DimensionObject
   *
   * @property {number} width
   *           The width of the `Component`s computed style.
   *
   * @property {number} height
   *           The height of the `Component`s computed style.
   */

  /**
   * Get an object that contains width and height values of the `Component`s
   * computed style.
   *
   * @return {Component~DimensionObject}
   *         The dimensions of the components element
   */


  Component.prototype.currentDimensions = function currentDimensions() {
    return {
      width: this.currentDimension('width'),
      height: this.currentDimension('height')
    };
  };

  /**
   * Get the width of the `Component`s computed style. Uses `window.getComputedStyle`.
   *
   * @return {number} width
   *           The width of the `Component`s computed style.
   */


  Component.prototype.currentWidth = function currentWidth() {
    return this.currentDimension('width');
  };

  /**
   * Get the height of the `Component`s computed style. Uses `window.getComputedStyle`.
   *
   * @return {number} height
   *           The height of the `Component`s computed style.
   */


  Component.prototype.currentHeight = function currentHeight() {
    return this.currentDimension('height');
  };

  /**
   * Set the focus to this component
   */


  Component.prototype.focus = function focus() {
    this.el_.focus();
  };

  /**
   * Remove the focus from this component
   */


  Component.prototype.blur = function blur() {
    this.el_.blur();
  };

  /**
   * Emit a 'tap' events when touch event support gets detected. This gets used to
   * support toggling the controls through a tap on the video. They get enabled
   * because every sub-component would have extra overhead otherwise.
   *
   * @private
   * @fires Component#tap
   * @listens Component#touchstart
   * @listens Component#touchmove
   * @listens Component#touchleave
   * @listens Component#touchcancel
   * @listens Component#touchend
    */


  Component.prototype.emitTapEvents = function emitTapEvents() {
    // Track the start time so we can determine how long the touch lasted
    var touchStart = 0;
    var firstTouch = null;

    // Maximum movement allowed during a touch event to still be considered a tap
    // Other popular libs use anywhere from 2 (hammer.js) to 15,
    // so 10 seems like a nice, round number.
    var tapMovementThreshold = 10;

    // The maximum length a touch can be while still being considered a tap
    var touchTimeThreshold = 200;

    var couldBeTap = void 0;

    this.on('touchstart', function (event) {
      // If more than one finger, don't consider treating this as a click
      if (event.touches.length === 1) {
        // Copy pageX/pageY from the object
        firstTouch = {
          pageX: event.touches[0].pageX,
          pageY: event.touches[0].pageY
        };
        // Record start time so we can detect a tap vs. "touch and hold"
        touchStart = new Date().getTime();
        // Reset couldBeTap tracking
        couldBeTap = true;
      }
    });

    this.on('touchmove', function (event) {
      // If more than one finger, don't consider treating this as a click
      if (event.touches.length > 1) {
        couldBeTap = false;
      } else if (firstTouch) {
        // Some devices will throw touchmoves for all but the slightest of taps.
        // So, if we moved only a small distance, this could still be a tap
        var xdiff = event.touches[0].pageX - firstTouch.pageX;
        var ydiff = event.touches[0].pageY - firstTouch.pageY;
        var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);

        if (touchDistance > tapMovementThreshold) {
          couldBeTap = false;
        }
      }
    });

    var noTap = function noTap() {
      couldBeTap = false;
    };

    // TODO: Listen to the original target. http://youtu.be/DujfpXOKUp8?t=13m8s
    this.on('touchleave', noTap);
    this.on('touchcancel', noTap);

    // When the touch ends, measure how long it took and trigger the appropriate
    // event
    this.on('touchend', function (event) {
      firstTouch = null;
      // Proceed only if the touchmove/leave/cancel event didn't happen
      if (couldBeTap === true) {
        // Measure how long the touch lasted
        var touchTime = new Date().getTime() - touchStart;

        // Make sure the touch was less than the threshold to be considered a tap
        if (touchTime < touchTimeThreshold) {
          // Don't let browser turn this into a click
          event.preventDefault();
          /**
           * Triggered when a `Component` is tapped.
           *
           * @event Component#tap
           * @type {EventTarget~Event}
           */
          this.trigger('tap');
          // It may be good to copy the touchend event object and change the
          // type to tap, if the other event properties aren't exact after
          // Events.fixEvent runs (e.g. event.target)
        }
      }
    });
  };

  /**
   * This function reports user activity whenever touch events happen. This can get
   * turned off by any sub-components that wants touch events to act another way.
   *
   * Report user touch activity when touch events occur. User activity gets used to
   * determine when controls should show/hide. It is simple when it comes to mouse
   * events, because any mouse event should show the controls. So we capture mouse
   * events that bubble up to the player and report activity when that happens.
   * With touch events it isn't as easy as `touchstart` and `touchend` toggle player
   * controls. So touch events can't help us at the player level either.
   *
   * User activity gets checked asynchronously. So what could happen is a tap event
   * on the video turns the controls off. Then the `touchend` event bubbles up to
   * the player. Which, if it reported user activity, would turn the controls right
   * back on. We also don't want to completely block touch events from bubbling up.
   * Furthermore a `touchmove` event and anything other than a tap, should not turn
   * controls back on.
   *
   * @listens Component#touchstart
   * @listens Component#touchmove
   * @listens Component#touchend
   * @listens Component#touchcancel
   */


  Component.prototype.enableTouchActivity = function enableTouchActivity() {
    // Don't continue if the root player doesn't support reporting user activity
    if (!this.player() || !this.player().reportUserActivity) {
      return;
    }

    // listener for reporting that the user is active
    var report = bind(this.player(), this.player().reportUserActivity);

    var touchHolding = void 0;

    this.on('touchstart', function () {
      report();
      // For as long as the they are touching the device or have their mouse down,
      // we consider them active even if they're not moving their finger or mouse.
      // So we want to continue to update that they are active
      this.clearInterval(touchHolding);
      // report at the same interval as activityCheck
      touchHolding = this.setInterval(report, 250);
    });

    var touchEnd = function touchEnd(event) {
      report();
      // stop the interval that maintains activity if the touch is holding
      this.clearInterval(touchHolding);
    };

    this.on('touchmove', report);
    this.on('touchend', touchEnd);
    this.on('touchcancel', touchEnd);
  };

  /**
   * A callback that has no parameters and is bound into `Component`s context.
   *
   * @callback Component~GenericCallback
   * @this Component
   */

  /**
   * Creates a function that runs after an `x` millisecond timeout. This function is a
   * wrapper around `window.setTimeout`. There are a few reasons to use this one
   * instead though:
   * 1. It gets cleared via  {@link Component#clearTimeout} when
   *    {@link Component#dispose} gets called.
   * 2. The function callback will gets turned into a {@link Component~GenericCallback}
   *
   * > Note: You can use `window.clearTimeout` on the id returned by this function. This
   *         will cause its dispose listener not to get cleaned up! Please use
   *         {@link Component#clearTimeout} or {@link Component#dispose}.
   *
   * @param {Component~GenericCallback} fn
   *        The function that will be run after `timeout`.
   *
   * @param {number} timeout
   *        Timeout in milliseconds to delay before executing the specified function.
   *
   * @return {number}
   *         Returns a timeout ID that gets used to identify the timeout. It can also
   *         get used in {@link Component#clearTimeout} to clear the timeout that
   *         was set.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout}
   */


  Component.prototype.setTimeout = function setTimeout(fn, timeout) {
    fn = bind(this, fn);

    var timeoutId = window_1.setTimeout(fn, timeout);
    var disposeFn = function disposeFn() {
      this.clearTimeout(timeoutId);
    };

    disposeFn.guid = 'vjs-timeout-' + timeoutId;

    this.on('dispose', disposeFn);

    return timeoutId;
  };

  /**
   * Clears a timeout that gets created via `window.setTimeout` or
   * {@link Component#setTimeout}. If you set a timeout via {@link Component#setTimeout}
   * use this function instead of `window.clearTimout`. If you don't your dispose
   * listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} timeoutId
   *        The id of the timeout to clear. The return value of
   *        {@link Component#setTimeout} or `window.setTimeout`.
   *
   * @return {number}
   *         Returns the timeout id that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearTimeout}
   */


  Component.prototype.clearTimeout = function clearTimeout(timeoutId) {
    window_1.clearTimeout(timeoutId);

    var disposeFn = function disposeFn() {};

    disposeFn.guid = 'vjs-timeout-' + timeoutId;

    this.off('dispose', disposeFn);

    return timeoutId;
  };

  /**
   * Creates a function that gets run every `x` milliseconds. This function is a wrapper
   * around `window.setInterval`. There are a few reasons to use this one instead though.
   * 1. It gets cleared via  {@link Component#clearInterval} when
   *    {@link Component#dispose} gets called.
   * 2. The function callback will be a {@link Component~GenericCallback}
   *
   * @param {Component~GenericCallback} fn
   *        The function to run every `x` seconds.
   *
   * @param {number} interval
   *        Execute the specified function every `x` milliseconds.
   *
   * @return {number}
   *         Returns an id that can be used to identify the interval. It can also be be used in
   *         {@link Component#clearInterval} to clear the interval.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval}
   */


  Component.prototype.setInterval = function setInterval(fn, interval) {
    fn = bind(this, fn);

    var intervalId = window_1.setInterval(fn, interval);

    var disposeFn = function disposeFn() {
      this.clearInterval(intervalId);
    };

    disposeFn.guid = 'vjs-interval-' + intervalId;

    this.on('dispose', disposeFn);

    return intervalId;
  };

  /**
   * Clears an interval that gets created via `window.setInterval` or
   * {@link Component#setInterval}. If you set an inteval via {@link Component#setInterval}
   * use this function instead of `window.clearInterval`. If you don't your dispose
   * listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} intervalId
   *        The id of the interval to clear. The return value of
   *        {@link Component#setInterval} or `window.setInterval`.
   *
   * @return {number}
   *         Returns the interval id that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval}
   */


  Component.prototype.clearInterval = function clearInterval(intervalId) {
    window_1.clearInterval(intervalId);

    var disposeFn = function disposeFn() {};

    disposeFn.guid = 'vjs-interval-' + intervalId;

    this.off('dispose', disposeFn);

    return intervalId;
  };

  /**
   * Queues up a callback to be passed to requestAnimationFrame (rAF), but
   * with a few extra bonuses:
   *
   * - Supports browsers that do not support rAF by falling back to
   *   {@link Component#setTimeout}.
   *
   * - The callback is turned into a {@link Component~GenericCallback} (i.e.
   *   bound to the component).
   *
   * - Automatic cancellation of the rAF callback is handled if the component
   *   is disposed before it is called.
   *
   * @param  {Component~GenericCallback} fn
   *         A function that will be bound to this component and executed just
   *         before the browser's next repaint.
   *
   * @return {number}
   *         Returns an rAF ID that gets used to identify the timeout. It can
   *         also be used in {@link Component#cancelAnimationFrame} to cancel
   *         the animation frame callback.
   *
   * @listens Component#dispose
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}
   */


  Component.prototype.requestAnimationFrame = function requestAnimationFrame(fn) {
    var _this2 = this;

    if (this.supportsRaf_) {
      fn = bind(this, fn);

      var id = window_1.requestAnimationFrame(fn);
      var disposeFn = function disposeFn() {
        return _this2.cancelAnimationFrame(id);
      };

      disposeFn.guid = 'vjs-raf-' + id;
      this.on('dispose', disposeFn);

      return id;
    }

    // Fall back to using a timer.
    return this.setTimeout(fn, 1000 / 60);
  };

  /**
   * Cancels a queued callback passed to {@link Component#requestAnimationFrame}
   * (rAF).
   *
   * If you queue an rAF callback via {@link Component#requestAnimationFrame},
   * use this function instead of `window.cancelAnimationFrame`. If you don't,
   * your dispose listener will not get cleaned up until {@link Component#dispose}!
   *
   * @param {number} id
   *        The rAF ID to clear. The return value of {@link Component#requestAnimationFrame}.
   *
   * @return {number}
   *         Returns the rAF ID that was cleared.
   *
   * @see [Similar to]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}
   */


  Component.prototype.cancelAnimationFrame = function cancelAnimationFrame(id) {
    if (this.supportsRaf_) {
      window_1.cancelAnimationFrame(id);

      var disposeFn = function disposeFn() {};

      disposeFn.guid = 'vjs-raf-' + id;

      this.off('dispose', disposeFn);

      return id;
    }

    // Fall back to using a timer.
    return this.clearTimeout(id);
  };

  /**
   * Register a `Component` with `videojs` given the name and the component.
   *
   * > NOTE: {@link Tech}s should not be registered as a `Component`. {@link Tech}s
   *         should be registered using {@link Tech.registerTech} or
   *         {@link videojs:videojs.registerTech}.
   *
   * > NOTE: This function can also be seen on videojs as
   *         {@link videojs:videojs.registerComponent}.
   *
   * @param {string} name
   *        The name of the `Component` to register.
   *
   * @param {Component} ComponentToRegister
   *        The `Component` class to register.
   *
   * @return {Component}
   *         The `Component` that was registered.
   */


  Component.registerComponent = function registerComponent(name, ComponentToRegister) {
    if (typeof name !== 'string' || !name) {
      throw new Error('Illegal component name, "' + name + '"; must be a non-empty string.');
    }

    var Tech = Component.getComponent('Tech');

    // We need to make sure this check is only done if Tech has been registered.
    var isTech = Tech && Tech.isTech(ComponentToRegister);
    var isComp = Component === ComponentToRegister || Component.prototype.isPrototypeOf(ComponentToRegister.prototype);

    if (isTech || !isComp) {
      var reason = void 0;

      if (isTech) {
        reason = 'techs must be registered using Tech.registerTech()';
      } else {
        reason = 'must be a Component subclass';
      }

      throw new Error('Illegal component, "' + name + '"; ' + reason + '.');
    }

    name = toTitleCase(name);

    if (!Component.components_) {
      Component.components_ = {};
    }

    var Player = Component.getComponent('Player');

    if (name === 'Player' && Player && Player.players) {
      var players = Player.players;
      var playerNames = Object.keys(players);

      // If we have players that were disposed, then their name will still be
      // in Players.players. So, we must loop through and verify that the value
      // for each item is not null. This allows registration of the Player component
      // after all players have been disposed or before any were created.
      if (players && playerNames.length > 0 && playerNames.map(function (pname) {
        return players[pname];
      }).every(Boolean)) {
        throw new Error('Can not register Player component after player has been created.');
      }
    }

    Component.components_[name] = ComponentToRegister;

    return ComponentToRegister;
  };

  /**
   * Get a `Component` based on the name it was registered with.
   *
   * @param {string} name
   *        The Name of the component to get.
   *
   * @return {Component}
   *         The `Component` that got registered under the given name.
   *
   * @deprecated In `videojs` 6 this will not return `Component`s that were not
   *             registered using {@link Component.registerComponent}. Currently we
   *             check the global `videojs` object for a `Component` name and
   *             return that if it exists.
   */


  Component.getComponent = function getComponent(name) {
    if (!name) {
      return;
    }

    name = toTitleCase(name);

    if (Component.components_ && Component.components_[name]) {
      return Component.components_[name];
    }
  };

  return Component;
}();

/**
 * Whether or not this component supports `requestAnimationFrame`.
 *
 * This is exposed primarily for testing purposes.
 *
 * @private
 * @type {Boolean}
 */


Component.prototype.supportsRaf_ = typeof window_1.requestAnimationFrame === 'function' && typeof window_1.cancelAnimationFrame === 'function';

Component.registerComponent('Component', Component);

/**
 * @file time-ranges.js
 * @module time-ranges
 */

/**
 * Returns the time for the specified index at the start or end
 * of a TimeRange object.
 *
 * @function time-ranges:indexFunction
 *
 * @param {number} [index=0]
 *        The range number to return the time for.
 *
 * @return {number}
 *         The time that offset at the specified index.
 *
 * @depricated index must be set to a value, in the future this will throw an error.
 */

/**
 * An object that contains ranges of time for various reasons.
 *
 * @typedef {Object} TimeRange
 *
 * @property {number} length
 *           The number of time ranges represented by this Object
 *
 * @property {time-ranges:indexFunction} start
 *           Returns the time offset at which a specified time range begins.
 *
 * @property {time-ranges:indexFunction} end
 *           Returns the time offset at which a specified time range begins.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TimeRanges
 */

/**
 * Check if any of the time ranges are over the maximum index.
 *
 * @param {string} fnName
 *        The function name to use for logging
 *
 * @param {number} index
 *        The index to check
 *
 * @param {number} maxIndex
 *        The maximum possible index
 *
 * @throws {Error} if the timeRanges provided are over the maxIndex
 */
function rangeCheck(fnName, index, maxIndex) {
  if (typeof index !== 'number' || index < 0 || index > maxIndex) {
    throw new Error('Failed to execute \'' + fnName + '\' on \'TimeRanges\': The index provided (' + index + ') is non-numeric or out of bounds (0-' + maxIndex + ').');
  }
}

/**
 * Check if any of the time ranges are over the maximum index.
 *
 * @param {string} fnName
 *        The function name to use for logging
 *
 * @param {string} valueIndex
 *        The proprety that should be used to get the time. should be 'start' or 'end'
 *
 * @param {Array} ranges
 *        An array of time ranges
 *
 * @param {Array} [rangeIndex=0]
 *        The index to start the search at
 *
 * @return {number}
 *         The time that offset at the specified index.
 *
 *
 * @depricated rangeIndex must be set to a value, in the future this will throw an error.
 * @throws {Error} if rangeIndex is more than the length of ranges
 */
function getRange(fnName, valueIndex, ranges, rangeIndex) {
  rangeCheck(fnName, rangeIndex, ranges.length - 1);
  return ranges[rangeIndex][valueIndex];
}

/**
 * Create a time range object givent ranges of time.
 *
 * @param {Array} [ranges]
 *        An array of time ranges.
 */
function createTimeRangesObj(ranges) {
  if (ranges === undefined || ranges.length === 0) {
    return {
      length: 0,
      start: function start() {
        throw new Error('This TimeRanges object is empty');
      },
      end: function end() {
        throw new Error('This TimeRanges object is empty');
      }
    };
  }
  return {
    length: ranges.length,
    start: getRange.bind(null, 'start', 0, ranges),
    end: getRange.bind(null, 'end', 1, ranges)
  };
}

/**
 * Should create a fake `TimeRange` object which mimics an HTML5 time range instance.
 *
 * @param {number|Array} start
 *        The start of a single range or an array of ranges
 *
 * @param {number} end
 *        The end of a single range.
 *
 * @private
 */
function createTimeRanges(start, end) {
  if (Array.isArray(start)) {
    return createTimeRangesObj(start);
  } else if (start === undefined || end === undefined) {
    return createTimeRangesObj();
  }
  return createTimeRangesObj([[start, end]]);
}

/**
 * @file buffer.js
 * @module buffer
 */
/**
 * Compute the percentage of the media that has been buffered.
 *
 * @param {TimeRange} buffered
 *        The current `TimeRange` object representing buffered time ranges
 *
 * @param {number} duration
 *        Total duration of the media
 *
 * @return {number}
 *         Percent buffered of the total duration in decimal form.
 */
function bufferedPercent(buffered, duration) {
  var bufferedDuration = 0;
  var start = void 0;
  var end = void 0;

  if (!duration) {
    return 0;
  }

  if (!buffered || !buffered.length) {
    buffered = createTimeRanges(0, 0);
  }

  for (var i = 0; i < buffered.length; i++) {
    start = buffered.start(i);
    end = buffered.end(i);

    // buffered end can be bigger than duration by a very small fraction
    if (end > duration) {
      end = duration;
    }

    bufferedDuration += end - start;
  }

  return bufferedDuration / duration;
}

/**
 * @file fullscreen-api.js
 * @module fullscreen-api
 * @private
 */
/**
 * Store the browser-specific methods for the fullscreen API.
 *
 * @type {Object}
 * @see [Specification]{@link https://fullscreen.spec.whatwg.org}
 * @see [Map Approach From Screenfull.js]{@link https://github.com/sindresorhus/screenfull.js}
 */
var FullscreenApi = {};

// browser API methods
var apiMap = [['requestFullscreen', 'exitFullscreen', 'fullscreenElement', 'fullscreenEnabled', 'fullscreenchange', 'fullscreenerror'],
// WebKit
['webkitRequestFullscreen', 'webkitExitFullscreen', 'webkitFullscreenElement', 'webkitFullscreenEnabled', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Old WebKit (Safari 5.1)
['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitCurrentFullScreenElement', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitfullscreenerror'],
// Mozilla
['mozRequestFullScreen', 'mozCancelFullScreen', 'mozFullScreenElement', 'mozFullScreenEnabled', 'mozfullscreenchange', 'mozfullscreenerror'],
// Microsoft
['msRequestFullscreen', 'msExitFullscreen', 'msFullscreenElement', 'msFullscreenEnabled', 'MSFullscreenChange', 'MSFullscreenError']];

var specApi = apiMap[0];
var browserApi = void 0;

// determine the supported set of functions
for (var i = 0; i < apiMap.length; i++) {
  // check for exitFullscreen function
  if (apiMap[i][1] in document_1) {
    browserApi = apiMap[i];
    break;
  }
}

// map the browser API names to the spec API names
if (browserApi) {
  for (var _i = 0; _i < browserApi.length; _i++) {
    FullscreenApi[specApi[_i]] = browserApi[_i];
  }
}

/**
 * @file media-error.js
 */
/**
 * A Custom `MediaError` class which mimics the standard HTML5 `MediaError` class.
 *
 * @param {number|string|Object|MediaError} value
 *        This can be of multiple types:
 *        - number: should be a standard error code
 *        - string: an error message (the code will be 0)
 *        - Object: arbitrary properties
 *        - `MediaError` (native): used to populate a video.js `MediaError` object
 *        - `MediaError` (video.js): will return itself if it's already a
 *          video.js `MediaError` object.
 *
 * @see [MediaError Spec]{@link https://dev.w3.org/html5/spec-author-view/video.html#mediaerror}
 * @see [Encrypted MediaError Spec]{@link https://www.w3.org/TR/2013/WD-encrypted-media-20130510/#error-codes}
 *
 * @class MediaError
 */
function MediaError(value) {

  // Allow redundant calls to this constructor to avoid having `instanceof`
  // checks peppered around the code.
  if (value instanceof MediaError) {
    return value;
  }

  if (typeof value === 'number') {
    this.code = value;
  } else if (typeof value === 'string') {
    // default code is zero, so this is a custom error
    this.message = value;
  } else if (isObject(value)) {

    // We assign the `code` property manually because native `MediaError` objects
    // do not expose it as an own/enumerable property of the object.
    if (typeof value.code === 'number') {
      this.code = value.code;
    }

    assign(this, value);
  }

  if (!this.message) {
    this.message = MediaError.defaultMessages[this.code] || '';
  }
}

/**
 * The error code that refers two one of the defined `MediaError` types
 *
 * @type {Number}
 */
MediaError.prototype.code = 0;

/**
 * An optional message that to show with the error. Message is not part of the HTML5
 * video spec but allows for more informative custom errors.
 *
 * @type {String}
 */
MediaError.prototype.message = '';

/**
 * An optional status code that can be set by plugins to allow even more detail about
 * the error. For example a plugin might provide a specific HTTP status code and an
 * error message for that code. Then when the plugin gets that error this class will
 * know how to display an error message for it. This allows a custom message to show
 * up on the `Player` error overlay.
 *
 * @type {Array}
 */
MediaError.prototype.status = null;

/**
 * Errors indexed by the W3C standard. The order **CANNOT CHANGE**! See the
 * specification listed under {@link MediaError} for more information.
 *
 * @enum {array}
 * @readonly
 * @property {string} 0 - MEDIA_ERR_CUSTOM
 * @property {string} 1 - MEDIA_ERR_CUSTOM
 * @property {string} 2 - MEDIA_ERR_ABORTED
 * @property {string} 3 - MEDIA_ERR_NETWORK
 * @property {string} 4 - MEDIA_ERR_SRC_NOT_SUPPORTED
 * @property {string} 5 - MEDIA_ERR_ENCRYPTED
 */
MediaError.errorTypes = ['MEDIA_ERR_CUSTOM', 'MEDIA_ERR_ABORTED', 'MEDIA_ERR_NETWORK', 'MEDIA_ERR_DECODE', 'MEDIA_ERR_SRC_NOT_SUPPORTED', 'MEDIA_ERR_ENCRYPTED'];

/**
 * The default `MediaError` messages based on the {@link MediaError.errorTypes}.
 *
 * @type {Array}
 * @constant
 */
MediaError.defaultMessages = {
  1: 'You aborted the media playback',
  2: 'A network error caused the media download to fail part-way.',
  3: 'The media playback was aborted due to a corruption problem or because the media used features your browser did not support.',
  4: 'The media could not be loaded, either because the server or network failed or because the format is not supported.',
  5: 'The media is encrypted and we do not have the keys to decrypt it.'
};

// Add types as properties on MediaError
// e.g. MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
for (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
  MediaError[MediaError.errorTypes[errNum]] = errNum;
  // values should be accessible on both the class and instance
  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
}

var tuple = SafeParseTuple;

function SafeParseTuple(obj, reviver) {
    var json;
    var error = null;

    try {
        json = JSON.parse(obj, reviver);
    } catch (err) {
        error = err;
    }

    return [error, json]
}

/**
 * @file text-track-list-converter.js Utilities for capturing text track state and
 * re-creating tracks based on a capture.
 *
 * @module text-track-list-converter
 */

/**
 * Examine a single {@link TextTrack} and return a JSON-compatible javascript object that
 * represents the {@link TextTrack}'s state.
 *
 * @param {TextTrack} track
 *        The text track to query.
 *
 * @return {Object}
 *         A serializable javascript representation of the TextTrack.
 * @private
 */
var trackToJson_ = function trackToJson_(track) {
  var ret = ['kind', 'label', 'language', 'id', 'inBandMetadataTrackDispatchType', 'mode', 'src'].reduce(function (acc, prop, i) {

    if (track[prop]) {
      acc[prop] = track[prop];
    }

    return acc;
  }, {
    cues: track.cues && Array.prototype.map.call(track.cues, function (cue) {
      return {
        startTime: cue.startTime,
        endTime: cue.endTime,
        text: cue.text,
        id: cue.id
      };
    })
  });

  return ret;
};

/**
 * Examine a {@link Tech} and return a JSON-compatible javascript array that represents the
 * state of all {@link TextTrack}s currently configured. The return array is compatible with
 * {@link text-track-list-converter:jsonToTextTracks}.
 *
 * @param {Tech} tech
 *        The tech object to query
 *
 * @return {Array}
 *         A serializable javascript representation of the {@link Tech}s
 *         {@link TextTrackList}.
 */
var textTracksToJson = function textTracksToJson(tech) {

  var trackEls = tech.$$('track');

  var trackObjs = Array.prototype.map.call(trackEls, function (t) {
    return t.track;
  });
  var tracks = Array.prototype.map.call(trackEls, function (trackEl) {
    var json = trackToJson_(trackEl.track);

    if (trackEl.src) {
      json.src = trackEl.src;
    }
    return json;
  });

  return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function (track) {
    return trackObjs.indexOf(track) === -1;
  }).map(trackToJson_));
};

/**
 * Create a set of remote {@link TextTrack}s on a {@link Tech} based on an array of javascript
 * object {@link TextTrack} representations.
 *
 * @param {Array} json
 *        An array of `TextTrack` representation objects, like those that would be
 *        produced by `textTracksToJson`.
 *
 * @param {Tech} tech
 *        The `Tech` to create the `TextTrack`s on.
 */
var jsonToTextTracks = function jsonToTextTracks(json, tech) {
  json.forEach(function (track) {
    var addedTrack = tech.addRemoteTextTrack(track).track;

    if (!track.src && track.cues) {
      track.cues.forEach(function (cue) {
        return addedTrack.addCue(cue);
      });
    }
  });

  return tech.textTracks();
};

var textTrackConverter = { textTracksToJson: textTracksToJson, jsonToTextTracks: jsonToTextTracks, trackToJson_: trackToJson_ };

/**
 * @file modal-dialog.js
 */
var MODAL_CLASS_NAME = 'vjs-modal-dialog';
var ESC = 27;

/**
 * The `ModalDialog` displays over the video and its controls, which blocks
 * interaction with the player until it is closed.
 *
 * Modal dialogs include a "Close" button and will close when that button
 * is activated - or when ESC is pressed anywhere.
 *
 * @extends Component
 */

var ModalDialog = function (_Component) {
  inherits(ModalDialog, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Mixed} [options.content=undefined]
   *        Provide customized content for this modal.
   *
   * @param {string} [options.description]
   *        A text description for the modal, primarily for accessibility.
   *
   * @param {boolean} [options.fillAlways=false]
   *        Normally, modals are automatically filled only the first time
   *        they open. This tells the modal to refresh its content
   *        every time it opens.
   *
   * @param {string} [options.label]
   *        A text label for the modal, primarily for accessibility.
   *
   * @param {boolean} [options.temporary=true]
   *        If `true`, the modal can only be opened once; it will be
   *        disposed as soon as it's closed.
   *
   * @param {boolean} [options.uncloseable=false]
   *        If `true`, the user will not be able to close the modal
   *        through the UI in the normal ways. Programmatic closing is
   *        still possible.
   */
  function ModalDialog(player, options) {
    classCallCheck(this, ModalDialog);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = false;

    _this.closeable(!_this.options_.uncloseable);
    _this.content(_this.options_.content);

    // Make sure the contentEl is defined AFTER any children are initialized
    // because we only want the contents of the modal in the contentEl
    // (not the UI elements like the close button).
    _this.contentEl_ = createEl('div', {
      className: MODAL_CLASS_NAME + '-content'
    }, {
      role: 'document'
    });

    _this.descEl_ = createEl('p', {
      className: MODAL_CLASS_NAME + '-description vjs-control-text',
      id: _this.el().getAttribute('aria-describedby')
    });

    textContent(_this.descEl_, _this.description());
    _this.el_.appendChild(_this.descEl_);
    _this.el_.appendChild(_this.contentEl_);
    return _this;
  }

  /**
   * Create the `ModalDialog`'s DOM element
   *
   * @return {Element}
   *         The DOM element that gets created.
   */


  ModalDialog.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildCSSClass(),
      tabIndex: -1
    }, {
      'aria-describedby': this.id() + '_description',
      'aria-hidden': 'true',
      'aria-label': this.label(),
      'role': 'dialog'
    });
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  ModalDialog.prototype.buildCSSClass = function buildCSSClass() {
    return MODAL_CLASS_NAME + ' vjs-hidden ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Handles `keydown` events on the document, looking for ESC, which closes
   * the modal.
   *
   * @param {EventTarget~Event} e
   *        The keypress that triggered this event.
   *
   * @listens keydown
   */


  ModalDialog.prototype.handleKeyPress = function handleKeyPress(e) {
    if (e.which === ESC && this.closeable()) {
      this.close();
    }
  };

  /**
   * Returns the label string for this modal. Primarily used for accessibility.
   *
   * @return {string}
   *         the localized or raw label of this modal.
   */


  ModalDialog.prototype.label = function label() {
    return this.localize(this.options_.label || 'Modal Window');
  };

  /**
   * Returns the description string for this modal. Primarily used for
   * accessibility.
   *
   * @return {string}
   *         The localized or raw description of this modal.
   */


  ModalDialog.prototype.description = function description() {
    var desc = this.options_.description || this.localize('This is a modal window.');

    // Append a universal closeability message if the modal is closeable.
    if (this.closeable()) {
      desc += ' ' + this.localize('This modal can be closed by pressing the Escape key or activating the close button.');
    }

    return desc;
  };

  /**
   * Opens the modal.
   *
   * @fires ModalDialog#beforemodalopen
   * @fires ModalDialog#modalopen
   */


  ModalDialog.prototype.open = function open() {
    if (!this.opened_) {
      var player = this.player();

      /**
        * Fired just before a `ModalDialog` is opened.
        *
        * @event ModalDialog#beforemodalopen
        * @type {EventTarget~Event}
        */
      this.trigger('beforemodalopen');
      this.opened_ = true;

      // Fill content if the modal has never opened before and
      // never been filled.
      if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {
        this.fill();
      }

      // If the player was playing, pause it and take note of its previously
      // playing state.
      this.wasPlaying_ = !player.paused();

      if (this.options_.pauseOnOpen && this.wasPlaying_) {
        player.pause();
      }

      if (this.closeable()) {
        this.on(this.el_.ownerDocument, 'keydown', bind(this, this.handleKeyPress));
      }

      player.controls(false);
      this.show();
      this.conditionalFocus_();
      this.el().setAttribute('aria-hidden', 'false');

      /**
        * Fired just after a `ModalDialog` is opened.
        *
        * @event ModalDialog#modalopen
        * @type {EventTarget~Event}
        */
      this.trigger('modalopen');
      this.hasBeenOpened_ = true;
    }
  };

  /**
   * If the `ModalDialog` is currently open or closed.
   *
   * @param  {boolean} [value]
   *         If given, it will open (`true`) or close (`false`) the modal.
   *
   * @return {boolean}
   *         the current open state of the modaldialog
   */


  ModalDialog.prototype.opened = function opened(value) {
    if (typeof value === 'boolean') {
      this[value ? 'open' : 'close']();
    }
    return this.opened_;
  };

  /**
   * Closes the modal, does nothing if the `ModalDialog` is
   * not open.
   *
   * @fires ModalDialog#beforemodalclose
   * @fires ModalDialog#modalclose
   */


  ModalDialog.prototype.close = function close() {
    if (!this.opened_) {
      return;
    }
    var player = this.player();

    /**
      * Fired just before a `ModalDialog` is closed.
      *
      * @event ModalDialog#beforemodalclose
      * @type {EventTarget~Event}
      */
    this.trigger('beforemodalclose');
    this.opened_ = false;

    if (this.wasPlaying_ && this.options_.pauseOnOpen) {
      player.play();
    }

    if (this.closeable()) {
      this.off(this.el_.ownerDocument, 'keydown', bind(this, this.handleKeyPress));
    }

    player.controls(true);
    this.hide();
    this.el().setAttribute('aria-hidden', 'true');

    /**
      * Fired just after a `ModalDialog` is closed.
      *
      * @event ModalDialog#modalclose
      * @type {EventTarget~Event}
      */
    this.trigger('modalclose');
    this.conditionalBlur_();

    if (this.options_.temporary) {
      this.dispose();
    }
  };

  /**
   * Check to see if the `ModalDialog` is closeable via the UI.
   *
   * @param  {boolean} [value]
   *         If given as a boolean, it will set the `closeable` option.
   *
   * @return {boolean}
   *         Returns the final value of the closable option.
   */


  ModalDialog.prototype.closeable = function closeable(value) {
    if (typeof value === 'boolean') {
      var closeable = this.closeable_ = !!value;
      var close = this.getChild('closeButton');

      // If this is being made closeable and has no close button, add one.
      if (closeable && !close) {

        // The close button should be a child of the modal - not its
        // content element, so temporarily change the content element.
        var temp = this.contentEl_;

        this.contentEl_ = this.el_;
        close = this.addChild('closeButton', { controlText: 'Close Modal Dialog' });
        this.contentEl_ = temp;
        this.on(close, 'close', this.close);
      }

      // If this is being made uncloseable and has a close button, remove it.
      if (!closeable && close) {
        this.off(close, 'close', this.close);
        this.removeChild(close);
        close.dispose();
      }
    }
    return this.closeable_;
  };

  /**
   * Fill the modal's content element with the modal's "content" option.
   * The content element will be emptied before this change takes place.
   */


  ModalDialog.prototype.fill = function fill() {
    this.fillWith(this.content());
  };

  /**
   * Fill the modal's content element with arbitrary content.
   * The content element will be emptied before this change takes place.
   *
   * @fires ModalDialog#beforemodalfill
   * @fires ModalDialog#modalfill
   *
   * @param {Mixed} [content]
   *        The same rules apply to this as apply to the `content` option.
   */


  ModalDialog.prototype.fillWith = function fillWith(content) {
    var contentEl = this.contentEl();
    var parentEl = contentEl.parentNode;
    var nextSiblingEl = contentEl.nextSibling;

    /**
     * Fired just before a `ModalDialog` is filled with content.
     *
     * @event ModalDialog#beforemodalfill
     * @type {EventTarget~Event}
     */
    this.trigger('beforemodalfill');
    this.hasBeenFilled_ = true;

    // Detach the content element from the DOM before performing
    // manipulation to avoid modifying the live DOM multiple times.
    parentEl.removeChild(contentEl);
    this.empty();
    insertContent(contentEl, content);
    /**
     * Fired just after a `ModalDialog` is filled with content.
     *
     * @event ModalDialog#modalfill
     * @type {EventTarget~Event}
     */
    this.trigger('modalfill');

    // Re-inject the re-filled content element.
    if (nextSiblingEl) {
      parentEl.insertBefore(contentEl, nextSiblingEl);
    } else {
      parentEl.appendChild(contentEl);
    }

    // make sure that the close button is last in the dialog DOM
    var closeButton = this.getChild('closeButton');

    if (closeButton) {
      parentEl.appendChild(closeButton.el_);
    }
  };

  /**
   * Empties the content element. This happens anytime the modal is filled.
   *
   * @fires ModalDialog#beforemodalempty
   * @fires ModalDialog#modalempty
   */


  ModalDialog.prototype.empty = function empty() {
    /**
     * Fired just before a `ModalDialog` is emptied.
     *
     * @event ModalDialog#beforemodalempty
     * @type {EventTarget~Event}
     */
    this.trigger('beforemodalempty');
    emptyEl(this.contentEl());

    /**
     * Fired just after a `ModalDialog` is emptied.
     *
     * @event ModalDialog#modalempty
     * @type {EventTarget~Event}
     */
    this.trigger('modalempty');
  };

  /**
   * Gets or sets the modal content, which gets normalized before being
   * rendered into the DOM.
   *
   * This does not update the DOM or fill the modal, but it is called during
   * that process.
   *
   * @param  {Mixed} [value]
   *         If defined, sets the internal content value to be used on the
   *         next call(s) to `fill`. This value is normalized before being
   *         inserted. To "clear" the internal content value, pass `null`.
   *
   * @return {Mixed}
   *         The current content of the modal dialog
   */


  ModalDialog.prototype.content = function content(value) {
    if (typeof value !== 'undefined') {
      this.content_ = value;
    }
    return this.content_;
  };

  /**
   * conditionally focus the modal dialog if focus was previously on the player.
   *
   * @private
   */


  ModalDialog.prototype.conditionalFocus_ = function conditionalFocus_() {
    var activeEl = document_1.activeElement;
    var playerEl = this.player_.el_;

    this.previouslyActiveEl_ = null;

    if (playerEl.contains(activeEl) || playerEl === activeEl) {
      this.previouslyActiveEl_ = activeEl;

      this.focus();

      this.on(document_1, 'keydown', this.handleKeyDown);
    }
  };

  /**
   * conditionally blur the element and refocus the last focused element
   *
   * @private
   */


  ModalDialog.prototype.conditionalBlur_ = function conditionalBlur_() {
    if (this.previouslyActiveEl_) {
      this.previouslyActiveEl_.focus();
      this.previouslyActiveEl_ = null;
    }

    this.off(document_1, 'keydown', this.handleKeyDown);
  };

  /**
   * Keydown handler. Attached when modal is focused.
   *
   * @listens keydown
   */


  ModalDialog.prototype.handleKeyDown = function handleKeyDown(event) {
    // exit early if it isn't a tab key
    if (event.which !== 9) {
      return;
    }

    var focusableEls = this.focusableEls_();
    var activeEl = this.el_.querySelector(':focus');
    var focusIndex = void 0;

    for (var i = 0; i < focusableEls.length; i++) {
      if (activeEl === focusableEls[i]) {
        focusIndex = i;
        break;
      }
    }

    if (document_1.activeElement === this.el_) {
      focusIndex = 0;
    }

    if (event.shiftKey && focusIndex === 0) {
      focusableEls[focusableEls.length - 1].focus();
      event.preventDefault();
    } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {
      focusableEls[0].focus();
      event.preventDefault();
    }
  };

  /**
   * get all focusable elements
   *
   * @private
   */


  ModalDialog.prototype.focusableEls_ = function focusableEls_() {
    var allChildren = this.el_.querySelectorAll('*');

    return Array.prototype.filter.call(allChildren, function (child) {
      return (child instanceof window_1.HTMLAnchorElement || child instanceof window_1.HTMLAreaElement) && child.hasAttribute('href') || (child instanceof window_1.HTMLInputElement || child instanceof window_1.HTMLSelectElement || child instanceof window_1.HTMLTextAreaElement || child instanceof window_1.HTMLButtonElement) && !child.hasAttribute('disabled') || child instanceof window_1.HTMLIFrameElement || child instanceof window_1.HTMLObjectElement || child instanceof window_1.HTMLEmbedElement || child.hasAttribute('tabindex') && child.getAttribute('tabindex') !== -1 || child.hasAttribute('contenteditable');
    });
  };

  return ModalDialog;
}(Component);

/**
 * Default options for `ModalDialog` default options.
 *
 * @type {Object}
 * @private
 */


ModalDialog.prototype.options_ = {
  pauseOnOpen: true,
  temporary: true
};

Component.registerComponent('ModalDialog', ModalDialog);

/**
 * @file track-list.js
 */
/**
 * Common functionaliy between {@link TextTrackList}, {@link AudioTrackList}, and
 * {@link VideoTrackList}
 *
 * @extends EventTarget
 */

var TrackList = function (_EventTarget) {
  inherits(TrackList, _EventTarget);

  /**
   * Create an instance of this class
   *
   * @param {Track[]} tracks
   *        A list of tracks to initialize the list with.
   *
   * @param {Object} [list]
   *        The child object with inheritance done manually for ie8.
   *
   * @abstract
   */
  function TrackList() {
    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var _ret;

    var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    classCallCheck(this, TrackList);

    var _this = possibleConstructorReturn(this, _EventTarget.call(this));

    if (!list) {
      list = _this; // eslint-disable-line
      if (IS_IE8) {
        list = document_1.createElement('custom');
        for (var prop in TrackList.prototype) {
          if (prop !== 'constructor') {
            list[prop] = TrackList.prototype[prop];
          }
        }
      }
    }

    list.tracks_ = [];

    /**
     * @memberof TrackList
     * @member {number} length
     *         The current number of `Track`s in the this Trackist.
     * @instance
     */
    Object.defineProperty(list, 'length', {
      get: function get$$1() {
        return this.tracks_.length;
      }
    });

    for (var i = 0; i < tracks.length; i++) {
      list.addTrack(tracks[i]);
    }

    // must return the object, as for ie8 it will not be this
    // but a reference to a document object
    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a {@link Track} to the `TrackList`
   *
   * @param {Track} track
   *        The audio, video, or text track to add to the list.
   *
   * @fires TrackList#addtrack
   */


  TrackList.prototype.addTrack = function addTrack(track) {
    var index = this.tracks_.length;

    if (!('' + index in this)) {
      Object.defineProperty(this, index, {
        get: function get$$1() {
          return this.tracks_[index];
        }
      });
    }

    // Do not add duplicate tracks
    if (this.tracks_.indexOf(track) === -1) {
      this.tracks_.push(track);
      /**
       * Triggered when a track is added to a track list.
       *
       * @event TrackList#addtrack
       * @type {EventTarget~Event}
       * @property {Track} track
       *           A reference to track that was added.
       */
      this.trigger({
        track: track,
        type: 'addtrack'
      });
    }
  };

  /**
   * Remove a {@link Track} from the `TrackList`
   *
   * @param {Track} rtrack
   *        The audio, video, or text track to remove from the list.
   *
   * @fires TrackList#removetrack
   */


  TrackList.prototype.removeTrack = function removeTrack(rtrack) {
    var track = void 0;

    for (var i = 0, l = this.length; i < l; i++) {
      if (this[i] === rtrack) {
        track = this[i];
        if (track.off) {
          track.off();
        }

        this.tracks_.splice(i, 1);

        break;
      }
    }

    if (!track) {
      return;
    }

    /**
     * Triggered when a track is removed from track list.
     *
     * @event TrackList#removetrack
     * @type {EventTarget~Event}
     * @property {Track} track
     *           A reference to track that was removed.
     */
    this.trigger({
      track: track,
      type: 'removetrack'
    });
  };

  /**
   * Get a Track from the TrackList by a tracks id
   *
   * @param {String} id - the id of the track to get
   * @method getTrackById
   * @return {Track}
   * @private
   */


  TrackList.prototype.getTrackById = function getTrackById(id) {
    var result = null;

    for (var i = 0, l = this.length; i < l; i++) {
      var track = this[i];

      if (track.id === id) {
        result = track;
        break;
      }
    }

    return result;
  };

  return TrackList;
}(EventTarget);

/**
 * Triggered when a different track is selected/enabled.
 *
 * @event TrackList#change
 * @type {EventTarget~Event}
 */

/**
 * Events that can be called with on + eventName. See {@link EventHandler}.
 *
 * @property {Object} TrackList#allowedEvents_
 * @private
 */


TrackList.prototype.allowedEvents_ = {
  change: 'change',
  addtrack: 'addtrack',
  removetrack: 'removetrack'
};

// emulate attribute EventHandler support to allow for feature detection
for (var event in TrackList.prototype.allowedEvents_) {
  TrackList.prototype['on' + event] = null;
}

/**
 * @file audio-track-list.js
 */
/**
 * Anywhere we call this function we diverge from the spec
 * as we only support one enabled audiotrack at a time
 *
 * @param {AudioTrackList} list
 *        list to work on
 *
 * @param {AudioTrack} track
 *        The track to skip
 *
 * @private
 */
var disableOthers = function disableOthers(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    // another audio track is enabled, disable it
    list[i].enabled = false;
  }
};

/**
 * The current list of {@link AudioTrack} for a media file.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist}
 * @extends TrackList
 */

var AudioTrackList = function (_TrackList) {
  inherits(AudioTrackList, _TrackList);

  /**
   * Create an instance of this class.
   *
   * @param {AudioTrack[]} [tracks=[]]
   *        A list of `AudioTrack` to instantiate the list with.
   */
  function AudioTrackList() {
    var _this, _ret;

    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, AudioTrackList);

    var list = void 0;

    // make sure only 1 track is enabled
    // sorted from last index to first index
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].enabled) {
        disableOthers(tracks, tracks[i]);
        break;
      }
    }

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (IS_IE8) {
      list = document_1.createElement('custom');
      for (var prop in TrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TrackList.prototype[prop];
        }
      }
      for (var _prop in AudioTrackList.prototype) {
        if (_prop !== 'constructor') {
          list[_prop] = AudioTrackList.prototype[_prop];
        }
      }
    }

    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
    list.changing_ = false;

    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add an {@link AudioTrack} to the `AudioTrackList`.
   *
   * @param {AudioTrack} track
   *        The AudioTrack to add to the list
   *
   * @fires TrackList#addtrack
   */


  AudioTrackList.prototype.addTrack = function addTrack(track) {
    var _this2 = this;

    if (track.enabled) {
      disableOthers(this, track);
    }

    _TrackList.prototype.addTrack.call(this, track);
    // native tracks don't have this
    if (!track.addEventListener) {
      return;
    }

    /**
     * @listens AudioTrack#enabledchange
     * @fires TrackList#change
     */
    track.addEventListener('enabledchange', function () {
      // when we are disabling other tracks (since we don't support
      // more than one track at a time) we will set changing_
      // to true so that we don't trigger additional change events
      if (_this2.changing_) {
        return;
      }
      _this2.changing_ = true;
      disableOthers(_this2, track);
      _this2.changing_ = false;
      _this2.trigger('change');
    });
  };

  return AudioTrackList;
}(TrackList);

/**
 * @file video-track-list.js
 */
/**
 * Un-select all other {@link VideoTrack}s that are selected.
 *
 * @param {VideoTrackList} list
 *        list to work on
 *
 * @param {VideoTrack} track
 *        The track to skip
 *
 * @private
 */
var disableOthers$1 = function disableOthers(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    // another video track is enabled, disable it
    list[i].selected = false;
  }
};

/**
 * The current list of {@link VideoTrack} for a video.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist}
 * @extends TrackList
 */

var VideoTrackList = function (_TrackList) {
  inherits(VideoTrackList, _TrackList);

  /**
   * Create an instance of this class.
   *
   * @param {VideoTrack[]} [tracks=[]]
   *        A list of `VideoTrack` to instantiate the list with.
   */
  function VideoTrackList() {
    var _this, _ret;

    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, VideoTrackList);

    var list = void 0;

    // make sure only 1 track is enabled
    // sorted from last index to first index
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].selected) {
        disableOthers$1(tracks, tracks[i]);
        break;
      }
    }

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (IS_IE8) {
      list = document_1.createElement('custom');
      for (var prop in TrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TrackList.prototype[prop];
        }
      }
      for (var _prop in VideoTrackList.prototype) {
        if (_prop !== 'constructor') {
          list[_prop] = VideoTrackList.prototype[_prop];
        }
      }
    }

    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
    list.changing_ = false;

    /**
     * @member {number} VideoTrackList#selectedIndex
     *         The current index of the selected {@link VideoTrack`}.
     */
    Object.defineProperty(list, 'selectedIndex', {
      get: function get$$1() {
        for (var _i = 0; _i < this.length; _i++) {
          if (this[_i].selected) {
            return _i;
          }
        }
        return -1;
      },
      set: function set$$1() {}
    });

    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a {@link VideoTrack} to the `VideoTrackList`.
   *
   * @param {VideoTrack} track
   *        The VideoTrack to add to the list
   *
   * @fires TrackList#addtrack
   */


  VideoTrackList.prototype.addTrack = function addTrack(track) {
    var _this2 = this;

    if (track.selected) {
      disableOthers$1(this, track);
    }

    _TrackList.prototype.addTrack.call(this, track);
    // native tracks don't have this
    if (!track.addEventListener) {
      return;
    }

    /**
     * @listens VideoTrack#selectedchange
     * @fires TrackList#change
     */
    track.addEventListener('selectedchange', function () {
      if (_this2.changing_) {
        return;
      }
      _this2.changing_ = true;
      disableOthers$1(_this2, track);
      _this2.changing_ = false;
      _this2.trigger('change');
    });
  };

  return VideoTrackList;
}(TrackList);

/**
 * @file text-track-list.js
 */
/**
 * The current list of {@link TextTrack} for a media file.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttracklist}
 * @extends TrackList
 */

var TextTrackList = function (_TrackList) {
  inherits(TextTrackList, _TrackList);

  /**
   * Create an instance of this class.
   *
   * @param {TextTrack[]} [tracks=[]]
   *        A list of `TextTrack` to instantiate the list with.
   */
  function TextTrackList() {
    var _this, _ret;

    var tracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, TextTrackList);

    var list = void 0;

    // IE8 forces us to implement inheritance ourselves
    // as it does not support Object.defineProperty properly
    if (IS_IE8) {
      list = document_1.createElement('custom');
      for (var prop in TrackList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TrackList.prototype[prop];
        }
      }
      for (var _prop in TextTrackList.prototype) {
        if (_prop !== 'constructor') {
          list[_prop] = TextTrackList.prototype[_prop];
        }
      }
    }

    list = (_this = possibleConstructorReturn(this, _TrackList.call(this, tracks, list)), _this);
    return _ret = list, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a {@link TextTrack} to the `TextTrackList`
   *
   * @param {TextTrack} track
   *        The text track to add to the list.
   *
   * @fires TrackList#addtrack
   */


  TextTrackList.prototype.addTrack = function addTrack(track) {
    _TrackList.prototype.addTrack.call(this, track);

    /**
     * @listens TextTrack#modechange
     * @fires TrackList#change
     */
    track.addEventListener('modechange', bind(this, function () {
      this.trigger('change');
    }));

    var nonLanguageTextTrackKind = ['metadata', 'chapters'];

    if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {
      track.addEventListener('modechange', bind(this, function () {
        this.trigger('selectedlanguagechange');
      }));
    }
  };

  return TextTrackList;
}(TrackList);

/**
 * @file html-track-element-list.js
 */

/**
 * The current list of {@link HtmlTrackElement}s.
 */

var HtmlTrackElementList = function () {

  /**
   * Create an instance of this class.
   *
   * @param {HtmlTrackElement[]} [tracks=[]]
   *        A list of `HtmlTrackElement` to instantiate the list with.
   */
  function HtmlTrackElementList() {
    var trackElements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    classCallCheck(this, HtmlTrackElementList);

    var list = this; // eslint-disable-line

    if (IS_IE8) {
      list = document_1.createElement('custom');

      for (var prop in HtmlTrackElementList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = HtmlTrackElementList.prototype[prop];
        }
      }
    }

    list.trackElements_ = [];

    /**
     * @memberof HtmlTrackElementList
     * @member {number} length
     *         The current number of `Track`s in the this Trackist.
     * @instance
     */
    Object.defineProperty(list, 'length', {
      get: function get$$1() {
        return this.trackElements_.length;
      }
    });

    for (var i = 0, length = trackElements.length; i < length; i++) {
      list.addTrackElement_(trackElements[i]);
    }

    if (IS_IE8) {
      return list;
    }
  }

  /**
   * Add an {@link HtmlTrackElement} to the `HtmlTrackElementList`
   *
   * @param {HtmlTrackElement} trackElement
   *        The track element to add to the list.
   *
   * @private
   */


  HtmlTrackElementList.prototype.addTrackElement_ = function addTrackElement_(trackElement) {
    var index = this.trackElements_.length;

    if (!('' + index in this)) {
      Object.defineProperty(this, index, {
        get: function get$$1() {
          return this.trackElements_[index];
        }
      });
    }

    // Do not add duplicate elements
    if (this.trackElements_.indexOf(trackElement) === -1) {
      this.trackElements_.push(trackElement);
    }
  };

  /**
   * Get an {@link HtmlTrackElement} from the `HtmlTrackElementList` given an
   * {@link TextTrack}.
   *
   * @param {TextTrack} track
   *        The track associated with a track element.
   *
   * @return {HtmlTrackElement|undefined}
   *         The track element that was found or undefined.
   *
   * @private
   */


  HtmlTrackElementList.prototype.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {
    var trackElement_ = void 0;

    for (var i = 0, length = this.trackElements_.length; i < length; i++) {
      if (track === this.trackElements_[i].track) {
        trackElement_ = this.trackElements_[i];

        break;
      }
    }

    return trackElement_;
  };

  /**
   * Remove a {@link HtmlTrackElement} from the `HtmlTrackElementList`
   *
   * @param {HtmlTrackElement} trackElement
   *        The track element to remove from the list.
   *
   * @private
   */


  HtmlTrackElementList.prototype.removeTrackElement_ = function removeTrackElement_(trackElement) {
    for (var i = 0, length = this.trackElements_.length; i < length; i++) {
      if (trackElement === this.trackElements_[i]) {
        this.trackElements_.splice(i, 1);

        break;
      }
    }
  };

  return HtmlTrackElementList;
}();

/**
 * @file text-track-cue-list.js
 */
/**
 * @typedef {Object} TextTrackCueList~TextTrackCue
 *
 * @property {string} id
 *           The unique id for this text track cue
 *
 * @property {number} startTime
 *           The start time for this text track cue
 *
 * @property {number} endTime
 *           The end time for this text track cue
 *
 * @property {boolean} pauseOnExit
 *           Pause when the end time is reached if true.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcue}
 */

/**
 * A List of TextTrackCues.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackcuelist}
 */

var TextTrackCueList = function () {

  /**
   * Create an instance of this class..
   *
   * @param {Array} cues
   *        A list of cues to be initialized with
   */
  function TextTrackCueList(cues) {
    classCallCheck(this, TextTrackCueList);

    var list = this; // eslint-disable-line

    if (IS_IE8) {
      list = document_1.createElement('custom');

      for (var prop in TextTrackCueList.prototype) {
        if (prop !== 'constructor') {
          list[prop] = TextTrackCueList.prototype[prop];
        }
      }
    }

    TextTrackCueList.prototype.setCues_.call(list, cues);

    /**
     * @memberof TextTrackCueList
     * @member {number} length
     *         The current number of `TextTrackCue`s in the TextTrackCueList.
     * @instance
     */
    Object.defineProperty(list, 'length', {
      get: function get$$1() {
        return this.length_;
      }
    });

    if (IS_IE8) {
      return list;
    }
  }

  /**
   * A setter for cues in this list. Creates getters
   * an an index for the cues.
   *
   * @param {Array} cues
   *        An array of cues to set
   *
   * @private
   */


  TextTrackCueList.prototype.setCues_ = function setCues_(cues) {
    var oldLength = this.length || 0;
    var i = 0;
    var l = cues.length;

    this.cues_ = cues;
    this.length_ = cues.length;

    var defineProp = function defineProp(index) {
      if (!('' + index in this)) {
        Object.defineProperty(this, '' + index, {
          get: function get$$1() {
            return this.cues_[index];
          }
        });
      }
    };

    if (oldLength < l) {
      i = oldLength;

      for (; i < l; i++) {
        defineProp.call(this, i);
      }
    }
  };

  /**
   * Get a `TextTrackCue` that is currently in the `TextTrackCueList` by id.
   *
   * @param {string} id
   *        The id of the cue that should be searched for.
   *
   * @return {TextTrackCueList~TextTrackCue|null}
   *         A single cue or null if none was found.
   */


  TextTrackCueList.prototype.getCueById = function getCueById(id) {
    var result = null;

    for (var i = 0, l = this.length; i < l; i++) {
      var cue = this[i];

      if (cue.id === id) {
        result = cue;
        break;
      }
    }

    return result;
  };

  return TextTrackCueList;
}();

/**
 * @file track-kinds.js
 */

/**
 * All possible `VideoTrackKind`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-videotrack-kind
 * @typedef VideoTrack~Kind
 * @enum
 */
var VideoTrackKind = {
  alternative: 'alternative',
  captions: 'captions',
  main: 'main',
  sign: 'sign',
  subtitles: 'subtitles',
  commentary: 'commentary'
};

/**
 * All possible `AudioTrackKind`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-audiotrack-kind
 * @typedef AudioTrack~Kind
 * @enum
 */
var AudioTrackKind = {
  'alternative': 'alternative',
  'descriptions': 'descriptions',
  'main': 'main',
  'main-desc': 'main-desc',
  'translation': 'translation',
  'commentary': 'commentary'
};

/**
 * All possible `TextTrackKind`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-kind
 * @typedef TextTrack~Kind
 * @enum
 */
var TextTrackKind = {
  subtitles: 'subtitles',
  captions: 'captions',
  descriptions: 'descriptions',
  chapters: 'chapters',
  metadata: 'metadata'
};

/**
 * All possible `TextTrackMode`s
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#texttrackmode
 * @typedef TextTrack~Mode
 * @enum
 */
var TextTrackMode = {
  disabled: 'disabled',
  hidden: 'hidden',
  showing: 'showing'
};

/**
 * @file track.js
 */
/**
 * A Track class that contains all of the common functionality for {@link AudioTrack},
 * {@link VideoTrack}, and {@link TextTrack}.
 *
 * > Note: This class should not be used directly
 *
 * @see {@link https://html.spec.whatwg.org/multipage/embedded-content.html}
 * @extends EventTarget
 * @abstract
 */

var Track = function (_EventTarget) {
  inherits(Track, _EventTarget);

  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {string} [options.kind='']
   *        A valid kind for the track type you are creating.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @abstract
   */
  function Track() {
    var _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Track);

    var _this = possibleConstructorReturn(this, _EventTarget.call(this));

    var track = _this; // eslint-disable-line

    if (IS_IE8) {
      track = document_1.createElement('custom');
      for (var prop in Track.prototype) {
        if (prop !== 'constructor') {
          track[prop] = Track.prototype[prop];
        }
      }
    }

    var trackProps = {
      id: options.id || 'vjs_track_' + newGUID(),
      kind: options.kind || '',
      label: options.label || '',
      language: options.language || ''
    };

    /**
     * @memberof Track
     * @member {string} id
     *         The id of this track. Cannot be changed after creation.
     * @instance
     *
     * @readonly
     */

    /**
     * @memberof Track
     * @member {string} kind
     *         The kind of track that this is. Cannot be changed after creation.
     * @instance
     *
     * @readonly
     */

    /**
     * @memberof Track
     * @member {string} label
     *         The label of this track. Cannot be changed after creation.
     * @instance
     *
     * @readonly
     */

    /**
     * @memberof Track
     * @member {string} language
     *         The two letter language code for this track. Cannot be changed after
     *         creation.
     * @instance
     *
     * @readonly
     */

    var _loop = function _loop(key) {
      Object.defineProperty(track, key, {
        get: function get$$1() {
          return trackProps[key];
        },
        set: function set$$1() {}
      });
    };

    for (var key in trackProps) {
      _loop(key);
    }

    return _ret = track, possibleConstructorReturn(_this, _ret);
  }

  return Track;
}(EventTarget);

/**
 * @file url.js
 * @module url
 */
/**
 * @typedef {Object} url:URLObject
 *
 * @property {string} protocol
 *           The protocol of the url that was parsed.
 *
 * @property {string} hostname
 *           The hostname of the url that was parsed.
 *
 * @property {string} port
 *           The port of the url that was parsed.
 *
 * @property {string} pathname
 *           The pathname of the url that was parsed.
 *
 * @property {string} search
 *           The search query of the url that was parsed.
 *
 * @property {string} hash
 *           The hash of the url that was parsed.
 *
 * @property {string} host
 *           The host of the url that was parsed.
 */

/**
 * Resolve and parse the elements of a URL.
 *
 * @param  {String} url
 *         The url to parse
 *
 * @return {url:URLObject}
 *         An object of url details
 */
var parseUrl = function parseUrl(url) {
  var props = ['protocol', 'hostname', 'port', 'pathname', 'search', 'hash', 'host'];

  // add the url to an anchor and let the browser parse the URL
  var a = document_1.createElement('a');

  a.href = url;

  // IE8 (and 9?) Fix
  // ie8 doesn't parse the URL correctly until the anchor is actually
  // added to the body, and an innerHTML is needed to trigger the parsing
  var addToBody = a.host === '' && a.protocol !== 'file:';
  var div = void 0;

  if (addToBody) {
    div = document_1.createElement('div');
    div.innerHTML = '<a href="' + url + '"></a>';
    a = div.firstChild;
    // prevent the div from affecting layout
    div.setAttribute('style', 'display:none; position:absolute;');
    document_1.body.appendChild(div);
  }

  // Copy the specific URL properties to a new object
  // This is also needed for IE8 because the anchor loses its
  // properties when it's removed from the dom
  var details = {};

  for (var i = 0; i < props.length; i++) {
    details[props[i]] = a[props[i]];
  }

  // IE9 adds the port to the host property unlike everyone else. If
  // a port identifier is added for standard ports, strip it.
  if (details.protocol === 'http:') {
    details.host = details.host.replace(/:80$/, '');
  }

  if (details.protocol === 'https:') {
    details.host = details.host.replace(/:443$/, '');
  }

  if (addToBody) {
    document_1.body.removeChild(div);
  }

  return details;
};

/**
 * Get absolute version of relative URL. Used to tell flash correct URL.
 *
 *
 * @param  {string} url
 *         URL to make absolute
 *
 * @return {string}
 *         Absolute URL
 *
 * @see http://stackoverflow.com/questions/470832/getting-an-absolute-url-from-a-relative-one-ie6-issue
 */
var getAbsoluteURL = function getAbsoluteURL(url) {
  // Check if absolute URL
  if (!url.match(/^https?:\/\//)) {
    // Convert to absolute URL. Flash hosted off-site needs an absolute URL.
    var div = document_1.createElement('div');

    div.innerHTML = '<a href="' + url + '">x</a>';
    url = div.firstChild.href;
  }

  return url;
};

/**
 * Returns the extension of the passed file name. It will return an empty string
 * if passed an invalid path.
 *
 * @param {string} path
 *        The fileName path like '/path/to/file.mp4'
 *
 * @returns {string}
 *          The extension in lower case or an empty string if no
 *          extension could be found.
 */
var getFileExtension = function getFileExtension(path) {
  if (typeof path === 'string') {
    var splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/i;
    var pathParts = splitPathRe.exec(path);

    if (pathParts) {
      return pathParts.pop().toLowerCase();
    }
  }

  return '';
};

/**
 * Returns whether the url passed is a cross domain request or not.
 *
 * @param {string} url
 *        The url to check.
 *
 * @return {boolean}
 *         Whether it is a cross domain request or not.
 */
var isCrossOrigin = function isCrossOrigin(url) {
  var winLoc = window_1.location;
  var urlInfo = parseUrl(url);

  // IE8 protocol relative urls will return ':' for protocol
  var srcProtocol = urlInfo.protocol === ':' ? winLoc.protocol : urlInfo.protocol;

  // Check if url is for another domain/origin
  // IE8 doesn't know location.origin, so we won't rely on it here
  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;

  return crossOrigin;
};

var Url = (Object.freeze || Object)({
	parseUrl: parseUrl,
	getAbsoluteURL: getAbsoluteURL,
	getFileExtension: getFileExtension,
	isCrossOrigin: isCrossOrigin
});

var isFunction_1 = isFunction;

var toString$1 = Object.prototype.toString;

function isFunction (fn) {
  var string = toString$1.call(fn);
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
}

var trim_1 = createCommonjsModule(function (module, exports) {
exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};
});

var forEach_1 = forEach;

var toString$2 = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

function forEach(list, iterator, context) {
    if (!isFunction_1(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this;
    }
    
    if (toString$2.call(list) === '[object Array]')
        forEachArray$1(list, iterator, context);
    else if (typeof list === 'string')
        forEachString(list, iterator, context);
    else
        forEachObject(list, iterator, context);
}

function forEachArray$1(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array);
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string);
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object);
        }
    }
}

var isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    };

var parseHeaders = function (headers) {
  if (!headers)
    return {}

  var result = {};

  forEach_1(
      trim_1(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim_1(row.slice(0, index)).toLowerCase()
          , value = trim_1(row.slice(index + 1));

        if (typeof(result[key]) === 'undefined') {
          result[key] = value;
        } else if (isArray(result[key])) {
          result[key].push(value);
        } else {
          result[key] = [ result[key], value ];
        }
      }
  );

  return result
};

var immutable = extend;

var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

function extend() {
    var target = {};

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
            if (hasOwnProperty$1.call(source, key)) {
                target[key] = source[key];
            }
        }
    }

    return target
}

var xhr = createXHR;
createXHR.XMLHttpRequest = window_1.XMLHttpRequest || noop;
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window_1.XDomainRequest;

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback);
        options.method = method.toUpperCase();
        return _createXHR(options)
    };
});

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i]);
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri;

    if (isFunction_1(options)) {
        callback = options;
        if (typeof uri === "string") {
            params = {uri:uri};
        }
    } else {
        params = immutable(options, {uri: uri});
    }

    params.callback = callback;
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback);
    return _createXHR(options)
}

function _createXHR(options) {
    if(typeof options.callback === "undefined"){
        throw new Error("callback argument missing")
    }

    var called = false;
    var callback = function cbOnce(err, response, body){
        if(!called){
            called = true;
            options.callback(err, response, body);
        }
    };

    function readystatechange() {
        if (xhr.readyState === 4) {
            setTimeout(loadFunc, 0);
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined;

        if (xhr.response) {
            body = xhr.response;
        } else {
            body = xhr.responseText || getXml(xhr);
        }

        if (isJson) {
            try {
                body = JSON.parse(body);
            } catch (e) {}
        }

        return body
    }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer);
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") );
        }
        evt.statusCode = 0;
        return callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status;
        clearTimeout(timeoutTimer);
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200;
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status);
        }
        var response = failureResponse;
        var err = null;

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            };
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders());
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error");
        }
        return callback(err, response, response.body)
    }

    var xhr = options.xhr || null;

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest();
        }else{
            xhr = new createXHR.XMLHttpRequest();
        }
    }

    var key;
    var aborted;
    var uri = xhr.url = options.uri || options.url;
    var method = xhr.method = options.method || "GET";
    var body = options.body || options.data;
    var headers = xhr.headers = options.headers || {};
    var sync = !!options.sync;
    var isJson = false;
    var timeoutTimer;
    var failureResponse = {
        body: undefined,
        headers: {},
        statusCode: 0,
        method: method,
        url: uri,
        rawRequest: xhr
    };

    if ("json" in options && options.json !== false) {
        isJson = true;
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json"); //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json"); //Don't override existing accept header declared by user
            body = JSON.stringify(options.json === true ? body : options.json);
        }
    }

    xhr.onreadystatechange = readystatechange;
    xhr.onload = loadFunc;
    xhr.onerror = errorFunc;
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    };
    xhr.onabort = function(){
        aborted = true;
    };
    xhr.ontimeout = errorFunc;
    xhr.open(method, uri, !sync, options.username, options.password);
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials;
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            if (aborted) return
            aborted = true;//IE9 may still call readystatechange
            xhr.abort("timeout");
            var e = new Error("XMLHttpRequest timeout");
            e.code = "ETIMEDOUT";
            errorFunc(e);
        }, options.timeout );
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key]);
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType;
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr);
    }

    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.
    xhr.send(body || null);

    return xhr


}

function getXml(xhr) {
    if (xhr.responseType === "document") {
        return xhr.responseXML
    }
    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
        return xhr.responseXML
    }

    return null
}

function noop() {}

/**
 * @file text-track.js
 */
/**
 * Takes a webvtt file contents and parses it into cues
 *
 * @param {string} srcContent
 *        webVTT file contents
 *
 * @param {TextTrack} track
 *        TextTrack to add cues to. Cues come from the srcContent.
 *
 * @private
 */
var parseCues = function parseCues(srcContent, track) {
  var parser = new window_1.WebVTT.Parser(window_1, window_1.vttjs, window_1.WebVTT.StringDecoder());
  var errors = [];

  parser.oncue = function (cue) {
    track.addCue(cue);
  };

  parser.onparsingerror = function (error) {
    errors.push(error);
  };

  parser.onflush = function () {
    track.trigger({
      type: 'loadeddata',
      target: track
    });
  };

  parser.parse(srcContent);
  if (errors.length > 0) {
    if (window_1.console && window_1.console.groupCollapsed) {
      window_1.console.groupCollapsed('Text Track parsing errors for ' + track.src);
    }
    errors.forEach(function (error) {
      return log$1.error(error);
    });
    if (window_1.console && window_1.console.groupEnd) {
      window_1.console.groupEnd();
    }
  }

  parser.flush();
};

/**
 * Load a `TextTrack` from a specifed url.
 *
 * @param {string} src
 *        Url to load track from.
 *
 * @param {TextTrack} track
 *        Track to add cues to. Comes from the content at the end of `url`.
 *
 * @private
 */
var loadTrack = function loadTrack(src, track) {
  var opts = {
    uri: src
  };
  var crossOrigin = isCrossOrigin(src);

  if (crossOrigin) {
    opts.cors = crossOrigin;
  }

  xhr(opts, bind(this, function (err, response, responseBody) {
    if (err) {
      return log$1.error(err, response);
    }

    track.loaded_ = true;

    // Make sure that vttjs has loaded, otherwise, wait till it finished loading
    // NOTE: this is only used for the alt/video.novtt.js build
    if (typeof window_1.WebVTT !== 'function') {
      if (track.tech_) {
        var loadHandler = function loadHandler() {
          return parseCues(responseBody, track);
        };

        track.tech_.on('vttjsloaded', loadHandler);
        track.tech_.on('vttjserror', function () {
          log$1.error('vttjs failed to load, stopping trying to process ' + track.src);
          track.tech_.off('vttjsloaded', loadHandler);
        });
      }
    } else {
      parseCues(responseBody, track);
    }
  }));
};

/**
 * A representation of a single `TextTrack`.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#texttrack}
 * @extends Track
 */

var TextTrack = function (_Track) {
  inherits(TextTrack, _Track);

  /**
   * Create an instance of this class.
   *
   * @param {Object} options={}
   *        Object of option names and values
   *
   * @param {Tech} options.tech
   *        A reference to the tech that owns this TextTrack.
   *
   * @param {TextTrack~Kind} [options.kind='subtitles']
   *        A valid text track kind.
   *
   * @param {TextTrack~Mode} [options.mode='disabled']
   *        A valid text track mode.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this TextTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {string} [options.srclang='']
   *        A valid two character language code. An alternative, but deprioritized
   *        vesion of `options.language`
   *
   * @param {string} [options.src]
   *        A url to TextTrack cues.
   *
   * @param {boolean} [options.default]
   *        If this track should default to on or off.
   */
  function TextTrack() {
    var _this, _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, TextTrack);

    if (!options.tech) {
      throw new Error('A tech was not provided.');
    }

    var settings = mergeOptions(options, {
      kind: TextTrackKind[options.kind] || 'subtitles',
      language: options.language || options.srclang || ''
    });
    var mode = TextTrackMode[settings.mode] || 'disabled';
    var default_ = settings['default'];

    if (settings.kind === 'metadata' || settings.kind === 'chapters') {
      mode = 'hidden';
    }
    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var tt = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);

    tt.tech_ = settings.tech;

    if (IS_IE8) {
      for (var prop in TextTrack.prototype) {
        if (prop !== 'constructor') {
          tt[prop] = TextTrack.prototype[prop];
        }
      }
    }

    tt.cues_ = [];
    tt.activeCues_ = [];

    var cues = new TextTrackCueList(tt.cues_);
    var activeCues = new TextTrackCueList(tt.activeCues_);
    var changed = false;
    var timeupdateHandler = bind(tt, function () {

      // Accessing this.activeCues for the side-effects of updating itself
      // due to it's nature as a getter function. Do not remove or cues will
      // stop updating!
      /* eslint-disable no-unused-expressions */
      this.activeCues;
      /* eslint-enable no-unused-expressions */
      if (changed) {
        this.trigger('cuechange');
        changed = false;
      }
    });

    if (mode !== 'disabled') {
      tt.tech_.ready(function () {
        tt.tech_.on('timeupdate', timeupdateHandler);
      }, true);
    }

    /**
     * @memberof TextTrack
     * @member {boolean} default
     *         If this track was set to be on or off by default. Cannot be changed after
     *         creation.
     * @instance
     *
     * @readonly
     */
    Object.defineProperty(tt, 'default', {
      get: function get$$1() {
        return default_;
      },
      set: function set$$1() {}
    });

    /**
     * @memberof TextTrack
     * @member {string} mode
     *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will
     *         not be set if setting to an invalid mode.
     * @instance
     *
     * @fires TextTrack#modechange
     */
    Object.defineProperty(tt, 'mode', {
      get: function get$$1() {
        return mode;
      },
      set: function set$$1(newMode) {
        var _this2 = this;

        if (!TextTrackMode[newMode]) {
          return;
        }
        mode = newMode;
        if (mode === 'showing') {

          this.tech_.ready(function () {
            _this2.tech_.on('timeupdate', timeupdateHandler);
          }, true);
        }
        /**
         * An event that fires when mode changes on this track. This allows
         * the TextTrackList that holds this track to act accordingly.
         *
         * > Note: This is not part of the spec!
         *
         * @event TextTrack#modechange
         * @type {EventTarget~Event}
         */
        this.trigger('modechange');
      }
    });

    /**
     * @memberof TextTrack
     * @member {TextTrackCueList} cues
     *         The text track cue list for this TextTrack.
     * @instance
     */
    Object.defineProperty(tt, 'cues', {
      get: function get$$1() {
        if (!this.loaded_) {
          return null;
        }

        return cues;
      },
      set: function set$$1() {}
    });

    /**
     * @memberof TextTrack
     * @member {TextTrackCueList} activeCues
     *         The list text track cues that are currently active for this TextTrack.
     * @instance
     */
    Object.defineProperty(tt, 'activeCues', {
      get: function get$$1() {
        if (!this.loaded_) {
          return null;
        }

        // nothing to do
        if (this.cues.length === 0) {
          return activeCues;
        }

        var ct = this.tech_.currentTime();
        var active = [];

        for (var i = 0, l = this.cues.length; i < l; i++) {
          var cue = this.cues[i];

          if (cue.startTime <= ct && cue.endTime >= ct) {
            active.push(cue);
          } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {
            active.push(cue);
          }
        }

        changed = false;

        if (active.length !== this.activeCues_.length) {
          changed = true;
        } else {
          for (var _i = 0; _i < active.length; _i++) {
            if (this.activeCues_.indexOf(active[_i]) === -1) {
              changed = true;
            }
          }
        }

        this.activeCues_ = active;
        activeCues.setCues_(this.activeCues_);

        return activeCues;
      },
      set: function set$$1() {}
    });

    if (settings.src) {
      tt.src = settings.src;
      loadTrack(settings.src, tt);
    } else {
      tt.loaded_ = true;
    }

    return _ret = tt, possibleConstructorReturn(_this, _ret);
  }

  /**
   * Add a cue to the internal list of cues.
   *
   * @param {TextTrack~Cue} cue
   *        The cue to add to our internal list
   */


  TextTrack.prototype.addCue = function addCue(originalCue) {
    var cue = originalCue;

    if (window_1.vttjs && !(originalCue instanceof window_1.vttjs.VTTCue)) {
      cue = new window_1.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);

      for (var prop in originalCue) {
        if (!(prop in cue)) {
          cue[prop] = originalCue[prop];
        }
      }

      // make sure that `id` is copied over
      cue.id = originalCue.id;
      cue.originalCue_ = originalCue;
    }

    var tracks = this.tech_.textTracks();

    for (var i = 0; i < tracks.length; i++) {
      if (tracks[i] !== this) {
        tracks[i].removeCue(cue);
      }
    }

    this.cues_.push(cue);
    this.cues.setCues_(this.cues_);
  };

  /**
   * Remove a cue from our internal list
   *
   * @param {TextTrack~Cue} removeCue
   *        The cue to remove from our internal list
   */


  TextTrack.prototype.removeCue = function removeCue(_removeCue) {
    var i = this.cues_.length;

    while (i--) {
      var cue = this.cues_[i];

      if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {
        this.cues_.splice(i, 1);
        this.cues.setCues_(this.cues_);
        break;
      }
    }
  };

  return TextTrack;
}(Track);

/**
 * cuechange - One or more cues in the track have become active or stopped being active.
 */


TextTrack.prototype.allowedEvents_ = {
  cuechange: 'cuechange'
};

/**
 * A representation of a single `AudioTrack`. If it is part of an {@link AudioTrackList}
 * only one `AudioTrack` in the list will be enabled at a time.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotrack}
 * @extends Track
 */

var AudioTrack = function (_Track) {
  inherits(AudioTrack, _Track);

  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {AudioTrack~Kind} [options.kind='']
   *        A valid audio track kind
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {boolean} [options.enabled]
   *        If this track is the one that is currently playing. If this track is part of
   *        an {@link AudioTrackList}, only one {@link AudioTrack} will be enabled.
   */
  function AudioTrack() {
    var _this, _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, AudioTrack);

    var settings = mergeOptions(options, {
      kind: AudioTrackKind[options.kind] || ''
    });
    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var track = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);
    var enabled = false;

    if (IS_IE8) {
      for (var prop in AudioTrack.prototype) {
        if (prop !== 'constructor') {
          track[prop] = AudioTrack.prototype[prop];
        }
      }
    }
    /**
     * @memberof AudioTrack
     * @member {boolean} enabled
     *         If this `AudioTrack` is enabled or not. When setting this will
     *         fire {@link AudioTrack#enabledchange} if the state of enabled is changed.
     * @instance
     *
     * @fires VideoTrack#selectedchange
     */
    Object.defineProperty(track, 'enabled', {
      get: function get$$1() {
        return enabled;
      },
      set: function set$$1(newEnabled) {
        // an invalid or unchanged value
        if (typeof newEnabled !== 'boolean' || newEnabled === enabled) {
          return;
        }
        enabled = newEnabled;

        /**
         * An event that fires when enabled changes on this track. This allows
         * the AudioTrackList that holds this track to act accordingly.
         *
         * > Note: This is not part of the spec! Native tracks will do
         *         this internally without an event.
         *
         * @event AudioTrack#enabledchange
         * @type {EventTarget~Event}
         */
        this.trigger('enabledchange');
      }
    });

    // if the user sets this track to selected then
    // set selected to that true value otherwise
    // we keep it false
    if (settings.enabled) {
      track.enabled = settings.enabled;
    }
    track.loaded_ = true;

    return _ret = track, possibleConstructorReturn(_this, _ret);
  }

  return AudioTrack;
}(Track);

/**
 * A representation of a single `VideoTrack`.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#videotrack}
 * @extends Track
 */

var VideoTrack = function (_Track) {
  inherits(VideoTrack, _Track);

  /**
   * Create an instance of this class.
   *
   * @param {Object} [options={}]
   *        Object of option names and values
   *
   * @param {string} [options.kind='']
   *        A valid {@link VideoTrack~Kind}
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this AudioTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {boolean} [options.selected]
   *        If this track is the one that is currently playing.
   */
  function VideoTrack() {
    var _this, _ret;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, VideoTrack);

    var settings = mergeOptions(options, {
      kind: VideoTrackKind[options.kind] || ''
    });

    // on IE8 this will be a document element
    // for every other browser this will be a normal object
    var track = (_this = possibleConstructorReturn(this, _Track.call(this, settings)), _this);
    var selected = false;

    if (IS_IE8) {
      for (var prop in VideoTrack.prototype) {
        if (prop !== 'constructor') {
          track[prop] = VideoTrack.prototype[prop];
        }
      }
    }

    /**
     * @memberof VideoTrack
     * @member {boolean} selected
     *         If this `VideoTrack` is selected or not. When setting this will
     *         fire {@link VideoTrack#selectedchange} if the state of selected changed.
     * @instance
     *
     * @fires VideoTrack#selectedchange
     */
    Object.defineProperty(track, 'selected', {
      get: function get$$1() {
        return selected;
      },
      set: function set$$1(newSelected) {
        // an invalid or unchanged value
        if (typeof newSelected !== 'boolean' || newSelected === selected) {
          return;
        }
        selected = newSelected;

        /**
         * An event that fires when selected changes on this track. This allows
         * the VideoTrackList that holds this track to act accordingly.
         *
         * > Note: This is not part of the spec! Native tracks will do
         *         this internally without an event.
         *
         * @event VideoTrack#selectedchange
         * @type {EventTarget~Event}
         */
        this.trigger('selectedchange');
      }
    });

    // if the user sets this track to selected then
    // set selected to that true value otherwise
    // we keep it false
    if (settings.selected) {
      track.selected = settings.selected;
    }

    return _ret = track, possibleConstructorReturn(_this, _ret);
  }

  return VideoTrack;
}(Track);

/**
 * @file html-track-element.js
 */

/**
 * @memberof HTMLTrackElement
 * @typedef {HTMLTrackElement~ReadyState}
 * @enum {number}
 */
var NONE = 0;
var LOADING = 1;
var LOADED = 2;
var ERROR = 3;

/**
 * A single track represented in the DOM.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#htmltrackelement}
 * @extends EventTarget
 */

var HTMLTrackElement = function (_EventTarget) {
  inherits(HTMLTrackElement, _EventTarget);

  /**
   * Create an instance of this class.
   *
   * @param {Object} options={}
   *        Object of option names and values
   *
   * @param {Tech} options.tech
   *        A reference to the tech that owns this HTMLTrackElement.
   *
   * @param {TextTrack~Kind} [options.kind='subtitles']
   *        A valid text track kind.
   *
   * @param {TextTrack~Mode} [options.mode='disabled']
   *        A valid text track mode.
   *
   * @param {string} [options.id='vjs_track_' + Guid.newGUID()]
   *        A unique id for this TextTrack.
   *
   * @param {string} [options.label='']
   *        The menu label for this track.
   *
   * @param {string} [options.language='']
   *        A valid two character language code.
   *
   * @param {string} [options.srclang='']
   *        A valid two character language code. An alternative, but deprioritized
   *        vesion of `options.language`
   *
   * @param {string} [options.src]
   *        A url to TextTrack cues.
   *
   * @param {boolean} [options.default]
   *        If this track should default to on or off.
   */
  function HTMLTrackElement() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, HTMLTrackElement);

    var _this = possibleConstructorReturn(this, _EventTarget.call(this));

    var readyState = void 0;
    var trackElement = _this; // eslint-disable-line

    if (IS_IE8) {
      trackElement = document_1.createElement('custom');

      for (var prop in HTMLTrackElement.prototype) {
        if (prop !== 'constructor') {
          trackElement[prop] = HTMLTrackElement.prototype[prop];
        }
      }
    }

    var track = new TextTrack(options);

    trackElement.kind = track.kind;
    trackElement.src = track.src;
    trackElement.srclang = track.language;
    trackElement.label = track.label;
    trackElement['default'] = track['default'];

    /**
     * @memberof HTMLTrackElement
     * @member {HTMLTrackElement~ReadyState} readyState
     *         The current ready state of the track element.
     * @instance
     */
    Object.defineProperty(trackElement, 'readyState', {
      get: function get$$1() {
        return readyState;
      }
    });

    /**
     * @memberof HTMLTrackElement
     * @member {TextTrack} track
     *         The underlying TextTrack object.
     * @instance
     *
     */
    Object.defineProperty(trackElement, 'track', {
      get: function get$$1() {
        return track;
      }
    });

    readyState = NONE;

    /**
     * @listens TextTrack#loadeddata
     * @fires HTMLTrackElement#load
     */
    track.addEventListener('loadeddata', function () {
      readyState = LOADED;

      trackElement.trigger({
        type: 'load',
        target: trackElement
      });
    });

    if (IS_IE8) {
      var _ret;

      return _ret = trackElement, possibleConstructorReturn(_this, _ret);
    }
    return _this;
  }

  return HTMLTrackElement;
}(EventTarget);

HTMLTrackElement.prototype.allowedEvents_ = {
  load: 'load'
};

HTMLTrackElement.NONE = NONE;
HTMLTrackElement.LOADING = LOADING;
HTMLTrackElement.LOADED = LOADED;
HTMLTrackElement.ERROR = ERROR;

/*
 * This file contains all track properties that are used in
 * player.js, tech.js, html5.js and possibly other techs in the future.
 */

var NORMAL = {
  audio: {
    ListClass: AudioTrackList,
    TrackClass: AudioTrack,
    capitalName: 'Audio'
  },
  video: {
    ListClass: VideoTrackList,
    TrackClass: VideoTrack,
    capitalName: 'Video'
  },
  text: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: 'Text'
  }
};

Object.keys(NORMAL).forEach(function (type) {
  NORMAL[type].getterName = type + 'Tracks';
  NORMAL[type].privateName = type + 'Tracks_';
});

var REMOTE = {
  remoteText: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: 'RemoteText',
    getterName: 'remoteTextTracks',
    privateName: 'remoteTextTracks_'
  },
  remoteTextEl: {
    ListClass: HtmlTrackElementList,
    TrackClass: HTMLTrackElement,
    capitalName: 'RemoteTextTrackEls',
    getterName: 'remoteTextTrackEls',
    privateName: 'remoteTextTrackEls_'
  }
};

var ALL = mergeOptions(NORMAL, REMOTE);

REMOTE.names = Object.keys(REMOTE);
NORMAL.names = Object.keys(NORMAL);
ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
var _objCreate = Object.create || (function() {
  function F() {}
  return function(o) {
    if (arguments.length !== 1) {
      throw new Error('Object.create shim only accepts one parameter.');
    }
    F.prototype = o;
    return new F();
  };
})();

// Creates a new ParserError object from an errorData object. The errorData
// object should have default code and message properties. The default message
// property can be overriden by passing in a message parameter.
// See ParsingError.Errors below for acceptable errors.
function ParsingError(errorData, message) {
  this.name = "ParsingError";
  this.code = errorData.code;
  this.message = message || errorData.message;
}
ParsingError.prototype = _objCreate(Error.prototype);
ParsingError.prototype.constructor = ParsingError;

// ParsingError metadata for acceptable ParsingErrors.
ParsingError.Errors = {
  BadSignature: {
    code: 0,
    message: "Malformed WebVTT signature."
  },
  BadTimeStamp: {
    code: 1,
    message: "Malformed time stamp."
  }
};

// Try to parse input as a time stamp.
function parseTimeStamp(input) {

  function computeSeconds(h, m, s, f) {
    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1000;
  }

  var m = input.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/);
  if (!m) {
    return null;
  }

  if (m[3]) {
    // Timestamp takes the form of [hours]:[minutes]:[seconds].[milliseconds]
    return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]);
  } else if (m[1] > 59) {
    // Timestamp takes the form of [hours]:[minutes].[milliseconds]
    // First position is hours as it's over 59.
    return computeSeconds(m[1], m[2], 0,  m[4]);
  } else {
    // Timestamp takes the form of [minutes]:[seconds].[milliseconds]
    return computeSeconds(0, m[1], m[2], m[4]);
  }
}

// A settings object holds key/value pairs and will ignore anything but the first
// assignment to a specific key.
function Settings() {
  this.values = _objCreate(null);
}

Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function(k, v) {
    if (!this.get(k) && v !== "") {
      this.values[k] = v;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }
    return this.has(k) ? this.values[k] : dflt;
  },
  // Check whether we have a value for a key.
  has: function(k) {
    return k in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function(k, v, a) {
    for (var n = 0; n < a.length; ++n) {
      if (v === a[n]) {
        this.set(k, v);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function(k, v) {
    if (/^-?\d+$/.test(v)) { // integer
      this.set(k, parseInt(v, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function(k, v) {
    var m;
    if ((m = v.match(/^([\d]{1,3})(\.[\d]*)?%$/))) {
      v = parseFloat(v);
      if (v >= 0 && v <= 100) {
        this.set(k, v);
        return true;
      }
    }
    return false;
  }
};

// Helper function to parse input into groups separated by 'groupDelim', and
// interprete each group as a key/value pair separated by 'keyValueDelim'.
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== "string") {
      continue;
    }
    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }
    var k = kv[0];
    var v = kv[1];
    callback(k, v);
  }
}

function parseCue(input, cue, regionList) {
  // Remember the original input if we need to throw an error.
  var oInput = input;
  // 4.1 WebVTT timestamp
  function consumeTimeStamp() {
    var ts = parseTimeStamp(input);
    if (ts === null) {
      throw new ParsingError(ParsingError.Errors.BadTimeStamp,
                            "Malformed timestamp: " + oInput);
    }
    // Remove time stamp from input.
    input = input.replace(/^[^\sa-zA-Z-]+/, "");
    return ts;
  }

  // 4.4.2 WebVTT cue settings
  function consumeCueSettings(input, cue) {
    var settings = new Settings();

    parseOptions(input, function (k, v) {
      switch (k) {
      case "region":
        // Find the last region we parsed with the same region id.
        for (var i = regionList.length - 1; i >= 0; i--) {
          if (regionList[i].id === v) {
            settings.set(k, regionList[i].region);
            break;
          }
        }
        break;
      case "vertical":
        settings.alt(k, v, ["rl", "lr"]);
        break;
      case "line":
        var vals = v.split(","),
            vals0 = vals[0];
        settings.integer(k, vals0);
        settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;
        settings.alt(k, vals0, ["auto"]);
        if (vals.length === 2) {
          settings.alt("lineAlign", vals[1], ["start", "middle", "end"]);
        }
        break;
      case "position":
        vals = v.split(",");
        settings.percent(k, vals[0]);
        if (vals.length === 2) {
          settings.alt("positionAlign", vals[1], ["start", "middle", "end"]);
        }
        break;
      case "size":
        settings.percent(k, v);
        break;
      case "align":
        settings.alt(k, v, ["start", "middle", "end", "left", "right"]);
        break;
      }
    }, /:/, /\s/);

    // Apply default values for any missing fields.
    cue.region = settings.get("region", null);
    cue.vertical = settings.get("vertical", "");
    cue.line = settings.get("line", "auto");
    cue.lineAlign = settings.get("lineAlign", "start");
    cue.snapToLines = settings.get("snapToLines", true);
    cue.size = settings.get("size", 100);
    cue.align = settings.get("align", "middle");
    cue.position = settings.get("position", {
      start: 0,
      left: 0,
      middle: 50,
      end: 100,
      right: 100
    }, cue.align);
    cue.positionAlign = settings.get("positionAlign", {
      start: "start",
      left: "start",
      middle: "middle",
      end: "end",
      right: "end"
    }, cue.align);
  }

  function skipWhitespace() {
    input = input.replace(/^\s+/, "");
  }

  // 4.1 WebVTT cue timings.
  skipWhitespace();
  cue.startTime = consumeTimeStamp();   // (1) collect cue start time
  skipWhitespace();
  if (input.substr(0, 3) !== "-->") {     // (3) next characters must match "-->"
    throw new ParsingError(ParsingError.Errors.BadTimeStamp,
                           "Malformed time stamp (time stamps must be separated by '-->'): " +
                           oInput);
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp();     // (5) collect cue end time

  // 4.1 WebVTT cue settings list.
  skipWhitespace();
  consumeCueSettings(input, cue);
}

var ESCAPE = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&lrm;": "\u200e",
  "&rlm;": "\u200f",
  "&nbsp;": "\u00a0"
};

var TAG_NAME = {
  c: "span",
  i: "i",
  b: "b",
  u: "u",
  ruby: "ruby",
  rt: "rt",
  v: "span",
  lang: "span"
};

var TAG_ANNOTATION = {
  v: "title",
  lang: "lang"
};

var NEEDS_PARENT = {
  rt: "ruby"
};

// Parse content into a document fragment.
function parseContent(window, input) {
  function nextToken() {
    // Check for end-of-string.
    if (!input) {
      return null;
    }

    // Consume 'n' characters from the input.
    function consume(result) {
      input = input.substr(result.length);
      return result;
    }

    var m = input.match(/^([^<]*)(<[^>]+>?)?/);
    // If there is some text before the next tag, return it, otherwise return
    // the tag.
    return consume(m[1] ? m[1] : m[2]);
  }

  // Unescape a string 's'.
  function unescape1(e) {
    return ESCAPE[e];
  }
  function unescape(s) {
    while ((m = s.match(/&(amp|lt|gt|lrm|rlm|nbsp);/))) {
      s = s.replace(m[0], unescape1);
    }
    return s;
  }

  function shouldAdd(current, element) {
    return !NEEDS_PARENT[element.localName] ||
           NEEDS_PARENT[element.localName] === current.localName;
  }

  // Create an element for this tag.
  function createElement(type, annotation) {
    var tagName = TAG_NAME[type];
    if (!tagName) {
      return null;
    }
    var element = window.document.createElement(tagName);
    element.localName = tagName;
    var name = TAG_ANNOTATION[type];
    if (name && annotation) {
      element[name] = annotation.trim();
    }
    return element;
  }

  var rootDiv = window.document.createElement("div"),
      current = rootDiv,
      t,
      tagStack = [];

  while ((t = nextToken()) !== null) {
    if (t[0] === '<') {
      if (t[1] === "/") {
        // If the closing tag matches, move back up to the parent node.
        if (tagStack.length &&
            tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {
          tagStack.pop();
          current = current.parentNode;
        }
        // Otherwise just ignore the end tag.
        continue;
      }
      var ts = parseTimeStamp(t.substr(1, t.length - 2));
      var node;
      if (ts) {
        // Timestamps are lead nodes as well.
        node = window.document.createProcessingInstruction("timestamp", ts);
        current.appendChild(node);
        continue;
      }
      var m = t.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
      // If we can't parse the tag, skip to the next tag.
      if (!m) {
        continue;
      }
      // Try to construct an element, and ignore the tag if we couldn't.
      node = createElement(m[1], m[3]);
      if (!node) {
        continue;
      }
      // Determine if the tag should be added based on the context of where it
      // is placed in the cuetext.
      if (!shouldAdd(current, node)) {
        continue;
      }
      // Set the class list (as a list of classes, separated by space).
      if (m[2]) {
        node.className = m[2].substr(1).replace('.', ' ');
      }
      // Append the node to the current node, and enter the scope of the new
      // node.
      tagStack.push(m[1]);
      current.appendChild(node);
      current = node;
      continue;
    }

    // Text nodes are leaf nodes.
    current.appendChild(window.document.createTextNode(unescape(t)));
  }

  return rootDiv;
}

// This is a list of all the Unicode characters that have a strong
// right-to-left category. What this means is that these characters are
// written right-to-left for sure. It was generated by pulling all the strong
// right-to-left characters out of the Unicode data table. That table can
// found at: http://www.unicode.org/Public/UNIDATA/UnicodeData.txt
var strongRTLRanges = [[0x5be, 0x5be], [0x5c0, 0x5c0], [0x5c3, 0x5c3], [0x5c6, 0x5c6],
 [0x5d0, 0x5ea], [0x5f0, 0x5f4], [0x608, 0x608], [0x60b, 0x60b], [0x60d, 0x60d],
 [0x61b, 0x61b], [0x61e, 0x64a], [0x66d, 0x66f], [0x671, 0x6d5], [0x6e5, 0x6e6],
 [0x6ee, 0x6ef], [0x6fa, 0x70d], [0x70f, 0x710], [0x712, 0x72f], [0x74d, 0x7a5],
 [0x7b1, 0x7b1], [0x7c0, 0x7ea], [0x7f4, 0x7f5], [0x7fa, 0x7fa], [0x800, 0x815],
 [0x81a, 0x81a], [0x824, 0x824], [0x828, 0x828], [0x830, 0x83e], [0x840, 0x858],
 [0x85e, 0x85e], [0x8a0, 0x8a0], [0x8a2, 0x8ac], [0x200f, 0x200f],
 [0xfb1d, 0xfb1d], [0xfb1f, 0xfb28], [0xfb2a, 0xfb36], [0xfb38, 0xfb3c],
 [0xfb3e, 0xfb3e], [0xfb40, 0xfb41], [0xfb43, 0xfb44], [0xfb46, 0xfbc1],
 [0xfbd3, 0xfd3d], [0xfd50, 0xfd8f], [0xfd92, 0xfdc7], [0xfdf0, 0xfdfc],
 [0xfe70, 0xfe74], [0xfe76, 0xfefc], [0x10800, 0x10805], [0x10808, 0x10808],
 [0x1080a, 0x10835], [0x10837, 0x10838], [0x1083c, 0x1083c], [0x1083f, 0x10855],
 [0x10857, 0x1085f], [0x10900, 0x1091b], [0x10920, 0x10939], [0x1093f, 0x1093f],
 [0x10980, 0x109b7], [0x109be, 0x109bf], [0x10a00, 0x10a00], [0x10a10, 0x10a13],
 [0x10a15, 0x10a17], [0x10a19, 0x10a33], [0x10a40, 0x10a47], [0x10a50, 0x10a58],
 [0x10a60, 0x10a7f], [0x10b00, 0x10b35], [0x10b40, 0x10b55], [0x10b58, 0x10b72],
 [0x10b78, 0x10b7f], [0x10c00, 0x10c48], [0x1ee00, 0x1ee03], [0x1ee05, 0x1ee1f],
 [0x1ee21, 0x1ee22], [0x1ee24, 0x1ee24], [0x1ee27, 0x1ee27], [0x1ee29, 0x1ee32],
 [0x1ee34, 0x1ee37], [0x1ee39, 0x1ee39], [0x1ee3b, 0x1ee3b], [0x1ee42, 0x1ee42],
 [0x1ee47, 0x1ee47], [0x1ee49, 0x1ee49], [0x1ee4b, 0x1ee4b], [0x1ee4d, 0x1ee4f],
 [0x1ee51, 0x1ee52], [0x1ee54, 0x1ee54], [0x1ee57, 0x1ee57], [0x1ee59, 0x1ee59],
 [0x1ee5b, 0x1ee5b], [0x1ee5d, 0x1ee5d], [0x1ee5f, 0x1ee5f], [0x1ee61, 0x1ee62],
 [0x1ee64, 0x1ee64], [0x1ee67, 0x1ee6a], [0x1ee6c, 0x1ee72], [0x1ee74, 0x1ee77],
 [0x1ee79, 0x1ee7c], [0x1ee7e, 0x1ee7e], [0x1ee80, 0x1ee89], [0x1ee8b, 0x1ee9b],
 [0x1eea1, 0x1eea3], [0x1eea5, 0x1eea9], [0x1eeab, 0x1eebb], [0x10fffd, 0x10fffd]];

function isStrongRTLChar(charCode) {
  for (var i = 0; i < strongRTLRanges.length; i++) {
    var currentRange = strongRTLRanges[i];
    if (charCode >= currentRange[0] && charCode <= currentRange[1]) {
      return true;
    }
  }

  return false;
}

function determineBidi(cueDiv) {
  var nodeStack = [],
      text = "",
      charCode;

  if (!cueDiv || !cueDiv.childNodes) {
    return "ltr";
  }

  function pushNodes(nodeStack, node) {
    for (var i = node.childNodes.length - 1; i >= 0; i--) {
      nodeStack.push(node.childNodes[i]);
    }
  }

  function nextTextNode(nodeStack) {
    if (!nodeStack || !nodeStack.length) {
      return null;
    }

    var node = nodeStack.pop(),
        text = node.textContent || node.innerText;
    if (text) {
      // TODO: This should match all unicode type B characters (paragraph
      // separator characters). See issue #115.
      var m = text.match(/^.*(\n|\r)/);
      if (m) {
        nodeStack.length = 0;
        return m[0];
      }
      return text;
    }
    if (node.tagName === "ruby") {
      return nextTextNode(nodeStack);
    }
    if (node.childNodes) {
      pushNodes(nodeStack, node);
      return nextTextNode(nodeStack);
    }
  }

  pushNodes(nodeStack, cueDiv);
  while ((text = nextTextNode(nodeStack))) {
    for (var i = 0; i < text.length; i++) {
      charCode = text.charCodeAt(i);
      if (isStrongRTLChar(charCode)) {
        return "rtl";
      }
    }
  }
  return "ltr";
}

function computeLinePos(cue) {
  if (typeof cue.line === "number" &&
      (cue.snapToLines || (cue.line >= 0 && cue.line <= 100))) {
    return cue.line;
  }
  if (!cue.track || !cue.track.textTrackList ||
      !cue.track.textTrackList.mediaElement) {
    return -1;
  }
  var track = cue.track,
      trackList = track.textTrackList,
      count = 0;
  for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
    if (trackList[i].mode === "showing") {
      count++;
    }
  }
  return ++count * -1;
}

function StyleBox() {
}

// Apply styles to a div. If there is no div passed then it defaults to the
// div on 'this'.
StyleBox.prototype.applyStyles = function(styles, div) {
  div = div || this.div;
  for (var prop in styles) {
    if (styles.hasOwnProperty(prop)) {
      div.style[prop] = styles[prop];
    }
  }
};

StyleBox.prototype.formatStyle = function(val, unit) {
  return val === 0 ? 0 : val + unit;
};

// Constructs the computed display state of the cue (a div). Places the div
// into the overlay which should be a block level element (usually a div).
function CueStyleBox(window, cue, styleOptions) {
  var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);
  var color = "rgba(255, 255, 255, 1)";
  var backgroundColor = "rgba(0, 0, 0, 0.8)";

  if (isIE8) {
    color = "rgb(255, 255, 255)";
    backgroundColor = "rgb(0, 0, 0)";
  }

  StyleBox.call(this);
  this.cue = cue;

  // Parse our cue's text into a DOM tree rooted at 'cueDiv'. This div will
  // have inline positioning and will function as the cue background box.
  this.cueDiv = parseContent(window, cue.text);
  var styles = {
    color: color,
    backgroundColor: backgroundColor,
    position: "relative",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    display: "inline"
  };

  if (!isIE8) {
    styles.writingMode = cue.vertical === "" ? "horizontal-tb"
                                             : cue.vertical === "lr" ? "vertical-lr"
                                                                     : "vertical-rl";
    styles.unicodeBidi = "plaintext";
  }
  this.applyStyles(styles, this.cueDiv);

  // Create an absolutely positioned div that will be used to position the cue
  // div. Note, all WebVTT cue-setting alignments are equivalent to the CSS
  // mirrors of them except "middle" which is "center" in CSS.
  this.div = window.document.createElement("div");
  styles = {
    textAlign: cue.align === "middle" ? "center" : cue.align,
    font: styleOptions.font,
    whiteSpace: "pre-line",
    position: "absolute"
  };

  if (!isIE8) {
    styles.direction = determineBidi(this.cueDiv);
    styles.writingMode = cue.vertical === "" ? "horizontal-tb"
                                             : cue.vertical === "lr" ? "vertical-lr"
                                                                     : "vertical-rl".
    stylesunicodeBidi =  "plaintext";
  }

  this.applyStyles(styles);

  this.div.appendChild(this.cueDiv);

  // Calculate the distance from the reference edge of the viewport to the text
  // position of the cue box. The reference edge will be resolved later when
  // the box orientation styles are applied.
  var textPos = 0;
  switch (cue.positionAlign) {
  case "start":
    textPos = cue.position;
    break;
  case "middle":
    textPos = cue.position - (cue.size / 2);
    break;
  case "end":
    textPos = cue.position - cue.size;
    break;
  }

  // Horizontal box orientation; textPos is the distance from the left edge of the
  // area to the left edge of the box and cue.size is the distance extending to
  // the right from there.
  if (cue.vertical === "") {
    this.applyStyles({
      left:  this.formatStyle(textPos, "%"),
      width: this.formatStyle(cue.size, "%")
    });
  // Vertical box orientation; textPos is the distance from the top edge of the
  // area to the top edge of the box and cue.size is the height extending
  // downwards from there.
  } else {
    this.applyStyles({
      top: this.formatStyle(textPos, "%"),
      height: this.formatStyle(cue.size, "%")
    });
  }

  this.move = function(box) {
    this.applyStyles({
      top: this.formatStyle(box.top, "px"),
      bottom: this.formatStyle(box.bottom, "px"),
      left: this.formatStyle(box.left, "px"),
      right: this.formatStyle(box.right, "px"),
      height: this.formatStyle(box.height, "px"),
      width: this.formatStyle(box.width, "px")
    });
  };
}
CueStyleBox.prototype = _objCreate(StyleBox.prototype);
CueStyleBox.prototype.constructor = CueStyleBox;

// Represents the co-ordinates of an Element in a way that we can easily
// compute things with such as if it overlaps or intersects with another Element.
// Can initialize it with either a StyleBox or another BoxPosition.
function BoxPosition(obj) {
  var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);

  // Either a BoxPosition was passed in and we need to copy it, or a StyleBox
  // was passed in and we need to copy the results of 'getBoundingClientRect'
  // as the object returned is readonly. All co-ordinate values are in reference
  // to the viewport origin (top left).
  var lh, height, width, top;
  if (obj.div) {
    height = obj.div.offsetHeight;
    width = obj.div.offsetWidth;
    top = obj.div.offsetTop;

    var rects = (rects = obj.div.childNodes) && (rects = rects[0]) &&
                rects.getClientRects && rects.getClientRects();
    obj = obj.div.getBoundingClientRect();
    // In certain cases the outter div will be slightly larger then the sum of
    // the inner div's lines. This could be due to bold text, etc, on some platforms.
    // In this case we should get the average line height and use that. This will
    // result in the desired behaviour.
    lh = rects ? Math.max((rects[0] && rects[0].height) || 0, obj.height / rects.length)
               : 0;

  }
  this.left = obj.left;
  this.right = obj.right;
  this.top = obj.top || top;
  this.height = obj.height || height;
  this.bottom = obj.bottom || (top + (obj.height || height));
  this.width = obj.width || width;
  this.lineHeight = lh !== undefined ? lh : obj.lineHeight;

  if (isIE8 && !this.lineHeight) {
    this.lineHeight = 13;
  }
}

// Move the box along a particular axis. Optionally pass in an amount to move
// the box. If no amount is passed then the default is the line height of the
// box.
BoxPosition.prototype.move = function(axis, toMove) {
  toMove = toMove !== undefined ? toMove : this.lineHeight;
  switch (axis) {
  case "+x":
    this.left += toMove;
    this.right += toMove;
    break;
  case "-x":
    this.left -= toMove;
    this.right -= toMove;
    break;
  case "+y":
    this.top += toMove;
    this.bottom += toMove;
    break;
  case "-y":
    this.top -= toMove;
    this.bottom -= toMove;
    break;
  }
};

// Check if this box overlaps another box, b2.
BoxPosition.prototype.overlaps = function(b2) {
  return this.left < b2.right &&
         this.right > b2.left &&
         this.top < b2.bottom &&
         this.bottom > b2.top;
};

// Check if this box overlaps any other boxes in boxes.
BoxPosition.prototype.overlapsAny = function(boxes) {
  for (var i = 0; i < boxes.length; i++) {
    if (this.overlaps(boxes[i])) {
      return true;
    }
  }
  return false;
};

// Check if this box is within another box.
BoxPosition.prototype.within = function(container) {
  return this.top >= container.top &&
         this.bottom <= container.bottom &&
         this.left >= container.left &&
         this.right <= container.right;
};

// Check if this box is entirely within the container or it is overlapping
// on the edge opposite of the axis direction passed. For example, if "+x" is
// passed and the box is overlapping on the left edge of the container, then
// return true.
BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
  switch (axis) {
  case "+x":
    return this.left < container.left;
  case "-x":
    return this.right > container.right;
  case "+y":
    return this.top < container.top;
  case "-y":
    return this.bottom > container.bottom;
  }
};

// Find the percentage of the area that this box is overlapping with another
// box.
BoxPosition.prototype.intersectPercentage = function(b2) {
  var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)),
      y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)),
      intersectArea = x * y;
  return intersectArea / (this.height * this.width);
};

// Convert the positions from this box to CSS compatible positions using
// the reference container's positions. This has to be done because this
// box's positions are in reference to the viewport origin, whereas, CSS
// values are in referecne to their respective edges.
BoxPosition.prototype.toCSSCompatValues = function(reference) {
  return {
    top: this.top - reference.top,
    bottom: reference.bottom - this.bottom,
    left: this.left - reference.left,
    right: reference.right - this.right,
    height: this.height,
    width: this.width
  };
};

// Get an object that represents the box's position without anything extra.
// Can pass a StyleBox, HTMLElement, or another BoxPositon.
BoxPosition.getSimpleBoxPosition = function(obj) {
  var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
  var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
  var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;

  obj = obj.div ? obj.div.getBoundingClientRect() :
                obj.tagName ? obj.getBoundingClientRect() : obj;
  var ret = {
    left: obj.left,
    right: obj.right,
    top: obj.top || top,
    height: obj.height || height,
    bottom: obj.bottom || (top + (obj.height || height)),
    width: obj.width || width
  };
  return ret;
};

// Move a StyleBox to its specified, or next best, position. The containerBox
// is the box that contains the StyleBox, such as a div. boxPositions are
// a list of other boxes that the styleBox can't overlap with.
function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {

  // Find the best position for a cue box, b, on the video. The axis parameter
  // is a list of axis, the order of which, it will move the box along. For example:
  // Passing ["+x", "-x"] will move the box first along the x axis in the positive
  // direction. If it doesn't find a good position for it there it will then move
  // it along the x axis in the negative direction.
  function findBestPosition(b, axis) {
    var bestPosition,
        specifiedPosition = new BoxPosition(b),
        percentage = 1; // Highest possible so the first thing we get is better.

    for (var i = 0; i < axis.length; i++) {
      while (b.overlapsOppositeAxis(containerBox, axis[i]) ||
             (b.within(containerBox) && b.overlapsAny(boxPositions))) {
        b.move(axis[i]);
      }
      // We found a spot where we aren't overlapping anything. This is our
      // best position.
      if (b.within(containerBox)) {
        return b;
      }
      var p = b.intersectPercentage(containerBox);
      // If we're outside the container box less then we were on our last try
      // then remember this position as the best position.
      if (percentage > p) {
        bestPosition = new BoxPosition(b);
        percentage = p;
      }
      // Reset the box position to the specified position.
      b = new BoxPosition(specifiedPosition);
    }
    return bestPosition || specifiedPosition;
  }

  var boxPosition = new BoxPosition(styleBox),
      cue = styleBox.cue,
      linePos = computeLinePos(cue),
      axis = [];

  // If we have a line number to align the cue to.
  if (cue.snapToLines) {
    var size;
    switch (cue.vertical) {
    case "":
      axis = [ "+y", "-y" ];
      size = "height";
      break;
    case "rl":
      axis = [ "+x", "-x" ];
      size = "width";
      break;
    case "lr":
      axis = [ "-x", "+x" ];
      size = "width";
      break;
    }

    var step = boxPosition.lineHeight,
        position = step * Math.round(linePos),
        maxPosition = containerBox[size] + step,
        initialAxis = axis[0];

    // If the specified intial position is greater then the max position then
    // clamp the box to the amount of steps it would take for the box to
    // reach the max position.
    if (Math.abs(position) > maxPosition) {
      position = position < 0 ? -1 : 1;
      position *= Math.ceil(maxPosition / step) * step;
    }

    // If computed line position returns negative then line numbers are
    // relative to the bottom of the video instead of the top. Therefore, we
    // need to increase our initial position by the length or width of the
    // video, depending on the writing direction, and reverse our axis directions.
    if (linePos < 0) {
      position += cue.vertical === "" ? containerBox.height : containerBox.width;
      axis = axis.reverse();
    }

    // Move the box to the specified position. This may not be its best
    // position.
    boxPosition.move(initialAxis, position);

  } else {
    // If we have a percentage line value for the cue.
    var calculatedPercentage = (boxPosition.lineHeight / containerBox.height) * 100;

    switch (cue.lineAlign) {
    case "middle":
      linePos -= (calculatedPercentage / 2);
      break;
    case "end":
      linePos -= calculatedPercentage;
      break;
    }

    // Apply initial line position to the cue box.
    switch (cue.vertical) {
    case "":
      styleBox.applyStyles({
        top: styleBox.formatStyle(linePos, "%")
      });
      break;
    case "rl":
      styleBox.applyStyles({
        left: styleBox.formatStyle(linePos, "%")
      });
      break;
    case "lr":
      styleBox.applyStyles({
        right: styleBox.formatStyle(linePos, "%")
      });
      break;
    }

    axis = [ "+y", "-x", "+x", "-y" ];

    // Get the box position again after we've applied the specified positioning
    // to it.
    boxPosition = new BoxPosition(styleBox);
  }

  var bestPosition = findBestPosition(boxPosition, axis);
  styleBox.move(bestPosition.toCSSCompatValues(containerBox));
}

function WebVTT$1() {
  // Nothing
}

// Helper to allow strings to be decoded instead of the default binary utf8 data.
WebVTT$1.StringDecoder = function() {
  return {
    decode: function(data) {
      if (!data) {
        return "";
      }
      if (typeof data !== "string") {
        throw new Error("Error - expected string data.");
      }
      return decodeURIComponent(encodeURIComponent(data));
    }
  };
};

WebVTT$1.convertCueToDOMTree = function(window, cuetext) {
  if (!window || !cuetext) {
    return null;
  }
  return parseContent(window, cuetext);
};

var FONT_SIZE_PERCENT = 0.05;
var FONT_STYLE = "sans-serif";
var CUE_BACKGROUND_PADDING = "1.5%";

// Runs the processing model over the cues and regions passed to it.
// @param overlay A block level element (usually a div) that the computed cues
//                and regions will be placed into.
WebVTT$1.processCues = function(window, cues, overlay) {
  if (!window || !cues || !overlay) {
    return null;
  }

  // Remove all previous children.
  while (overlay.firstChild) {
    overlay.removeChild(overlay.firstChild);
  }

  var paddedOverlay = window.document.createElement("div");
  paddedOverlay.style.position = "absolute";
  paddedOverlay.style.left = "0";
  paddedOverlay.style.right = "0";
  paddedOverlay.style.top = "0";
  paddedOverlay.style.bottom = "0";
  paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
  overlay.appendChild(paddedOverlay);

  // Determine if we need to compute the display states of the cues. This could
  // be the case if a cue's state has been changed since the last computation or
  // if it has not been computed yet.
  function shouldCompute(cues) {
    for (var i = 0; i < cues.length; i++) {
      if (cues[i].hasBeenReset || !cues[i].displayState) {
        return true;
      }
    }
    return false;
  }

  // We don't need to recompute the cues' display states. Just reuse them.
  if (!shouldCompute(cues)) {
    for (var i = 0; i < cues.length; i++) {
      paddedOverlay.appendChild(cues[i].displayState);
    }
    return;
  }

  var boxPositions = [],
      containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay),
      fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
  var styleOptions = {
    font: fontSize + "px " + FONT_STYLE
  };

  (function() {
    var styleBox, cue;

    for (var i = 0; i < cues.length; i++) {
      cue = cues[i];

      // Compute the intial position and styles of the cue div.
      styleBox = new CueStyleBox(window, cue, styleOptions);
      paddedOverlay.appendChild(styleBox.div);

      // Move the cue div to it's correct line position.
      moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);

      // Remember the computed div so that we don't have to recompute it later
      // if we don't have too.
      cue.displayState = styleBox.div;

      boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
    }
  })();
};

WebVTT$1.Parser = function(window, vttjs, decoder) {
  if (!decoder) {
    decoder = vttjs;
    vttjs = {};
  }
  if (!vttjs) {
    vttjs = {};
  }

  this.window = window;
  this.vttjs = vttjs;
  this.state = "INITIAL";
  this.buffer = "";
  this.decoder = decoder || new TextDecoder("utf8");
  this.regionList = [];
};

WebVTT$1.Parser.prototype = {
  // If the error is a ParsingError then report it to the consumer if
  // possible. If it's not a ParsingError then throw it like normal.
  reportOrThrowError: function(e) {
    if (e instanceof ParsingError) {
      this.onparsingerror && this.onparsingerror(e);
    } else {
      throw e;
    }
  },
  parse: function (data) {
    var self = this;

    // If there is no data then we won't decode it, but will just try to parse
    // whatever is in buffer already. This may occur in circumstances, for
    // example when flush() is called.
    if (data) {
      // Try to decode the data that we received.
      self.buffer += self.decoder.decode(data, {stream: true});
    }

    function collectNextLine() {
      var buffer = self.buffer;
      var pos = 0;
      while (pos < buffer.length && buffer[pos] !== '\r' && buffer[pos] !== '\n') {
        ++pos;
      }
      var line = buffer.substr(0, pos);
      // Advance the buffer early in case we fail below.
      if (buffer[pos] === '\r') {
        ++pos;
      }
      if (buffer[pos] === '\n') {
        ++pos;
      }
      self.buffer = buffer.substr(pos);
      return line;
    }

    // 3.4 WebVTT region and WebVTT region settings syntax
    function parseRegion(input) {
      var settings = new Settings();

      parseOptions(input, function (k, v) {
        switch (k) {
        case "id":
          settings.set(k, v);
          break;
        case "width":
          settings.percent(k, v);
          break;
        case "lines":
          settings.integer(k, v);
          break;
        case "regionanchor":
        case "viewportanchor":
          var xy = v.split(',');
          if (xy.length !== 2) {
            break;
          }
          // We have to make sure both x and y parse, so use a temporary
          // settings object here.
          var anchor = new Settings();
          anchor.percent("x", xy[0]);
          anchor.percent("y", xy[1]);
          if (!anchor.has("x") || !anchor.has("y")) {
            break;
          }
          settings.set(k + "X", anchor.get("x"));
          settings.set(k + "Y", anchor.get("y"));
          break;
        case "scroll":
          settings.alt(k, v, ["up"]);
          break;
        }
      }, /=/, /\s/);

      // Create the region, using default values for any values that were not
      // specified.
      if (settings.has("id")) {
        var region = new (self.vttjs.VTTRegion || self.window.VTTRegion)();
        region.width = settings.get("width", 100);
        region.lines = settings.get("lines", 3);
        region.regionAnchorX = settings.get("regionanchorX", 0);
        region.regionAnchorY = settings.get("regionanchorY", 100);
        region.viewportAnchorX = settings.get("viewportanchorX", 0);
        region.viewportAnchorY = settings.get("viewportanchorY", 100);
        region.scroll = settings.get("scroll", "");
        // Register the region.
        self.onregion && self.onregion(region);
        // Remember the VTTRegion for later in case we parse any VTTCues that
        // reference it.
        self.regionList.push({
          id: settings.get("id"),
          region: region
        });
      }
    }

    // draft-pantos-http-live-streaming-20
    // https://tools.ietf.org/html/draft-pantos-http-live-streaming-20#section-3.5
    // 3.5 WebVTT
    function parseTimestampMap(input) {
      var settings = new Settings();

      parseOptions(input, function(k, v) {
        switch(k) {
        case "MPEGT":
          settings.integer(k + 'S', v);
          break;
        case "LOCA":
          settings.set(k + 'L', parseTimeStamp(v));
          break;
        }
      }, /[^\d]:/, /,/);

      self.ontimestampmap && self.ontimestampmap({
        "MPEGTS": settings.get("MPEGTS"),
        "LOCAL": settings.get("LOCAL")
      });
    }

    // 3.2 WebVTT metadata header syntax
    function parseHeader(input) {
      if (input.match(/X-TIMESTAMP-MAP/)) {
        // This line contains HLS X-TIMESTAMP-MAP metadata
        parseOptions(input, function(k, v) {
          switch(k) {
          case "X-TIMESTAMP-MAP":
            parseTimestampMap(v);
            break;
          }
        }, /=/);
      } else {
        parseOptions(input, function (k, v) {
          switch (k) {
          case "Region":
            // 3.3 WebVTT region metadata header syntax
            parseRegion(v);
            break;
          }
        }, /:/);
      }

    }

    // 5.1 WebVTT file parsing.
    try {
      var line;
      if (self.state === "INITIAL") {
        // We can't start parsing until we have the first line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        line = collectNextLine();

        var m = line.match(/^WEBVTT([ \t].*)?$/);
        if (!m || !m[0]) {
          throw new ParsingError(ParsingError.Errors.BadSignature);
        }

        self.state = "HEADER";
      }

      var alreadyCollectedLine = false;
      while (self.buffer) {
        // We can't parse a line until we have the full line.
        if (!/\r\n|\n/.test(self.buffer)) {
          return this;
        }

        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }

        switch (self.state) {
        case "HEADER":
          // 13-18 - Allow a header (metadata) under the WEBVTT line.
          if (/:/.test(line)) {
            parseHeader(line);
          } else if (!line) {
            // An empty line terminates the header and starts the body (cues).
            self.state = "ID";
          }
          continue;
        case "NOTE":
          // Ignore NOTE blocks.
          if (!line) {
            self.state = "ID";
          }
          continue;
        case "ID":
          // Check for the start of NOTE blocks.
          if (/^NOTE($|[ \t])/.test(line)) {
            self.state = "NOTE";
            break;
          }
          // 19-29 - Allow any number of line terminators, then initialize new cue values.
          if (!line) {
            continue;
          }
          self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, "");
          self.state = "CUE";
          // 30-39 - Check if self line contains an optional identifier or timing data.
          if (line.indexOf("-->") === -1) {
            self.cue.id = line;
            continue;
          }
          // Process line as start of a cue.
          /*falls through*/
        case "CUE":
          // 40 - Collect cue timings and settings.
          try {
            parseCue(line, self.cue, self.regionList);
          } catch (e) {
            self.reportOrThrowError(e);
            // In case of an error ignore rest of the cue.
            self.cue = null;
            self.state = "BADCUE";
            continue;
          }
          self.state = "CUETEXT";
          continue;
        case "CUETEXT":
          var hasSubstring = line.indexOf("-->") !== -1;
          // 34 - If we have an empty line then report the cue.
          // 35 - If we have the special substring '-->' then report the cue,
          // but do not collect the line as we need to process the current
          // one as a new cue.
          if (!line || hasSubstring && (alreadyCollectedLine = true)) {
            // We are done parsing self cue.
            self.oncue && self.oncue(self.cue);
            self.cue = null;
            self.state = "ID";
            continue;
          }
          if (self.cue.text) {
            self.cue.text += "\n";
          }
          self.cue.text += line;
          continue;
        case "BADCUE": // BADCUE
          // 54-62 - Collect and discard the remaining cue.
          if (!line) {
            self.state = "ID";
          }
          continue;
        }
      }
    } catch (e) {
      self.reportOrThrowError(e);

      // If we are currently parsing a cue, report what we have.
      if (self.state === "CUETEXT" && self.cue && self.oncue) {
        self.oncue(self.cue);
      }
      self.cue = null;
      // Enter BADWEBVTT state if header was not parsed correctly otherwise
      // another exception occurred so enter BADCUE state.
      self.state = self.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
    }
    return this;
  },
  flush: function () {
    var self = this;
    try {
      // Finish decoding the stream.
      self.buffer += self.decoder.decode();
      // Synthesize the end of the current cue or region.
      if (self.cue || self.state === "HEADER") {
        self.buffer += "\n\n";
        self.parse();
      }
      // If we've flushed, parsed, and we're still on the INITIAL state then
      // that means we don't have enough of the stream to parse the first
      // line.
      if (self.state === "INITIAL") {
        throw new ParsingError(ParsingError.Errors.BadSignature);
      }
    } catch(e) {
      self.reportOrThrowError(e);
    }
    self.onflush && self.onflush();
    return this;
  }
};

var vtt$1 = WebVTT$1;

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var autoKeyword = "auto";
var directionSetting = {
  "": true,
  "lr": true,
  "rl": true
};
var alignSetting = {
  "start": true,
  "middle": true,
  "end": true,
  "left": true,
  "right": true
};

function findDirectionSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var dir = directionSetting[value.toLowerCase()];
  return dir ? value.toLowerCase() : false;
}

function findAlignSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var align = alignSetting[value.toLowerCase()];
  return align ? value.toLowerCase() : false;
}

function extend$1(obj) {
  var i = 1;
  for (; i < arguments.length; i++) {
    var cobj = arguments[i];
    for (var p in cobj) {
      obj[p] = cobj[p];
    }
  }

  return obj;
}

function VTTCue(startTime, endTime, text) {
  var cue = this;
  var isIE8 = (/MSIE\s8\.0/).test(navigator.userAgent);
  var baseObj = {};

  if (isIE8) {
    cue = document.createElement('custom');
  } else {
    baseObj.enumerable = true;
  }

  /**
   * Shim implementation specific properties. These properties are not in
   * the spec.
   */

  // Lets us know when the VTTCue's data has changed in such a way that we need
  // to recompute its display state. This lets us compute its display state
  // lazily.
  cue.hasBeenReset = false;

  /**
   * VTTCue and TextTrackCue properties
   * http://dev.w3.org/html5/webvtt/#vttcue-interface
   */

  var _id = "";
  var _pauseOnExit = false;
  var _startTime = startTime;
  var _endTime = endTime;
  var _text = text;
  var _region = null;
  var _vertical = "";
  var _snapToLines = true;
  var _line = "auto";
  var _lineAlign = "start";
  var _position = 50;
  var _positionAlign = "middle";
  var _size = 50;
  var _align = "middle";

  Object.defineProperty(cue,
    "id", extend$1({}, baseObj, {
      get: function() {
        return _id;
      },
      set: function(value) {
        _id = "" + value;
      }
    }));

  Object.defineProperty(cue,
    "pauseOnExit", extend$1({}, baseObj, {
      get: function() {
        return _pauseOnExit;
      },
      set: function(value) {
        _pauseOnExit = !!value;
      }
    }));

  Object.defineProperty(cue,
    "startTime", extend$1({}, baseObj, {
      get: function() {
        return _startTime;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("Start time must be set to a number.");
        }
        _startTime = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "endTime", extend$1({}, baseObj, {
      get: function() {
        return _endTime;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("End time must be set to a number.");
        }
        _endTime = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "text", extend$1({}, baseObj, {
      get: function() {
        return _text;
      },
      set: function(value) {
        _text = "" + value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "region", extend$1({}, baseObj, {
      get: function() {
        return _region;
      },
      set: function(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "vertical", extend$1({}, baseObj, {
      get: function() {
        return _vertical;
      },
      set: function(value) {
        var setting = findDirectionSetting(value);
        // Have to check for false because the setting an be an empty string.
        if (setting === false) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "snapToLines", extend$1({}, baseObj, {
      get: function() {
        return _snapToLines;
      },
      set: function(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "line", extend$1({}, baseObj, {
      get: function() {
        return _line;
      },
      set: function(value) {
        if (typeof value !== "number" && value !== autoKeyword) {
          throw new SyntaxError("An invalid number or illegal string was specified.");
        }
        _line = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "lineAlign", extend$1({}, baseObj, {
      get: function() {
        return _lineAlign;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "position", extend$1({}, baseObj, {
      get: function() {
        return _position;
      },
      set: function(value) {
        if (value < 0 || value > 100) {
          throw new Error("Position must be between 0 and 100.");
        }
        _position = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "positionAlign", extend$1({}, baseObj, {
      get: function() {
        return _positionAlign;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "size", extend$1({}, baseObj, {
      get: function() {
        return _size;
      },
      set: function(value) {
        if (value < 0 || value > 100) {
          throw new Error("Size must be between 0 and 100.");
        }
        _size = value;
        this.hasBeenReset = true;
      }
    }));

  Object.defineProperty(cue,
    "align", extend$1({}, baseObj, {
      get: function() {
        return _align;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _align = setting;
        this.hasBeenReset = true;
      }
    }));

  /**
   * Other <track> spec defined properties
   */

  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state
  cue.displayState = undefined;

  if (isIE8) {
    return cue;
  }
}

/**
 * VTTCue methods
 */

VTTCue.prototype.getCueAsHTML = function() {
  // Assume WebVTT.convertCueToDOMTree is on the global.
  return WebVTT.convertCueToDOMTree(window, this.text);
};

var vttcue = VTTCue;

/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var scrollSetting = {
  "": true,
  "up": true
};

function findScrollSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var scroll = scrollSetting[value.toLowerCase()];
  return scroll ? value.toLowerCase() : false;
}

function isValidPercentValue(value) {
  return typeof value === "number" && (value >= 0 && value <= 100);
}

// VTTRegion shim http://dev.w3.org/html5/webvtt/#vttregion-interface
function VTTRegion() {
  var _width = 100;
  var _lines = 3;
  var _regionAnchorX = 0;
  var _regionAnchorY = 100;
  var _viewportAnchorX = 0;
  var _viewportAnchorY = 100;
  var _scroll = "";

  Object.defineProperties(this, {
    "width": {
      enumerable: true,
      get: function() {
        return _width;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("Width must be between 0 and 100.");
        }
        _width = value;
      }
    },
    "lines": {
      enumerable: true,
      get: function() {
        return _lines;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("Lines must be set to a number.");
        }
        _lines = value;
      }
    },
    "regionAnchorY": {
      enumerable: true,
      get: function() {
        return _regionAnchorY;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("RegionAnchorX must be between 0 and 100.");
        }
        _regionAnchorY = value;
      }
    },
    "regionAnchorX": {
      enumerable: true,
      get: function() {
        return _regionAnchorX;
      },
      set: function(value) {
        if(!isValidPercentValue(value)) {
          throw new Error("RegionAnchorY must be between 0 and 100.");
        }
        _regionAnchorX = value;
      }
    },
    "viewportAnchorY": {
      enumerable: true,
      get: function() {
        return _viewportAnchorY;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("ViewportAnchorY must be between 0 and 100.");
        }
        _viewportAnchorY = value;
      }
    },
    "viewportAnchorX": {
      enumerable: true,
      get: function() {
        return _viewportAnchorX;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("ViewportAnchorX must be between 0 and 100.");
        }
        _viewportAnchorX = value;
      }
    },
    "scroll": {
      enumerable: true,
      get: function() {
        return _scroll;
      },
      set: function(value) {
        var setting = findScrollSetting(value);
        // Have to check for false as an empty string is a legal value.
        if (setting === false) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _scroll = setting;
      }
    }
  });
}

var vttregion = VTTRegion;

var browserIndex = createCommonjsModule(function (module) {
/**
 * Copyright 2013 vtt.js Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Default exports for Node. Export the extended versions of VTTCue and
// VTTRegion in Node since we likely want the capability to convert back and
// forth between JSON. If we don't then it's not that big of a deal since we're
// off browser.



var vttjs = module.exports = {
  WebVTT: vtt$1,
  VTTCue: vttcue,
  VTTRegion: vttregion
};

window_1.vttjs = vttjs;
window_1.WebVTT = vttjs.WebVTT;

var cueShim = vttjs.VTTCue;
var regionShim = vttjs.VTTRegion;
var nativeVTTCue = window_1.VTTCue;
var nativeVTTRegion = window_1.VTTRegion;

vttjs.shim = function() {
  window_1.VTTCue = cueShim;
  window_1.VTTRegion = regionShim;
};

vttjs.restore = function() {
  window_1.VTTCue = nativeVTTCue;
  window_1.VTTRegion = nativeVTTRegion;
};

if (!window_1.VTTCue) {
  vttjs.shim();
}
});

/**
 * @file tech.js
 */

/**
 * An Object containing a structure like: `{src: 'url', type: 'mimetype'}` or string
 * that just contains the src url alone.
 * * `var SourceObject = {src: 'http://ex.com/video.mp4', type: 'video/mp4'};`
   * `var SourceString = 'http://example.com/some-video.mp4';`
 *
 * @typedef {Object|string} Tech~SourceObject
 *
 * @property {string} src
 *           The url to the source
 *
 * @property {string} type
 *           The mime type of the source
 */

/**
 * A function used by {@link Tech} to create a new {@link TextTrack}.
 *
 * @private
 *
 * @param {Tech} self
 *        An instance of the Tech class.
 *
 * @param {string} kind
 *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
 *
 * @param {string} [label]
 *        Label to identify the text track
 *
 * @param {string} [language]
 *        Two letter language abbreviation
 *
 * @param {Object} [options={}]
 *        An object with additional text track options
 *
 * @return {TextTrack}
 *          The text track that was created.
 */
function createTrackHelper(self, kind, label, language) {
  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

  var tracks = self.textTracks();

  options.kind = kind;

  if (label) {
    options.label = label;
  }
  if (language) {
    options.language = language;
  }
  options.tech = self;

  var track = new ALL.text.TrackClass(options);

  tracks.addTrack(track);

  return track;
}

/**
 * This is the base class for media playback technology controllers, such as
 * {@link Flash} and {@link HTML5}
 *
 * @extends Component
 */

var Tech = function (_Component) {
  inherits(Tech, _Component);

  /**
   * Create an instance of this Tech.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} ready
   *        Callback function to call when the `HTML5` Tech is ready.
   */
  function Tech() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var ready = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
    classCallCheck(this, Tech);

    // we don't want the tech to report user activity automatically.
    // This is done manually in addControlsListeners
    options.reportTouchActivity = false;

    // keep track of whether the current source has played at all to
    // implement a very limited played()
    var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));

    _this.hasStarted_ = false;
    _this.on('playing', function () {
      this.hasStarted_ = true;
    });
    _this.on('loadstart', function () {
      this.hasStarted_ = false;
    });

    ALL.names.forEach(function (name) {
      var props = ALL[name];

      if (options && options[props.getterName]) {
        _this[props.privateName] = options[props.getterName];
      }
    });

    // Manually track progress in cases where the browser/flash player doesn't report it.
    if (!_this.featuresProgressEvents) {
      _this.manualProgressOn();
    }

    // Manually track timeupdates in cases where the browser/flash player doesn't report it.
    if (!_this.featuresTimeupdateEvents) {
      _this.manualTimeUpdatesOn();
    }

    ['Text', 'Audio', 'Video'].forEach(function (track) {
      if (options['native' + track + 'Tracks'] === false) {
        _this['featuresNative' + track + 'Tracks'] = false;
      }
    });

    if (options.nativeCaptions === false || options.nativeTextTracks === false) {
      _this.featuresNativeTextTracks = false;
    } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {
      _this.featuresNativeTextTracks = true;
    }

    if (!_this.featuresNativeTextTracks) {
      _this.emulateTextTracks();
    }

    _this.autoRemoteTextTracks_ = new ALL.text.ListClass();

    _this.initTrackListeners();

    // Turn on component tap events only if not using native controls
    if (!options.nativeControlsForTouch) {
      _this.emitTapEvents();
    }

    if (_this.constructor) {
      _this.name_ = _this.constructor.name || 'Unknown Tech';
    }
    return _this;
  }

  /* Fallbacks for unsupported event types
  ================================================================================ */

  /**
   * Polyfill the `progress` event for browsers that don't support it natively.
   *
   * @see {@link Tech#trackProgress}
   */


  Tech.prototype.manualProgressOn = function manualProgressOn() {
    this.on('durationchange', this.onDurationChange);

    this.manualProgress = true;

    // Trigger progress watching when a source begins loading
    this.one('ready', this.trackProgress);
  };

  /**
   * Turn off the polyfill for `progress` events that was created in
   * {@link Tech#manualProgressOn}
   */


  Tech.prototype.manualProgressOff = function manualProgressOff() {
    this.manualProgress = false;
    this.stopTrackingProgress();

    this.off('durationchange', this.onDurationChange);
  };

  /**
   * This is used to trigger a `progress` event when the buffered percent changes. It
   * sets an interval function that will be called every 500 milliseconds to check if the
   * buffer end percent has changed.
   *
   * > This function is called by {@link Tech#manualProgressOn}
   *
   * @param {EventTarget~Event} event
   *        The `ready` event that caused this to run.
   *
   * @listens Tech#ready
   * @fires Tech#progress
   */


  Tech.prototype.trackProgress = function trackProgress(event) {
    this.stopTrackingProgress();
    this.progressInterval = this.setInterval(bind(this, function () {
      // Don't trigger unless buffered amount is greater than last time

      var numBufferedPercent = this.bufferedPercent();

      if (this.bufferedPercent_ !== numBufferedPercent) {
        /**
         * See {@link Player#progress}
         *
         * @event Tech#progress
         * @type {EventTarget~Event}
         */
        this.trigger('progress');
      }

      this.bufferedPercent_ = numBufferedPercent;

      if (numBufferedPercent === 1) {
        this.stopTrackingProgress();
      }
    }), 500);
  };

  /**
   * Update our internal duration on a `durationchange` event by calling
   * {@link Tech#duration}.
   *
   * @param {EventTarget~Event} event
   *        The `durationchange` event that caused this to run.
   *
   * @listens Tech#durationchange
   */


  Tech.prototype.onDurationChange = function onDurationChange(event) {
    this.duration_ = this.duration();
  };

  /**
   * Get and create a `TimeRange` object for buffering.
   *
   * @return {TimeRange}
   *         The time range object that was created.
   */


  Tech.prototype.buffered = function buffered() {
    return createTimeRanges(0, 0);
  };

  /**
   * Get the percentage of the current video that is currently buffered.
   *
   * @return {number}
   *         A number from 0 to 1 that represents the decimal percentage of the
   *         video that is buffered.
   *
   */


  Tech.prototype.bufferedPercent = function bufferedPercent$$1() {
    return bufferedPercent(this.buffered(), this.duration_);
  };

  /**
   * Turn off the polyfill for `progress` events that was created in
   * {@link Tech#manualProgressOn}
   * Stop manually tracking progress events by clearing the interval that was set in
   * {@link Tech#trackProgress}.
   */


  Tech.prototype.stopTrackingProgress = function stopTrackingProgress() {
    this.clearInterval(this.progressInterval);
  };

  /**
   * Polyfill the `timeupdate` event for browsers that don't support it.
   *
   * @see {@link Tech#trackCurrentTime}
   */


  Tech.prototype.manualTimeUpdatesOn = function manualTimeUpdatesOn() {
    this.manualTimeUpdates = true;

    this.on('play', this.trackCurrentTime);
    this.on('pause', this.stopTrackingCurrentTime);
  };

  /**
   * Turn off the polyfill for `timeupdate` events that was created in
   * {@link Tech#manualTimeUpdatesOn}
   */


  Tech.prototype.manualTimeUpdatesOff = function manualTimeUpdatesOff() {
    this.manualTimeUpdates = false;
    this.stopTrackingCurrentTime();
    this.off('play', this.trackCurrentTime);
    this.off('pause', this.stopTrackingCurrentTime);
  };

  /**
   * Sets up an interval function to track current time and trigger `timeupdate` every
   * 250 milliseconds.
   *
   * @listens Tech#play
   * @triggers Tech#timeupdate
   */


  Tech.prototype.trackCurrentTime = function trackCurrentTime() {
    if (this.currentTimeInterval) {
      this.stopTrackingCurrentTime();
    }
    this.currentTimeInterval = this.setInterval(function () {
      /**
       * Triggered at an interval of 250ms to indicated that time is passing in the video.
       *
       * @event Tech#timeupdate
       * @type {EventTarget~Event}
       */
      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });

      // 42 = 24 fps // 250 is what Webkit uses // FF uses 15
    }, 250);
  };

  /**
   * Stop the interval function created in {@link Tech#trackCurrentTime} so that the
   * `timeupdate` event is no longer triggered.
   *
   * @listens {Tech#pause}
   */


  Tech.prototype.stopTrackingCurrentTime = function stopTrackingCurrentTime() {
    this.clearInterval(this.currentTimeInterval);

    // #1002 - if the video ends right before the next timeupdate would happen,
    // the progress bar won't make it all the way to the end
    this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
  };

  /**
   * Turn off all event polyfills, clear the `Tech`s {@link AudioTrackList},
   * {@link VideoTrackList}, and {@link TextTrackList}, and dispose of this Tech.
   *
   * @fires Component#dispose
   */


  Tech.prototype.dispose = function dispose() {

    // clear out all tracks because we can't reuse them between techs
    this.clearTracks(NORMAL.names);

    // Turn off any manual progress or timeupdate tracking
    if (this.manualProgress) {
      this.manualProgressOff();
    }

    if (this.manualTimeUpdates) {
      this.manualTimeUpdatesOff();
    }

    _Component.prototype.dispose.call(this);
  };

  /**
   * Clear out a single `TrackList` or an array of `TrackLists` given their names.
   *
   * > Note: Techs without source handlers should call this between sources for `video`
   *         & `audio` tracks. You don't want to use them between tracks!
   *
   * @param {string[]|string} types
   *        TrackList names to clear, valid names are `video`, `audio`, and
   *        `text`.
   */


  Tech.prototype.clearTracks = function clearTracks(types) {
    var _this2 = this;

    types = [].concat(types);
    // clear out all tracks because we can't reuse them between techs
    types.forEach(function (type) {
      var list = _this2[type + 'Tracks']() || [];
      var i = list.length;

      while (i--) {
        var track = list[i];

        if (type === 'text') {
          _this2.removeRemoteTextTrack(track);
        }
        list.removeTrack(track);
      }
    });
  };

  /**
   * Remove any TextTracks added via addRemoteTextTrack that are
   * flagged for automatic garbage collection
   */


  Tech.prototype.cleanupAutoTextTracks = function cleanupAutoTextTracks() {
    var list = this.autoRemoteTextTracks_ || [];
    var i = list.length;

    while (i--) {
      var track = list[i];

      this.removeRemoteTextTrack(track);
    }
  };

  /**
   * Reset the tech, which will removes all sources and reset the internal readyState.
   *
   * @abstract
   */


  Tech.prototype.reset = function reset() {};

  /**
   * Get or set an error on the Tech.
   *
   * @param {MediaError} [err]
   *        Error to set on the Tech
   *
   * @return {MediaError|null}
   *         The current error object on the tech, or null if there isn't one.
   */


  Tech.prototype.error = function error(err) {
    if (err !== undefined) {
      this.error_ = new MediaError(err);
      this.trigger('error');
    }
    return this.error_;
  };

  /**
   * Returns the `TimeRange`s that have been played through for the current source.
   *
   * > NOTE: This implementation is incomplete. It does not track the played `TimeRange`.
   *         It only checks wether the source has played at all or not.
   *
   * @return {TimeRange}
   *         - A single time range if this video has played
   *         - An empty set of ranges if not.
   */


  Tech.prototype.played = function played() {
    if (this.hasStarted_) {
      return createTimeRanges(0, 0);
    }
    return createTimeRanges();
  };

  /**
   * Causes a manual time update to occur if {@link Tech#manualTimeUpdatesOn} was
   * previously called.
   *
   * @fires Tech#timeupdate
   */


  Tech.prototype.setCurrentTime = function setCurrentTime() {
    // improve the accuracy of manual timeupdates
    if (this.manualTimeUpdates) {
      /**
       * A manual `timeupdate` event.
       *
       * @event Tech#timeupdate
       * @type {EventTarget~Event}
       */
      this.trigger({ type: 'timeupdate', target: this, manuallyTriggered: true });
    }
  };

  /**
   * Turn on listeners for {@link VideoTrackList}, {@link {AudioTrackList}, and
   * {@link TextTrackList} events.
   *
   * This adds {@link EventTarget~EventListeners} for `addtrack`, and  `removetrack`.
   *
   * @fires Tech#audiotrackchange
   * @fires Tech#videotrackchange
   * @fires Tech#texttrackchange
   */


  Tech.prototype.initTrackListeners = function initTrackListeners() {
    var _this3 = this;

    /**
     * Triggered when tracks are added or removed on the Tech {@link AudioTrackList}
     *
     * @event Tech#audiotrackchange
     * @type {EventTarget~Event}
     */

    /**
     * Triggered when tracks are added or removed on the Tech {@link VideoTrackList}
     *
     * @event Tech#videotrackchange
     * @type {EventTarget~Event}
     */

    /**
     * Triggered when tracks are added or removed on the Tech {@link TextTrackList}
     *
     * @event Tech#texttrackchange
     * @type {EventTarget~Event}
     */
    NORMAL.names.forEach(function (name) {
      var props = NORMAL[name];
      var trackListChanges = function trackListChanges() {
        _this3.trigger(name + 'trackchange');
      };

      var tracks = _this3[props.getterName]();

      tracks.addEventListener('removetrack', trackListChanges);
      tracks.addEventListener('addtrack', trackListChanges);

      _this3.on('dispose', function () {
        tracks.removeEventListener('removetrack', trackListChanges);
        tracks.removeEventListener('addtrack', trackListChanges);
      });
    });
  };

  /**
   * Emulate TextTracks using vtt.js if necessary
   *
   * @fires Tech#vttjsloaded
   * @fires Tech#vttjserror
   */


  Tech.prototype.addWebVttScript_ = function addWebVttScript_() {
    var _this4 = this;

    if (window_1.WebVTT) {
      return;
    }

    // Initially, Tech.el_ is a child of a dummy-div wait until the Component system
    // signals that the Tech is ready at which point Tech.el_ is part of the DOM
    // before inserting the WebVTT script
    if (document_1.body.contains(this.el())) {

      // load via require if available and vtt.js script location was not passed in
      // as an option. novtt builds will turn the above require call into an empty object
      // which will cause this if check to always fail.
      if (!this.options_['vtt.js'] && isPlain(browserIndex) && Object.keys(browserIndex).length > 0) {
        this.trigger('vttjsloaded');
        return;
      }

      // load vtt.js via the script location option or the cdn of no location was
      // passed in
      var script = document_1.createElement('script');

      script.src = this.options_['vtt.js'] || 'https://vjs.zencdn.net/vttjs/0.12.4/vtt.min.js';
      script.onload = function () {
        /**
         * Fired when vtt.js is loaded.
         *
         * @event Tech#vttjsloaded
         * @type {EventTarget~Event}
         */
        _this4.trigger('vttjsloaded');
      };
      script.onerror = function () {
        /**
         * Fired when vtt.js was not loaded due to an error
         *
         * @event Tech#vttjsloaded
         * @type {EventTarget~Event}
         */
        _this4.trigger('vttjserror');
      };
      this.on('dispose', function () {
        script.onload = null;
        script.onerror = null;
      });
      // but have not loaded yet and we set it to true before the inject so that
      // we don't overwrite the injected window.WebVTT if it loads right away
      window_1.WebVTT = true;
      this.el().parentNode.appendChild(script);
    } else {
      this.ready(this.addWebVttScript_);
    }
  };

  /**
   * Emulate texttracks
   *
   */


  Tech.prototype.emulateTextTracks = function emulateTextTracks() {
    var _this5 = this;

    var tracks = this.textTracks();
    var remoteTracks = this.remoteTextTracks();
    var handleAddTrack = function handleAddTrack(e) {
      return tracks.addTrack(e.track);
    };
    var handleRemoveTrack = function handleRemoveTrack(e) {
      return tracks.removeTrack(e.track);
    };

    remoteTracks.on('addtrack', handleAddTrack);
    remoteTracks.on('removetrack', handleRemoveTrack);

    this.addWebVttScript_();

    var updateDisplay = function updateDisplay() {
      return _this5.trigger('texttrackchange');
    };

    var textTracksChanges = function textTracksChanges() {
      updateDisplay();

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        track.removeEventListener('cuechange', updateDisplay);
        if (track.mode === 'showing') {
          track.addEventListener('cuechange', updateDisplay);
        }
      }
    };

    textTracksChanges();
    tracks.addEventListener('change', textTracksChanges);
    tracks.addEventListener('addtrack', textTracksChanges);
    tracks.addEventListener('removetrack', textTracksChanges);

    this.on('dispose', function () {
      remoteTracks.off('addtrack', handleAddTrack);
      remoteTracks.off('removetrack', handleRemoveTrack);
      tracks.removeEventListener('change', textTracksChanges);
      tracks.removeEventListener('addtrack', textTracksChanges);
      tracks.removeEventListener('removetrack', textTracksChanges);

      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];

        track.removeEventListener('cuechange', updateDisplay);
      }
    });
  };

  /**
   * Create and returns a remote {@link TextTrack} object.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @return {TextTrack}
   *         The TextTrack that gets created.
   */


  Tech.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (!kind) {
      throw new Error('TextTrack kind is required but was not provided');
    }

    return createTrackHelper(this, kind, label, language);
  };

  /**
   * Create an emulated TextTrack for use by addRemoteTextTrack
   *
   * This is intended to be overridden by classes that inherit from
   * Tech in order to create native or custom TextTracks.
   *
   * @param {Object} options
   *        The object should contain the options to initialize the TextTrack with.
   *
   * @param {string} [options.kind]
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
   *
   * @param {string} [options.label].
   *        Label to identify the text track
   *
   * @param {string} [options.language]
   *        Two letter language abbreviation.
   *
   * @return {HTMLTrackElement}
   *         The track element that gets created.
   */


  Tech.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {
    var track = mergeOptions(options, {
      tech: this
    });

    return new REMOTE.remoteTextEl.TrackClass(track);
  };

  /**
   * Creates a remote text track object and returns an html track element.
   *
   * > Note: This can be an emulated {@link HTMLTrackElement} or a native one.
   *
   * @param {Object} options
   *        See {@link Tech#createRemoteTextTrack} for more detailed properties.
   *
   * @param {boolean} [manualCleanup=true]
   *        - When false: the TextTrack will be automatically removed from the video
   *          element whenever the source changes
   *        - When True: The TextTrack will have to be cleaned up manually
   *
   * @return {HTMLTrackElement}
   *         An Html Track Element.
   *
   * @deprecated The default functionality for this function will be equivalent
   *             to "manualCleanup=false" in the future. The manualCleanup parameter will
   *             also be removed.
   */


  Tech.prototype.addRemoteTextTrack = function addRemoteTextTrack() {
    var _this6 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var manualCleanup = arguments[1];

    var htmlTrackElement = this.createRemoteTextTrack(options);

    if (manualCleanup !== true && manualCleanup !== false) {
      // deprecation warning
      log$1.warn('Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js');
      manualCleanup = true;
    }

    // store HTMLTrackElement and TextTrack to remote list
    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
    this.remoteTextTracks().addTrack(htmlTrackElement.track);

    if (manualCleanup !== true) {
      // create the TextTrackList if it doesn't exist
      this.ready(function () {
        return _this6.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);
      });
    }

    return htmlTrackElement;
  };

  /**
   * Remove a remote text track from the remote `TextTrackList`.
   *
   * @param {TextTrack} track
   *        `TextTrack` to remove from the `TextTrackList`
   */


  Tech.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);

    // remove HTMLTrackElement and TextTrack from remote list
    this.remoteTextTrackEls().removeTrackElement_(trackElement);
    this.remoteTextTracks().removeTrack(track);
    this.autoRemoteTextTracks_.removeTrack(track);
  };

  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   *
   * @abstract
   */


  Tech.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    return {};
  };

  /**
   * A method to set a poster from a `Tech`.
   *
   * @abstract
   */


  Tech.prototype.setPoster = function setPoster() {};

  /**
   * A method to check for the presence of the 'playsinine' <video> attribute.
   *
   * @abstract
   */


  Tech.prototype.playsinline = function playsinline() {};

  /**
   * A method to set or unset the 'playsinine' <video> attribute.
   *
   * @abstract
   */


  Tech.prototype.setPlaysinline = function setPlaysinline() {};

  /*
   * Check if the tech can support the given mime-type.
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param  {string} type
   *         The mimetype to check for support
   *
   * @return {string}
   *         'probably', 'maybe', or empty string
   *
   * @see [Spec]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType}
   *
   * @abstract
   */


  Tech.prototype.canPlayType = function canPlayType() {
    return '';
  };

  /**
   * Check if the type is supported by this tech.
   *
   * The base tech does not support any type, but source handlers might
   * overwrite this.
   *
   * @param {string} type
   *        The media type to check
   * @return {string} Returns the native video element's response
   */


  Tech.canPlayType = function canPlayType() {
    return '';
  };

  /**
   * Check if the tech can support the given source
   * @param {Object} srcObj
   *        The source object
   * @param {Object} options
   *        The options passed to the tech
   * @return {string} 'probably', 'maybe', or '' (empty string)
   */


  Tech.canPlaySource = function canPlaySource(srcObj, options) {
    return Tech.canPlayType(srcObj.type);
  };

  /*
   * Return whether the argument is a Tech or not.
   * Can be passed either a Class like `Html5` or a instance like `player.tech_`
   *
   * @param {Object} component
   *        The item to check
   *
   * @return {boolean}
   *         Whether it is a tech or not
   *         - True if it is a tech
   *         - False if it is not
   */


  Tech.isTech = function isTech(component) {
    return component.prototype instanceof Tech || component instanceof Tech || component === Tech;
  };

  /**
   * Registers a `Tech` into a shared list for videojs.
   *
   * @param {string} name
   *        Name of the `Tech` to register.
   *
   * @param {Object} tech
   *        The `Tech` class to register.
   */


  Tech.registerTech = function registerTech(name, tech) {
    if (!Tech.techs_) {
      Tech.techs_ = {};
    }

    if (!Tech.isTech(tech)) {
      throw new Error('Tech ' + name + ' must be a Tech');
    }

    if (!Tech.canPlayType) {
      throw new Error('Techs must have a static canPlayType method on them');
    }
    if (!Tech.canPlaySource) {
      throw new Error('Techs must have a static canPlaySource method on them');
    }

    name = toTitleCase(name);

    Tech.techs_[name] = tech;
    if (name !== 'Tech') {
      // camel case the techName for use in techOrder
      Tech.defaultTechOrder_.push(name);
    }
    return tech;
  };

  /**
   * Get a `Tech` from the shared list by name.
   *
   * @param {string} name
   *        `camelCase` or `TitleCase` name of the Tech to get
   *
   * @return {Tech|undefined}
   *         The `Tech` or undefined if there was no tech with the name requsted.
   */


  Tech.getTech = function getTech(name) {
    if (!name) {
      return;
    }

    name = toTitleCase(name);

    if (Tech.techs_ && Tech.techs_[name]) {
      return Tech.techs_[name];
    }

    if (window_1 && window_1.videojs && window_1.videojs[name]) {
      log$1.warn('The ' + name + ' tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)');
      return window_1.videojs[name];
    }
  };

  return Tech;
}(Component);

/**
 * Get the {@link VideoTrackList}
 *
 * @returns {VideoTrackList}
 * @method Tech.prototype.videoTracks
 */

/**
 * Get the {@link AudioTrackList}
 *
 * @returns {AudioTrackList}
 * @method Tech.prototype.audioTracks
 */

/**
 * Get the {@link TextTrackList}
 *
 * @returns {TextTrackList}
 * @method Tech.prototype.textTracks
 */

/**
 * Get the remote element {@link TextTrackList}
 *
 * @returns {TextTrackList}
 * @method Tech.prototype.remoteTextTracks
 */

/**
 * Get the remote element {@link HtmlTrackElementList}
 *
 * @returns {HtmlTrackElementList}
 * @method Tech.prototype.remoteTextTrackEls
 */

ALL.names.forEach(function (name) {
  var props = ALL[name];

  Tech.prototype[props.getterName] = function () {
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});

/**
 * List of associated text tracks
 *
 * @type {TextTrackList}
 * @private
 * @property Tech#textTracks_
 */

/**
 * List of associated audio tracks.
 *
 * @type {AudioTrackList}
 * @private
 * @property Tech#audioTracks_
 */

/**
 * List of associated video tracks.
 *
 * @type {VideoTrackList}
 * @private
 * @property Tech#videoTracks_
 */

/**
 * Boolean indicating wether the `Tech` supports volume control.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresVolumeControl = true;

/**
 * Boolean indicating wether the `Tech` support fullscreen resize control.
 * Resizing plugins using request fullscreen reloads the plugin
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresFullscreenResize = false;

/**
 * Boolean indicating wether the `Tech` supports changing the speed at which the video
 * plays. Examples:
 *   - Set player to play 2x (twice) as fast
 *   - Set player to play 0.5x (half) as fast
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresPlaybackRate = false;

/**
 * Boolean indicating wether the `Tech` supports the `progress` event. This is currently
 * not triggered by video-js-swf. This will be used to determine if
 * {@link Tech#manualProgressOn} should be called.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresProgressEvents = false;

/**
 * Boolean indicating wether the `Tech` supports the `timeupdate` event. This is currently
 * not triggered by video-js-swf. This will be used to determine if
 * {@link Tech#manualTimeUpdates} should be called.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresTimeupdateEvents = false;

/**
 * Boolean indicating wether the `Tech` supports the native `TextTrack`s.
 * This will help us integrate with native `TextTrack`s if the browser supports them.
 *
 * @type {boolean}
 * @default
 */
Tech.prototype.featuresNativeTextTracks = false;

/**
 * A functional mixin for techs that want to use the Source Handler pattern.
 * Source handlers are scripts for handling specific formats.
 * The source handler pattern is used for adaptive formats (HLS, DASH) that
 * manually load video data and feed it into a Source Buffer (Media Source Extensions)
 * Example: `Tech.withSourceHandlers.call(MyTech);`
 *
 * @param {Tech} _Tech
 *        The tech to add source handler functions to.
 *
 * @mixes Tech~SourceHandlerAdditions
 */
Tech.withSourceHandlers = function (_Tech) {

  /**
   * Register a source handler
   *
   * @param {Function} handler
   *        The source handler class
   *
   * @param {number} [index]
   *        Register it at the following index
   */
  _Tech.registerSourceHandler = function (handler, index) {
    var handlers = _Tech.sourceHandlers;

    if (!handlers) {
      handlers = _Tech.sourceHandlers = [];
    }

    if (index === undefined) {
      // add to the end of the list
      index = handlers.length;
    }

    handlers.splice(index, 0, handler);
  };

  /**
   * Check if the tech can support the given type. Also checks the
   * Techs sourceHandlers.
   *
   * @param {string} type
   *         The mimetype to check.
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */
  _Tech.canPlayType = function (type) {
    var handlers = _Tech.sourceHandlers || [];
    var can = void 0;

    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canPlayType(type);

      if (can) {
        return can;
      }
    }

    return '';
  };

  /**
   * Returns the first source handler that supports the source.
   *
   * TODO: Answer question: should 'probably' be prioritized over 'maybe'
   *
   * @param {Tech~SourceObject} source
   *        The source object
   *
   * @param {Object} options
   *        The options passed to the tech
   *
   * @return {SourceHandler|null}
   *          The first source handler that supports the source or null if
   *          no SourceHandler supports the source
   */
  _Tech.selectSourceHandler = function (source, options) {
    var handlers = _Tech.sourceHandlers || [];
    var can = void 0;

    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canHandleSource(source, options);

      if (can) {
        return handlers[i];
      }
    }

    return null;
  };

  /**
   * Check if the tech can support the given source.
   *
   * @param {Tech~SourceObject} srcObj
   *        The source object
   *
   * @param {Object} options
   *        The options passed to the tech
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */
  _Tech.canPlaySource = function (srcObj, options) {
    var sh = _Tech.selectSourceHandler(srcObj, options);

    if (sh) {
      return sh.canHandleSource(srcObj, options);
    }

    return '';
  };

  /**
   * When using a source handler, prefer its implementation of
   * any function normally provided by the tech.
   */
  var deferrable = ['seekable', 'duration'];

  /**
   * A wrapper around {@link Tech#seekable} that will call a `SourceHandler`s seekable
   * function if it exists, with a fallback to the Techs seekable function.
   *
   * @method _Tech.seekable
   */

  /**
   * A wrapper around {@link Tech#duration} that will call a `SourceHandler`s duration
   * function if it exists, otherwise it will fallback to the techs duration function.
   *
   * @method _Tech.duration
   */

  deferrable.forEach(function (fnName) {
    var originalFn = this[fnName];

    if (typeof originalFn !== 'function') {
      return;
    }

    this[fnName] = function () {
      if (this.sourceHandler_ && this.sourceHandler_[fnName]) {
        return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
      }
      return originalFn.apply(this, arguments);
    };
  }, _Tech.prototype);

  /**
   * Create a function for setting the source using a source object
   * and source handlers.
   * Should never be called unless a source handler was found.
   *
   * @param {Tech~SourceObject} source
   *        A source object with src and type keys
   */
  _Tech.prototype.setSource = function (source) {
    var sh = _Tech.selectSourceHandler(source, this.options_);

    if (!sh) {
      // Fall back to a native source hander when unsupported sources are
      // deliberately set
      if (_Tech.nativeSourceHandler) {
        sh = _Tech.nativeSourceHandler;
      } else {
        log$1.error('No source hander found for the current source.');
      }
    }

    // Dispose any existing source handler
    this.disposeSourceHandler();
    this.off('dispose', this.disposeSourceHandler);

    if (sh !== _Tech.nativeSourceHandler) {
      this.currentSource_ = source;
    }

    this.sourceHandler_ = sh.handleSource(source, this, this.options_);
    this.on('dispose', this.disposeSourceHandler);
  };

  /**
   * Clean up any existing SourceHandlers and listeners when the Tech is disposed.
   *
   * @listens Tech#dispose
   */
  _Tech.prototype.disposeSourceHandler = function () {
    // if we have a source and get another one
    // then we are loading something new
    // than clear all of our current tracks
    if (this.currentSource_) {
      this.clearTracks(['audio', 'video']);
      this.currentSource_ = null;
    }

    // always clean up auto-text tracks
    this.cleanupAutoTextTracks();

    if (this.sourceHandler_) {

      if (this.sourceHandler_.dispose) {
        this.sourceHandler_.dispose();
      }

      this.sourceHandler_ = null;
    }
  };
};

// The base Tech class needs to be registered as a Component. It is the only
// Tech that can be registered as a Component.
Component.registerComponent('Tech', Tech);
Tech.registerTech('Tech', Tech);

/**
 * A list of techs that should be added to techOrder on Players
 *
 * @private
 */
Tech.defaultTechOrder_ = [];

var middlewares = {};

function use(type, middleware) {
  middlewares[type] = middlewares[type] || [];
  middlewares[type].push(middleware);
}



function setSource(player, src, next) {
  player.setTimeout(function () {
    return setSourceHelper(src, middlewares[src.type], next, player);
  }, 1);
}

function setTech(middleware, tech) {
  middleware.forEach(function (mw) {
    return mw.setTech && mw.setTech(tech);
  });
}

function get$1(middleware, tech, method) {
  return middleware.reduceRight(middlewareIterator(method), tech[method]());
}

function set$1(middleware, tech, method, arg) {
  return tech[method](middleware.reduce(middlewareIterator(method), arg));
}

var allowedGetters = {
  buffered: 1,
  currentTime: 1,
  duration: 1,
  seekable: 1,
  played: 1
};

var allowedSetters = {
  setCurrentTime: 1
};

function middlewareIterator(method) {
  return function (value, mw) {
    if (mw[method]) {
      return mw[method](value);
    }

    return value;
  };
}

function setSourceHelper() {
  var src = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var middleware = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var next = arguments[2];
  var player = arguments[3];
  var acc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
  var lastRun = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var mwFactory = middleware[0],
      mwrest = middleware.slice(1);

  // if mwFactory is a string, then we're at a fork in the road

  if (typeof mwFactory === 'string') {
    setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun);

    // if we have an mwFactory, call it with the player to get the mw,
    // then call the mw's setSource method
  } else if (mwFactory) {
    var mw = mwFactory(player);

    mw.setSource(assign({}, src), function (err, _src) {

      // something happened, try the next middleware on the current level
      // make sure to use the old src
      if (err) {
        return setSourceHelper(src, mwrest, next, player, acc, lastRun);
      }

      // we've succeeded, now we need to go deeper
      acc.push(mw);

      // if it's the same time, continue does the current chain
      // otherwise, we want to go down the new chain
      setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);
    });
  } else if (mwrest.length) {
    setSourceHelper(src, mwrest, next, player, acc, lastRun);
  } else if (lastRun) {
    next(src, acc);
  } else {
    setSourceHelper(src, middlewares['*'], next, player, acc, true);
  }
}

/**
 * @module filter-source
 */
/**
 * Filter out single bad source objects or multiple source objects in an
 * array. Also flattens nested source object arrays into a 1 dimensional
 * array of source objects.
 *
 * @param {Tech~SourceObject|Tech~SourceObject[]} src
 *        The src object to filter
 *
 * @return {Tech~SourceObject[]}
 *         An array of sourceobjects containing only valid sources
 *
 * @private
 */
var filterSource = function filterSource(src) {
  // traverse array
  if (Array.isArray(src)) {
    var newsrc = [];

    src.forEach(function (srcobj) {
      srcobj = filterSource(srcobj);

      if (Array.isArray(srcobj)) {
        newsrc = newsrc.concat(srcobj);
      } else if (isObject(srcobj)) {
        newsrc.push(srcobj);
      }
    });

    src = newsrc;
  } else if (typeof src === 'string' && src.trim()) {
    // convert string into object
    src = [{ src: src }];
  } else if (isObject(src) && typeof src.src === 'string' && src.src && src.src.trim()) {
    // src is already valid
    src = [src];
  } else {
    // invalid source, turn it into an empty array
    src = [];
  }

  return src;
};

/**
 * @file loader.js
 */
/**
 * The `MediaLoader` is the `Component` that decides which playback technology to load
 * when a player is initialized.
 *
 * @extends Component
 */

var MediaLoader = function (_Component) {
  inherits(MediaLoader, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value stroe of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function that is run when this component is ready.
   */
  function MediaLoader(player, options, ready) {
    classCallCheck(this, MediaLoader);

    // MediaLoader has no element
    var options_ = mergeOptions({ createEl: false }, options);

    // If there are no sources when the player is initialized,
    // load the first supported playback technology.

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options_, ready));

    if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {
      for (var i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {
        var techName = toTitleCase(j[i]);
        var tech = Tech.getTech(techName);

        // Support old behavior of techs being registered as components.
        // Remove once that deprecated behavior is removed.
        if (!techName) {
          tech = Component.getComponent(techName);
        }

        // Check if the browser supports this technology
        if (tech && tech.isSupported()) {
          player.loadTech_(techName);
          break;
        }
      }
    } else {
      // Loop through playback technologies (HTML5, Flash) and check for support.
      // Then load the best source.
      // A few assumptions here:
      //   All playback technologies respect preload false.
      player.src(options.playerOptions.sources);
    }
    return _this;
  }

  return MediaLoader;
}(Component);

Component.registerComponent('MediaLoader', MediaLoader);

/**
 * @file button.js
 */
/**
 * Clickable Component which is clickable or keyboard actionable,
 * but is not a native HTML button.
 *
 * @extends Component
 */

var ClickableComponent = function (_Component) {
  inherits(ClickableComponent, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  function ClickableComponent(player, options) {
    classCallCheck(this, ClickableComponent);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.emitTapEvents();

    _this.enable();
    return _this;
  }

  /**
   * Create the `Component`s DOM element.
   *
   * @param {string} [tag=div]
   *        The element's node type.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element.
   *
   * @param {Object} [attributes={}]
   *        An object of attributes that should be set on the element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  ClickableComponent.prototype.createEl = function createEl$$1() {
    var tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div';
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    props = assign({
      innerHTML: '<span aria-hidden="true" class="vjs-icon-placeholder"></span>',
      className: this.buildCSSClass(),
      tabIndex: 0
    }, props);

    if (tag === 'button') {
      log$1.error('Creating a ClickableComponent with an HTML element of ' + tag + ' is not supported; use a Button instead.');
    }

    // Add ARIA attributes for clickable element which is not a native HTML button
    attributes = assign({
      'role': 'button',

      // let the screen reader user know that the text of the element may change
      'aria-live': 'polite'
    }, attributes);

    this.tabIndex_ = props.tabIndex;

    var el = _Component.prototype.createEl.call(this, tag, props, attributes);

    this.createControlTextEl(el);

    return el;
  };

  /**
   * Create a control text element on this `Component`
   *
   * @param {Element} [el]
   *        Parent element for the control text.
   *
   * @return {Element}
   *         The control text element that gets created.
   */


  ClickableComponent.prototype.createControlTextEl = function createControlTextEl(el) {
    this.controlTextEl_ = createEl('span', {
      className: 'vjs-control-text'
    });

    if (el) {
      el.appendChild(this.controlTextEl_);
    }

    this.controlText(this.controlText_, el);

    return this.controlTextEl_;
  };

  /**
   * Get or set the localize text to use for the controls on the `Component`.
   *
   * @param {string} [text]
   *        Control text for element.
   *
   * @param {Element} [el=this.el()]
   *        Element to set the title on.
   *
   * @return {string}
   *         - The control text when getting
   */


  ClickableComponent.prototype.controlText = function controlText(text) {
    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.el();

    if (!text) {
      return this.controlText_ || 'Need Text';
    }

    var localizedText = this.localize(text);

    this.controlText_ = text;
    textContent(this.controlTextEl_, localizedText);
    if (!this.nonIconControl) {
      // Set title attribute if only an icon is shown
      el.setAttribute('title', localizedText);
    }
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  ClickableComponent.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-control vjs-button ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Enable this `Component`s element.
   */


  ClickableComponent.prototype.enable = function enable() {
    if (!this.enabled_) {
      this.enabled_ = true;
      this.removeClass('vjs-disabled');
      this.el_.setAttribute('aria-disabled', 'false');
      if (typeof this.tabIndex_ !== 'undefined') {
        this.el_.setAttribute('tabIndex', this.tabIndex_);
      }
      this.on(['tap', 'click'], this.handleClick);
      this.on('focus', this.handleFocus);
      this.on('blur', this.handleBlur);
    }
  };

  /**
   * Disable this `Component`s element.
   */


  ClickableComponent.prototype.disable = function disable() {
    this.enabled_ = false;
    this.addClass('vjs-disabled');
    this.el_.setAttribute('aria-disabled', 'true');
    if (typeof this.tabIndex_ !== 'undefined') {
      this.el_.removeAttribute('tabIndex');
    }
    this.off(['tap', 'click'], this.handleClick);
    this.off('focus', this.handleFocus);
    this.off('blur', this.handleBlur);
  };

  /**
   * This gets called when a `ClickableComponent` gets:
   * - Clicked (via the `click` event, listening starts in the constructor)
   * - Tapped (via the `tap` event, listening starts in the constructor)
   * - The following things happen in order:
   *   1. {@link ClickableComponent#handleFocus} is called via a `focus` event on the
   *      `ClickableComponent`.
   *   2. {@link ClickableComponent#handleFocus} adds a listener for `keydown` on using
   *      {@link ClickableComponent#handleKeyPress}.
   *   3. `ClickableComponent` has not had a `blur` event (`blur` means that focus was lost). The user presses
   *      the space or enter key.
   *   4. {@link ClickableComponent#handleKeyPress} calls this function with the `keydown`
   *      event as a parameter.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   * @abstract
   */


  ClickableComponent.prototype.handleClick = function handleClick(event) {};

  /**
   * This gets called when a `ClickableComponent` gains focus via a `focus` event.
   * Turns on listening for `keydown` events. When they happen it
   * calls `this.handleKeyPress`.
   *
   * @param {EventTarget~Event} event
   *        The `focus` event that caused this function to be called.
   *
   * @listens focus
   */


  ClickableComponent.prototype.handleFocus = function handleFocus(event) {
    on(document_1, 'keydown', bind(this, this.handleKeyPress));
  };

  /**
   * Called when this ClickableComponent has focus and a key gets pressed down. By
   * default it will call `this.handleClick` when the key is space or enter.
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */


  ClickableComponent.prototype.handleKeyPress = function handleKeyPress(event) {

    // Support Space (32) or Enter (13) key operation to fire a click event
    if (event.which === 32 || event.which === 13) {
      event.preventDefault();
      this.trigger('click');
    } else if (_Component.prototype.handleKeyPress) {

      // Pass keypress handling up for unsupported keys
      _Component.prototype.handleKeyPress.call(this, event);
    }
  };

  /**
   * Called when a `ClickableComponent` loses focus. Turns off the listener for
   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.
   *
   * @param {EventTarget~Event} event
   *        The `blur` event that caused this function to be called.
   *
   * @listens blur
   */


  ClickableComponent.prototype.handleBlur = function handleBlur(event) {
    off(document_1, 'keydown', bind(this, this.handleKeyPress));
  };

  return ClickableComponent;
}(Component);

Component.registerComponent('ClickableComponent', ClickableComponent);

/**
 * @file poster-image.js
 */
/**
 * A `ClickableComponent` that handles showing the poster image for the player.
 *
 * @extends ClickableComponent
 */

var PosterImage = function (_ClickableComponent) {
  inherits(PosterImage, _ClickableComponent);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should attach to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PosterImage(player, options) {
    classCallCheck(this, PosterImage);

    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));

    _this.update();
    player.on('posterchange', bind(_this, _this.update));
    return _this;
  }

  /**
   * Clean up and dispose of the `PosterImage`.
   */


  PosterImage.prototype.dispose = function dispose() {
    this.player().off('posterchange', this.update);
    _ClickableComponent.prototype.dispose.call(this);
  };

  /**
   * Create the `PosterImage`s DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  PosterImage.prototype.createEl = function createEl$$1() {
    var el = createEl('div', {
      className: 'vjs-poster',

      // Don't want poster to be tabbable.
      tabIndex: -1
    });

    // To ensure the poster image resizes while maintaining its original aspect
    // ratio, use a div with `background-size` when available. For browsers that
    // do not support `background-size` (e.g. IE8), fall back on using a regular
    // img element.
    if (!BACKGROUND_SIZE_SUPPORTED) {
      this.fallbackImg_ = createEl('img');
      el.appendChild(this.fallbackImg_);
    }

    return el;
  };

  /**
   * An {@link EventTarget~EventListener} for {@link Player#posterchange} events.
   *
   * @listens Player#posterchange
   *
   * @param {EventTarget~Event} [event]
   *        The `Player#posterchange` event that triggered this function.
   */


  PosterImage.prototype.update = function update(event) {
    var url = this.player().poster();

    this.setSrc(url);

    // If there's no poster source we should display:none on this component
    // so it's not still clickable or right-clickable
    if (url) {
      this.show();
    } else {
      this.hide();
    }
  };

  /**
   * Set the source of the `PosterImage` depending on the display method.
   *
   * @param {string} url
   *        The URL to the source for the `PosterImage`.
   */


  PosterImage.prototype.setSrc = function setSrc(url) {
    if (this.fallbackImg_) {
      this.fallbackImg_.src = url;
    } else {
      var backgroundImage = '';

      // Any falsey values should stay as an empty string, otherwise
      // this will throw an extra error
      if (url) {
        backgroundImage = 'url("' + url + '")';
      }

      this.el_.style.backgroundImage = backgroundImage;
    }
  };

  /**
   * An {@link EventTarget~EventListener} for clicks on the `PosterImage`. See
   * {@link ClickableComponent#handleClick} for instances where this will be triggered.
   *
   * @listens tap
   * @listens click
   * @listens keydown
   *
   * @param {EventTarget~Event} event
   +        The `click`, `tap` or `keydown` event that caused this function to be called.
   */


  PosterImage.prototype.handleClick = function handleClick(event) {
    // We don't want a click to trigger playback when controls are disabled
    if (!this.player_.controls()) {
      return;
    }

    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };

  return PosterImage;
}(ClickableComponent);

Component.registerComponent('PosterImage', PosterImage);

/**
 * @file text-track-display.js
 */
var darkGray = '#222';
var lightGray = '#ccc';
var fontMap = {
  monospace: 'monospace',
  sansSerif: 'sans-serif',
  serif: 'serif',
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: 'sans-serif',
  proportionalSerif: 'serif',
  casual: '"Comic Sans MS", Impact, fantasy',
  script: '"Monotype Corsiva", cursive',
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};

/**
 * Construct an rgba color from a given hex color code.
 *
 * @param {number} color
 *        Hex number for color, like #f0e.
 *
 * @param {number} opacity
 *        Value for opacity, 0.0 - 1.0.
 *
 * @return {string}
 *         The rgba color that was created, like 'rgba(255, 0, 0, 0.3)'.
 *
 * @private
 */
function constructColor(color, opacity) {
  return 'rgba(' +
  // color looks like "#f0e"
  parseInt(color[1] + color[1], 16) + ',' + parseInt(color[2] + color[2], 16) + ',' + parseInt(color[3] + color[3], 16) + ',' + opacity + ')';
}

/**
 * Try to update the style of a DOM element. Some style changes will throw an error,
 * particularly in IE8. Those should be noops.
 *
 * @param {Element} el
 *        The DOM element to be styled.
 *
 * @param {string} style
 *        The CSS property on the element that should be styled.
 *
 * @param {string} rule
 *        The style rule that should be applied to the property.
 *
 * @private
 */
function tryUpdateStyle(el, style, rule) {
  try {
    el.style[style] = rule;
  } catch (e) {

    // Satisfies linter.
    return;
  }
}

/**
 * The component for displaying text track cues.
 *
 * @extends Component
 */

var TextTrackDisplay = function (_Component) {
  inherits(TextTrackDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when `TextTrackDisplay` is ready.
   */
  function TextTrackDisplay(player, options, ready) {
    classCallCheck(this, TextTrackDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options, ready));

    player.on('loadstart', bind(_this, _this.toggleDisplay));
    player.on('texttrackchange', bind(_this, _this.updateDisplay));
    player.on('loadstart', bind(_this, _this.preselectTrack));

    // This used to be called during player init, but was causing an error
    // if a track should show by default and the display hadn't loaded yet.
    // Should probably be moved to an external track loader when we support
    // tracks that don't need a display.
    player.ready(bind(_this, function () {
      if (player.tech_ && player.tech_.featuresNativeTextTracks) {
        this.hide();
        return;
      }

      player.on('fullscreenchange', bind(this, this.updateDisplay));

      var tracks = this.options_.playerOptions.tracks || [];

      for (var i = 0; i < tracks.length; i++) {
        this.player_.addRemoteTextTrack(tracks[i], true);
      }

      this.preselectTrack();
    }));
    return _this;
  }

  /**
  * Preselect a track following this precedence:
  * - matches the previously selected {@link TextTrack}'s language and kind
  * - matches the previously selected {@link TextTrack}'s language only
  * - is the first default captions track
  * - is the first default descriptions track
  *
  * @listens Player#loadstart
  */


  TextTrackDisplay.prototype.preselectTrack = function preselectTrack() {
    var modes = { captions: 1, subtitles: 1 };
    var trackList = this.player_.textTracks();
    var userPref = this.player_.cache_.selectedLanguage;
    var firstDesc = void 0;
    var firstCaptions = void 0;
    var preferredTrack = void 0;

    for (var i = 0; i < trackList.length; i++) {
      var track = trackList[i];

      if (userPref && userPref.enabled && userPref.language === track.language) {
        // Always choose the track that matches both language and kind
        if (track.kind === userPref.kind) {
          preferredTrack = track;
          // or choose the first track that matches language
        } else if (!preferredTrack) {
          preferredTrack = track;
        }

        // clear everything if offTextTrackMenuItem was clicked
      } else if (userPref && !userPref.enabled) {
        preferredTrack = null;
        firstDesc = null;
        firstCaptions = null;
      } else if (track['default']) {
        if (track.kind === 'descriptions' && !firstDesc) {
          firstDesc = track;
        } else if (track.kind in modes && !firstCaptions) {
          firstCaptions = track;
        }
      }
    }

    // The preferredTrack matches the user preference and takes
    // precendence over all the other tracks.
    // So, display the preferredTrack before the first default track
    // and the subtitles/captions track before the descriptions track
    if (preferredTrack) {
      preferredTrack.mode = 'showing';
    } else if (firstCaptions) {
      firstCaptions.mode = 'showing';
    } else if (firstDesc) {
      firstDesc.mode = 'showing';
    }
  };

  /**
   * Turn display of {@link TextTrack}'s from the current state into the other state.
   * There are only two states:
   * - 'shown'
   * - 'hidden'
   *
   * @listens Player#loadstart
   */


  TextTrackDisplay.prototype.toggleDisplay = function toggleDisplay() {
    if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {
      this.hide();
    } else {
      this.show();
    }
  };

  /**
   * Create the {@link Component}'s DOM element.
   *
   * @return {Element}
   *         The element that was created.
   */


  TextTrackDisplay.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-text-track-display'
    }, {
      'aria-live': 'off',
      'aria-atomic': 'true'
    });
  };

  /**
   * Clear all displayed {@link TextTrack}s.
   */


  TextTrackDisplay.prototype.clearDisplay = function clearDisplay() {
    if (typeof window_1.WebVTT === 'function') {
      window_1.WebVTT.processCues(window_1, [], this.el_);
    }
  };

  /**
   * Update the displayed TextTrack when a either a {@link Player#texttrackchange} or
   * a {@link Player#fullscreenchange} is fired.
   *
   * @listens Player#texttrackchange
   * @listens Player#fullscreenchange
   */


  TextTrackDisplay.prototype.updateDisplay = function updateDisplay() {
    var tracks = this.player_.textTracks();

    this.clearDisplay();

    // Track display prioritization model: if multiple tracks are 'showing',
    //  display the first 'subtitles' or 'captions' track which is 'showing',
    //  otherwise display the first 'descriptions' track which is 'showing'

    var descriptionsTrack = null;
    var captionsSubtitlesTrack = null;
    var i = tracks.length;

    while (i--) {
      var track = tracks[i];

      if (track.mode === 'showing') {
        if (track.kind === 'descriptions') {
          descriptionsTrack = track;
        } else {
          captionsSubtitlesTrack = track;
        }
      }
    }

    if (captionsSubtitlesTrack) {
      if (this.getAttribute('aria-live') !== 'off') {
        this.setAttribute('aria-live', 'off');
      }
      this.updateForTrack(captionsSubtitlesTrack);
    } else if (descriptionsTrack) {
      if (this.getAttribute('aria-live') !== 'assertive') {
        this.setAttribute('aria-live', 'assertive');
      }
      this.updateForTrack(descriptionsTrack);
    }
  };

  /**
   * Add an {@link Texttrack} to to the {@link Tech}s {@link TextTrackList}.
   *
   * @param {TextTrack} track
   *        Text track object to be added to the list.
   */


  TextTrackDisplay.prototype.updateForTrack = function updateForTrack(track) {
    if (typeof window_1.WebVTT !== 'function' || !track.activeCues) {
      return;
    }

    var overrides = this.player_.textTrackSettings.getValues();
    var cues = [];

    for (var _i = 0; _i < track.activeCues.length; _i++) {
      cues.push(track.activeCues[_i]);
    }

    window_1.WebVTT.processCues(window_1, cues, this.el_);

    var i = cues.length;

    while (i--) {
      var cue = cues[i];

      if (!cue) {
        continue;
      }

      var cueDiv = cue.displayState;

      if (overrides.color) {
        cueDiv.firstChild.style.color = overrides.color;
      }
      if (overrides.textOpacity) {
        tryUpdateStyle(cueDiv.firstChild, 'color', constructColor(overrides.color || '#fff', overrides.textOpacity));
      }
      if (overrides.backgroundColor) {
        cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
      }
      if (overrides.backgroundOpacity) {
        tryUpdateStyle(cueDiv.firstChild, 'backgroundColor', constructColor(overrides.backgroundColor || '#000', overrides.backgroundOpacity));
      }
      if (overrides.windowColor) {
        if (overrides.windowOpacity) {
          tryUpdateStyle(cueDiv, 'backgroundColor', constructColor(overrides.windowColor, overrides.windowOpacity));
        } else {
          cueDiv.style.backgroundColor = overrides.windowColor;
        }
      }
      if (overrides.edgeStyle) {
        if (overrides.edgeStyle === 'dropshadow') {
          cueDiv.firstChild.style.textShadow = '2px 2px 3px ' + darkGray + ', 2px 2px 4px ' + darkGray + ', 2px 2px 5px ' + darkGray;
        } else if (overrides.edgeStyle === 'raised') {
          cueDiv.firstChild.style.textShadow = '1px 1px ' + darkGray + ', 2px 2px ' + darkGray + ', 3px 3px ' + darkGray;
        } else if (overrides.edgeStyle === 'depressed') {
          cueDiv.firstChild.style.textShadow = '1px 1px ' + lightGray + ', 0 1px ' + lightGray + ', -1px -1px ' + darkGray + ', 0 -1px ' + darkGray;
        } else if (overrides.edgeStyle === 'uniform') {
          cueDiv.firstChild.style.textShadow = '0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray + ', 0 0 4px ' + darkGray;
        }
      }
      if (overrides.fontPercent && overrides.fontPercent !== 1) {
        var fontSize = window_1.parseFloat(cueDiv.style.fontSize);

        cueDiv.style.fontSize = fontSize * overrides.fontPercent + 'px';
        cueDiv.style.height = 'auto';
        cueDiv.style.top = 'auto';
        cueDiv.style.bottom = '2px';
      }
      if (overrides.fontFamily && overrides.fontFamily !== 'default') {
        if (overrides.fontFamily === 'small-caps') {
          cueDiv.firstChild.style.fontVariant = 'small-caps';
        } else {
          cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
        }
      }
    }
  };

  return TextTrackDisplay;
}(Component);

Component.registerComponent('TextTrackDisplay', TextTrackDisplay);

/**
 * @file loading-spinner.js
 */
/**
 * A loading spinner for use during waiting/loading events.
 *
 * @extends Component
 */

var LoadingSpinner = function (_Component) {
  inherits(LoadingSpinner, _Component);

  function LoadingSpinner() {
    classCallCheck(this, LoadingSpinner);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the `LoadingSpinner`s DOM element.
   *
   * @return {Element}
   *         The dom element that gets created.
   */
  LoadingSpinner.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-loading-spinner',
      dir: 'ltr'
    });
  };

  return LoadingSpinner;
}(Component);

Component.registerComponent('LoadingSpinner', LoadingSpinner);

/**
 * @file button.js
 */
/**
 * Base class for all buttons.
 *
 * @extends ClickableComponent
 */

var Button = function (_ClickableComponent) {
  inherits(Button, _ClickableComponent);

  function Button() {
    classCallCheck(this, Button);
    return possibleConstructorReturn(this, _ClickableComponent.apply(this, arguments));
  }

  /**
   * Create the `Button`s DOM element.
   *
   * @param {string} [tag="button"]
   *        The element's node type. This argument is IGNORED: no matter what
   *        is passed, it will always create a `button` element.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element.
   *
   * @param {Object} [attributes={}]
   *        An object of attributes that should be set on the element.
   *
   * @return {Element}
   *         The element that gets created.
   */
  Button.prototype.createEl = function createEl(tag) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    tag = 'button';

    props = assign({
      innerHTML: '<span aria-hidden="true" class="vjs-icon-placeholder"></span>',
      className: this.buildCSSClass()
    }, props);

    // Add attributes for button element
    attributes = assign({

      // Necessary since the default button type is "submit"
      'type': 'button',

      // let the screen reader user know that the text of the button may change
      'aria-live': 'polite'
    }, attributes);

    var el = Component.prototype.createEl.call(this, tag, props, attributes);

    this.createControlTextEl(el);

    return el;
  };

  /**
   * Add a child `Component` inside of this `Button`.
   *
   * @param {string|Component} child
   *        The name or instance of a child to add.
   *
   * @param {Object} [options={}]
   *        The key/value store of options that will get passed to children of
   *        the child.
   *
   * @return {Component}
   *         The `Component` that gets added as a child. When using a string the
   *         `Component` will get created by this process.
   *
   * @deprecated since version 5
   */


  Button.prototype.addChild = function addChild(child) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var className = this.constructor.name;

    log$1.warn('Adding an actionable (user controllable) child to a Button (' + className + ') is not supported; use a ClickableComponent instead.');

    // Avoid the error message generated by ClickableComponent's addChild method
    return Component.prototype.addChild.call(this, child, options);
  };

  /**
   * Enable the `Button` element so that it can be activated or clicked. Use this with
   * {@link Button#disable}.
   */


  Button.prototype.enable = function enable() {
    _ClickableComponent.prototype.enable.call(this);
    this.el_.removeAttribute('disabled');
  };

  /**
   * Enable the `Button` element so that it cannot be activated or clicked. Use this with
   * {@link Button#enable}.
   */


  Button.prototype.disable = function disable() {
    _ClickableComponent.prototype.disable.call(this);
    this.el_.setAttribute('disabled', 'disabled');
  };

  /**
   * This gets called when a `Button` has focus and `keydown` is triggered via a key
   * press.
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to get called.
   *
   * @listens keydown
   */


  Button.prototype.handleKeyPress = function handleKeyPress(event) {

    // Ignore Space (32) or Enter (13) key operation, which is handled by the browser for a button.
    if (event.which === 32 || event.which === 13) {
      return;
    }

    // Pass keypress handling up for unsupported keys
    _ClickableComponent.prototype.handleKeyPress.call(this, event);
  };

  return Button;
}(ClickableComponent);

Component.registerComponent('Button', Button);

/**
 * @file big-play-button.js
 */
/**
 * The initial play button that shows before the video has played. The hiding of the
 * `BigPlayButton` get done via CSS and `Player` states.
 *
 * @extends Button
 */

var BigPlayButton = function (_Button) {
  inherits(BigPlayButton, _Button);

  function BigPlayButton(player, options) {
    classCallCheck(this, BigPlayButton);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.mouseused_ = false;

    _this.on('mousedown', _this.handleMouseDown);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object. Always returns 'vjs-big-play-button'.
   */


  BigPlayButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-big-play-button';
  };

  /**
   * This gets called when a `BigPlayButton` "clicked". See {@link ClickableComponent}
   * for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  BigPlayButton.prototype.handleClick = function handleClick(event) {
    var playPromise = this.player_.play();

    // exit early if clicked via the mouse
    if (this.mouseused_ && event.clientX && event.clientY) {
      return;
    }

    var cb = this.player_.getChild('controlBar');
    var playToggle = cb && cb.getChild('playToggle');

    if (!playToggle) {
      this.player_.focus();
      return;
    }

    var playFocus = function playFocus() {
      return playToggle.focus();
    };

    if (playPromise && playPromise.then) {
      var ignoreRejectedPlayPromise = function ignoreRejectedPlayPromise() {};

      playPromise.then(playFocus, ignoreRejectedPlayPromise);
    } else {
      this.setTimeout(playFocus, 1);
    }
  };

  BigPlayButton.prototype.handleKeyPress = function handleKeyPress(event) {
    this.mouseused_ = false;

    _Button.prototype.handleKeyPress.call(this, event);
  };

  BigPlayButton.prototype.handleMouseDown = function handleMouseDown(event) {
    this.mouseused_ = true;
  };

  return BigPlayButton;
}(Button);

/**
 * The text that should display over the `BigPlayButton`s controls. Added to for localization.
 *
 * @type {string}
 * @private
 */


BigPlayButton.prototype.controlText_ = 'Play Video';

Component.registerComponent('BigPlayButton', BigPlayButton);

/**
 * @file close-button.js
 */
/**
 * The `CloseButton` is a `{@link Button}` that fires a `close` event when
 * it gets clicked.
 *
 * @extends Button
 */

var CloseButton = function (_Button) {
  inherits(CloseButton, _Button);

  /**
   * Creates an instance of the this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  function CloseButton(player, options) {
    classCallCheck(this, CloseButton);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.controlText(options && options.controlText || _this.localize('Close'));
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  CloseButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-close-button ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * This gets called when a `CloseButton` gets clicked. See
   * {@link ClickableComponent#handleClick} for more information on when this will be
   * triggered
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   * @fires CloseButton#close
   */


  CloseButton.prototype.handleClick = function handleClick(event) {

    /**
     * Triggered when the a `CloseButton` is clicked.
     *
     * @event CloseButton#close
     * @type {EventTarget~Event}
     *
     * @property {boolean} [bubbles=false]
     *           set to false so that the close event does not
     *           bubble up to parents if there is no listener
     */
    this.trigger({ type: 'close', bubbles: false });
  };

  return CloseButton;
}(Button);

Component.registerComponent('CloseButton', CloseButton);

/**
 * @file play-toggle.js
 */
/**
 * Button to toggle between play and pause.
 *
 * @extends Button
 */

var PlayToggle = function (_Button) {
  inherits(PlayToggle, _Button);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PlayToggle(player, options) {
    classCallCheck(this, PlayToggle);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.on(player, 'play', _this.handlePlay);
    _this.on(player, 'pause', _this.handlePause);
    _this.on(player, 'ended', _this.handleEnded);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  PlayToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-play-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * This gets called when an `PlayToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  PlayToggle.prototype.handleClick = function handleClick(event) {
    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };

  /**
   * Add the vjs-playing class to the element so it can change appearance.
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#play
   */


  PlayToggle.prototype.handlePlay = function handlePlay(event) {
    this.removeClass('vjs-ended');
    this.removeClass('vjs-paused');
    this.addClass('vjs-playing');
    // change the button text to "Pause"
    this.controlText('Pause');
  };

  /**
   * Add the vjs-paused class to the element so it can change appearance.
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#pause
   */


  PlayToggle.prototype.handlePause = function handlePause(event) {
    this.removeClass('vjs-playing');
    this.addClass('vjs-paused');
    // change the button text to "Play"
    this.controlText('Play');
  };

  /**
   * Add the vjs-ended class to the element so it can change appearance
   *
   */


  PlayToggle.prototype.handleEnded = function handleEnded(event) {
    this.removeClass('vjs-playing');
    this.addClass('vjs-ended');
    // change the button text to "Replay"
    this.controlText('Replay');
  };

  return PlayToggle;
}(Button);

/**
 * The text that should display over the `PlayToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


PlayToggle.prototype.controlText_ = 'Play';

Component.registerComponent('PlayToggle', PlayToggle);

/**
 * @file format-time.js
 * @module Format-time
 */

/**
 * Format seconds as a time string, H:MM:SS or M:SS. Supplying a guide (in seconds)
 * will force a number of leading zeros to cover the length of the guide.
 *
 * @param {number} seconds
 *        Number of seconds to be turned into a string
 *
 * @param {number} guide
 *        Number (in seconds) to model the string after
 *
 * @return {string}
 *         Time formatted as H:MM:SS or M:SS
 */
function formatTime(seconds) {
  var guide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : seconds;

  seconds = seconds < 0 ? 0 : seconds;
  var s = Math.floor(seconds % 60);
  var m = Math.floor(seconds / 60 % 60);
  var h = Math.floor(seconds / 3600);
  var gm = Math.floor(guide / 60 % 60);
  var gh = Math.floor(guide / 3600);

  // handle invalid times
  if (isNaN(seconds) || seconds === Infinity) {
    // '-' is false for all relational operators (e.g. <, >=) so this setting
    // will add the minimum number of fields specified by the guide
    h = m = s = '-';
  }

  // Check if we need to show hours
  h = h > 0 || gh > 0 ? h + ':' : '';

  // If hours are showing, we may need to add a leading zero.
  // Always show at least one digit of minutes.
  m = ((h || gm >= 10) && m < 10 ? '0' + m : m) + ':';

  // Check if leading zero is need for seconds
  s = s < 10 ? '0' + s : s;

  return h + m + s;
}

/**
 * @file current-time-display.js
 */
/**
 * Displays the current time
 *
 * @extends Component
 */

var CurrentTimeDisplay = function (_Component) {
  inherits(CurrentTimeDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function CurrentTimeDisplay(player, options) {
    classCallCheck(this, CurrentTimeDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.throttledUpdateContent = throttle(bind(_this, _this.updateContent), 25);
    _this.on(player, 'timeupdate', _this.throttledUpdateContent);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  CurrentTimeDisplay.prototype.createEl = function createEl$$1() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-current-time vjs-time-control vjs-control'
    });

    this.contentEl_ = createEl('div', {
      className: 'vjs-current-time-display'
    }, {
      // tell screen readers not to automatically read the time as it changes
      'aria-live': 'off'
    }, createEl('span', {
      className: 'vjs-control-text',
      textContent: this.localize('Current Time')
    }));

    this.updateTextNode_();
    el.appendChild(this.contentEl_);
    return el;
  };

  /**
   * Updates the "current time" text node with new content using the
   * contents of the `formattedTime_` property.
   *
   * @private
   */


  CurrentTimeDisplay.prototype.updateTextNode_ = function updateTextNode_() {
    if (this.textNode_) {
      this.contentEl_.removeChild(this.textNode_);
    }
    this.textNode_ = document_1.createTextNode(' ' + (this.formattedTime_ || '0:00'));
    this.contentEl_.appendChild(this.textNode_);
  };

  /**
   * Update current time display
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` event that caused this function to run.
   *
   * @listens Player#timeupdate
   */


  CurrentTimeDisplay.prototype.updateContent = function updateContent(event) {
    // Allows for smooth scrubbing, when player can't keep up.
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    var formattedTime = formatTime(time, this.player_.duration());

    if (formattedTime !== this.formattedTime_) {
      this.formattedTime_ = formattedTime;
      this.requestAnimationFrame(this.updateTextNode_);
    }
  };

  return CurrentTimeDisplay;
}(Component);

Component.registerComponent('CurrentTimeDisplay', CurrentTimeDisplay);

/**
 * @file duration-display.js
 */
/**
 * Displays the duration
 *
 * @extends Component
 */

var DurationDisplay = function (_Component) {
  inherits(DurationDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function DurationDisplay(player, options) {
    classCallCheck(this, DurationDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.throttledUpdateContent = throttle(bind(_this, _this.updateContent), 25);

    _this.on(player, ['durationchange',

    // Also listen for timeupdate and loadedmetadata because removing those
    // listeners could have broken dependent applications/libraries. These
    // can likely be removed for 7.0.
    'loadedmetadata', 'timeupdate'], _this.throttledUpdateContent);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  DurationDisplay.prototype.createEl = function createEl$$1() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-duration vjs-time-control vjs-control'
    });

    this.contentEl_ = createEl('div', {
      className: 'vjs-duration-display'
    }, {
      // tell screen readers not to automatically read the time as it changes
      'aria-live': 'off'
    }, createEl('span', {
      className: 'vjs-control-text',
      textContent: this.localize('Duration Time')
    }));

    this.updateTextNode_();
    el.appendChild(this.contentEl_);
    return el;
  };

  /**
   * Updates the "current time" text node with new content using the
   * contents of the `formattedTime_` property.
   *
   * @private
   */


  DurationDisplay.prototype.updateTextNode_ = function updateTextNode_() {
    if (this.textNode_) {
      this.contentEl_.removeChild(this.textNode_);
    }
    this.textNode_ = document_1.createTextNode(' ' + (this.formattedTime_ || '0:00'));
    this.contentEl_.appendChild(this.textNode_);
  };

  /**
   * Update duration time display.
   *
   * @param {EventTarget~Event} [event]
   *        The `durationchange`, `timeupdate`, or `loadedmetadata` event that caused
   *        this function to be called.
   *
   * @listens Player#durationchange
   * @listens Player#timeupdate
   * @listens Player#loadedmetadata
   */


  DurationDisplay.prototype.updateContent = function updateContent(event) {
    var duration = this.player_.duration();

    if (duration && this.duration_ !== duration) {
      this.duration_ = duration;
      this.formattedTime_ = formatTime(duration);
      this.requestAnimationFrame(this.updateTextNode_);
    }
  };

  return DurationDisplay;
}(Component);

Component.registerComponent('DurationDisplay', DurationDisplay);

/**
 * @file time-divider.js
 */
/**
 * The separator between the current time and duration.
 * Can be hidden if it's not needed in the design.
 *
 * @extends Component
 */

var TimeDivider = function (_Component) {
  inherits(TimeDivider, _Component);

  function TimeDivider() {
    classCallCheck(this, TimeDivider);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the component's DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  TimeDivider.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-time-control vjs-time-divider',
      innerHTML: '<div><span>/</span></div>'
    });
  };

  return TimeDivider;
}(Component);

Component.registerComponent('TimeDivider', TimeDivider);

/**
 * @file remaining-time-display.js
 */
/**
 * Displays the time left in the video
 *
 * @extends Component
 */

var RemainingTimeDisplay = function (_Component) {
  inherits(RemainingTimeDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function RemainingTimeDisplay(player, options) {
    classCallCheck(this, RemainingTimeDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.throttledUpdateContent = throttle(bind(_this, _this.updateContent), 25);
    _this.on(player, ['timeupdate', 'durationchange'], _this.throttledUpdateContent);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  RemainingTimeDisplay.prototype.createEl = function createEl$$1() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-remaining-time vjs-time-control vjs-control'
    });

    this.contentEl_ = createEl('div', {
      className: 'vjs-remaining-time-display'
    }, {
      // tell screen readers not to automatically read the time as it changes
      'aria-live': 'off'
    }, createEl('span', {
      className: 'vjs-control-text',
      textContent: this.localize('Remaining Time')
    }));

    this.updateTextNode_();
    el.appendChild(this.contentEl_);
    return el;
  };

  /**
   * Updates the "remaining time" text node with new content using the
   * contents of the `formattedTime_` property.
   *
   * @private
   */


  RemainingTimeDisplay.prototype.updateTextNode_ = function updateTextNode_() {
    if (this.textNode_) {
      this.contentEl_.removeChild(this.textNode_);
    }
    this.textNode_ = document_1.createTextNode(' -' + (this.formattedTime_ || '0:00'));
    this.contentEl_.appendChild(this.textNode_);
  };

  /**
   * Update remaining time display.
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` or `durationchange` event that caused this to run.
   *
   * @listens Player#timeupdate
   * @listens Player#durationchange
   */


  RemainingTimeDisplay.prototype.updateContent = function updateContent(event) {
    if (this.player_.duration()) {
      var formattedTime = formatTime(this.player_.remainingTime());

      if (formattedTime !== this.formattedTime_) {
        this.formattedTime_ = formattedTime;
        this.requestAnimationFrame(this.updateTextNode_);
      }
    }
  };

  return RemainingTimeDisplay;
}(Component);

Component.registerComponent('RemainingTimeDisplay', RemainingTimeDisplay);

/**
 * @file live-display.js
 */
// TODO - Future make it click to snap to live

/**
 * Displays the live indicator when duration is Infinity.
 *
 * @extends Component
 */

var LiveDisplay = function (_Component) {
  inherits(LiveDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function LiveDisplay(player, options) {
    classCallCheck(this, LiveDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.updateShowing();
    _this.on(_this.player(), 'durationchange', _this.updateShowing);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  LiveDisplay.prototype.createEl = function createEl$$1() {
    var el = _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-live-control vjs-control'
    });

    this.contentEl_ = createEl('div', {
      className: 'vjs-live-display',
      innerHTML: '<span class="vjs-control-text">' + this.localize('Stream Type') + '</span>' + this.localize('LIVE')
    }, {
      'aria-live': 'off'
    });

    el.appendChild(this.contentEl_);
    return el;
  };

  /**
   * Check the duration to see if the LiveDisplay should be showing or not. Then show/hide
   * it accordingly
   *
   * @param {EventTarget~Event} [event]
   *        The {@link Player#durationchange} event that caused this function to run.
   *
   * @listens Player#durationchange
   */


  LiveDisplay.prototype.updateShowing = function updateShowing(event) {
    if (this.player().duration() === Infinity) {
      this.show();
    } else {
      this.hide();
    }
  };

  return LiveDisplay;
}(Component);

Component.registerComponent('LiveDisplay', LiveDisplay);

/**
 * @file slider.js
 */
/**
 * The base functionality for a slider. Can be vertical or horizontal.
 * For instance the volume bar or the seek bar on a video is a slider.
 *
 * @extends Component
 */

var Slider = function (_Component) {
  inherits(Slider, _Component);

  /**
   * Create an instance of this class
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function Slider(player, options) {
    classCallCheck(this, Slider);

    // Set property names to bar to match with the child Slider class is looking for
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.bar = _this.getChild(_this.options_.barName);

    // Set a horizontal or vertical class on the slider depending on the slider type
    _this.vertical(!!_this.options_.vertical);

    _this.on('mousedown', _this.handleMouseDown);
    _this.on('touchstart', _this.handleMouseDown);
    _this.on('focus', _this.handleFocus);
    _this.on('blur', _this.handleBlur);
    _this.on('click', _this.handleClick);

    _this.on(player, 'controlsvisible', _this.update);

    if (_this.playerEvent) {
      _this.on(player, _this.playerEvent, _this.update);
    }
    return _this;
  }

  /**
   * Create the `Button`s DOM element.
   *
   * @param {string} type
   *        Type of element to create.
   *
   * @param {Object} [props={}]
   *        List of properties in Object form.
   *
   * @param {Object} [attributes={}]
   *        list of attributes in Object form.
   *
   * @return {Element}
   *         The element that gets created.
   */


  Slider.prototype.createEl = function createEl$$1(type) {
    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    // Add the slider element class to all sub classes
    props.className = props.className + ' vjs-slider';
    props = assign({
      tabIndex: 0
    }, props);

    attributes = assign({
      'role': 'slider',
      'aria-valuenow': 0,
      'aria-valuemin': 0,
      'aria-valuemax': 100,
      'tabIndex': 0
    }, attributes);

    return _Component.prototype.createEl.call(this, type, props, attributes);
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `Slider`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   * @fires Slider#slideractive
   */


  Slider.prototype.handleMouseDown = function handleMouseDown(event) {
    var doc = this.bar.el_.ownerDocument;

    event.preventDefault();
    blockTextSelection();

    this.addClass('vjs-sliding');
    /**
     * Triggered when the slider is in an active state
     *
     * @event Slider#slideractive
     * @type {EventTarget~Event}
     */
    this.trigger('slideractive');

    this.on(doc, 'mousemove', this.handleMouseMove);
    this.on(doc, 'mouseup', this.handleMouseUp);
    this.on(doc, 'touchmove', this.handleMouseMove);
    this.on(doc, 'touchend', this.handleMouseUp);

    this.handleMouseMove(event);
  };

  /**
   * Handle the `mousemove`, `touchmove`, and `mousedown` events on this `Slider`.
   * The `mousemove` and `touchmove` events will only only trigger this function during
   * `mousedown` and `touchstart`. This is due to {@link Slider#handleMouseDown} and
   * {@link Slider#handleMouseUp}.
   *
   * @param {EventTarget~Event} event
   *        `mousedown`, `mousemove`, `touchstart`, or `touchmove` event that triggered
   *        this function
   *
   * @listens mousemove
   * @listens touchmove
   */


  Slider.prototype.handleMouseMove = function handleMouseMove(event) {};

  /**
   * Handle `mouseup` or `touchend` events on the `Slider`.
   *
   * @param {EventTarget~Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   * @fires Slider#sliderinactive
   */


  Slider.prototype.handleMouseUp = function handleMouseUp() {
    var doc = this.bar.el_.ownerDocument;

    unblockTextSelection();

    this.removeClass('vjs-sliding');
    /**
     * Triggered when the slider is no longer in an active state.
     *
     * @event Slider#sliderinactive
     * @type {EventTarget~Event}
     */
    this.trigger('sliderinactive');

    this.off(doc, 'mousemove', this.handleMouseMove);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchmove', this.handleMouseMove);
    this.off(doc, 'touchend', this.handleMouseUp);

    this.update();
  };

  /**
   * Update the progress bar of the `Slider`.
   *
   * @returns {number}
   *          The percentage of progress the progress bar represents as a
   *          number from 0 to 1.
   */


  Slider.prototype.update = function update() {

    // In VolumeBar init we have a setTimeout for update that pops and update
    // to the end of the execution stack. The player is destroyed before then
    // update will cause an error
    if (!this.el_) {
      return;
    }

    // If scrubbing, we could use a cached value to make the handle keep up
    // with the user's mouse. On HTML5 browsers scrubbing is really smooth, but
    // some flash players are slow, so we might want to utilize this later.
    // var progress =  (this.player_.scrubbing()) ? this.player_.getCache().currentTime / this.player_.duration() : this.player_.currentTime() / this.player_.duration();
    var progress = this.getPercent();
    var bar = this.bar;

    // If there's no bar...
    if (!bar) {
      return;
    }

    // Protect against no duration and other division issues
    if (typeof progress !== 'number' || progress !== progress || progress < 0 || progress === Infinity) {
      progress = 0;
    }

    // Convert to a percentage for setting
    var percentage = (progress * 100).toFixed(2) + '%';
    var style = bar.el().style;

    // Set the new bar width or height
    if (this.vertical()) {
      style.height = percentage;
    } else {
      style.width = percentage;
    }

    return progress;
  };

  /**
   * Calculate distance for slider
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run.
   *
   * @return {number}
   *         The current position of the Slider.
   *         - postition.x for vertical `Slider`s
   *         - postition.y for horizontal `Slider`s
   */


  Slider.prototype.calculateDistance = function calculateDistance(event) {
    var position = getPointerPosition(this.el_, event);

    if (this.vertical()) {
      return position.y;
    }
    return position.x;
  };

  /**
   * Handle a `focus` event on this `Slider`.
   *
   * @param {EventTarget~Event} event
   *        The `focus` event that caused this function to run.
   *
   * @listens focus
   */


  Slider.prototype.handleFocus = function handleFocus() {
    this.on(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);
  };

  /**
   * Handle a `keydown` event on the `Slider`. Watches for left, rigth, up, and down
   * arrow keys. This function will only be called when the slider has focus. See
   * {@link Slider#handleFocus} and {@link Slider#handleBlur}.
   *
   * @param {EventTarget~Event} event
   *        the `keydown` event that caused this function to run.
   *
   * @listens keydown
   */


  Slider.prototype.handleKeyPress = function handleKeyPress(event) {
    // Left and Down Arrows
    if (event.which === 37 || event.which === 40) {
      event.preventDefault();
      this.stepBack();

      // Up and Right Arrows
    } else if (event.which === 38 || event.which === 39) {
      event.preventDefault();
      this.stepForward();
    }
  };

  /**
   * Handle a `blur` event on this `Slider`.
   *
   * @param {EventTarget~Event} event
   *        The `blur` event that caused this function to run.
   *
   * @listens blur
   */

  Slider.prototype.handleBlur = function handleBlur() {
    this.off(this.bar.el_.ownerDocument, 'keydown', this.handleKeyPress);
  };

  /**
   * Listener for click events on slider, used to prevent clicks
   *   from bubbling up to parent elements like button menus.
   *
   * @param {Object} event
   *        Event that caused this object to run
   */


  Slider.prototype.handleClick = function handleClick(event) {
    event.stopImmediatePropagation();
    event.preventDefault();
  };

  /**
   * Get/set if slider is horizontal for vertical
   *
   * @param {boolean} [bool]
   *        - true if slider is vertical,
   *        - false is horizontal
   *
   * @return {boolean}
   *         - true if slider is vertical, and getting
   *         - false if the slider is horizontal, and getting
   */


  Slider.prototype.vertical = function vertical(bool) {
    if (bool === undefined) {
      return this.vertical_ || false;
    }

    this.vertical_ = !!bool;

    if (this.vertical_) {
      this.addClass('vjs-slider-vertical');
    } else {
      this.addClass('vjs-slider-horizontal');
    }
  };

  return Slider;
}(Component);

Component.registerComponent('Slider', Slider);

/**
 * @file load-progress-bar.js
 */
/**
 * Shows loading progress
 *
 * @extends Component
 */

var LoadProgressBar = function (_Component) {
  inherits(LoadProgressBar, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function LoadProgressBar(player, options) {
    classCallCheck(this, LoadProgressBar);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.partEls_ = [];
    _this.on(player, 'progress', _this.update);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  LoadProgressBar.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-load-progress',
      innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Loaded') + '</span>: 0%</span>'
    });
  };

  /**
   * Update progress bar
   *
   * @param {EventTarget~Event} [event]
   *        The `progress` event that caused this function to run.
   *
   * @listens Player#progress
   */


  LoadProgressBar.prototype.update = function update(event) {
    var buffered = this.player_.buffered();
    var duration = this.player_.duration();
    var bufferedEnd = this.player_.bufferedEnd();
    var children = this.partEls_;

    // get the percent width of a time compared to the total end
    var percentify = function percentify(time, end) {
      // no NaN
      var percent = time / end || 0;

      return (percent >= 1 ? 1 : percent) * 100 + '%';
    };

    // update the width of the progress bar
    this.el_.style.width = percentify(bufferedEnd, duration);

    // add child elements to represent the individual buffered time ranges
    for (var i = 0; i < buffered.length; i++) {
      var start = buffered.start(i);
      var end = buffered.end(i);
      var part = children[i];

      if (!part) {
        part = this.el_.appendChild(createEl());
        children[i] = part;
      }

      // set the percent based on the width of the progress bar (bufferedEnd)
      part.style.left = percentify(start, bufferedEnd);
      part.style.width = percentify(end - start, bufferedEnd);
    }

    // remove unused buffered range elements
    for (var _i = children.length; _i > buffered.length; _i--) {
      this.el_.removeChild(children[_i - 1]);
    }
    children.length = buffered.length;
  };

  return LoadProgressBar;
}(Component);

Component.registerComponent('LoadProgressBar', LoadProgressBar);

/**
 * @file time-tooltip.js
 */
/**
 * Time tooltips display a time above the progress bar.
 *
 * @extends Component
 */

var TimeTooltip = function (_Component) {
  inherits(TimeTooltip, _Component);

  function TimeTooltip() {
    classCallCheck(this, TimeTooltip);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the time tooltip DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  TimeTooltip.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-time-tooltip'
    });
  };

  /**
   * Updates the position of the time tooltip relative to the `SeekBar`.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */


  TimeTooltip.prototype.update = function update(seekBarRect, seekBarPoint, content) {
    var tooltipRect = getBoundingClientRect(this.el_);
    var playerRect = getBoundingClientRect(this.player_.el());
    var seekBarPointPx = seekBarRect.width * seekBarPoint;

    // do nothing if either rect isn't available
    // for example, if the player isn't in the DOM for testing
    if (!playerRect || !tooltipRect) {
      return;
    }

    // This is the space left of the `seekBarPoint` available within the bounds
    // of the player. We calculate any gap between the left edge of the player
    // and the left edge of the `SeekBar` and add the number of pixels in the
    // `SeekBar` before hitting the `seekBarPoint`
    var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;

    // This is the space right of the `seekBarPoint` available within the bounds
    // of the player. We calculate the number of pixels from the `seekBarPoint`
    // to the right edge of the `SeekBar` and add to that any gap between the
    // right edge of the `SeekBar` and the player.
    var spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);

    // This is the number of pixels by which the tooltip will need to be pulled
    // further to the right to center it over the `seekBarPoint`.
    var pullTooltipBy = tooltipRect.width / 2;

    // Adjust the `pullTooltipBy` distance to the left or right depending on
    // the results of the space calculations above.
    if (spaceLeftOfPoint < pullTooltipBy) {
      pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
    } else if (spaceRightOfPoint < pullTooltipBy) {
      pullTooltipBy = spaceRightOfPoint;
    }

    // Due to the imprecision of decimal/ratio based calculations and varying
    // rounding behaviors, there are cases where the spacing adjustment is off
    // by a pixel or two. This adds insurance to these calculations.
    if (pullTooltipBy < 0) {
      pullTooltipBy = 0;
    } else if (pullTooltipBy > tooltipRect.width) {
      pullTooltipBy = tooltipRect.width;
    }

    this.el_.style.right = '-' + pullTooltipBy + 'px';
    textContent(this.el_, content);
  };

  return TimeTooltip;
}(Component);

Component.registerComponent('TimeTooltip', TimeTooltip);

/**
 * @file play-progress-bar.js
 */
/**
 * Used by {@link SeekBar} to display media playback progress as part of the
 * {@link ProgressControl}.
 *
 * @extends Component
 */

var PlayProgressBar = function (_Component) {
  inherits(PlayProgressBar, _Component);

  function PlayProgressBar() {
    classCallCheck(this, PlayProgressBar);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */
  PlayProgressBar.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-play-progress vjs-slider-bar',
      innerHTML: '<span class="vjs-control-text"><span>' + this.localize('Progress') + '</span>: 0%</span>'
    });
  };

  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   * {@link TimeTooltip} child.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */


  PlayProgressBar.prototype.update = function update(seekBarRect, seekBarPoint) {
    var _this2 = this;

    // If there is an existing rAF ID, cancel it so we don't over-queue.
    if (this.rafId_) {
      this.cancelAnimationFrame(this.rafId_);
    }

    this.rafId_ = this.requestAnimationFrame(function () {
      var time = _this2.player_.scrubbing() ? _this2.player_.getCache().currentTime : _this2.player_.currentTime();

      var content = formatTime(time, _this2.player_.duration());
      var timeTooltip = _this2.getChild('timeTooltip');

      if (timeTooltip) {
        timeTooltip.update(seekBarRect, seekBarPoint, content);
      }
    });
  };

  return PlayProgressBar;
}(Component);

/**
 * Default options for {@link PlayProgressBar}.
 *
 * @type {Object}
 * @private
 */


PlayProgressBar.prototype.options_ = {
  children: []
};

// Time tooltips should not be added to a player on mobile devices or IE8
if ((!IE_VERSION || IE_VERSION > 8) && !IS_IOS && !IS_ANDROID) {
  PlayProgressBar.prototype.options_.children.push('timeTooltip');
}

Component.registerComponent('PlayProgressBar', PlayProgressBar);

/**
 * @file mouse-time-display.js
 */
/**
 * The {@link MouseTimeDisplay} component tracks mouse movement over the
 * {@link ProgressControl}. It displays an indicator and a {@link TimeTooltip}
 * indicating the time which is represented by a given point in the
 * {@link ProgressControl}.
 *
 * @extends Component
 */

var MouseTimeDisplay = function (_Component) {
  inherits(MouseTimeDisplay, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The {@link Player} that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function MouseTimeDisplay(player, options) {
    classCallCheck(this, MouseTimeDisplay);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.update = throttle(bind(_this, _this.update), 25);
    return _this;
  }

  /**
   * Create the DOM element for this class.
   *
   * @return {Element}
   *         The element that was created.
   */


  MouseTimeDisplay.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-mouse-display'
    });
  };

  /**
   * Enqueues updates to its own DOM as well as the DOM of its
   * {@link TimeTooltip} child.
   *
   * @param {Object} seekBarRect
   *        The `ClientRect` for the {@link SeekBar} element.
   *
   * @param {number} seekBarPoint
   *        A number from 0 to 1, representing a horizontal reference point
   *        from the left edge of the {@link SeekBar}
   */


  MouseTimeDisplay.prototype.update = function update(seekBarRect, seekBarPoint) {
    var _this2 = this;

    // If there is an existing rAF ID, cancel it so we don't over-queue.
    if (this.rafId_) {
      this.cancelAnimationFrame(this.rafId_);
    }

    this.rafId_ = this.requestAnimationFrame(function () {
      var duration = _this2.player_.duration();
      var content = formatTime(seekBarPoint * duration, duration);

      _this2.el_.style.left = seekBarRect.width * seekBarPoint + 'px';
      _this2.getChild('timeTooltip').update(seekBarRect, seekBarPoint, content);
    });
  };

  return MouseTimeDisplay;
}(Component);

/**
 * Default options for `MouseTimeDisplay`
 *
 * @type {Object}
 * @private
 */


MouseTimeDisplay.prototype.options_ = {
  children: ['timeTooltip']
};

Component.registerComponent('MouseTimeDisplay', MouseTimeDisplay);

/**
 * @file seek-bar.js
 */
// The number of seconds the `step*` functions move the timeline.
var STEP_SECONDS = 5;

/**
 * Seek bar and container for the progress bars. Uses {@link PlayProgressBar}
 * as its `bar`.
 *
 * @extends Slider
 */

var SeekBar = function (_Slider) {
  inherits(SeekBar, _Slider);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function SeekBar(player, options) {
    classCallCheck(this, SeekBar);

    var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));

    _this.update = throttle(bind(_this, _this.update), 50);
    _this.on(player, ['timeupdate', 'ended'], _this.update);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  SeekBar.prototype.createEl = function createEl$$1() {
    return _Slider.prototype.createEl.call(this, 'div', {
      className: 'vjs-progress-holder'
    }, {
      'aria-label': this.localize('Progress Bar')
    });
  };

  /**
   * Update the seek bar's UI.
   *
   * @param {EventTarget~Event} [event]
   *        The `timeupdate` or `ended` event that caused this to run.
   *
   * @listens Player#timeupdate
   * @listens Player#ended
   */


  SeekBar.prototype.update = function update() {
    var percent = _Slider.prototype.update.call(this);
    var duration = this.player_.duration();

    // Allows for smooth scrubbing, when player can't keep up.
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();

    // machine readable value of progress bar (percentage complete)
    this.el_.setAttribute('aria-valuenow', (percent * 100).toFixed(2));

    // human readable value of progress bar (time complete)
    this.el_.setAttribute('aria-valuetext', this.localize('progress bar timing: currentTime={1} duration={2}', [formatTime(time, duration), formatTime(duration, duration)], '{1} of {2}'));

    // Update the `PlayProgressBar`.
    this.bar.update(getBoundingClientRect(this.el_), percent);

    return percent;
  };

  /**
   * Get the percentage of media played so far.
   *
   * @return {number}
   *         The percentage of media played so far (0 to 1).
   */


  SeekBar.prototype.getPercent = function getPercent() {

    // Allows for smooth scrubbing, when player can't keep up.
    var time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();

    var percent = time / this.player_.duration();

    return percent >= 1 ? 1 : percent;
  };

  /**
   * Handle mouse down on seek bar
   *
   * @param {EventTarget~Event} event
   *        The `mousedown` event that caused this to run.
   *
   * @listens mousedown
   */


  SeekBar.prototype.handleMouseDown = function handleMouseDown(event) {
    this.player_.scrubbing(true);

    this.videoWasPlaying = !this.player_.paused();
    this.player_.pause();

    _Slider.prototype.handleMouseDown.call(this, event);
  };

  /**
   * Handle mouse move on seek bar
   *
   * @param {EventTarget~Event} event
   *        The `mousemove` event that caused this to run.
   *
   * @listens mousemove
   */


  SeekBar.prototype.handleMouseMove = function handleMouseMove(event) {
    var newTime = this.calculateDistance(event) * this.player_.duration();

    // Don't let video end while scrubbing.
    if (newTime === this.player_.duration()) {
      newTime = newTime - 0.1;
    }

    // Set new time (tell player to seek to new time)
    this.player_.currentTime(newTime);
  };

  /**
   * Handle mouse up on seek bar
   *
   * @param {EventTarget~Event} event
   *        The `mouseup` event that caused this to run.
   *
   * @listens mouseup
   */


  SeekBar.prototype.handleMouseUp = function handleMouseUp(event) {
    _Slider.prototype.handleMouseUp.call(this, event);

    this.player_.scrubbing(false);
    if (this.videoWasPlaying) {
      this.player_.play();
    }
  };

  /**
   * Move more quickly fast forward for keyboard-only users
   */


  SeekBar.prototype.stepForward = function stepForward() {
    this.player_.currentTime(this.player_.currentTime() + STEP_SECONDS);
  };

  /**
   * Move more quickly rewind for keyboard-only users
   */


  SeekBar.prototype.stepBack = function stepBack() {
    this.player_.currentTime(this.player_.currentTime() - STEP_SECONDS);
  };

  /**
   * Toggles the playback state of the player
   * This gets called when enter or space is used on the seekbar
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called
   *
   */


  SeekBar.prototype.handleAction = function handleAction(event) {
    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };

  /**
   * Called when this SeekBar has focus and a key gets pressed down. By
   * default it will call `this.handleAction` when the key is space or enter.
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */


  SeekBar.prototype.handleKeyPress = function handleKeyPress(event) {

    // Support Space (32) or Enter (13) key operation to fire a click event
    if (event.which === 32 || event.which === 13) {
      event.preventDefault();
      this.handleAction(event);
    } else if (_Slider.prototype.handleKeyPress) {

      // Pass keypress handling up for unsupported keys
      _Slider.prototype.handleKeyPress.call(this, event);
    }
  };

  return SeekBar;
}(Slider);

/**
 * Default options for the `SeekBar`
 *
 * @type {Object}
 * @private
 */


SeekBar.prototype.options_ = {
  children: ['loadProgressBar', 'playProgressBar'],
  barName: 'playProgressBar'
};

// MouseTimeDisplay tooltips should not be added to a player on mobile devices or IE8
if ((!IE_VERSION || IE_VERSION > 8) && !IS_IOS && !IS_ANDROID) {
  SeekBar.prototype.options_.children.splice(1, 0, 'mouseTimeDisplay');
}

/**
 * Call the update event for this Slider when this event happens on the player.
 *
 * @type {string}
 */
SeekBar.prototype.playerEvent = 'timeupdate';

Component.registerComponent('SeekBar', SeekBar);

/**
 * @file progress-control.js
 */
/**
 * The Progress Control component contains the seek bar, load progress,
 * and play progress.
 *
 * @extends Component
 */

var ProgressControl = function (_Component) {
  inherits(ProgressControl, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function ProgressControl(player, options) {
    classCallCheck(this, ProgressControl);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.handleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);
    _this.on(_this.el_, 'mousemove', _this.handleMouseMove);

    _this.throttledHandleMouseSeek = throttle(bind(_this, _this.handleMouseSeek), 25);
    _this.on(['mousedown', 'touchstart'], _this.handleMouseDown);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  ProgressControl.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-progress-control vjs-control'
    });
  };

  /**
   * When the mouse moves over the `ProgressControl`, the pointer position
   * gets passed down to the `MouseTimeDisplay` component.
   *
   * @param {EventTarget~Event} event
   *        The `mousemove` event that caused this function to run.
   *
   * @listen mousemove
   */


  ProgressControl.prototype.handleMouseMove = function handleMouseMove(event) {
    var seekBar = this.getChild('seekBar');
    var mouseTimeDisplay = seekBar.getChild('mouseTimeDisplay');
    var seekBarEl = seekBar.el();
    var seekBarRect = getBoundingClientRect(seekBarEl);
    var seekBarPoint = getPointerPosition(seekBarEl, event).x;

    // The default skin has a gap on either side of the `SeekBar`. This means
    // that it's possible to trigger this behavior outside the boundaries of
    // the `SeekBar`. This ensures we stay within it at all times.
    if (seekBarPoint > 1) {
      seekBarPoint = 1;
    } else if (seekBarPoint < 0) {
      seekBarPoint = 0;
    }

    if (mouseTimeDisplay) {
      mouseTimeDisplay.update(seekBarRect, seekBarPoint);
    }
  };

  /**
   * A throttled version of the {@link ProgressControl#handleMouseSeek} listener.
   *
   * @method ProgressControl#throttledHandleMouseSeek
   * @param {EventTarget~Event} event
   *        The `mousemove` event that caused this function to run.
   *
   * @listen mousemove
   * @listen touchmove
   */

  /**
   * Handle `mousemove` or `touchmove` events on the `ProgressControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousemove
   * @listens touchmove
   */


  ProgressControl.prototype.handleMouseSeek = function handleMouseSeek(event) {
    var seekBar = this.getChild('seekBar');

    seekBar.handleMouseMove(event);
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `ProgressControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */


  ProgressControl.prototype.handleMouseDown = function handleMouseDown(event) {
    var doc = this.el_.ownerDocument;

    this.on(doc, 'mousemove', this.throttledHandleMouseSeek);
    this.on(doc, 'touchmove', this.throttledHandleMouseSeek);
    this.on(doc, 'mouseup', this.handleMouseUp);
    this.on(doc, 'touchend', this.handleMouseUp);
  };

  /**
   * Handle `mouseup` or `touchend` events on the `ProgressControl`.
   *
   * @param {EventTarget~Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   */


  ProgressControl.prototype.handleMouseUp = function handleMouseUp(event) {
    var doc = this.el_.ownerDocument;

    this.off(doc, 'mousemove', this.throttledHandleMouseSeek);
    this.off(doc, 'touchmove', this.throttledHandleMouseSeek);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchend', this.handleMouseUp);
  };

  return ProgressControl;
}(Component);

/**
 * Default options for `ProgressControl`
 *
 * @type {Object}
 * @private
 */


ProgressControl.prototype.options_ = {
  children: ['seekBar']
};

Component.registerComponent('ProgressControl', ProgressControl);

/**
 * @file fullscreen-toggle.js
 */
/**
 * Toggle fullscreen video
 *
 * @extends Button
 */

var FullscreenToggle = function (_Button) {
  inherits(FullscreenToggle, _Button);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function FullscreenToggle(player, options) {
    classCallCheck(this, FullscreenToggle);

    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    _this.on(player, 'fullscreenchange', _this.handleFullscreenChange);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  FullscreenToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-fullscreen-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * Handles fullscreenchange on the player and change control text accordingly.
   *
   * @param {EventTarget~Event} [event]
   *        The {@link Player#fullscreenchange} event that caused this function to be
   *        called.
   *
   * @listens Player#fullscreenchange
   */


  FullscreenToggle.prototype.handleFullscreenChange = function handleFullscreenChange(event) {
    if (this.player_.isFullscreen()) {
      this.controlText('Non-Fullscreen');
    } else {
      this.controlText('Fullscreen');
    }
  };

  /**
   * This gets called when an `FullscreenToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  FullscreenToggle.prototype.handleClick = function handleClick(event) {
    if (!this.player_.isFullscreen()) {
      this.player_.requestFullscreen();
    } else {
      this.player_.exitFullscreen();
    }
  };

  return FullscreenToggle;
}(Button);

/**
 * The text that should display over the `FullscreenToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


FullscreenToggle.prototype.controlText_ = 'Fullscreen';

Component.registerComponent('FullscreenToggle', FullscreenToggle);

/**
 * Check if volume control is supported and if it isn't hide the
 * `Component` that was passed  using the `vjs-hidden` class.
 *
 * @param {Component} self
 *        The component that should be hidden if volume is unsupported
 *
 * @param {Player} player
 *        A reference to the player
 *
 * @private
 */
var checkVolumeSupport = function checkVolumeSupport(self, player) {
  // hide volume controls when they're not supported by the current tech
  if (player.tech_ && !player.tech_.featuresVolumeControl) {
    self.addClass('vjs-hidden');
  }

  self.on(player, 'loadstart', function () {
    if (!player.tech_.featuresVolumeControl) {
      self.addClass('vjs-hidden');
    } else {
      self.removeClass('vjs-hidden');
    }
  });
};

/**
 * @file volume-level.js
 */
/**
 * Shows volume level
 *
 * @extends Component
 */

var VolumeLevel = function (_Component) {
  inherits(VolumeLevel, _Component);

  function VolumeLevel() {
    classCallCheck(this, VolumeLevel);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  VolumeLevel.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-level',
      innerHTML: '<span class="vjs-control-text"></span>'
    });
  };

  return VolumeLevel;
}(Component);

Component.registerComponent('VolumeLevel', VolumeLevel);

/**
 * @file volume-bar.js
 */
// Required children
/**
 * The bar that contains the volume level and can be clicked on to adjust the level
 *
 * @extends Slider
 */

var VolumeBar = function (_Slider) {
  inherits(VolumeBar, _Slider);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function VolumeBar(player, options) {
    classCallCheck(this, VolumeBar);

    var _this = possibleConstructorReturn(this, _Slider.call(this, player, options));

    _this.on('slideractive', _this.updateLastVolume_);
    _this.on(player, 'volumechange', _this.updateARIAAttributes);
    player.ready(function () {
      return _this.updateARIAAttributes();
    });
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  VolumeBar.prototype.createEl = function createEl() {
    return _Slider.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-bar vjs-slider-bar'
    }, {
      'aria-label': this.localize('Volume Level'),
      'aria-live': 'polite'
    });
  };

  /**
   * Handle movement events on the {@link VolumeMenuButton}.
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run.
   *
   * @listens mousemove
   */


  VolumeBar.prototype.handleMouseMove = function handleMouseMove(event) {
    this.checkMuted();
    this.player_.volume(this.calculateDistance(event));
  };

  /**
   * If the player is muted unmute it.
   */


  VolumeBar.prototype.checkMuted = function checkMuted() {
    if (this.player_.muted()) {
      this.player_.muted(false);
    }
  };

  /**
   * Get percent of volume level
   *
   * @return {number}
   *         Volume level percent as a decimal number.
   */


  VolumeBar.prototype.getPercent = function getPercent() {
    if (this.player_.muted()) {
      return 0;
    }
    return this.player_.volume();
  };

  /**
   * Increase volume level for keyboard users
   */


  VolumeBar.prototype.stepForward = function stepForward() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() + 0.1);
  };

  /**
   * Decrease volume level for keyboard users
   */


  VolumeBar.prototype.stepBack = function stepBack() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() - 0.1);
  };

  /**
   * Update ARIA accessibility attributes
   *
   * @param {EventTarget~Event} [event]
   *        The `volumechange` event that caused this function to run.
   *
   * @listens Player#volumechange
   */


  VolumeBar.prototype.updateARIAAttributes = function updateARIAAttributes(event) {
    var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();

    this.el_.setAttribute('aria-valuenow', ariaValue);
    this.el_.setAttribute('aria-valuetext', ariaValue + '%');
  };

  /**
   * Returns the current value of the player volume as a percentage
   *
   * @private
   */


  VolumeBar.prototype.volumeAsPercentage_ = function volumeAsPercentage_() {
    return Math.round(this.player_.volume() * 100);
  };

  /**
   * When user starts dragging the VolumeBar, store the volume and listen for
   * the end of the drag. When the drag ends, if the volume was set to zero,
   * set lastVolume to the stored volume.
   *
   * @listens slideractive
   * @private
   */


  VolumeBar.prototype.updateLastVolume_ = function updateLastVolume_() {
    var _this2 = this;

    var volumeBeforeDrag = this.player_.volume();

    this.one('sliderinactive', function () {
      if (_this2.player_.volume() === 0) {
        _this2.player_.lastVolume_(volumeBeforeDrag);
      }
    });
  };

  return VolumeBar;
}(Slider);

/**
 * Default options for the `VolumeBar`
 *
 * @type {Object}
 * @private
 */


VolumeBar.prototype.options_ = {
  children: ['volumeLevel'],
  barName: 'volumeLevel'
};

/**
 * Call the update event for this Slider when this event happens on the player.
 *
 * @type {string}
 */
VolumeBar.prototype.playerEvent = 'volumechange';

Component.registerComponent('VolumeBar', VolumeBar);

/**
 * @file volume-control.js
 */
// Required children
/**
 * The component for controlling the volume level
 *
 * @extends Component
 */

var VolumeControl = function (_Component) {
  inherits(VolumeControl, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function VolumeControl(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, VolumeControl);

    options.vertical = options.vertical || false;

    // Pass the vertical option down to the VolumeBar if
    // the VolumeBar is turned on.
    if (typeof options.volumeBar === 'undefined' || isPlain(options.volumeBar)) {
      options.volumeBar = options.volumeBar || {};
      options.volumeBar.vertical = options.vertical;
    }

    // hide this control if volume support is missing
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    checkVolumeSupport(_this, player);

    _this.throttledHandleMouseMove = throttle(bind(_this, _this.handleMouseMove), 25);

    _this.on('mousedown', _this.handleMouseDown);
    _this.on('touchstart', _this.handleMouseDown);

    // while the slider is active (the mouse has been pressed down and
    // is dragging) or in focus we do not want to hide the VolumeBar
    _this.on(_this.volumeBar, ['focus', 'slideractive'], function () {
      _this.volumeBar.addClass('vjs-slider-active');
      _this.addClass('vjs-slider-active');
      _this.trigger('slideractive');
    });

    _this.on(_this.volumeBar, ['blur', 'sliderinactive'], function () {
      _this.volumeBar.removeClass('vjs-slider-active');
      _this.removeClass('vjs-slider-active');
      _this.trigger('sliderinactive');
    });
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  VolumeControl.prototype.createEl = function createEl() {
    var orientationClass = 'vjs-volume-horizontal';

    if (this.options_.vertical) {
      orientationClass = 'vjs-volume-vertical';
    }

    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-control vjs-control ' + orientationClass
    });
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */


  VolumeControl.prototype.handleMouseDown = function handleMouseDown(event) {
    var doc = this.el_.ownerDocument;

    this.on(doc, 'mousemove', this.throttledHandleMouseMove);
    this.on(doc, 'touchmove', this.throttledHandleMouseMove);
    this.on(doc, 'mouseup', this.handleMouseUp);
    this.on(doc, 'touchend', this.handleMouseUp);
  };

  /**
   * Handle `mouseup` or `touchend` events on the `VolumeControl`.
   *
   * @param {EventTarget~Event} event
   *        `mouseup` or `touchend` event that triggered this function.
   *
   * @listens touchend
   * @listens mouseup
   */


  VolumeControl.prototype.handleMouseUp = function handleMouseUp(event) {
    var doc = this.el_.ownerDocument;

    this.off(doc, 'mousemove', this.throttledHandleMouseMove);
    this.off(doc, 'touchmove', this.throttledHandleMouseMove);
    this.off(doc, 'mouseup', this.handleMouseUp);
    this.off(doc, 'touchend', this.handleMouseUp);
  };

  /**
   * Handle `mousedown` or `touchstart` events on the `VolumeControl`.
   *
   * @param {EventTarget~Event} event
   *        `mousedown` or `touchstart` event that triggered this function
   *
   * @listens mousedown
   * @listens touchstart
   */


  VolumeControl.prototype.handleMouseMove = function handleMouseMove(event) {
    this.volumeBar.handleMouseMove(event);
  };

  return VolumeControl;
}(Component);

/**
 * Default options for the `VolumeControl`
 *
 * @type {Object}
 * @private
 */


VolumeControl.prototype.options_ = {
  children: ['volumeBar']
};

Component.registerComponent('VolumeControl', VolumeControl);

/**
 * @file mute-toggle.js
 */
/**
 * A button component for muting the audio.
 *
 * @extends Button
 */

var MuteToggle = function (_Button) {
  inherits(MuteToggle, _Button);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function MuteToggle(player, options) {
    classCallCheck(this, MuteToggle);

    // hide this control if volume support is missing
    var _this = possibleConstructorReturn(this, _Button.call(this, player, options));

    checkVolumeSupport(_this, player);

    _this.on(player, ['loadstart', 'volumechange'], _this.update);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  MuteToggle.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-mute-control ' + _Button.prototype.buildCSSClass.call(this);
  };

  /**
   * This gets called when an `MuteToggle` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  MuteToggle.prototype.handleClick = function handleClick(event) {
    var vol = this.player_.volume();
    var lastVolume = this.player_.lastVolume_();

    if (vol === 0) {
      var volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;

      this.player_.volume(volumeToSet);
      this.player_.muted(false);
    } else {
      this.player_.muted(this.player_.muted() ? false : true);
    }
  };

  /**
   * Update the `MuteToggle` button based on the state of `volume` and `muted`
   * on the player.
   *
   * @param {EventTarget~Event} [event]
   *        The {@link Player#loadstart} event if this function was called
   *        through an event.
   *
   * @listens Player#loadstart
   * @listens Player#volumechange
   */


  MuteToggle.prototype.update = function update(event) {
    this.updateIcon_();
    this.updateControlText_();
  };

  /**
   * Update the appearance of the `MuteToggle` icon.
   *
   * Possible states (given `level` variable below):
   * - 0: crossed out
   * - 1: zero bars of volume
   * - 2: one bar of volume
   * - 3: two bars of volume
   *
   * @private
   */


  MuteToggle.prototype.updateIcon_ = function updateIcon_() {
    var vol = this.player_.volume();
    var level = 3;

    if (vol === 0 || this.player_.muted()) {
      level = 0;
    } else if (vol < 0.33) {
      level = 1;
    } else if (vol < 0.67) {
      level = 2;
    }

    // TODO improve muted icon classes
    for (var i = 0; i < 4; i++) {
      removeClass(this.el_, 'vjs-vol-' + i);
    }
    addClass(this.el_, 'vjs-vol-' + level);
  };

  /**
   * If `muted` has changed on the player, update the control text
   * (`title` attribute on `vjs-mute-control` element and content of
   * `vjs-control-text` element).
   *
   * @private
   */


  MuteToggle.prototype.updateControlText_ = function updateControlText_() {
    var soundOff = this.player_.muted() || this.player_.volume() === 0;
    var text = soundOff ? 'Unmute' : 'Mute';

    if (this.controlText() !== text) {
      this.controlText(text);
    }
  };

  return MuteToggle;
}(Button);

/**
 * The text that should display over the `MuteToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


MuteToggle.prototype.controlText_ = 'Mute';

Component.registerComponent('MuteToggle', MuteToggle);

/**
 * @file volume-control.js
 */
// Required children
/**
 * A Component to contain the MuteToggle and VolumeControl so that
 * they can work together.
 *
 * @extends Component
 */

var VolumePanel = function (_Component) {
  inherits(VolumePanel, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function VolumePanel(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, VolumePanel);

    if (typeof options.inline !== 'undefined') {
      options.inline = options.inline;
    } else {
      options.inline = true;
    }

    // pass the inline option down to the VolumeControl as vertical if
    // the VolumeControl is on.
    if (typeof options.volumeControl === 'undefined' || isPlain(options.volumeControl)) {
      options.volumeControl = options.volumeControl || {};
      options.volumeControl.vertical = !options.inline;
    }

    // hide this control if volume support is missing
    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    checkVolumeSupport(_this, player);

    // while the slider is active (the mouse has been pressed down and
    // is dragging) or in focus we do not want to hide the VolumeBar
    _this.on(_this.volumeControl, ['slideractive'], _this.sliderActive_);
    _this.on(_this.muteToggle, 'focus', _this.sliderActive_);

    _this.on(_this.volumeControl, ['sliderinactive'], _this.sliderInactive_);
    _this.on(_this.muteToggle, 'blur', _this.sliderInactive_);
    return _this;
  }

  /**
   * Add vjs-slider-active class to the VolumePanel
   *
   * @listens VolumeControl#slideractive
   * @private
   */


  VolumePanel.prototype.sliderActive_ = function sliderActive_() {
    this.addClass('vjs-slider-active');
  };

  /**
   * Removes vjs-slider-active class to the VolumePanel
   *
   * @listens VolumeControl#sliderinactive
   * @private
   */


  VolumePanel.prototype.sliderInactive_ = function sliderInactive_() {
    this.removeClass('vjs-slider-active');
  };

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  VolumePanel.prototype.createEl = function createEl() {
    var orientationClass = 'vjs-volume-panel-horizontal';

    if (!this.options_.inline) {
      orientationClass = 'vjs-volume-panel-vertical';
    }

    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-volume-panel vjs-control ' + orientationClass
    });
  };

  return VolumePanel;
}(Component);

/**
 * Default options for the `VolumeControl`
 *
 * @type {Object}
 * @private
 */


VolumePanel.prototype.options_ = {
  children: ['muteToggle', 'volumeControl']
};

Component.registerComponent('VolumePanel', VolumePanel);

/**
 * @file menu.js
 */
/**
 * The Menu component is used to build popup menus, including subtitle and
 * captions selection menus.
 *
 * @extends Component
 */

var Menu = function (_Component) {
  inherits(Menu, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Player} player
   *        the player that this component should attach to
   *
   * @param {Object} [options]
   *        Object of option names and values
   *
   */
  function Menu(player, options) {
    classCallCheck(this, Menu);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    if (options) {
      _this.menuButton_ = options.menuButton;
    }

    _this.focusedChild_ = -1;

    _this.on('keydown', _this.handleKeyPress);
    return _this;
  }

  /**
   * Add a {@link MenuItem} to the menu.
   *
   * @param {Object|string} component
   *        The name or instance of the `MenuItem` to add.
   *
   */


  Menu.prototype.addItem = function addItem(component) {
    this.addChild(component);
    component.on('click', bind(this, function (event) {
      // Unpress the associated MenuButton, and move focus back to it
      if (this.menuButton_) {
        this.menuButton_.unpressButton();

        // don't focus menu button if item is a caption settings item
        // because focus will move elsewhere and it logs an error on IE8
        if (component.name() !== 'CaptionSettingsMenuItem') {
          this.menuButton_.focus();
        }
      }
    }));
  };

  /**
   * Create the `Menu`s DOM element.
   *
   * @return {Element}
   *         the element that was created
   */


  Menu.prototype.createEl = function createEl$$1() {
    var contentElType = this.options_.contentElType || 'ul';

    this.contentEl_ = createEl(contentElType, {
      className: 'vjs-menu-content'
    });

    this.contentEl_.setAttribute('role', 'menu');

    var el = _Component.prototype.createEl.call(this, 'div', {
      append: this.contentEl_,
      className: 'vjs-menu'
    });

    el.appendChild(this.contentEl_);

    // Prevent clicks from bubbling up. Needed for Menu Buttons,
    // where a click on the parent is significant
    on(el, 'click', function (event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    });

    return el;
  };

  /**
   * Handle a `keydown` event on this menu. This listener is added in the constructor.
   *
   * @param {EventTarget~Event} event
   *        A `keydown` event that happened on the menu.
   *
   * @listens keydown
   */


  Menu.prototype.handleKeyPress = function handleKeyPress(event) {
    // Left and Down Arrows
    if (event.which === 37 || event.which === 40) {
      event.preventDefault();
      this.stepForward();

      // Up and Right Arrows
    } else if (event.which === 38 || event.which === 39) {
      event.preventDefault();
      this.stepBack();
    }
  };

  /**
   * Move to next (lower) menu item for keyboard users.
   */


  Menu.prototype.stepForward = function stepForward() {
    var stepChild = 0;

    if (this.focusedChild_ !== undefined) {
      stepChild = this.focusedChild_ + 1;
    }
    this.focus(stepChild);
  };

  /**
   * Move to previous (higher) menu item for keyboard users.
   */


  Menu.prototype.stepBack = function stepBack() {
    var stepChild = 0;

    if (this.focusedChild_ !== undefined) {
      stepChild = this.focusedChild_ - 1;
    }
    this.focus(stepChild);
  };

  /**
   * Set focus on a {@link MenuItem} in the `Menu`.
   *
   * @param {Object|string} [item=0]
   *        Index of child item set focus on.
   */


  Menu.prototype.focus = function focus() {
    var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    var children = this.children().slice();
    var haveTitle = children.length && children[0].className && /vjs-menu-title/.test(children[0].className);

    if (haveTitle) {
      children.shift();
    }

    if (children.length > 0) {
      if (item < 0) {
        item = 0;
      } else if (item >= children.length) {
        item = children.length - 1;
      }

      this.focusedChild_ = item;

      children[item].el_.focus();
    }
  };

  return Menu;
}(Component);

Component.registerComponent('Menu', Menu);

/**
 * @file menu-button.js
 */
/**
 * A `MenuButton` class for any popup {@link Menu}.
 *
 * @extends Component
 */

var MenuButton = function (_Component) {
  inherits(MenuButton, _Component);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function MenuButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, MenuButton);

    var _this = possibleConstructorReturn(this, _Component.call(this, player, options));

    _this.menuButton_ = new Button(player, options);

    _this.menuButton_.controlText(_this.controlText_);
    _this.menuButton_.el_.setAttribute('aria-haspopup', 'true');

    // Add buildCSSClass values to the button, not the wrapper
    var buttonClass = Button.prototype.buildCSSClass();

    _this.menuButton_.el_.className = _this.buildCSSClass() + ' ' + buttonClass;
    _this.menuButton_.removeClass('vjs-control');

    _this.addChild(_this.menuButton_);

    _this.update();

    _this.enabled_ = true;

    _this.on(_this.menuButton_, 'tap', _this.handleClick);
    _this.on(_this.menuButton_, 'click', _this.handleClick);
    _this.on(_this.menuButton_, 'focus', _this.handleFocus);
    _this.on(_this.menuButton_, 'blur', _this.handleBlur);

    _this.on('keydown', _this.handleSubmenuKeyPress);
    return _this;
  }

  /**
   * Update the menu based on the current state of its items.
   */


  MenuButton.prototype.update = function update() {
    var menu = this.createMenu();

    if (this.menu) {
      this.removeChild(this.menu);
    }

    this.menu = menu;
    this.addChild(menu);

    /**
     * Track the state of the menu button
     *
     * @type {Boolean}
     * @private
     */
    this.buttonPressed_ = false;
    this.menuButton_.el_.setAttribute('aria-expanded', 'false');

    if (this.items && this.items.length <= this.hideThreshold_) {
      this.hide();
    } else {
      this.show();
    }
  };

  /**
   * Create the menu and add all items to it.
   *
   * @return {Menu}
   *         The constructed menu
   */


  MenuButton.prototype.createMenu = function createMenu() {
    var menu = new Menu(this.player_, { menuButton: this });

    /**
     * Hide the menu if the number of items is less than or equal to this threshold. This defaults
     * to 0 and whenever we add items which can be hidden to the menu we'll increment it. We list
     * it here because every time we run `createMenu` we need to reset the value.
     *
     * @protected
     * @type {Number}
     */
    this.hideThreshold_ = 0;

    // Add a title list item to the top
    if (this.options_.title) {
      var title = createEl('li', {
        className: 'vjs-menu-title',
        innerHTML: toTitleCase(this.options_.title),
        tabIndex: -1
      });

      this.hideThreshold_ += 1;

      menu.children_.unshift(title);
      prependTo(title, menu.contentEl());
    }

    this.items = this.createItems();

    if (this.items) {
      // Add menu items to the menu
      for (var i = 0; i < this.items.length; i++) {
        menu.addItem(this.items[i]);
      }
    }

    return menu;
  };

  /**
   * Create the list of menu items. Specific to each subclass.
   *
   * @abstract
   */


  MenuButton.prototype.createItems = function createItems() {};

  /**
   * Create the `MenuButtons`s DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  MenuButton.prototype.createEl = function createEl$$1() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildWrapperCSSClass()
    }, {});
  };

  /**
   * Allow sub components to stack CSS class names for the wrapper element
   *
   * @return {string}
   *         The constructed wrapper DOM `className`
   */


  MenuButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    var menuButtonClass = 'vjs-menu-button';

    // If the inline option is passed, we want to use different styles altogether.
    if (this.options_.inline === true) {
      menuButtonClass += '-inline';
    } else {
      menuButtonClass += '-popup';
    }

    // TODO: Fix the CSS so that this isn't necessary
    var buttonClass = Button.prototype.buildCSSClass();

    return 'vjs-menu-button ' + menuButtonClass + ' ' + buttonClass + ' ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  MenuButton.prototype.buildCSSClass = function buildCSSClass() {
    var menuButtonClass = 'vjs-menu-button';

    // If the inline option is passed, we want to use different styles altogether.
    if (this.options_.inline === true) {
      menuButtonClass += '-inline';
    } else {
      menuButtonClass += '-popup';
    }

    return 'vjs-menu-button ' + menuButtonClass + ' ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Get or set the localized control text that will be used for accessibility.
   *
   * > NOTE: This will come from the internal `menuButton_` element.
   *
   * @param {string} [text]
   *        Control text for element.
   *
   * @param {Element} [el=this.menuButton_.el()]
   *        Element to set the title on.
   *
   * @return {string}
   *         - The control text when getting
   */


  MenuButton.prototype.controlText = function controlText(text) {
    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.menuButton_.el();

    return this.menuButton_.controlText(text, el);
  };

  /**
   * Handle a click on a `MenuButton`.
   * See {@link ClickableComponent#handleClick} for instances where this is called.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  MenuButton.prototype.handleClick = function handleClick(event) {
    // When you click the button it adds focus, which will show the menu.
    // So we'll remove focus when the mouse leaves the button. Focus is needed
    // for tab navigation.

    this.one(this.menu.contentEl(), 'mouseleave', bind(this, function (e) {
      this.unpressButton();
      this.el_.blur();
    }));
    if (this.buttonPressed_) {
      this.unpressButton();
    } else {
      this.pressButton();
    }
  };

  /**
   * Set the focus to the actual button, not to this element
   */


  MenuButton.prototype.focus = function focus() {
    this.menuButton_.focus();
  };

  /**
   * Remove the focus from the actual button, not this element
   */


  MenuButton.prototype.blur = function blur() {
    this.menuButton_.blur();
  };

  /**
   * This gets called when a `MenuButton` gains focus via a `focus` event.
   * Turns on listening for `keydown` events. When they happen it
   * calls `this.handleKeyPress`.
   *
   * @param {EventTarget~Event} event
   *        The `focus` event that caused this function to be called.
   *
   * @listens focus
   */


  MenuButton.prototype.handleFocus = function handleFocus() {
    on(document_1, 'keydown', bind(this, this.handleKeyPress));
  };

  /**
   * Called when a `MenuButton` loses focus. Turns off the listener for
   * `keydown` events. Which Stops `this.handleKeyPress` from getting called.
   *
   * @param {EventTarget~Event} event
   *        The `blur` event that caused this function to be called.
   *
   * @listens blur
   */


  MenuButton.prototype.handleBlur = function handleBlur() {
    off(document_1, 'keydown', bind(this, this.handleKeyPress));
  };

  /**
   * Handle tab, escape, down arrow, and up arrow keys for `MenuButton`. See
   * {@link ClickableComponent#handleKeyPress} for instances where this is called.
   *
   * @param {EventTarget~Event} event
   *        The `keydown` event that caused this function to be called.
   *
   * @listens keydown
   */


  MenuButton.prototype.handleKeyPress = function handleKeyPress(event) {

    // Escape (27) key or Tab (9) key unpress the 'button'
    if (event.which === 27 || event.which === 9) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      // Don't preventDefault for Tab key - we still want to lose focus
      if (event.which !== 9) {
        event.preventDefault();
        // Set focus back to the menu button's button
        this.menuButton_.el_.focus();
      }
      // Up (38) key or Down (40) key press the 'button'
    } else if (event.which === 38 || event.which === 40) {
      if (!this.buttonPressed_) {
        this.pressButton();
        event.preventDefault();
      }
    }
  };

  /**
   * Handle a `keydown` event on a sub-menu. The listener for this is added in
   * the constructor.
   *
   * @param {EventTarget~Event} event
   *        Key press event
   *
   * @listens keydown
   */


  MenuButton.prototype.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {

    // Escape (27) key or Tab (9) key unpress the 'button'
    if (event.which === 27 || event.which === 9) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      // Don't preventDefault for Tab key - we still want to lose focus
      if (event.which !== 9) {
        event.preventDefault();
        // Set focus back to the menu button's button
        this.menuButton_.el_.focus();
      }
    }
  };

  /**
   * Put the current `MenuButton` into a pressed state.
   */


  MenuButton.prototype.pressButton = function pressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = true;
      this.menu.lockShowing();
      this.menuButton_.el_.setAttribute('aria-expanded', 'true');
      // set the focus into the submenu
      this.menu.focus();
    }
  };

  /**
   * Take the current `MenuButton` out of a pressed state.
   */


  MenuButton.prototype.unpressButton = function unpressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = false;
      this.menu.unlockShowing();
      this.menuButton_.el_.setAttribute('aria-expanded', 'false');
    }
  };

  /**
   * Disable the `MenuButton`. Don't allow it to be clicked.
   */


  MenuButton.prototype.disable = function disable() {
    this.unpressButton();

    this.enabled_ = false;
    this.addClass('vjs-disabled');

    this.menuButton_.disable();
  };

  /**
   * Enable the `MenuButton`. Allow it to be clicked.
   */


  MenuButton.prototype.enable = function enable() {
    this.enabled_ = true;
    this.removeClass('vjs-disabled');

    this.menuButton_.enable();
  };

  return MenuButton;
}(Component);

Component.registerComponent('MenuButton', MenuButton);

/**
 * @file track-button.js
 */
/**
 * The base class for buttons that toggle specific  track types (e.g. subtitles).
 *
 * @extends MenuButton
 */

var TrackButton = function (_MenuButton) {
  inherits(TrackButton, _MenuButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function TrackButton(player, options) {
    classCallCheck(this, TrackButton);

    var tracks = options.tracks;

    var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));

    if (_this.items.length <= 1) {
      _this.hide();
    }

    if (!tracks) {
      return possibleConstructorReturn(_this);
    }

    var updateHandler = bind(_this, _this.update);

    tracks.addEventListener('removetrack', updateHandler);
    tracks.addEventListener('addtrack', updateHandler);
    _this.player_.on('ready', updateHandler);

    _this.player_.on('dispose', function () {
      tracks.removeEventListener('removetrack', updateHandler);
      tracks.removeEventListener('addtrack', updateHandler);
    });
    return _this;
  }

  return TrackButton;
}(MenuButton);

Component.registerComponent('TrackButton', TrackButton);

/**
 * @file menu-item.js
 */
/**
 * The component for a menu item. `<li>`
 *
 * @extends ClickableComponent
 */

var MenuItem = function (_ClickableComponent) {
  inherits(MenuItem, _ClickableComponent);

  /**
   * Creates an instance of the this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   *
   */
  function MenuItem(player, options) {
    classCallCheck(this, MenuItem);

    var _this = possibleConstructorReturn(this, _ClickableComponent.call(this, player, options));

    _this.selectable = options.selectable;

    _this.selected(options.selected);

    if (_this.selectable) {
      // TODO: May need to be either menuitemcheckbox or menuitemradio,
      //       and may need logical grouping of menu items.
      _this.el_.setAttribute('role', 'menuitemcheckbox');
    } else {
      _this.el_.setAttribute('role', 'menuitem');
    }
    return _this;
  }

  /**
   * Create the `MenuItem's DOM element
   *
   * @param {string} [type=li]
   *        Element's node type, not actually used, always set to `li`.
   *
   * @param {Object} [props={}]
   *        An object of properties that should be set on the element
   *
   * @param {Object} [attrs={}]
   *        An object of attributes that should be set on the element
   *
   * @return {Element}
   *         The element that gets created.
   */


  MenuItem.prototype.createEl = function createEl(type, props, attrs) {
    // The control is textual, not just an icon
    this.nonIconControl = true;

    return _ClickableComponent.prototype.createEl.call(this, 'li', assign({
      className: 'vjs-menu-item',
      innerHTML: '<span class="vjs-menu-item-text">' + this.localize(this.options_.label) + '</span>',
      tabIndex: -1
    }, props), attrs);
  };

  /**
   * Any click on a `MenuItem` puts int into the selected state.
   * See {@link ClickableComponent#handleClick} for instances where this is called.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  MenuItem.prototype.handleClick = function handleClick(event) {
    this.selected(true);
  };

  /**
   * Set the state for this menu item as selected or not.
   *
   * @param {boolean} selected
   *        if the menu item is selected or not
   */


  MenuItem.prototype.selected = function selected(_selected) {
    if (this.selectable) {
      if (_selected) {
        this.addClass('vjs-selected');
        this.el_.setAttribute('aria-checked', 'true');
        // aria-checked isn't fully supported by browsers/screen readers,
        // so indicate selected state to screen reader in the control text.
        this.controlText(', selected');
      } else {
        this.removeClass('vjs-selected');
        this.el_.setAttribute('aria-checked', 'false');
        // Indicate un-selected state to screen reader
        // Note that a space clears out the selected state text
        this.controlText(' ');
      }
    }
  };

  return MenuItem;
}(ClickableComponent);

Component.registerComponent('MenuItem', MenuItem);

/**
 * @file text-track-menu-item.js
 */
/**
 * The specific menu item type for selecting a language within a text track kind
 *
 * @extends MenuItem
 */

var TextTrackMenuItem = function (_MenuItem) {
  inherits(TextTrackMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function TextTrackMenuItem(player, options) {
    classCallCheck(this, TextTrackMenuItem);

    var track = options.track;
    var tracks = player.textTracks();

    // Modify options for parent MenuItem class's init.
    options.label = track.label || track.language || 'Unknown';
    options.selected = track.mode === 'showing';

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.track = track;
    var changeHandler = bind(_this, _this.handleTracksChange);
    var selectedLanguageChangeHandler = bind(_this, _this.handleSelectedLanguageChange);

    player.on(['loadstart', 'texttrackchange'], changeHandler);
    tracks.addEventListener('change', changeHandler);
    tracks.addEventListener('selectedlanguagechange', selectedLanguageChangeHandler);
    _this.on('dispose', function () {
      tracks.removeEventListener('change', changeHandler);
      tracks.removeEventListener('selectedlanguagechange', selectedLanguageChangeHandler);
    });

    // iOS7 doesn't dispatch change events to TextTrackLists when an
    // associated track's mode changes. Without something like
    // Object.observe() (also not present on iOS7), it's not
    // possible to detect changes to the mode attribute and polyfill
    // the change event. As a poor substitute, we manually dispatch
    // change events whenever the controls modify the mode.
    if (tracks.onchange === undefined) {
      var event = void 0;

      _this.on(['tap', 'click'], function () {
        if (_typeof(window_1.Event) !== 'object') {
          // Android 2.3 throws an Illegal Constructor error for window.Event
          try {
            event = new window_1.Event('change');
          } catch (err) {
            // continue regardless of error
          }
        }

        if (!event) {
          event = document_1.createEvent('Event');
          event.initEvent('change', true, true);
        }

        tracks.dispatchEvent(event);
      });
    }
    return _this;
  }

  /**
   * This gets called when an `TextTrackMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} event
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  TextTrackMenuItem.prototype.handleClick = function handleClick(event) {
    var kind = this.track.kind;
    var kinds = this.track.kinds;
    var tracks = this.player_.textTracks();

    if (!kinds) {
      kinds = [kind];
    }

    _MenuItem.prototype.handleClick.call(this, event);

    if (!tracks) {
      return;
    }

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      if (track === this.track && kinds.indexOf(track.kind) > -1) {
        if (track.mode !== 'showing') {
          track.mode = 'showing';
        }
      } else if (track.mode !== 'disabled') {
        track.mode = 'disabled';
      }
    }
  };

  /**
   * Handle text track list change
   *
   * @param {EventTarget~Event} event
   *        The `change` event that caused this function to be called.
   *
   * @listens TextTrackList#change
   */


  TextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    this.selected(this.track.mode === 'showing');
  };

  TextTrackMenuItem.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
    if (this.track.mode === 'showing') {
      var selectedLanguage = this.player_.cache_.selectedLanguage;

      // Don't replace the kind of track across the same language
      if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {
        return;
      }

      this.player_.cache_.selectedLanguage = {
        enabled: true,
        language: this.track.language,
        kind: this.track.kind
      };
    }
  };

  return TextTrackMenuItem;
}(MenuItem);

Component.registerComponent('TextTrackMenuItem', TextTrackMenuItem);

/**
 * @file off-text-track-menu-item.js
 */
/**
 * A special menu item for turning of a specific type of text track
 *
 * @extends TextTrackMenuItem
 */

var OffTextTrackMenuItem = function (_TextTrackMenuItem) {
  inherits(OffTextTrackMenuItem, _TextTrackMenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function OffTextTrackMenuItem(player, options) {
    classCallCheck(this, OffTextTrackMenuItem);

    // Create pseudo track info
    // Requires options['kind']
    options.track = {
      player: player,
      kind: options.kind,
      kinds: options.kinds,
      'default': false,
      mode: 'disabled'
    };

    if (!options.kinds) {
      options.kinds = [options.kind];
    }

    if (options.label) {
      options.track.label = options.label;
    } else {
      options.track.label = options.kinds.join(' and ') + ' off';
    }

    // MenuItem is selectable
    options.selectable = true;

    var _this = possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));

    _this.selected(true);
    return _this;
  }

  /**
   * Handle text track change
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run
   */


  OffTextTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var selected = true;

    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];

      if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === 'showing') {
        selected = false;
        break;
      }
    }

    this.selected(selected);
  };

  OffTextTrackMenuItem.prototype.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
    var tracks = this.player().textTracks();
    var allHidden = true;

    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];

      if (['captions', 'descriptions', 'subtitles'].indexOf(track.kind) > -1 && track.mode === 'showing') {
        allHidden = false;
        break;
      }
    }

    if (allHidden) {
      this.player_.cache_.selectedLanguage = {
        enabled: false
      };
    }
  };

  return OffTextTrackMenuItem;
}(TextTrackMenuItem);

Component.registerComponent('OffTextTrackMenuItem', OffTextTrackMenuItem);

/**
 * @file text-track-button.js
 */
/**
 * The base class for buttons that toggle specific text track types (e.g. subtitles)
 *
 * @extends MenuButton
 */

var TextTrackButton = function (_TrackButton) {
  inherits(TextTrackButton, _TrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function TextTrackButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, TextTrackButton);

    options.tracks = player.textTracks();

    return possibleConstructorReturn(this, _TrackButton.call(this, player, options));
  }

  /**
   * Create a menu item for each text track
   *
   * @param {TextTrackMenuItem[]} [items=[]]
   *        Existing array of items to use during creation
   *
   * @return {TextTrackMenuItem[]}
   *         Array of menu items that were created
   */


  TextTrackButton.prototype.createItems = function createItems() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var TrackMenuItem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TextTrackMenuItem;


    // Label is an overide for the [track] off label
    // USed to localise captions/subtitles
    var label = void 0;

    if (this.label_) {
      label = this.label_ + ' off';
    }
    // Add an OFF menu item to turn all tracks off
    items.push(new OffTextTrackMenuItem(this.player_, {
      kinds: this.kinds_,
      kind: this.kind_,
      label: label
    }));

    this.hideThreshold_ += 1;

    var tracks = this.player_.textTracks();

    if (!Array.isArray(this.kinds_)) {
      this.kinds_ = [this.kind_];
    }

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      // only add tracks that are of an appropriate kind and have a label
      if (this.kinds_.indexOf(track.kind) > -1) {

        var item = new TrackMenuItem(this.player_, {
          track: track,
          // MenuItem is selectable
          selectable: true
        });

        item.addClass('vjs-' + track.kind + '-menu-item');
        items.push(item);
      }
    }

    return items;
  };

  return TextTrackButton;
}(TrackButton);

Component.registerComponent('TextTrackButton', TextTrackButton);

/**
 * @file chapters-track-menu-item.js
 */
/**
 * The chapter track menu item
 *
 * @extends MenuItem
 */

var ChaptersTrackMenuItem = function (_MenuItem) {
  inherits(ChaptersTrackMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function ChaptersTrackMenuItem(player, options) {
    classCallCheck(this, ChaptersTrackMenuItem);

    var track = options.track;
    var cue = options.cue;
    var currentTime = player.currentTime();

    // Modify options for parent MenuItem class's init.
    options.selectable = true;
    options.label = cue.text;
    options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.track = track;
    _this.cue = cue;
    track.addEventListener('cuechange', bind(_this, _this.update));
    return _this;
  }

  /**
   * This gets called when an `ChaptersTrackMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  ChaptersTrackMenuItem.prototype.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this);
    this.player_.currentTime(this.cue.startTime);
    this.update(this.cue.startTime);
  };

  /**
   * Update chapter menu item
   *
   * @param {EventTarget~Event} [event]
   *        The `cuechange` event that caused this function to run.
   *
   * @listens TextTrack#cuechange
   */


  ChaptersTrackMenuItem.prototype.update = function update(event) {
    var cue = this.cue;
    var currentTime = this.player_.currentTime();

    // vjs.log(currentTime, cue.startTime);
    this.selected(cue.startTime <= currentTime && currentTime < cue.endTime);
  };

  return ChaptersTrackMenuItem;
}(MenuItem);

Component.registerComponent('ChaptersTrackMenuItem', ChaptersTrackMenuItem);

/**
 * @file chapters-button.js
 */
/**
 * The button component for toggling and selecting chapters
 * Chapters act much differently than other text tracks
 * Cues are navigation vs. other tracks of alternative languages
 *
 * @extends TextTrackButton
 */

var ChaptersButton = function (_TextTrackButton) {
  inherits(ChaptersButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this function is ready.
   */
  function ChaptersButton(player, options, ready) {
    classCallCheck(this, ChaptersButton);
    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  ChaptersButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  ChaptersButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-chapters-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Update the menu based on the current state of its items.
   *
   * @param {EventTarget~Event} [event]
   *        An event that triggered this function to run.
   *
   * @listens TextTrackList#addtrack
   * @listens TextTrackList#removetrack
   * @listens TextTrackList#change
   */


  ChaptersButton.prototype.update = function update(event) {
    if (!this.track_ || event && (event.type === 'addtrack' || event.type === 'removetrack')) {
      this.setTrack(this.findChaptersTrack());
    }
    _TextTrackButton.prototype.update.call(this);
  };

  /**
   * Set the currently selected track for the chapters button.
   *
   * @param {TextTrack} track
   *        The new track to select. Nothing will change if this is the currently selected
   *        track.
   */


  ChaptersButton.prototype.setTrack = function setTrack(track) {
    if (this.track_ === track) {
      return;
    }

    if (!this.updateHandler_) {
      this.updateHandler_ = this.update.bind(this);
    }

    // here this.track_ refers to the old track instance
    if (this.track_) {
      var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);

      if (remoteTextTrackEl) {
        remoteTextTrackEl.removeEventListener('load', this.updateHandler_);
      }

      this.track_ = null;
    }

    this.track_ = track;

    // here this.track_ refers to the new track instance
    if (this.track_) {
      this.track_.mode = 'hidden';

      var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);

      if (_remoteTextTrackEl) {
        _remoteTextTrackEl.addEventListener('load', this.updateHandler_);
      }
    }
  };

  /**
   * Find the track object that is currently in use by this ChaptersButton
   *
   * @return {TextTrack|undefined}
   *         The current track or undefined if none was found.
   */


  ChaptersButton.prototype.findChaptersTrack = function findChaptersTrack() {
    var tracks = this.player_.textTracks() || [];

    for (var i = tracks.length - 1; i >= 0; i--) {
      // We will always choose the last track as our chaptersTrack
      var track = tracks[i];

      if (track.kind === this.kind_) {
        return track;
      }
    }
  };

  /**
   * Get the caption for the ChaptersButton based on the track label. This will also
   * use the current tracks localized kind as a fallback if a label does not exist.
   *
   * @return {string}
   *         The tracks current label or the localized track kind.
   */


  ChaptersButton.prototype.getMenuCaption = function getMenuCaption() {
    if (this.track_ && this.track_.label) {
      return this.track_.label;
    }
    return this.localize(toTitleCase(this.kind_));
  };

  /**
   * Create menu from chapter track
   *
   * @return {Menu}
   *         New menu for the chapter buttons
   */


  ChaptersButton.prototype.createMenu = function createMenu() {
    this.options_.title = this.getMenuCaption();
    return _TextTrackButton.prototype.createMenu.call(this);
  };

  /**
   * Create a menu item for each text track
   *
   * @return {TextTrackMenuItem[]}
   *         Array of menu items
   */


  ChaptersButton.prototype.createItems = function createItems() {
    var items = [];

    if (!this.track_) {
      return items;
    }

    var cues = this.track_.cues;

    if (!cues) {
      return items;
    }

    for (var i = 0, l = cues.length; i < l; i++) {
      var cue = cues[i];
      var mi = new ChaptersTrackMenuItem(this.player_, { track: this.track_, cue: cue });

      items.push(mi);
    }

    return items;
  };

  return ChaptersButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


ChaptersButton.prototype.kind_ = 'chapters';

/**
 * The text that should display over the `ChaptersButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
ChaptersButton.prototype.controlText_ = 'Chapters';

Component.registerComponent('ChaptersButton', ChaptersButton);

/**
 * @file descriptions-button.js
 */
/**
 * The button component for toggling and selecting descriptions
 *
 * @extends TextTrackButton
 */

var DescriptionsButton = function (_TextTrackButton) {
  inherits(DescriptionsButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this component is ready.
   */
  function DescriptionsButton(player, options, ready) {
    classCallCheck(this, DescriptionsButton);

    var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));

    var tracks = player.textTracks();
    var changeHandler = bind(_this, _this.handleTracksChange);

    tracks.addEventListener('change', changeHandler);
    _this.on('dispose', function () {
      tracks.removeEventListener('change', changeHandler);
    });
    return _this;
  }

  /**
   * Handle text track change
   *
   * @param {EventTarget~Event} event
   *        The event that caused this function to run
   *
   * @listens TextTrackList#change
   */


  DescriptionsButton.prototype.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var disabled = false;

    // Check whether a track of a different kind is showing
    for (var i = 0, l = tracks.length; i < l; i++) {
      var track = tracks[i];

      if (track.kind !== this.kind_ && track.mode === 'showing') {
        disabled = true;
        break;
      }
    }

    // If another track is showing, disable this menu button
    if (disabled) {
      this.disable();
    } else {
      this.enable();
    }
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  DescriptionsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  DescriptionsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-descriptions-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  return DescriptionsButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


DescriptionsButton.prototype.kind_ = 'descriptions';

/**
 * The text that should display over the `DescriptionsButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
DescriptionsButton.prototype.controlText_ = 'Descriptions';

Component.registerComponent('DescriptionsButton', DescriptionsButton);

/**
 * @file subtitles-button.js
 */
/**
 * The button component for toggling and selecting subtitles
 *
 * @extends TextTrackButton
 */

var SubtitlesButton = function (_TextTrackButton) {
  inherits(SubtitlesButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this component is ready.
   */
  function SubtitlesButton(player, options, ready) {
    classCallCheck(this, SubtitlesButton);
    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  SubtitlesButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  SubtitlesButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-subtitles-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  return SubtitlesButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


SubtitlesButton.prototype.kind_ = 'subtitles';

/**
 * The text that should display over the `SubtitlesButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
SubtitlesButton.prototype.controlText_ = 'Subtitles';

Component.registerComponent('SubtitlesButton', SubtitlesButton);

/**
 * @file caption-settings-menu-item.js
 */
/**
 * The menu item for caption track settings menu
 *
 * @extends TextTrackMenuItem
 */

var CaptionSettingsMenuItem = function (_TextTrackMenuItem) {
  inherits(CaptionSettingsMenuItem, _TextTrackMenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function CaptionSettingsMenuItem(player, options) {
    classCallCheck(this, CaptionSettingsMenuItem);

    options.track = {
      player: player,
      kind: options.kind,
      label: options.kind + ' settings',
      selectable: false,
      'default': false,
      mode: 'disabled'
    };

    // CaptionSettingsMenuItem has no concept of 'selected'
    options.selectable = false;

    options.name = 'CaptionSettingsMenuItem';

    var _this = possibleConstructorReturn(this, _TextTrackMenuItem.call(this, player, options));

    _this.addClass('vjs-texttrack-settings');
    _this.controlText(', opens ' + options.kind + ' settings dialog');
    return _this;
  }

  /**
   * This gets called when an `CaptionSettingsMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  CaptionSettingsMenuItem.prototype.handleClick = function handleClick(event) {
    this.player().getChild('textTrackSettings').open();
  };

  return CaptionSettingsMenuItem;
}(TextTrackMenuItem);

Component.registerComponent('CaptionSettingsMenuItem', CaptionSettingsMenuItem);

/**
 * @file captions-button.js
 */
/**
 * The button component for toggling and selecting captions
 *
 * @extends TextTrackButton
 */

var CaptionsButton = function (_TextTrackButton) {
  inherits(CaptionsButton, _TextTrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} [ready]
   *        The function to call when this component is ready.
   */
  function CaptionsButton(player, options, ready) {
    classCallCheck(this, CaptionsButton);
    return possibleConstructorReturn(this, _TextTrackButton.call(this, player, options, ready));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  CaptionsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  CaptionsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-captions-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create caption menu items
   *
   * @return {CaptionSettingsMenuItem[]}
   *         The array of current menu items.
   */


  CaptionsButton.prototype.createItems = function createItems() {
    var items = [];

    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks)) {
      items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.kind_ }));

      this.hideThreshold_ += 1;
    }

    return _TextTrackButton.prototype.createItems.call(this, items);
  };

  return CaptionsButton;
}(TextTrackButton);

/**
 * `kind` of TextTrack to look for to associate it with this menu.
 *
 * @type {string}
 * @private
 */


CaptionsButton.prototype.kind_ = 'captions';

/**
 * The text that should display over the `CaptionsButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */
CaptionsButton.prototype.controlText_ = 'Captions';

Component.registerComponent('CaptionsButton', CaptionsButton);

/**
 * @file subs-caps-menu-item.js
 */
/**
 * SubsCapsMenuItem has an [cc] icon to distinguish captions from subtitles
 * in the SubsCapsMenu.
 *
 * @extends TextTrackMenuItem
 */

var SubsCapsMenuItem = function (_TextTrackMenuItem) {
  inherits(SubsCapsMenuItem, _TextTrackMenuItem);

  function SubsCapsMenuItem() {
    classCallCheck(this, SubsCapsMenuItem);
    return possibleConstructorReturn(this, _TextTrackMenuItem.apply(this, arguments));
  }

  SubsCapsMenuItem.prototype.createEl = function createEl(type, props, attrs) {
    var innerHTML = '<span class="vjs-menu-item-text">' + this.localize(this.options_.label);

    if (this.options_.track.kind === 'captions') {
      innerHTML += '\n        <span aria-hidden="true" class="vjs-icon-placeholder"></span>\n        <span class="vjs-control-text"> ' + this.localize('Captions') + '</span>\n      ';
    }

    innerHTML += '</span>';

    var el = _TextTrackMenuItem.prototype.createEl.call(this, type, assign({
      innerHTML: innerHTML
    }, props), attrs);

    return el;
  };

  return SubsCapsMenuItem;
}(TextTrackMenuItem);

Component.registerComponent('SubsCapsMenuItem', SubsCapsMenuItem);

/**
 * @file sub-caps-button.js
 */
/**
 * The button component for toggling and selecting captions and/or subtitles
 *
 * @extends TextTrackButton
 */

var SubsCapsButton = function (_TextTrackButton) {
  inherits(SubsCapsButton, _TextTrackButton);

  function SubsCapsButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, SubsCapsButton);

    // Although North America uses "captions" in most cases for
    // "captions and subtitles" other locales use "subtitles"
    var _this = possibleConstructorReturn(this, _TextTrackButton.call(this, player, options));

    _this.label_ = 'subtitles';
    if (['en', 'en-us', 'en-ca', 'fr-ca'].indexOf(_this.player_.language_) > -1) {
      _this.label_ = 'captions';
    }
    _this.menuButton_.controlText(toTitleCase(_this.label_));
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  SubsCapsButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-subs-caps-button ' + _TextTrackButton.prototype.buildCSSClass.call(this);
  };

  SubsCapsButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-subs-caps-button ' + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create caption/subtitles menu items
   *
   * @return {CaptionSettingsMenuItem[]}
   *         The array of current menu items.
   */


  SubsCapsButton.prototype.createItems = function createItems() {
    var items = [];

    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks)) {
      items.push(new CaptionSettingsMenuItem(this.player_, { kind: this.label_ }));

      this.hideThreshold_ += 1;
    }

    items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);
    return items;
  };

  return SubsCapsButton;
}(TextTrackButton);

/**
 * `kind`s of TextTrack to look for to associate it with this menu.
 *
 * @type {array}
 * @private
 */


SubsCapsButton.prototype.kinds_ = ['captions', 'subtitles'];

/**
 * The text that should display over the `SubsCapsButton`s controls.
 *
 *
 * @type {string}
 * @private
 */
SubsCapsButton.prototype.controlText_ = 'Subtitles';

Component.registerComponent('SubsCapsButton', SubsCapsButton);

/**
 * @file audio-track-menu-item.js
 */
/**
 * An {@link AudioTrack} {@link MenuItem}
 *
 * @extends MenuItem
 */

var AudioTrackMenuItem = function (_MenuItem) {
  inherits(AudioTrackMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function AudioTrackMenuItem(player, options) {
    classCallCheck(this, AudioTrackMenuItem);

    var track = options.track;
    var tracks = player.audioTracks();

    // Modify options for parent MenuItem class's init.
    options.label = track.label || track.language || 'Unknown';
    options.selected = track.enabled;

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.track = track;

    var changeHandler = bind(_this, _this.handleTracksChange);

    tracks.addEventListener('change', changeHandler);
    _this.on('dispose', function () {
      tracks.removeEventListener('change', changeHandler);
    });
    return _this;
  }

  /**
   * This gets called when an `AudioTrackMenuItem is "clicked". See {@link ClickableComponent}
   * for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  AudioTrackMenuItem.prototype.handleClick = function handleClick(event) {
    var tracks = this.player_.audioTracks();

    _MenuItem.prototype.handleClick.call(this, event);

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      track.enabled = track === this.track;
    }
  };

  /**
   * Handle any {@link AudioTrack} change.
   *
   * @param {EventTarget~Event} [event]
   *        The {@link AudioTrackList#change} event that caused this to run.
   *
   * @listens AudioTrackList#change
   */


  AudioTrackMenuItem.prototype.handleTracksChange = function handleTracksChange(event) {
    this.selected(this.track.enabled);
  };

  return AudioTrackMenuItem;
}(MenuItem);

Component.registerComponent('AudioTrackMenuItem', AudioTrackMenuItem);

/**
 * @file audio-track-button.js
 */
/**
 * The base class for buttons that toggle specific {@link AudioTrack} types.
 *
 * @extends TrackButton
 */

var AudioTrackButton = function (_TrackButton) {
  inherits(AudioTrackButton, _TrackButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options={}]
   *        The key/value store of player options.
   */
  function AudioTrackButton(player) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, AudioTrackButton);

    options.tracks = player.audioTracks();

    return possibleConstructorReturn(this, _TrackButton.call(this, player, options));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  AudioTrackButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-audio-button ' + _TrackButton.prototype.buildCSSClass.call(this);
  };

  AudioTrackButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-audio-button ' + _TrackButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create a menu item for each audio track
   *
   * @param {AudioTrackMenuItem[]} [items=[]]
   *        An array of existing menu items to use.
   *
   * @return {AudioTrackMenuItem[]}
   *         An array of menu items
   */


  AudioTrackButton.prototype.createItems = function createItems() {
    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    // if there's only one audio track, there no point in showing it
    this.hideThreshold_ = 1;

    var tracks = this.player_.audioTracks();

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      items.push(new AudioTrackMenuItem(this.player_, {
        track: track,
        // MenuItem is selectable
        selectable: true
      }));
    }

    return items;
  };

  return AudioTrackButton;
}(TrackButton);

/**
 * The text that should display over the `AudioTrackButton`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


AudioTrackButton.prototype.controlText_ = 'Audio Track';
Component.registerComponent('AudioTrackButton', AudioTrackButton);

/**
 * @file playback-rate-menu-item.js
 */
/**
 * The specific menu item type for selecting a playback rate.
 *
 * @extends MenuItem
 */

var PlaybackRateMenuItem = function (_MenuItem) {
  inherits(PlaybackRateMenuItem, _MenuItem);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PlaybackRateMenuItem(player, options) {
    classCallCheck(this, PlaybackRateMenuItem);

    var label = options.rate;
    var rate = parseFloat(label, 10);

    // Modify options for parent MenuItem class's init.
    options.label = label;
    options.selected = rate === 1;
    options.selectable = true;

    var _this = possibleConstructorReturn(this, _MenuItem.call(this, player, options));

    _this.label = label;
    _this.rate = rate;

    _this.on(player, 'ratechange', _this.update);
    return _this;
  }

  /**
   * This gets called when an `PlaybackRateMenuItem` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  PlaybackRateMenuItem.prototype.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this);
    this.player().playbackRate(this.rate);
  };

  /**
   * Update the PlaybackRateMenuItem when the playbackrate changes.
   *
   * @param {EventTarget~Event} [event]
   *        The `ratechange` event that caused this function to run.
   *
   * @listens Player#ratechange
   */


  PlaybackRateMenuItem.prototype.update = function update(event) {
    this.selected(this.player().playbackRate() === this.rate);
  };

  return PlaybackRateMenuItem;
}(MenuItem);

/**
 * The text that should display over the `PlaybackRateMenuItem`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


PlaybackRateMenuItem.prototype.contentElType = 'button';

Component.registerComponent('PlaybackRateMenuItem', PlaybackRateMenuItem);

/**
 * @file playback-rate-menu-button.js
 */
/**
 * The component for controlling the playback rate.
 *
 * @extends MenuButton
 */

var PlaybackRateMenuButton = function (_MenuButton) {
  inherits(PlaybackRateMenuButton, _MenuButton);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *        The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   */
  function PlaybackRateMenuButton(player, options) {
    classCallCheck(this, PlaybackRateMenuButton);

    var _this = possibleConstructorReturn(this, _MenuButton.call(this, player, options));

    _this.updateVisibility();
    _this.updateLabel();

    _this.on(player, 'loadstart', _this.updateVisibility);
    _this.on(player, 'ratechange', _this.updateLabel);
    return _this;
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  PlaybackRateMenuButton.prototype.createEl = function createEl$$1() {
    var el = _MenuButton.prototype.createEl.call(this);

    this.labelEl_ = createEl('div', {
      className: 'vjs-playback-rate-value',
      innerHTML: '1x'
    });

    el.appendChild(this.labelEl_);

    return el;
  };

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */


  PlaybackRateMenuButton.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-playback-rate ' + _MenuButton.prototype.buildCSSClass.call(this);
  };

  PlaybackRateMenuButton.prototype.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return 'vjs-playback-rate ' + _MenuButton.prototype.buildWrapperCSSClass.call(this);
  };

  /**
   * Create the playback rate menu
   *
   * @return {Menu}
   *         Menu object populated with {@link PlaybackRateMenuItem}s
   */


  PlaybackRateMenuButton.prototype.createMenu = function createMenu() {
    var menu = new Menu(this.player());
    var rates = this.playbackRates();

    if (rates) {
      for (var i = rates.length - 1; i >= 0; i--) {
        menu.addChild(new PlaybackRateMenuItem(this.player(), { rate: rates[i] + 'x' }));
      }
    }

    return menu;
  };

  /**
   * Updates ARIA accessibility attributes
   */


  PlaybackRateMenuButton.prototype.updateARIAAttributes = function updateARIAAttributes() {
    // Current playback rate
    this.el().setAttribute('aria-valuenow', this.player().playbackRate());
  };

  /**
   * This gets called when an `PlaybackRateMenuButton` is "clicked". See
   * {@link ClickableComponent} for more detailed information on what a click can be.
   *
   * @param {EventTarget~Event} [event]
   *        The `keydown`, `tap`, or `click` event that caused this function to be
   *        called.
   *
   * @listens tap
   * @listens click
   */


  PlaybackRateMenuButton.prototype.handleClick = function handleClick(event) {
    // select next rate option
    var currentRate = this.player().playbackRate();
    var rates = this.playbackRates();

    // this will select first one if the last one currently selected
    var newRate = rates[0];

    for (var i = 0; i < rates.length; i++) {
      if (rates[i] > currentRate) {
        newRate = rates[i];
        break;
      }
    }
    this.player().playbackRate(newRate);
  };

  /**
   * Get possible playback rates
   *
   * @return {Array}
   *         All possible playback rates
   */


  PlaybackRateMenuButton.prototype.playbackRates = function playbackRates() {
    return this.options_.playbackRates || this.options_.playerOptions && this.options_.playerOptions.playbackRates;
  };

  /**
   * Get whether playback rates is supported by the tech
   * and an array of playback rates exists
   *
   * @return {boolean}
   *         Whether changing playback rate is supported
   */


  PlaybackRateMenuButton.prototype.playbackRateSupported = function playbackRateSupported() {
    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
  };

  /**
   * Hide playback rate controls when they're no playback rate options to select
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#loadstart
   */


  PlaybackRateMenuButton.prototype.updateVisibility = function updateVisibility(event) {
    if (this.playbackRateSupported()) {
      this.removeClass('vjs-hidden');
    } else {
      this.addClass('vjs-hidden');
    }
  };

  /**
   * Update button label when rate changed
   *
   * @param {EventTarget~Event} [event]
   *        The event that caused this function to run.
   *
   * @listens Player#ratechange
   */


  PlaybackRateMenuButton.prototype.updateLabel = function updateLabel(event) {
    if (this.playbackRateSupported()) {
      this.labelEl_.innerHTML = this.player().playbackRate() + 'x';
    }
  };

  return PlaybackRateMenuButton;
}(MenuButton);

/**
 * The text that should display over the `FullscreenToggle`s controls. Added for localization.
 *
 * @type {string}
 * @private
 */


PlaybackRateMenuButton.prototype.controlText_ = 'Playback Rate';

Component.registerComponent('PlaybackRateMenuButton', PlaybackRateMenuButton);

/**
 * @file spacer.js
 */
/**
 * Just an empty spacer element that can be used as an append point for plugins, etc.
 * Also can be used to create space between elements when necessary.
 *
 * @extends Component
 */

var Spacer = function (_Component) {
  inherits(Spacer, _Component);

  function Spacer() {
    classCallCheck(this, Spacer);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  Spacer.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-spacer ' + _Component.prototype.buildCSSClass.call(this);
  };

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  Spacer.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: this.buildCSSClass()
    });
  };

  return Spacer;
}(Component);

Component.registerComponent('Spacer', Spacer);

/**
 * @file custom-control-spacer.js
 */
/**
 * Spacer specifically meant to be used as an insertion point for new plugins, etc.
 *
 * @extends Spacer
 */

var CustomControlSpacer = function (_Spacer) {
  inherits(CustomControlSpacer, _Spacer);

  function CustomControlSpacer() {
    classCallCheck(this, CustomControlSpacer);
    return possibleConstructorReturn(this, _Spacer.apply(this, arguments));
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   */
  CustomControlSpacer.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-custom-control-spacer ' + _Spacer.prototype.buildCSSClass.call(this);
  };

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */


  CustomControlSpacer.prototype.createEl = function createEl() {
    var el = _Spacer.prototype.createEl.call(this, {
      className: this.buildCSSClass()
    });

    // No-flex/table-cell mode requires there be some content
    // in the cell to fill the remaining space of the table.
    el.innerHTML = '&nbsp;';
    return el;
  };

  return CustomControlSpacer;
}(Spacer);

Component.registerComponent('CustomControlSpacer', CustomControlSpacer);

/**
 * @file control-bar.js
 */
// Required children
/**
 * Container of main controls.
 *
 * @extends Component
 */

var ControlBar = function (_Component) {
  inherits(ControlBar, _Component);

  function ControlBar() {
    classCallCheck(this, ControlBar);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  /**
   * Create the `Component`'s DOM element
   *
   * @return {Element}
   *         The element that was created.
   */
  ControlBar.prototype.createEl = function createEl() {
    return _Component.prototype.createEl.call(this, 'div', {
      className: 'vjs-control-bar',
      dir: 'ltr'
    }, {
      // The control bar is a group, but we don't aria-label it to avoid
      //  over-announcing by JAWS
      role: 'group'
    });
  };

  return ControlBar;
}(Component);

/**
 * Default options for `ControlBar`
 *
 * @type {Object}
 * @private
 */


ControlBar.prototype.options_ = {
  children: ['playToggle', 'volumePanel', 'currentTimeDisplay', 'timeDivider', 'durationDisplay', 'progressControl', 'liveDisplay', 'remainingTimeDisplay', 'customControlSpacer', 'playbackRateMenuButton', 'chaptersButton', 'descriptionsButton', 'subsCapsButton', 'audioTrackButton', 'fullscreenToggle']
};

Component.registerComponent('ControlBar', ControlBar);

/**
 * @file error-display.js
 */
/**
 * A display that indicates an error has occurred. This means that the video
 * is unplayable.
 *
 * @extends ModalDialog
 */

var ErrorDisplay = function (_ModalDialog) {
  inherits(ErrorDisplay, _ModalDialog);

  /**
   * Creates an instance of this class.
   *
   * @param  {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param  {Object} [options]
   *         The key/value store of player options.
   */
  function ErrorDisplay(player, options) {
    classCallCheck(this, ErrorDisplay);

    var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));

    _this.on(player, 'error', _this.open);
    return _this;
  }

  /**
   * Builds the default DOM `className`.
   *
   * @return {string}
   *         The DOM `className` for this object.
   *
   * @deprecated Since version 5.
   */


  ErrorDisplay.prototype.buildCSSClass = function buildCSSClass() {
    return 'vjs-error-display ' + _ModalDialog.prototype.buildCSSClass.call(this);
  };

  /**
   * Gets the localized error message based on the `Player`s error.
   *
   * @return {string}
   *         The `Player`s error message localized or an empty string.
   */


  ErrorDisplay.prototype.content = function content() {
    var error = this.player().error();

    return error ? this.localize(error.message) : '';
  };

  return ErrorDisplay;
}(ModalDialog);

/**
 * The default options for an `ErrorDisplay`.
 *
 * @private
 */


ErrorDisplay.prototype.options_ = mergeOptions(ModalDialog.prototype.options_, {
  pauseOnOpen: false,
  fillAlways: true,
  temporary: false,
  uncloseable: true
});

Component.registerComponent('ErrorDisplay', ErrorDisplay);

/**
 * @file text-track-settings.js
 */
var LOCAL_STORAGE_KEY = 'vjs-text-track-settings';

var COLOR_BLACK = ['#000', 'Black'];
var COLOR_BLUE = ['#00F', 'Blue'];
var COLOR_CYAN = ['#0FF', 'Cyan'];
var COLOR_GREEN = ['#0F0', 'Green'];
var COLOR_MAGENTA = ['#F0F', 'Magenta'];
var COLOR_RED = ['#F00', 'Red'];
var COLOR_WHITE = ['#FFF', 'White'];
var COLOR_YELLOW = ['#FF0', 'Yellow'];

var OPACITY_OPAQUE = ['1', 'Opaque'];
var OPACITY_SEMI = ['0.5', 'Semi-Transparent'];
var OPACITY_TRANS = ['0', 'Transparent'];

// Configuration for the various <select> elements in the DOM of this component.
//
// Possible keys include:
//
// `default`:
//   The default option index. Only needs to be provided if not zero.
// `parser`:
//   A function which is used to parse the value from the selected option in
//   a customized way.
// `selector`:
//   The selector used to find the associated <select> element.
var selectConfigs = {
  backgroundColor: {
    selector: '.vjs-bg-color > select',
    id: 'captions-background-color-%s',
    label: 'Color',
    options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
  },

  backgroundOpacity: {
    selector: '.vjs-bg-opacity > select',
    id: 'captions-background-opacity-%s',
    label: 'Transparency',
    options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]
  },

  color: {
    selector: '.vjs-fg-color > select',
    id: 'captions-foreground-color-%s',
    label: 'Color',
    options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
  },

  edgeStyle: {
    selector: '.vjs-edge-style > select',
    id: '%s',
    label: 'Text Edge Style',
    options: [['none', 'None'], ['raised', 'Raised'], ['depressed', 'Depressed'], ['uniform', 'Uniform'], ['dropshadow', 'Dropshadow']]
  },

  fontFamily: {
    selector: '.vjs-font-family > select',
    id: 'captions-font-family-%s',
    label: 'Font Family',
    options: [['proportionalSansSerif', 'Proportional Sans-Serif'], ['monospaceSansSerif', 'Monospace Sans-Serif'], ['proportionalSerif', 'Proportional Serif'], ['monospaceSerif', 'Monospace Serif'], ['casual', 'Casual'], ['script', 'Script'], ['small-caps', 'Small Caps']]
  },

  fontPercent: {
    selector: '.vjs-font-percent > select',
    id: 'captions-font-size-%s',
    label: 'Font Size',
    options: [['0.50', '50%'], ['0.75', '75%'], ['1.00', '100%'], ['1.25', '125%'], ['1.50', '150%'], ['1.75', '175%'], ['2.00', '200%'], ['3.00', '300%'], ['4.00', '400%']],
    'default': 2,
    parser: function parser(v) {
      return v === '1.00' ? null : Number(v);
    }
  },

  textOpacity: {
    selector: '.vjs-text-opacity > select',
    id: 'captions-foreground-opacity-%s',
    label: 'Transparency',
    options: [OPACITY_OPAQUE, OPACITY_SEMI]
  },

  // Options for this object are defined below.
  windowColor: {
    selector: '.vjs-window-color > select',
    id: 'captions-window-color-%s',
    label: 'Color'
  },

  // Options for this object are defined below.
  windowOpacity: {
    selector: '.vjs-window-opacity > select',
    id: 'captions-window-opacity-%s',
    label: 'Transparency',
    options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]
  }
};

selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;

/**
 * Get the actual value of an option.
 *
 * @param  {string} value
 *         The value to get
 *
 * @param  {Function} [parser]
 *         Optional function to adjust the value.
 *
 * @return {Mixed}
 *         - Will be `undefined` if no value exists
 *         - Will be `undefined` if the given value is "none".
 *         - Will be the actual value otherwise.
 *
 * @private
 */
function parseOptionValue(value, parser) {
  if (parser) {
    value = parser(value);
  }

  if (value && value !== 'none') {
    return value;
  }
}

/**
 * Gets the value of the selected <option> element within a <select> element.
 *
 * @param  {Element} el
 *         the element to look in
 *
 * @param  {Function} [parser]
 *         Optional function to adjust the value.
 *
 * @return {Mixed}
 *         - Will be `undefined` if no value exists
 *         - Will be `undefined` if the given value is "none".
 *         - Will be the actual value otherwise.
 *
 * @private
 */
function getSelectedOptionValue(el, parser) {
  var value = el.options[el.options.selectedIndex].value;

  return parseOptionValue(value, parser);
}

/**
 * Sets the selected <option> element within a <select> element based on a
 * given value.
 *
 * @param {Element} el
 *        The element to look in.
 *
 * @param {string} value
 *        the property to look on.
 *
 * @param {Function} [parser]
 *        Optional function to adjust the value before comparing.
 *
 * @private
 */
function setSelectedOption(el, value, parser) {
  if (!value) {
    return;
  }

  for (var i = 0; i < el.options.length; i++) {
    if (parseOptionValue(el.options[i].value, parser) === value) {
      el.selectedIndex = i;
      break;
    }
  }
}

/**
 * Manipulate Text Tracks settings.
 *
 * @extends ModalDialog
 */

var TextTrackSettings = function (_ModalDialog) {
  inherits(TextTrackSettings, _ModalDialog);

  /**
   * Creates an instance of this class.
   *
   * @param {Player} player
   *         The `Player` that this class should be attached to.
   *
   * @param {Object} [options]
   *         The key/value store of player options.
   */
  function TextTrackSettings(player, options) {
    classCallCheck(this, TextTrackSettings);

    options.temporary = false;

    var _this = possibleConstructorReturn(this, _ModalDialog.call(this, player, options));

    _this.updateDisplay = bind(_this, _this.updateDisplay);

    // fill the modal and pretend we have opened it
    _this.fill();
    _this.hasBeenOpened_ = _this.hasBeenFilled_ = true;

    _this.endDialog = createEl('p', {
      className: 'vjs-control-text',
      textContent: _this.localize('End of dialog window.')
    });
    _this.el().appendChild(_this.endDialog);

    _this.setDefaults();

    // Grab `persistTextTrackSettings` from the player options if not passed in child options
    if (options.persistTextTrackSettings === undefined) {
      _this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings;
    }

    _this.on(_this.$('.vjs-done-button'), 'click', function () {
      _this.saveSettings();
      _this.close();
    });

    _this.on(_this.$('.vjs-default-button'), 'click', function () {
      _this.setDefaults();
      _this.updateDisplay();
    });

    each(selectConfigs, function (config) {
      _this.on(_this.$(config.selector), 'change', _this.updateDisplay);
    });

    if (_this.options_.persistTextTrackSettings) {
      _this.restoreSettings();
    }
    return _this;
  }

  /**
   * Create a <select> element with configured options.
   *
   * @param {string} key
   *        Configuration key to use during creation.
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElSelect_ = function createElSelect_(key) {
    var _this2 = this;

    var legendId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'label';

    var config = selectConfigs[key];
    var id = config.id.replace('%s', this.id_);

    return ['<' + type + ' id="' + id + '" class="' + (type === 'label' ? 'vjs-label' : '') + '">', this.localize(config.label), '</' + type + '>', '<select aria-labelledby="' + legendId + ' ' + id + '">'].concat(config.options.map(function (o) {
      var optionId = id + '-' + o[1];

      return ['<option id="' + optionId + '" value="' + o[0] + '" ', 'aria-labelledby="' + legendId + ' ' + id + ' ' + optionId + '">', _this2.localize(o[1]), '</option>'].join('');
    })).concat('</select>').join('');
  };

  /**
   * Create foreground color element for the component
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElFgColor_ = function createElFgColor_() {
    var legendId = 'captions-text-legend-' + this.id_;

    return ['<fieldset class="vjs-fg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize('Text'), '</legend>', this.createElSelect_('color', legendId), '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_('textOpacity', legendId), '</span>', '</fieldset>'].join('');
  };

  /**
   * Create background color element for the component
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElBgColor_ = function createElBgColor_() {
    var legendId = 'captions-background-' + this.id_;

    return ['<fieldset class="vjs-bg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize('Background'), '</legend>', this.createElSelect_('backgroundColor', legendId), '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_('backgroundOpacity', legendId), '</span>', '</fieldset>'].join('');
  };

  /**
   * Create window color element for the component
   *
   * @return {string}
   *         An HTML string.
   *
   * @private
   */


  TextTrackSettings.prototype.createElWinColor_ = function createElWinColor_() {
    var legendId = 'captions-window-' + this.id_;

    return ['<fieldset class="vjs-window-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize('Window'), '</legend>', this.createElSelect_('windowColor', legendId), '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_('windowOpacity', legendId), '</span>', '</fieldset>'].join('');
  };

  /**
   * Create color elements for the component
   *
   * @return {Element}
   *         The element that was created
   *
   * @private
   */


  TextTrackSettings.prototype.createElColors_ = function createElColors_() {
    return createEl('div', {
      className: 'vjs-track-settings-colors',
      innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join('')
    });
  };

  /**
   * Create font elements for the component
   *
   * @return {Element}
   *         The element that was created.
   *
   * @private
   */


  TextTrackSettings.prototype.createElFont_ = function createElFont_() {
    return createEl('div', {
      className: 'vjs-track-settings-font">',
      innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_('fontPercent', '', 'legend'), '</fieldset>', '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_('edgeStyle', '', 'legend'), '</fieldset>', '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_('fontFamily', '', 'legend'), '</fieldset>'].join('')
    });
  };

  /**
   * Create controls for the component
   *
   * @return {Element}
   *         The element that was created.
   *
   * @private
   */


  TextTrackSettings.prototype.createElControls_ = function createElControls_() {
    var defaultsDescription = this.localize('restore all settings to the default values');

    return createEl('div', {
      className: 'vjs-track-settings-controls',
      innerHTML: ['<button class="vjs-default-button" title="' + defaultsDescription + '">', this.localize('Reset'), '<span class="vjs-control-text"> ' + defaultsDescription + '</span>', '</button>', '<button class="vjs-done-button">' + this.localize('Done') + '</button>'].join('')
    });
  };

  TextTrackSettings.prototype.content = function content() {
    return [this.createElColors_(), this.createElFont_(), this.createElControls_()];
  };

  TextTrackSettings.prototype.label = function label() {
    return this.localize('Caption Settings Dialog');
  };

  TextTrackSettings.prototype.description = function description() {
    return this.localize('Beginning of dialog window. Escape will cancel and close the window.');
  };

  TextTrackSettings.prototype.buildCSSClass = function buildCSSClass() {
    return _ModalDialog.prototype.buildCSSClass.call(this) + ' vjs-text-track-settings';
  };

  /**
   * Gets an object of text track settings (or null).
   *
   * @return {Object}
   *         An object with config values parsed from the DOM or localStorage.
   */


  TextTrackSettings.prototype.getValues = function getValues() {
    var _this3 = this;

    return reduce(selectConfigs, function (accum, config, key) {
      var value = getSelectedOptionValue(_this3.$(config.selector), config.parser);

      if (value !== undefined) {
        accum[key] = value;
      }

      return accum;
    }, {});
  };

  /**
   * Sets text track settings from an object of values.
   *
   * @param {Object} values
   *        An object with config values parsed from the DOM or localStorage.
   */


  TextTrackSettings.prototype.setValues = function setValues(values) {
    var _this4 = this;

    each(selectConfigs, function (config, key) {
      setSelectedOption(_this4.$(config.selector), values[key], config.parser);
    });
  };

  /**
   * Sets all `<select>` elements to their default values.
   */


  TextTrackSettings.prototype.setDefaults = function setDefaults() {
    var _this5 = this;

    each(selectConfigs, function (config) {
      var index = config.hasOwnProperty('default') ? config['default'] : 0;

      _this5.$(config.selector).selectedIndex = index;
    });
  };

  /**
   * Restore texttrack settings from localStorage
   */


  TextTrackSettings.prototype.restoreSettings = function restoreSettings() {
    var values = void 0;

    try {
      values = JSON.parse(window_1.localStorage.getItem(LOCAL_STORAGE_KEY));
    } catch (err) {
      log$1.warn(err);
    }

    if (values) {
      this.setValues(values);
    }
  };

  /**
   * Save text track settings to localStorage
   */


  TextTrackSettings.prototype.saveSettings = function saveSettings() {
    if (!this.options_.persistTextTrackSettings) {
      return;
    }

    var values = this.getValues();

    try {
      if (Object.keys(values).length) {
        window_1.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(values));
      } else {
        window_1.localStorage.removeItem(LOCAL_STORAGE_KEY);
      }
    } catch (err) {
      log$1.warn(err);
    }
  };

  /**
   * Update display of text track settings
   */


  TextTrackSettings.prototype.updateDisplay = function updateDisplay() {
    var ttDisplay = this.player_.getChild('textTrackDisplay');

    if (ttDisplay) {
      ttDisplay.updateDisplay();
    }
  };

  /**
   * conditionally blur the element and refocus the captions button
   *
   * @private
   */


  TextTrackSettings.prototype.conditionalBlur_ = function conditionalBlur_() {
    this.previouslyActiveEl_ = null;
    this.off(document_1, 'keydown', this.handleKeyDown);

    var cb = this.player_.controlBar;
    var subsCapsBtn = cb && cb.subsCapsButton;
    var ccBtn = cb && cb.captionsButton;

    if (subsCapsBtn) {
      subsCapsBtn.focus();
    } else if (ccBtn) {
      ccBtn.focus();
    }
  };

  return TextTrackSettings;
}(ModalDialog);

Component.registerComponent('TextTrackSettings', TextTrackSettings);

var _templateObject$2 = taggedTemplateLiteralLoose(['Text Tracks are being loaded from another origin but the crossorigin attribute isn\'t used.\n            This may prevent text tracks from loading.'], ['Text Tracks are being loaded from another origin but the crossorigin attribute isn\'t used.\n            This may prevent text tracks from loading.']);

/**
 * @file html5.js
 */
/**
 * HTML5 Media Controller - Wrapper for HTML5 Media API
 *
 * @mixes Tech~SouceHandlerAdditions
 * @extends Tech
 */

var Html5 = function (_Tech) {
  inherits(Html5, _Tech);

  /**
   * Create an instance of this Tech.
   *
   * @param {Object} [options]
   *        The key/value store of player options.
   *
   * @param {Component~ReadyCallback} ready
   *        Callback function to call when the `HTML5` Tech is ready.
   */
  function Html5(options, ready) {
    classCallCheck(this, Html5);

    var _this = possibleConstructorReturn(this, _Tech.call(this, options, ready));

    var source = options.source;
    var crossoriginTracks = false;

    // Set the source if one is provided
    // 1) Check if the source is new (if not, we want to keep the original so playback isn't interrupted)
    // 2) Check to see if the network state of the tag was failed at init, and if so, reset the source
    // anyway so the error gets fired.
    if (source && (_this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
      _this.setSource(source);
    } else {
      _this.handleLateInit_(_this.el_);
    }

    if (_this.el_.hasChildNodes()) {

      var nodes = _this.el_.childNodes;
      var nodesLength = nodes.length;
      var removeNodes = [];

      while (nodesLength--) {
        var node = nodes[nodesLength];
        var nodeName = node.nodeName.toLowerCase();

        if (nodeName === 'track') {
          if (!_this.featuresNativeTextTracks) {
            // Empty video tag tracks so the built-in player doesn't use them also.
            // This may not be fast enough to stop HTML5 browsers from reading the tags
            // so we'll need to turn off any default tracks if we're manually doing
            // captions and subtitles. videoElement.textTracks
            removeNodes.push(node);
          } else {
            // store HTMLTrackElement and TextTrack to remote list
            _this.remoteTextTrackEls().addTrackElement_(node);
            _this.remoteTextTracks().addTrack(node.track);
            _this.textTracks().addTrack(node.track);
            if (!crossoriginTracks && !_this.el_.hasAttribute('crossorigin') && isCrossOrigin(node.src)) {
              crossoriginTracks = true;
            }
          }
        }
      }

      for (var i = 0; i < removeNodes.length; i++) {
        _this.el_.removeChild(removeNodes[i]);
      }
    }

    _this.proxyNativeTracks_();
    if (_this.featuresNativeTextTracks && crossoriginTracks) {
      log$1.warn(tsml(_templateObject$2));
    }

    // prevent iOS Safari from disabling metadata text tracks during native playback
    _this.restoreMetadataTracksInIOSNativePlayer_();

    // Determine if native controls should be used
    // Our goal should be to get the custom controls on mobile solid everywhere
    // so we can remove this all together. Right now this will block custom
    // controls on touch enabled laptops like the Chrome Pixel
    if ((TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {
      _this.setControls(true);
    }

    // on iOS, we want to proxy `webkitbeginfullscreen` and `webkitendfullscreen`
    // into a `fullscreenchange` event
    _this.proxyWebkitFullscreen_();

    _this.triggerReady();
    return _this;
  }

  /**
   * Dispose of `HTML5` media element and remove all tracks.
   */


  Html5.prototype.dispose = function dispose() {
    Html5.disposeMediaElement(this.el_);
    // tech will handle clearing of the emulated track list
    _Tech.prototype.dispose.call(this);
  };

  /**
   * When a captions track is enabled in the iOS Safari native player, all other
   * tracks are disabled (including metadata tracks), which nulls all of their
   * associated cue points. This will restore metadata tracks to their pre-fullscreen
   * state in those cases so that cue points are not needlessly lost.
   *
   * @private
   */


  Html5.prototype.restoreMetadataTracksInIOSNativePlayer_ = function restoreMetadataTracksInIOSNativePlayer_() {
    var textTracks = this.textTracks();
    var metadataTracksPreFullscreenState = void 0;

    // captures a snapshot of every metadata track's current state
    var takeMetadataTrackSnapshot = function takeMetadataTrackSnapshot() {
      metadataTracksPreFullscreenState = [];

      for (var i = 0; i < textTracks.length; i++) {
        var track = textTracks[i];

        if (track.kind === 'metadata') {
          metadataTracksPreFullscreenState.push({
            track: track,
            storedMode: track.mode
          });
        }
      }
    };

    // snapshot each metadata track's initial state, and update the snapshot
    // each time there is a track 'change' event
    takeMetadataTrackSnapshot();
    textTracks.addEventListener('change', takeMetadataTrackSnapshot);

    var restoreTrackMode = function restoreTrackMode() {
      for (var i = 0; i < metadataTracksPreFullscreenState.length; i++) {
        var storedTrack = metadataTracksPreFullscreenState[i];

        if (storedTrack.track.mode === 'disabled' && storedTrack.track.mode !== storedTrack.storedMode) {
          storedTrack.track.mode = storedTrack.storedMode;
        }
      }
      // we only want this handler to be executed on the first 'change' event
      textTracks.removeEventListener('change', restoreTrackMode);
    };

    // when we enter fullscreen playback, stop updating the snapshot and
    // restore all track modes to their pre-fullscreen state
    this.on('webkitbeginfullscreen', function () {
      textTracks.removeEventListener('change', takeMetadataTrackSnapshot);

      // remove the listener before adding it just in case it wasn't previously removed
      textTracks.removeEventListener('change', restoreTrackMode);
      textTracks.addEventListener('change', restoreTrackMode);
    });

    // start updating the snapshot again after leaving fullscreen
    this.on('webkitendfullscreen', function () {
      // remove the listener before adding it just in case it wasn't previously removed
      textTracks.removeEventListener('change', takeMetadataTrackSnapshot);
      textTracks.addEventListener('change', takeMetadataTrackSnapshot);

      // remove the restoreTrackMode handler in case it wasn't triggered during fullscreen playback
      textTracks.removeEventListener('change', restoreTrackMode);
    });
  };

  /**
   * Proxy all native track list events to our track lists if the browser we are playing
   * in supports that type of track list.
   *
   * @private
   */


  Html5.prototype.proxyNativeTracks_ = function proxyNativeTracks_() {
    var _this2 = this;

    NORMAL.names.forEach(function (name) {
      var props = NORMAL[name];
      var elTracks = _this2.el()[props.getterName];
      var techTracks = _this2[props.getterName]();

      if (!_this2['featuresNative' + props.capitalName + 'Tracks'] || !elTracks || !elTracks.addEventListener) {
        return;
      }
      var listeners = {
        change: function change(e) {
          techTracks.trigger({
            type: 'change',
            target: techTracks,
            currentTarget: techTracks,
            srcElement: techTracks
          });
        },
        addtrack: function addtrack(e) {
          techTracks.addTrack(e.track);
        },
        removetrack: function removetrack(e) {
          techTracks.removeTrack(e.track);
        }
      };
      var removeOldTracks = function removeOldTracks() {
        var removeTracks = [];

        for (var i = 0; i < techTracks.length; i++) {
          var found = false;

          for (var j = 0; j < elTracks.length; j++) {
            if (elTracks[j] === techTracks[i]) {
              found = true;
              break;
            }
          }

          if (!found) {
            removeTracks.push(techTracks[i]);
          }
        }

        while (removeTracks.length) {
          techTracks.removeTrack(removeTracks.shift());
        }
      };

      Object.keys(listeners).forEach(function (eventName) {
        var listener = listeners[eventName];

        elTracks.addEventListener(eventName, listener);
        _this2.on('dispose', function (e) {
          return elTracks.removeEventListener(eventName, listener);
        });
      });

      // Remove (native) tracks that are not used anymore
      _this2.on('loadstart', removeOldTracks);
      _this2.on('dispose', function (e) {
        return _this2.off('loadstart', removeOldTracks);
      });
    });
  };

  /**
   * Create the `Html5` Tech's DOM element.
   *
   * @return {Element}
   *         The element that gets created.
   */


  Html5.prototype.createEl = function createEl$$1() {
    var el = this.options_.tag;

    // Check if this browser supports moving the element into the box.
    // On the iPhone video will break if you move the element,
    // So we have to create a brand new element.
    // If we ingested the player div, we do not need to move the media element.
    if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {

      // If the original tag is still there, clone and remove it.
      if (el) {
        var clone = el.cloneNode(true);

        if (el.parentNode) {
          el.parentNode.insertBefore(clone, el);
        }
        Html5.disposeMediaElement(el);
        el = clone;
      } else {
        el = document_1.createElement('video');

        // determine if native controls should be used
        var tagAttributes = this.options_.tag && getAttributes(this.options_.tag);
        var attributes = mergeOptions({}, tagAttributes);

        if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
          delete attributes.controls;
        }

        setAttributes(el, assign(attributes, {
          id: this.options_.techId,
          'class': 'vjs-tech'
        }));
      }

      el.playerId = this.options_.playerId;
    }

    if (typeof this.options_.preload !== 'undefined') {
      setAttribute(el, 'preload', this.options_.preload);
    }

    // Update specific tag settings, in case they were overridden
    // `autoplay` has to be *last* so that `muted` and `playsinline` are present
    // when iOS/Safari or other browsers attempt to autoplay.
    var settingsAttrs = ['loop', 'muted', 'playsinline', 'autoplay'];

    for (var i = settingsAttrs.length - 1; i >= 0; i--) {
      var attr = settingsAttrs[i];
      var value = this.options_[attr];

      if (typeof value !== 'undefined') {
        if (value) {
          setAttribute(el, attr, attr);
        } else {
          removeAttribute(el, attr);
        }
        el[attr] = value;
      }
    }

    return el;
  };

  /**
   * This will be triggered if the loadstart event has already fired, before videojs was
   * ready. Two known examples of when this can happen are:
   * 1. If we're loading the playback object after it has started loading
   * 2. The media is already playing the (often with autoplay on) then
   *
   * This function will fire another loadstart so that videojs can catchup.
   *
   * @fires Tech#loadstart
   *
   * @return {undefined}
   *         returns nothing.
   */


  Html5.prototype.handleLateInit_ = function handleLateInit_(el) {
    if (el.networkState === 0 || el.networkState === 3) {
      // The video element hasn't started loading the source yet
      // or didn't find a source
      return;
    }

    if (el.readyState === 0) {
      // NetworkState is set synchronously BUT loadstart is fired at the
      // end of the current stack, usually before setInterval(fn, 0).
      // So at this point we know loadstart may have already fired or is
      // about to fire, and either way the player hasn't seen it yet.
      // We don't want to fire loadstart prematurely here and cause a
      // double loadstart so we'll wait and see if it happens between now
      // and the next loop, and fire it if not.
      // HOWEVER, we also want to make sure it fires before loadedmetadata
      // which could also happen between now and the next loop, so we'll
      // watch for that also.
      var loadstartFired = false;
      var setLoadstartFired = function setLoadstartFired() {
        loadstartFired = true;
      };

      this.on('loadstart', setLoadstartFired);

      var triggerLoadstart = function triggerLoadstart() {
        // We did miss the original loadstart. Make sure the player
        // sees loadstart before loadedmetadata
        if (!loadstartFired) {
          this.trigger('loadstart');
        }
      };

      this.on('loadedmetadata', triggerLoadstart);

      this.ready(function () {
        this.off('loadstart', setLoadstartFired);
        this.off('loadedmetadata', triggerLoadstart);

        if (!loadstartFired) {
          // We did miss the original native loadstart. Fire it now.
          this.trigger('loadstart');
        }
      });

      return;
    }

    // From here on we know that loadstart already fired and we missed it.
    // The other readyState events aren't as much of a problem if we double
    // them, so not going to go to as much trouble as loadstart to prevent
    // that unless we find reason to.
    var eventsToTrigger = ['loadstart'];

    // loadedmetadata: newly equal to HAVE_METADATA (1) or greater
    eventsToTrigger.push('loadedmetadata');

    // loadeddata: newly increased to HAVE_CURRENT_DATA (2) or greater
    if (el.readyState >= 2) {
      eventsToTrigger.push('loadeddata');
    }

    // canplay: newly increased to HAVE_FUTURE_DATA (3) or greater
    if (el.readyState >= 3) {
      eventsToTrigger.push('canplay');
    }

    // canplaythrough: newly equal to HAVE_ENOUGH_DATA (4)
    if (el.readyState >= 4) {
      eventsToTrigger.push('canplaythrough');
    }

    // We still need to give the player time to add event listeners
    this.ready(function () {
      eventsToTrigger.forEach(function (type) {
        this.trigger(type);
      }, this);
    });
  };

  /**
   * Set current time for the `HTML5` tech.
   *
   * @param {number} seconds
   *        Set the current time of the media to this.
   */


  Html5.prototype.setCurrentTime = function setCurrentTime(seconds) {
    try {
      this.el_.currentTime = seconds;
    } catch (e) {
      log$1(e, 'Video is not ready. (Video.js)');
      // this.warning(VideoJS.warnings.videoNotReady);
    }
  };

  /**
   * Get the current duration of the HTML5 media element.
   *
   * @return {number}
   *         The duration of the media or 0 if there is no duration.
   */


  Html5.prototype.duration = function duration() {
    var _this3 = this;

    // Android Chrome will report duration as Infinity for VOD HLS until after
    // playback has started, which triggers the live display erroneously.
    // Return NaN if playback has not started and trigger a durationupdate once
    // the duration can be reliably known.
    if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {
      // Wait for the first `timeupdate` with currentTime > 0 - there may be
      // several with 0
      var checkProgress = function checkProgress() {
        if (_this3.el_.currentTime > 0) {
          // Trigger durationchange for genuinely live video
          if (_this3.el_.duration === Infinity) {
            _this3.trigger('durationchange');
          }
          _this3.off('timeupdate', checkProgress);
        }
      };

      this.on('timeupdate', checkProgress);
      return NaN;
    }
    return this.el_.duration || NaN;
  };

  /**
   * Get the current width of the HTML5 media element.
   *
   * @return {number}
   *         The width of the HTML5 media element.
   */


  Html5.prototype.width = function width() {
    return this.el_.offsetWidth;
  };

  /**
   * Get the current height of the HTML5 media element.
   *
   * @return {number}
   *         The heigth of the HTML5 media element.
   */


  Html5.prototype.height = function height() {
    return this.el_.offsetHeight;
  };

  /**
   * Proxy iOS `webkitbeginfullscreen` and `webkitendfullscreen` into
   * `fullscreenchange` event.
   *
   * @private
   * @fires fullscreenchange
   * @listens webkitendfullscreen
   * @listens webkitbeginfullscreen
   * @listens webkitbeginfullscreen
   */


  Html5.prototype.proxyWebkitFullscreen_ = function proxyWebkitFullscreen_() {
    var _this4 = this;

    if (!('webkitDisplayingFullscreen' in this.el_)) {
      return;
    }

    var endFn = function endFn() {
      this.trigger('fullscreenchange', { isFullscreen: false });
    };

    var beginFn = function beginFn() {
      if ('webkitPresentationMode' in this.el_ && this.el_.webkitPresentationMode !== 'picture-in-picture') {
        this.one('webkitendfullscreen', endFn);

        this.trigger('fullscreenchange', { isFullscreen: true });
      }
    };

    this.on('webkitbeginfullscreen', beginFn);
    this.on('dispose', function () {
      _this4.off('webkitbeginfullscreen', beginFn);
      _this4.off('webkitendfullscreen', endFn);
    });
  };

  /**
   * Check if fullscreen is supported on the current playback device.
   *
   * @return {boolean}
   *         - True if fullscreen is supported.
   *         - False if fullscreen is not supported.
   */


  Html5.prototype.supportsFullScreen = function supportsFullScreen() {
    if (typeof this.el_.webkitEnterFullScreen === 'function') {
      var userAgent = window_1.navigator && window_1.navigator.userAgent || '';

      // Seems to be broken in Chromium/Chrome && Safari in Leopard
      if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Request that the `HTML5` Tech enter fullscreen.
   */


  Html5.prototype.enterFullScreen = function enterFullScreen() {
    var video = this.el_;

    if (video.paused && video.networkState <= video.HAVE_METADATA) {
      // attempt to prime the video element for programmatic access
      // this isn't necessary on the desktop but shouldn't hurt
      this.el_.play();

      // playing and pausing synchronously during the transition to fullscreen
      // can get iOS ~6.1 devices into a play/pause loop
      this.setTimeout(function () {
        video.pause();
        video.webkitEnterFullScreen();
      }, 0);
    } else {
      video.webkitEnterFullScreen();
    }
  };

  /**
   * Request that the `HTML5` Tech exit fullscreen.
   */


  Html5.prototype.exitFullScreen = function exitFullScreen() {
    this.el_.webkitExitFullScreen();
  };

  /**
   * A getter/setter for the `Html5` Tech's source object.
   * > Note: Please use {@link Html5#setSource}
   *
   * @param {Tech~SourceObject} [src]
   *        The source object you want to set on the `HTML5` techs element.
   *
   * @return {Tech~SourceObject|undefined}
   *         - The current source object when a source is not passed in.
   *         - undefined when setting
   *
   * @deprecated Since version 5.
   */


  Html5.prototype.src = function src(_src) {
    if (_src === undefined) {
      return this.el_.src;
    }

    // Setting src through `src` instead of `setSrc` will be deprecated
    this.setSrc(_src);
  };

  /**
   * Reset the tech by removing all sources and then calling
   * {@link Html5.resetMediaElement}.
   */


  Html5.prototype.reset = function reset() {
    Html5.resetMediaElement(this.el_);
  };

  /**
   * Get the current source on the `HTML5` Tech. Falls back to returning the source from
   * the HTML5 media element.
   *
   * @return {Tech~SourceObject}
   *         The current source object from the HTML5 tech. With a fallback to the
   *         elements source.
   */


  Html5.prototype.currentSrc = function currentSrc() {
    if (this.currentSource_) {
      return this.currentSource_.src;
    }
    return this.el_.currentSrc;
  };

  /**
   * Set controls attribute for the HTML5 media Element.
   *
   * @param {string} val
   *        Value to set the controls attribute to
   */


  Html5.prototype.setControls = function setControls(val) {
    this.el_.controls = !!val;
  };

  /**
   * Create and returns a remote {@link TextTrack} object.
   *
   * @param {string} kind
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata)
   *
   * @param {string} [label]
   *        Label to identify the text track
   *
   * @param {string} [language]
   *        Two letter language abbreviation
   *
   * @return {TextTrack}
   *         The TextTrack that gets created.
   */


  Html5.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (!this.featuresNativeTextTracks) {
      return _Tech.prototype.addTextTrack.call(this, kind, label, language);
    }

    return this.el_.addTextTrack(kind, label, language);
  };

  /**
   * Creates either native TextTrack or an emulated TextTrack depending
   * on the value of `featuresNativeTextTracks`
   *
   * @param {Object} options
   *        The object should contain the options to intialize the TextTrack with.
   *
   * @param {string} [options.kind]
   *        `TextTrack` kind (subtitles, captions, descriptions, chapters, or metadata).
   *
   * @param {string} [options.label].
   *        Label to identify the text track
   *
   * @param {string} [options.language]
   *        Two letter language abbreviation.
   *
   * @param {boolean} [options.default]
   *        Default this track to on.
   *
   * @param {string} [options.id]
   *        The internal id to assign this track.
   *
   * @param {string} [options.src]
   *        A source url for the track.
   *
   * @return {HTMLTrackElement}
   *         The track element that gets created.
   */


  Html5.prototype.createRemoteTextTrack = function createRemoteTextTrack(options) {
    if (!this.featuresNativeTextTracks) {
      return _Tech.prototype.createRemoteTextTrack.call(this, options);
    }
    var htmlTrackElement = document_1.createElement('track');

    if (options.kind) {
      htmlTrackElement.kind = options.kind;
    }
    if (options.label) {
      htmlTrackElement.label = options.label;
    }
    if (options.language || options.srclang) {
      htmlTrackElement.srclang = options.language || options.srclang;
    }
    if (options['default']) {
      htmlTrackElement['default'] = options['default'];
    }
    if (options.id) {
      htmlTrackElement.id = options.id;
    }
    if (options.src) {
      htmlTrackElement.src = options.src;
    }

    return htmlTrackElement;
  };

  /**
   * Creates a remote text track object and returns an html track element.
   *
   * @param {Object} options The object should contain values for
   * kind, language, label, and src (location of the WebVTT file)
   * @param {Boolean} [manualCleanup=true] if set to false, the TextTrack will be
   * automatically removed from the video element whenever the source changes
   * @return {HTMLTrackElement} An Html Track Element.
   * This can be an emulated {@link HTMLTrackElement} or a native one.
   * @deprecated The default value of the "manualCleanup" parameter will default
   * to "false" in upcoming versions of Video.js
   */


  Html5.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);

    if (this.featuresNativeTextTracks) {
      this.el().appendChild(htmlTrackElement);
    }

    return htmlTrackElement;
  };

  /**
   * Remove remote `TextTrack` from `TextTrackList` object
   *
   * @param {TextTrack} track
   *        `TextTrack` object to remove
   */


  Html5.prototype.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    _Tech.prototype.removeRemoteTextTrack.call(this, track);

    if (this.featuresNativeTextTracks) {
      var tracks = this.$$('track');

      var i = tracks.length;

      while (i--) {
        if (track === tracks[i] || track === tracks[i].track) {
          this.el().removeChild(tracks[i]);
        }
      }
    }
  };

  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object}
   *         An object with supported media playback quality metrics
   */


  Html5.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    if (typeof this.el().getVideoPlaybackQuality === 'function') {
      return this.el().getVideoPlaybackQuality();
    }

    var videoPlaybackQuality = {};

    if (typeof this.el().webkitDroppedFrameCount !== 'undefined' && typeof this.el().webkitDecodedFrameCount !== 'undefined') {
      videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
      videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
    }

    if (window_1.performance && typeof window_1.performance.now === 'function') {
      videoPlaybackQuality.creationTime = window_1.performance.now();
    } else if (window_1.performance && window_1.performance.timing && typeof window_1.performance.timing.navigationStart === 'number') {
      videoPlaybackQuality.creationTime = window_1.Date.now() - window_1.performance.timing.navigationStart;
    }

    return videoPlaybackQuality;
  };

  return Html5;
}(Tech);

/* HTML5 Support Testing ---------------------------------------------------- */

if (isReal()) {

  /**
   * Element for testing browser HTML5 media capabilities
   *
   * @type {Element}
   * @constant
   * @private
   */
  Html5.TEST_VID = document_1.createElement('video');
  var track = document_1.createElement('track');

  track.kind = 'captions';
  track.srclang = 'en';
  track.label = 'English';
  Html5.TEST_VID.appendChild(track);
}

/**
 * Check if HTML5 media is supported by this browser/device.
 *
 * @return {boolean}
 *         - True if HTML5 media is supported.
 *         - False if HTML5 media is not supported.
 */
Html5.isSupported = function () {
  // IE9 with no Media Player is a LIAR! (#984)
  try {
    Html5.TEST_VID.volume = 0.5;
  } catch (e) {
    return false;
  }

  return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
};

/**
 * Check if the tech can support the given type
 *
 * @param {string} type
 *        The mimetype to check
 * @return {string} 'probably', 'maybe', or '' (empty string)
 */
Html5.canPlayType = function (type) {
  return Html5.TEST_VID.canPlayType(type);
};

/**
 * Check if the tech can support the given source
 * @param {Object} srcObj
 *        The source object
 * @param {Object} options
 *        The options passed to the tech
 * @return {string} 'probably', 'maybe', or '' (empty string)
 */
Html5.canPlaySource = function (srcObj, options) {
  return Html5.canPlayType(srcObj.type);
};

/**
 * Check if the volume can be changed in this browser/device.
 * Volume cannot be changed in a lot of mobile devices.
 * Specifically, it can't be changed from 1 on iOS.
 *
 * @return {boolean}
 *         - True if volume can be controlled
 *         - False otherwise
 */
Html5.canControlVolume = function () {
  // IE will error if Windows Media Player not installed #3315
  try {
    var volume = Html5.TEST_VID.volume;

    Html5.TEST_VID.volume = volume / 2 + 0.1;
    return volume !== Html5.TEST_VID.volume;
  } catch (e) {
    return false;
  }
};

/**
 * Check if the playback rate can be changed in this browser/device.
 *
 * @return {boolean}
 *         - True if playback rate can be controlled
 *         - False otherwise
 */
Html5.canControlPlaybackRate = function () {
  // Playback rate API is implemented in Android Chrome, but doesn't do anything
  // https://github.com/videojs/video.js/issues/3180
  if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {
    return false;
  }
  // IE will error if Windows Media Player not installed #3315
  try {
    var playbackRate = Html5.TEST_VID.playbackRate;

    Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
    return playbackRate !== Html5.TEST_VID.playbackRate;
  } catch (e) {
    return false;
  }
};

/**
 * Check to see if native `TextTrack`s are supported by this browser/device.
 *
 * @return {boolean}
 *         - True if native `TextTrack`s are supported.
 *         - False otherwise
 */
Html5.supportsNativeTextTracks = function () {
  return IS_ANY_SAFARI;
};

/**
 * Check to see if native `VideoTrack`s are supported by this browser/device
 *
 * @return {boolean}
 *        - True if native `VideoTrack`s are supported.
 *        - False otherwise
 */
Html5.supportsNativeVideoTracks = function () {
  return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
};

/**
 * Check to see if native `AudioTrack`s are supported by this browser/device
 *
 * @return {boolean}
 *        - True if native `AudioTrack`s are supported.
 *        - False otherwise
 */
Html5.supportsNativeAudioTracks = function () {
  return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
};

/**
 * An array of events available on the Html5 tech.
 *
 * @private
 * @type {Array}
 */
Html5.Events = ['loadstart', 'suspend', 'abort', 'error', 'emptied', 'stalled', 'loadedmetadata', 'loadeddata', 'canplay', 'canplaythrough', 'playing', 'waiting', 'seeking', 'seeked', 'ended', 'durationchange', 'timeupdate', 'progress', 'play', 'pause', 'ratechange', 'resize', 'volumechange'];

/**
 * Boolean indicating whether the `Tech` supports volume control.
 *
 * @type {boolean}
 * @default {@link Html5.canControlVolume}
 */
Html5.prototype.featuresVolumeControl = Html5.canControlVolume();

/**
 * Boolean indicating whether the `Tech` supports changing the speed at which the media
 * plays. Examples:
 *   - Set player to play 2x (twice) as fast
 *   - Set player to play 0.5x (half) as fast
 *
 * @type {boolean}
 * @default {@link Html5.canControlPlaybackRate}
 */
Html5.prototype.featuresPlaybackRate = Html5.canControlPlaybackRate();

/**
 * Boolean indicating whether the `HTML5` tech currently supports the media element
 * moving in the DOM. iOS breaks if you move the media element, so this is set this to
 * false there. Everywhere else this should be true.
 *
 * @type {boolean}
 * @default
 */
Html5.prototype.movingMediaElementInDOM = !IS_IOS;

// TODO: Previous comment: No longer appears to be used. Can probably be removed.
//       Is this true?
/**
 * Boolean indicating whether the `HTML5` tech currently supports automatic media resize
 * when going into fullscreen.
 *
 * @type {boolean}
 * @default
 */
Html5.prototype.featuresFullscreenResize = true;

/**
 * Boolean indicating whether the `HTML5` tech currently supports the progress event.
 * If this is false, manual `progress` events will be triggred instead.
 *
 * @type {boolean}
 * @default
 */
Html5.prototype.featuresProgressEvents = true;

/**
 * Boolean indicating whether the `HTML5` tech currently supports the timeupdate event.
 * If this is false, manual `timeupdate` events will be triggred instead.
 *
 * @default
 */
Html5.prototype.featuresTimeupdateEvents = true;

/**
 * Boolean indicating whether the `HTML5` tech currently supports native `TextTrack`s.
 *
 * @type {boolean}
 * @default {@link Html5.supportsNativeTextTracks}
 */
Html5.prototype.featuresNativeTextTracks = Html5.supportsNativeTextTracks();

/**
 * Boolean indicating whether the `HTML5` tech currently supports native `VideoTrack`s.
 *
 * @type {boolean}
 * @default {@link Html5.supportsNativeVideoTracks}
 */
Html5.prototype.featuresNativeVideoTracks = Html5.supportsNativeVideoTracks();

/**
 * Boolean indicating whether the `HTML5` tech currently supports native `AudioTrack`s.
 *
 * @type {boolean}
 * @default {@link Html5.supportsNativeAudioTracks}
 */
Html5.prototype.featuresNativeAudioTracks = Html5.supportsNativeAudioTracks();

// HTML5 Feature detection and Device Fixes --------------------------------- //
var canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;
var mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
var mp4RE = /^video\/mp4/i;

Html5.patchCanPlayType = function () {

  // Android 4.0 and above can play HLS to some extent but it reports being unable to do so
  if (ANDROID_VERSION >= 4.0 && !IS_FIREFOX) {
    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mpegurlRE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };

    // Override Android 2.2 and less canPlayType method which is broken
  } else if (IS_OLD_ANDROID) {
    Html5.TEST_VID.constructor.prototype.canPlayType = function (type) {
      if (type && mp4RE.test(type)) {
        return 'maybe';
      }
      return canPlayType.call(this, type);
    };
  }
};

Html5.unpatchCanPlayType = function () {
  var r = Html5.TEST_VID.constructor.prototype.canPlayType;

  Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;
  return r;
};

// by default, patch the media element
Html5.patchCanPlayType();

Html5.disposeMediaElement = function (el) {
  if (!el) {
    return;
  }

  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }

  // remove any child track or source nodes to prevent their loading
  while (el.hasChildNodes()) {
    el.removeChild(el.firstChild);
  }

  // remove any src reference. not setting `src=''` because that causes a warning
  // in firefox
  el.removeAttribute('src');

  // force the media element to update its loading state by calling load()
  // however IE on Windows 7N has a bug that throws an error so need a try/catch (#793)
  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function () {
      try {
        el.load();
      } catch (e) {
        // not supported
      }
    })();
  }
};

Html5.resetMediaElement = function (el) {
  if (!el) {
    return;
  }

  var sources = el.querySelectorAll('source');
  var i = sources.length;

  while (i--) {
    el.removeChild(sources[i]);
  }

  // remove any src reference.
  // not setting `src=''` because that throws an error
  el.removeAttribute('src');

  if (typeof el.load === 'function') {
    // wrapping in an iife so it's not deoptimized (#1060#discussion_r10324473)
    (function () {
      try {
        el.load();
      } catch (e) {
        // satisfy linter
      }
    })();
  }
};

/* Native HTML5 element property wrapping ----------------------------------- */
// Wrap native boolean attributes with getters that check both property and attribute
// The list is as followed:
// muted, defaultMuted, autoplay, controls, loop, playsinline
[
/**
 * Get the value of `muted` from the media element. `muted` indicates
 * that the volume for the media should be set to silent. This does not actually change
 * the `volume` attribute.
 *
 * @method Html5#muted
 * @return {boolean}
 *         - True if the value of `volume` should be ignored and the audio set to silent.
 *         - False if the value of `volume` should be used.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
 */
'muted',

/**
 * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
 * whether the media should start muted or not. Only changes the default state of the
 * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the
 * current state.
 *
 * @method Html5#defaultMuted
 * @return {boolean}
 *         - The value of `defaultMuted` from the media element.
 *         - True indicates that the media should start muted.
 *         - False indicates that the media should not start muted
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
 */
'defaultMuted',

/**
 * Get the value of `autoplay` from the media element. `autoplay` indicates
 * that the media should start to play as soon as the page is ready.
 *
 * @method Html5#autoplay
 * @return {boolean}
 *         - The value of `autoplay` from the media element.
 *         - True indicates that the media should start as soon as the page loads.
 *         - False indicates that the media should not start as soon as the page loads.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
 */
'autoplay',

/**
 * Get the value of `controls` from the media element. `controls` indicates
 * whether the native media controls should be shown or hidden.
 *
 * @method Html5#controls
 * @return {boolean}
 *         - The value of `controls` from the media element.
 *         - True indicates that native controls should be showing.
 *         - False indicates that native controls should be hidden.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}
 */
'controls',

/**
 * Get the value of `loop` from the media element. `loop` indicates
 * that the media should return to the start of the media and continue playing once
 * it reaches the end.
 *
 * @method Html5#loop
 * @return {boolean}
 *         - The value of `loop` from the media element.
 *         - True indicates that playback should seek back to start once
 *           the end of a media is reached.
 *         - False indicates that playback should not loop back to the start when the
 *           end of the media is reached.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
 */
'loop',

/**
 * Get the value of `playsinline` from the media element. `playsinline` indicates
 * to the browser that non-fullscreen playback is preferred when fullscreen
 * playback is the native default, such as in iOS Safari.
 *
 * @method Html5#playsinline
 * @return {boolean}
 *         - The value of `playsinline` from the media element.
 *         - True indicates that the media should play inline.
 *         - False indicates that the media should not play inline.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
 */
'playsinline'].forEach(function (prop) {
  Html5.prototype[prop] = function () {
    return this.el_[prop] || this.el_.hasAttribute(prop);
  };
});

// Wrap native boolean attributes with setters that set both property and attribute
// The list is as followed:
// setMuted, setDefaultMuted, setAutoplay, setLoop, setPlaysinline
// setControls is special-cased above
[
/**
 * Set the value of `muted` on the media element. `muted` indicates that the current
 * audio level should be silent.
 *
 * @method Html5#setMuted
 * @param {boolean} muted
 *        - True if the audio should be set to silent
 *        - False otherwise
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
 */
'muted',

/**
 * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current
 * audio level should be silent, but will only effect the muted level on intial playback..
 *
 * @method Html5.prototype.setDefaultMuted
 * @param {boolean} defaultMuted
 *        - True if the audio should be set to silent
 *        - False otherwise
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
 */
'defaultMuted',

/**
 * Set the value of `autoplay` on the media element. `autoplay` indicates
 * that the media should start to play as soon as the page is ready.
 *
 * @method Html5#setAutoplay
 * @param {boolean} autoplay
 *         - True indicates that the media should start as soon as the page loads.
 *         - False indicates that the media should not start as soon as the page loads.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
 */
'autoplay',

/**
 * Set the value of `loop` on the media element. `loop` indicates
 * that the media should return to the start of the media and continue playing once
 * it reaches the end.
 *
 * @method Html5#setLoop
 * @param {boolean} loop
 *         - True indicates that playback should seek back to start once
 *           the end of a media is reached.
 *         - False indicates that playback should not loop back to the start when the
 *           end of the media is reached.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
 */
'loop',

/**
 * Set the value of `playsinline` from the media element. `playsinline` indicates
 * to the browser that non-fullscreen playback is preferred when fullscreen
 * playback is the native default, such as in iOS Safari.
 *
 * @method Html5#setPlaysinline
 * @param {boolean} playsinline
 *         - True indicates that the media should play inline.
 *         - False indicates that the media should not play inline.
 *
 * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
 */
'playsinline'].forEach(function (prop) {
  Html5.prototype['set' + toTitleCase(prop)] = function (v) {
    this.el_[prop] = v;

    if (v) {
      this.el_.setAttribute(prop, prop);
    } else {
      this.el_.removeAttribute(prop);
    }
  };
});

// Wrap native properties with a getter
// The list is as followed
// paused, currentTime, buffered, volume, poster, preload, error, seeking
// seekable, ended, playbackRate, defaultPlaybackRate, played, networkState
// readyState, videoWidth, videoHeight
[
/**
 * Get the value of `paused` from the media element. `paused` indicates whether the media element
 * is currently paused or not.
 *
 * @method Html5#paused
 * @return {boolean}
 *         The value of `paused` from the media element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}
 */
'paused',

/**
 * Get the value of `currentTime` from the media element. `currentTime` indicates
 * the current second that the media is at in playback.
 *
 * @method Html5#currentTime
 * @return {number}
 *         The value of `currentTime` from the media element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}
 */
'currentTime',

/**
 * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`
 * object that represents the parts of the media that are already downloaded and
 * available for playback.
 *
 * @method Html5#buffered
 * @return {TimeRange}
 *         The value of `buffered` from the media element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}
 */
'buffered',

/**
 * Get the value of `volume` from the media element. `volume` indicates
 * the current playback volume of audio for a media. `volume` will be a value from 0
 * (silent) to 1 (loudest and default).
 *
 * @method Html5#volume
 * @return {number}
 *         The value of `volume` from the media element. Value will be between 0-1.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
 */
'volume',

/**
 * Get the value of `poster` from the media element. `poster` indicates
 * that the url of an image file that can/will be shown when no media data is available.
 *
 * @method Html5#poster
 * @return {string}
 *         The value of `poster` from the media element. Value will be a url to an
 *         image.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}
 */
'poster',

/**
 * Get the value of `preload` from the media element. `preload` indicates
 * what should download before the media is interacted with. It can have the following
 * values:
 * - none: nothing should be downloaded
 * - metadata: poster and the first few frames of the media may be downloaded to get
 *   media dimensions and other metadata
 * - auto: allow the media and metadata for the media to be downloaded before
 *    interaction
 *
 * @method Html5#preload
 * @return {string}
 *         The value of `preload` from the media element. Will be 'none', 'metadata',
 *         or 'auto'.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
 */
'preload',

/**
 * Get the value of the `error` from the media element. `error` indicates any
 * MediaError that may have occured during playback. If error returns null there is no
 * current error.
 *
 * @method Html5#error
 * @return {MediaError|null}
 *         The value of `error` from the media element. Will be `MediaError` if there
 *         is a current error and null otherwise.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}
 */
'error',

/**
 * Get the value of `seeking` from the media element. `seeking` indicates whether the
 * media is currently seeking to a new position or not.
 *
 * @method Html5#seeking
 * @return {boolean}
 *         - The value of `seeking` from the media element.
 *         - True indicates that the media is currently seeking to a new position.
 *         - Flase indicates that the media is not seeking to a new position at this time.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}
 */
'seeking',

/**
 * Get the value of `seekable` from the media element. `seekable` returns a
 * `TimeRange` object indicating ranges of time that can currently be `seeked` to.
 *
 * @method Html5#seekable
 * @return {TimeRange}
 *         The value of `seekable` from the media element. A `TimeRange` object
 *         indicating the current ranges of time that can be seeked to.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}
 */
'seekable',

/**
 * Get the value of `ended` from the media element. `ended` indicates whether
 * the media has reached the end or not.
 *
 * @method Html5#ended
 * @return {boolean}
 *         - The value of `ended` from the media element.
 *         - True indicates that the media has ended.
 *         - False indicates that the media has not ended.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
 */
'ended',

/**
 * Get the value of `playbackRate` from the media element. `playbackRate` indicates
 * the rate at which the media is currently playing back. Examples:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5#playbackRate
 * @return {number}
 *         The value of `playbackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
 */
'playbackRate',

/**
 * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates
 * the rate at which the media is currently playing back. This value will not indicate the current
 * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.
 *
 * Examples:
 *   - if defaultPlaybackRate is set to 2, media will play twice as fast.
 *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5.prototype.defaultPlaybackRate
 * @return {number}
 *         The value of `defaultPlaybackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
 */
'defaultPlaybackRate',

/**
 * Get the value of `played` from the media element. `played` returns a `TimeRange`
 * object representing points in the media timeline that have been played.
 *
 * @method Html5#played
 * @return {TimeRange}
 *         The value of `played` from the media element. A `TimeRange` object indicating
 *         the ranges of time that have been played.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}
 */
'played',

/**
 * Get the value of `networkState` from the media element. `networkState` indicates
 * the current network state. It returns an enumeration from the following list:
 * - 0: NETWORK_EMPTY
 * - 1: NEWORK_IDLE
 * - 2: NETWORK_LOADING
 * - 3: NETWORK_NO_SOURCE
 *
 * @method Html5#networkState
 * @return {number}
 *         The value of `networkState` from the media element. This will be a number
 *         from the list in the description.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}
 */
'networkState',

/**
 * Get the value of `readyState` from the media element. `readyState` indicates
 * the current state of the media element. It returns an enumeration from the
 * following list:
 * - 0: HAVE_NOTHING
 * - 1: HAVE_METADATA
 * - 2: HAVE_CURRENT_DATA
 * - 3: HAVE_FUTURE_DATA
 * - 4: HAVE_ENOUGH_DATA
 *
 * @method Html5#readyState
 * @return {number}
 *         The value of `readyState` from the media element. This will be a number
 *         from the list in the description.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}
 */
'readyState',

/**
 * Get the value of `videoWidth` from the video element. `videoWidth` indicates
 * the current width of the video in css pixels.
 *
 * @method Html5#videoWidth
 * @return {number}
 *         The value of `videoWidth` from the video element. This will be a number
 *         in css pixels.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
 */
'videoWidth',

/**
 * Get the value of `videoHeight` from the video element. `videoHeigth` indicates
 * the current height of the video in css pixels.
 *
 * @method Html5#videoHeight
 * @return {number}
 *         The value of `videoHeight` from the video element. This will be a number
 *         in css pixels.
 *
 * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
 */
'videoHeight'].forEach(function (prop) {
  Html5.prototype[prop] = function () {
    return this.el_[prop];
  };
});

// Wrap native properties with a setter in this format:
// set + toTitleCase(name)
// The list is as follows:
// setVolume, setSrc, setPoster, setPreload, setPlaybackRate, setDefaultPlaybackRate
[
/**
 * Set the value of `volume` on the media element. `volume` indicates the current
 * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
 * so on.
 *
 * @method Html5#setVolume
 * @param {number} percentAsDecimal
 *        The volume percent as a decimal. Valid range is from 0-1.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
 */
'volume',

/**
 * Set the value of `src` on the media element. `src` indicates the current
 * {@link Tech~SourceObject} for the media.
 *
 * @method Html5#setSrc
 * @param {Tech~SourceObject} src
 *        The source object to set as the current source.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}
 */
'src',

/**
 * Set the value of `poster` on the media element. `poster` is the url to
 * an image file that can/will be shown when no media data is available.
 *
 * @method Html5#setPoster
 * @param {string} poster
 *        The url to an image that should be used as the `poster` for the media
 *        element.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}
 */
'poster',

/**
 * Set the value of `preload` on the media element. `preload` indicates
 * what should download before the media is interacted with. It can have the following
 * values:
 * - none: nothing should be downloaded
 * - metadata: poster and the first few frames of the media may be downloaded to get
 *   media dimensions and other metadata
 * - auto: allow the media and metadata for the media to be downloaded before
 *    interaction
 *
 * @method Html5#setPreload
 * @param {string} preload
 *         The value of `preload` to set on the media element. Must be 'none', 'metadata',
 *         or 'auto'.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
 */
'preload',

/**
 * Set the value of `playbackRate` on the media element. `playbackRate` indicates
 * the rate at which the media should play back. Examples:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5#setPlaybackRate
 * @return {number}
 *         The value of `playbackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
 */
'playbackRate',

/**
 * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates
 * the rate at which the media should play back upon initial startup. Changing this value
 * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.
 *
 * Example Values:
 *   - if playbackRate is set to 2, media will play twice as fast.
 *   - if playbackRate is set to 0.5, media will play half as fast.
 *
 * @method Html5.prototype.setDefaultPlaybackRate
 * @return {number}
 *         The value of `defaultPlaybackRate` from the media element. A number indicating
 *         the current playback speed of the media, where 1 is normal speed.
 *
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}
 */
'defaultPlaybackRate'].forEach(function (prop) {
  Html5.prototype['set' + toTitleCase(prop)] = function (v) {
    this.el_[prop] = v;
  };
});

// wrap native functions with a function
// The list is as follows:
// pause, load play
[
/**
 * A wrapper around the media elements `pause` function. This will call the `HTML5`
 * media elements `pause` function.
 *
 * @method Html5#pause
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}
 */
'pause',

/**
 * A wrapper around the media elements `load` function. This will call the `HTML5`s
 * media element `load` function.
 *
 * @method Html5#load
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}
 */
'load',

/**
 * A wrapper around the media elements `play` function. This will call the `HTML5`s
 * media element `play` function.
 *
 * @method Html5#play
 * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}
 */
'play'].forEach(function (prop) {
  Html5.prototype[prop] = function () {
    return this.el_[prop]();
  };
});

Tech.withSourceHandlers(Html5);

/**
 * Native source handler for Html5, simply passes the source to the media element.
 *
 * @proprety {Tech~SourceObject} source
 *        The source object
 *
 * @proprety {Html5} tech
 *        The instance of the HTML5 tech.
 */
Html5.nativeSourceHandler = {};

/**
 * Check if the media element can play the given mime type.
 *
 * @param {string} type
 *        The mimetype to check
 *
 * @return {string}
 *         'probably', 'maybe', or '' (empty string)
 */
Html5.nativeSourceHandler.canPlayType = function (type) {
  // IE9 on Windows 7 without MediaPlayer throws an error here
  // https://github.com/videojs/video.js/issues/519
  try {
    return Html5.TEST_VID.canPlayType(type);
  } catch (e) {
    return '';
  }
};

/**
 * Check if the media element can handle a source natively.
 *
 * @param {Tech~SourceObject} source
 *         The source object
 *
 * @param {Object} [options]
 *         Options to be passed to the tech.
 *
 * @return {string}
 *         'probably', 'maybe', or '' (empty string).
 */
Html5.nativeSourceHandler.canHandleSource = function (source, options) {

  // If a type was provided we should rely on that
  if (source.type) {
    return Html5.nativeSourceHandler.canPlayType(source.type);

    // If no type, fall back to checking 'video/[EXTENSION]'
  } else if (source.src) {
    var ext = getFileExtension(source.src);

    return Html5.nativeSourceHandler.canPlayType('video/' + ext);
  }

  return '';
};

/**
 * Pass the source to the native media element.
 *
 * @param {Tech~SourceObject} source
 *        The source object
 *
 * @param {Html5} tech
 *        The instance of the Html5 tech
 *
 * @param {Object} [options]
 *        The options to pass to the source
 */
Html5.nativeSourceHandler.handleSource = function (source, tech, options) {
  tech.setSrc(source.src);
};

/**
 * A noop for the native dispose function, as cleanup is not needed.
 */
Html5.nativeSourceHandler.dispose = function () {};

// Register the native source handler
Html5.registerSourceHandler(Html5.nativeSourceHandler);

Tech.registerTech('Html5', Html5);

var _templateObject$1 = taggedTemplateLiteralLoose(['\n        Using the tech directly can be dangerous. I hope you know what you\'re doing.\n        See https://github.com/videojs/video.js/issues/2617 for more info.\n      '], ['\n        Using the tech directly can be dangerous. I hope you know what you\'re doing.\n        See https://github.com/videojs/video.js/issues/2617 for more info.\n      ']);

/**
 * @file player.js
 */
// Subclasses Component
// The following imports are used only to ensure that the corresponding modules
// are always included in the video.js package. Importing the modules will
// execute them and they will register themselves with video.js.
// Import Html5 tech, at least for disposing the original video tag.
// The following tech events are simply re-triggered
// on the player when they happen
var TECH_EVENTS_RETRIGGER = [
/**
 * Fired while the user agent is downloading media data.
 *
 * @event Player#progress
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `progress` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechProgress_
 * @fires Player#progress
 * @listens Tech#progress
 */
'progress',

/**
 * Fires when the loading of an audio/video is aborted.
 *
 * @event Player#abort
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `abort` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechAbort_
 * @fires Player#abort
 * @listens Tech#abort
 */
'abort',

/**
 * Fires when the browser is intentionally not getting media data.
 *
 * @event Player#suspend
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `suspend` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechSuspend_
 * @fires Player#suspend
 * @listens Tech#suspend
 */
'suspend',

/**
 * Fires when the current playlist is empty.
 *
 * @event Player#emptied
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `emptied` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechEmptied_
 * @fires Player#emptied
 * @listens Tech#emptied
 */
'emptied',
/**
 * Fires when the browser is trying to get media data, but data is not available.
 *
 * @event Player#stalled
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `stalled` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechStalled_
 * @fires Player#stalled
 * @listens Tech#stalled
 */
'stalled',

/**
 * Fires when the browser has loaded meta data for the audio/video.
 *
 * @event Player#loadedmetadata
 * @type {EventTarget~Event}
 */
/**
 * Retrigger the `stalled` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechLoadedmetadata_
 * @fires Player#loadedmetadata
 * @listens Tech#loadedmetadata
 */
'loadedmetadata',

/**
 * Fires when the browser has loaded the current frame of the audio/video.
 *
 * @event Player#loadeddata
 * @type {event}
 */
/**
 * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechLoaddeddata_
 * @fires Player#loadeddata
 * @listens Tech#loadeddata
 */
'loadeddata',

/**
 * Fires when the current playback position has changed.
 *
 * @event Player#timeupdate
 * @type {event}
 */
/**
 * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechTimeUpdate_
 * @fires Player#timeupdate
 * @listens Tech#timeupdate
 */
'timeupdate',

/**
 * Fires when the playing speed of the audio/video is changed
 *
 * @event Player#ratechange
 * @type {event}
 */
/**
 * Retrigger the `ratechange` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechRatechange_
 * @fires Player#ratechange
 * @listens Tech#ratechange
 */
'ratechange',

/**
 * Fires when the video's intrinsic dimensions change
 *
 * @event Player#resize
 * @type {event}
 */
/**
 * Retrigger the `resize` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechResize_
 * @fires Player#resize
 * @listens Tech#resize
 */
'resize',

/**
 * Fires when the volume has been changed
 *
 * @event Player#volumechange
 * @type {event}
 */
/**
 * Retrigger the `volumechange` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechVolumechange_
 * @fires Player#volumechange
 * @listens Tech#volumechange
 */
'volumechange',

/**
 * Fires when the text track has been changed
 *
 * @event Player#texttrackchange
 * @type {event}
 */
/**
 * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.
 *
 * @private
 * @method Player#handleTechTexttrackchange_
 * @fires Player#texttrackchange
 * @listens Tech#texttrackchange
 */
'texttrackchange'];

/**
 * An instance of the `Player` class is created when any of the Video.js setup methods
 * are used to initialize a video.
 *
 * After an instance has been created it can be accessed globally in two ways:
 * 1. By calling `videojs('example_video_1');`
 * 2. By using it directly via  `videojs.players.example_video_1;`
 *
 * @extends Component
 */

var Player = function (_Component) {
  inherits(Player, _Component);

  /**
   * Create an instance of this class.
   *
   * @param {Element} tag
   *        The original video DOM element used for configuring options.
   *
   * @param {Object} [options]
   *        Object of option names and values.
   *
   * @param {Component~ReadyCallback} [ready]
   *        Ready callback function.
   */
  function Player(tag, options, ready) {
    classCallCheck(this, Player);

    // Make sure tag ID exists
    tag.id = tag.id || 'vjs_video_' + newGUID();

    // Set Options
    // The options argument overrides options set in the video tag
    // which overrides globally set options.
    // This latter part coincides with the load order
    // (tag must exist before Player)
    options = assign(Player.getTagSettings(tag), options);

    // Delay the initialization of children because we need to set up
    // player properties first, and can't use `this` before `super()`
    options.initChildren = false;

    // Same with creating the element
    options.createEl = false;

    // we don't want the player to report touch activity on itself
    // see enableTouchActivity in Component
    options.reportTouchActivity = false;

    // If language is not set, get the closest lang attribute
    if (!options.language) {
      if (typeof tag.closest === 'function') {
        var closest = tag.closest('[lang]');

        if (closest) {
          options.language = closest.getAttribute('lang');
        }
      } else {
        var element = tag;

        while (element && element.nodeType === 1) {
          if (getAttributes(element).hasOwnProperty('lang')) {
            options.language = element.getAttribute('lang');
            break;
          }
          element = element.parentNode;
        }
      }
    }

    // Run base component initializing with new options

    // Turn off API access because we're loading a new tech that might load asynchronously
    var _this = possibleConstructorReturn(this, _Component.call(this, null, options, ready));

    _this.isReady_ = false;

    // if the global option object was accidentally blown away by
    // someone, bail early with an informative error
    if (!_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) {
      throw new Error('No techOrder specified. Did you overwrite ' + 'videojs.options instead of just changing the ' + 'properties you want to override?');
    }

    // Store the original tag used to set options
    _this.tag = tag;

    // Store the tag attributes used to restore html5 element
    _this.tagAttributes = tag && getAttributes(tag);

    // Update current language
    _this.language(_this.options_.language);

    // Update Supported Languages
    if (options.languages) {
      // Normalise player option languages to lowercase
      var languagesToLower = {};

      Object.getOwnPropertyNames(options.languages).forEach(function (name$$1) {
        languagesToLower[name$$1.toLowerCase()] = options.languages[name$$1];
      });
      _this.languages_ = languagesToLower;
    } else {
      _this.languages_ = Player.prototype.options_.languages;
    }

    // Cache for video property values.
    _this.cache_ = {};

    // Set poster
    _this.poster_ = options.poster || '';

    // Set controls
    _this.controls_ = !!options.controls;

    // Set default values for lastVolume
    _this.cache_.lastVolume = 1;

    // Original tag settings stored in options
    // now remove immediately so native controls don't flash.
    // May be turned back on by HTML5 tech if nativeControlsForTouch is true
    tag.controls = false;

    /*
     * Store the internal state of scrubbing
     *
     * @private
     * @return {Boolean} True if the user is scrubbing
     */
    _this.scrubbing_ = false;

    _this.el_ = _this.createEl();

    // Make this an evented object and use `el_` as its event bus.
    evented(_this, { eventBusKey: 'el_' });

    // We also want to pass the original player options to each component and plugin
    // as well so they don't need to reach back into the player for options later.
    // We also need to do another copy of this.options_ so we don't end up with
    // an infinite loop.
    var playerOptionsCopy = mergeOptions(_this.options_);

    // Load plugins
    if (options.plugins) {
      var plugins = options.plugins;

      Object.keys(plugins).forEach(function (name$$1) {
        if (typeof this[name$$1] === 'function') {
          this[name$$1](plugins[name$$1]);
        } else {
          throw new Error('plugin "' + name$$1 + '" does not exist');
        }
      }, _this);
    }

    _this.options_.playerOptions = playerOptionsCopy;

    _this.middleware_ = [];

    _this.initChildren();

    // Set isAudio based on whether or not an audio tag was used
    _this.isAudio(tag.nodeName.toLowerCase() === 'audio');

    // Update controls className. Can't do this when the controls are initially
    // set because the element doesn't exist yet.
    if (_this.controls()) {
      _this.addClass('vjs-controls-enabled');
    } else {
      _this.addClass('vjs-controls-disabled');
    }

    // Set ARIA label and region role depending on player type
    _this.el_.setAttribute('role', 'region');
    if (_this.isAudio()) {
      _this.el_.setAttribute('aria-label', _this.localize('Audio Player'));
    } else {
      _this.el_.setAttribute('aria-label', _this.localize('Video Player'));
    }

    if (_this.isAudio()) {
      _this.addClass('vjs-audio');
    }

    if (_this.flexNotSupported_()) {
      _this.addClass('vjs-no-flex');
    }

    // TODO: Make this smarter. Toggle user state between touching/mousing
    // using events, since devices can have both touch and mouse events.
    // if (browser.TOUCH_ENABLED) {
    //   this.addClass('vjs-touch-enabled');
    // }

    // iOS Safari has broken hover handling
    if (!IS_IOS) {
      _this.addClass('vjs-workinghover');
    }

    // Make player easily findable by ID
    Player.players[_this.id_] = _this;

    // Add a major version class to aid css in plugins
    var majorVersion = version.split('.')[0];

    _this.addClass('vjs-v' + majorVersion);

    // When the player is first initialized, trigger activity so components
    // like the control bar show themselves if needed
    _this.userActive(true);
    _this.reportUserActivity();
    _this.listenForUserActivity_();

    _this.on('fullscreenchange', _this.handleFullscreenChange_);
    _this.on('stageclick', _this.handleStageClick_);

    _this.changingSrc_ = false;
    return _this;
  }

  /**
   * Destroys the video player and does any necessary cleanup.
   *
   * This is especially helpful if you are dynamically adding and removing videos
   * to/from the DOM.
   *
   * @fires Player#dispose
   */


  Player.prototype.dispose = function dispose() {
    /**
     * Called when the player is being disposed of.
     *
     * @event Player#dispose
     * @type {EventTarget~Event}
     */
    this.trigger('dispose');
    // prevent dispose from being called twice
    this.off('dispose');

    if (this.styleEl_ && this.styleEl_.parentNode) {
      this.styleEl_.parentNode.removeChild(this.styleEl_);
    }

    // Kill reference to this player
    Player.players[this.id_] = null;

    if (this.tag && this.tag.player) {
      this.tag.player = null;
    }

    if (this.el_ && this.el_.player) {
      this.el_.player = null;
    }

    if (this.tech_) {
      this.tech_.dispose();
    }

    _Component.prototype.dispose.call(this);
  };

  /**
   * Create the `Player`'s DOM element.
   *
   * @return {Element}
   *         The DOM element that gets created.
   */


  Player.prototype.createEl = function createEl$$1() {
    var tag = this.tag;
    var el = void 0;
    var playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute('data-vjs-player');

    if (playerElIngest) {
      el = this.el_ = tag.parentNode;
    } else {
      el = this.el_ = _Component.prototype.createEl.call(this, 'div');
    }

    // set tabindex to -1 so we could focus on the player element
    tag.setAttribute('tabindex', '-1');

    // Remove width/height attrs from tag so CSS can make it 100% width/height
    tag.removeAttribute('width');
    tag.removeAttribute('height');

    // Copy over all the attributes from the tag, including ID and class
    // ID will now reference player box, not the video tag
    var attrs = getAttributes(tag);

    Object.getOwnPropertyNames(attrs).forEach(function (attr) {
      // workaround so we don't totally break IE7
      // http://stackoverflow.com/questions/3653444/css-styles-not-applied-on-dynamic-elements-in-internet-explorer-7
      if (attr === 'class') {
        el.className += ' ' + attrs[attr];
      } else {
        el.setAttribute(attr, attrs[attr]);
      }
    });

    // Update tag id/class for use as HTML5 playback tech
    // Might think we should do this after embedding in container so .vjs-tech class
    // doesn't flash 100% width/height, but class only applies with .video-js parent
    tag.playerId = tag.id;
    tag.id += '_html5_api';
    tag.className = 'vjs-tech';

    // Make player findable on elements
    tag.player = el.player = this;
    // Default state of video is paused
    this.addClass('vjs-paused');

    // Add a style element in the player that we'll use to set the width/height
    // of the player in a way that's still overrideable by CSS, just like the
    // video element
    if (window_1.VIDEOJS_NO_DYNAMIC_STYLE !== true) {
      this.styleEl_ = createStyleElement('vjs-styles-dimensions');
      var defaultsStyleEl = $('.vjs-styles-defaults');
      var head = $('head');

      head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
    }

    // Pass in the width/height/aspectRatio options which will update the style el
    this.width(this.options_.width);
    this.height(this.options_.height);
    this.fluid(this.options_.fluid);
    this.aspectRatio(this.options_.aspectRatio);

    // Hide any links within the video/audio tag, because IE doesn't hide them completely.
    var links = tag.getElementsByTagName('a');

    for (var i = 0; i < links.length; i++) {
      var linkEl = links.item(i);

      addClass(linkEl, 'vjs-hidden');
      linkEl.setAttribute('hidden', 'hidden');
    }

    // insertElFirst seems to cause the networkState to flicker from 3 to 2, so
    // keep track of the original for later so we can know if the source originally failed
    tag.initNetworkState_ = tag.networkState;

    // Wrap video tag in div (el/box) container
    if (tag.parentNode && !playerElIngest) {
      tag.parentNode.insertBefore(el, tag);
    }

    // insert the tag as the first child of the player element
    // then manually add it to the children array so that this.addChild
    // will work properly for other components
    //
    // Breaks iPhone, fixed in HTML5 setup.
    prependTo(tag, el);
    this.children_.unshift(tag);

    // Set lang attr on player to ensure CSS :lang() in consistent with player
    // if it's been set to something different to the doc
    this.el_.setAttribute('lang', this.language_);

    this.el_ = el;

    return el;
  };

  /**
   * A getter/setter for the `Player`'s width. Returns the player's configured value.
   * To get the current width use `currentWidth()`.
   *
   * @param {number} [value]
   *        The value to set the `Player`'s width to.
   *
   * @return {number}
   *         The current width of the `Player` when getting.
   */


  Player.prototype.width = function width(value) {
    return this.dimension('width', value);
  };

  /**
   * A getter/setter for the `Player`'s height. Returns the player's configured value.
   * To get the current height use `currentheight()`.
   *
   * @param {number} [value]
   *        The value to set the `Player`'s heigth to.
   *
   * @return {number}
   *         The current height of the `Player` when getting.
   */


  Player.prototype.height = function height(value) {
    return this.dimension('height', value);
  };

  /**
   * A getter/setter for the `Player`'s width & height.
   *
   * @param {string} dimension
   *        This string can be:
   *        - 'width'
   *        - 'height'
   *
   * @param {number} [value]
   *        Value for dimension specified in the first argument.
   *
   * @return {number}
   *         The dimension arguments value when getting (width/height).
   */


  Player.prototype.dimension = function dimension(_dimension, value) {
    var privDimension = _dimension + '_';

    if (value === undefined) {
      return this[privDimension] || 0;
    }

    if (value === '') {
      // If an empty string is given, reset the dimension to be automatic
      this[privDimension] = undefined;
    } else {
      var parsedVal = parseFloat(value);

      if (isNaN(parsedVal)) {
        log$1.error('Improper value "' + value + '" supplied for for ' + _dimension);
        return;
      }

      this[privDimension] = parsedVal;
    }

    this.updateStyleEl_();
  };

  /**
   * A getter/setter/toggler for the vjs-fluid `className` on the `Player`.
   *
   * @param {boolean} [bool]
   *        - A value of true adds the class.
   *        - A value of false removes the class.
   *        - No value will toggle the fluid class.
   *
   * @return {boolean|undefined}
   *         - The value of fluid when getting.
   *         - `undefined` when setting.
   */


  Player.prototype.fluid = function fluid(bool) {
    if (bool === undefined) {
      return !!this.fluid_;
    }

    this.fluid_ = !!bool;

    if (bool) {
      this.addClass('vjs-fluid');
    } else {
      this.removeClass('vjs-fluid');
    }

    this.updateStyleEl_();
  };

  /**
   * Get/Set the aspect ratio
   *
   * @param {string} [ratio]
   *        Aspect ratio for player
   *
   * @return {string|undefined}
   *         returns the current aspect ratio when getting
   */

  /**
   * A getter/setter for the `Player`'s aspect ratio.
   *
   * @param {string} [ratio]
   *        The value to set the `Player's aspect ratio to.
   *
   * @return {string|undefined}
   *         - The current aspect ratio of the `Player` when getting.
   *         - undefined when setting
   */


  Player.prototype.aspectRatio = function aspectRatio(ratio) {
    if (ratio === undefined) {
      return this.aspectRatio_;
    }

    // Check for width:height format
    if (!/^\d+\:\d+$/.test(ratio)) {
      throw new Error('Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.');
    }
    this.aspectRatio_ = ratio;

    // We're assuming if you set an aspect ratio you want fluid mode,
    // because in fixed mode you could calculate width and height yourself.
    this.fluid(true);

    this.updateStyleEl_();
  };

  /**
   * Update styles of the `Player` element (height, width and aspect ratio).
   *
   * @private
   * @listens Tech#loadedmetadata
   */


  Player.prototype.updateStyleEl_ = function updateStyleEl_() {
    if (window_1.VIDEOJS_NO_DYNAMIC_STYLE === true) {
      var _width = typeof this.width_ === 'number' ? this.width_ : this.options_.width;
      var _height = typeof this.height_ === 'number' ? this.height_ : this.options_.height;
      var techEl = this.tech_ && this.tech_.el();

      if (techEl) {
        if (_width >= 0) {
          techEl.width = _width;
        }
        if (_height >= 0) {
          techEl.height = _height;
        }
      }

      return;
    }

    var width = void 0;
    var height = void 0;
    var aspectRatio = void 0;
    var idClass = void 0;

    // The aspect ratio is either used directly or to calculate width and height.
    if (this.aspectRatio_ !== undefined && this.aspectRatio_ !== 'auto') {
      // Use any aspectRatio that's been specifically set
      aspectRatio = this.aspectRatio_;
    } else if (this.videoWidth() > 0) {
      // Otherwise try to get the aspect ratio from the video metadata
      aspectRatio = this.videoWidth() + ':' + this.videoHeight();
    } else {
      // Or use a default. The video element's is 2:1, but 16:9 is more common.
      aspectRatio = '16:9';
    }

    // Get the ratio as a decimal we can use to calculate dimensions
    var ratioParts = aspectRatio.split(':');
    var ratioMultiplier = ratioParts[1] / ratioParts[0];

    if (this.width_ !== undefined) {
      // Use any width that's been specifically set
      width = this.width_;
    } else if (this.height_ !== undefined) {
      // Or calulate the width from the aspect ratio if a height has been set
      width = this.height_ / ratioMultiplier;
    } else {
      // Or use the video's metadata, or use the video el's default of 300
      width = this.videoWidth() || 300;
    }

    if (this.height_ !== undefined) {
      // Use any height that's been specifically set
      height = this.height_;
    } else {
      // Otherwise calculate the height from the ratio and the width
      height = width * ratioMultiplier;
    }

    // Ensure the CSS class is valid by starting with an alpha character
    if (/^[^a-zA-Z]/.test(this.id())) {
      idClass = 'dimensions-' + this.id();
    } else {
      idClass = this.id() + '-dimensions';
    }

    // Ensure the right class is still on the player for the style element
    this.addClass(idClass);

    setTextContent(this.styleEl_, '\n      .' + idClass + ' {\n        width: ' + width + 'px;\n        height: ' + height + 'px;\n      }\n\n      .' + idClass + '.vjs-fluid {\n        padding-top: ' + ratioMultiplier * 100 + '%;\n      }\n    ');
  };

  /**
   * Load/Create an instance of playback {@link Tech} including element
   * and API methods. Then append the `Tech` element in `Player` as a child.
   *
   * @param {string} techName
   *        name of the playback technology
   *
   * @param {string} source
   *        video source
   *
   * @private
   */


  Player.prototype.loadTech_ = function loadTech_(techName, source) {
    var _this2 = this;

    // Pause and remove current playback technology
    if (this.tech_) {
      this.unloadTech_();
    }

    var titleTechName = toTitleCase(techName);
    var camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);

    // get rid of the HTML5 video tag as soon as we are using another tech
    if (titleTechName !== 'Html5' && this.tag) {
      Tech.getTech('Html5').disposeMediaElement(this.tag);
      this.tag.player = null;
      this.tag = null;
    }

    this.techName_ = titleTechName;

    // Turn off API access because we're loading a new tech that might load asynchronously
    this.isReady_ = false;

    // Grab tech-specific options from player options and add source and parent element to use.
    var techOptions = {
      source: source,
      'nativeControlsForTouch': this.options_.nativeControlsForTouch,
      'playerId': this.id(),
      'techId': this.id() + '_' + titleTechName + '_api',
      'autoplay': this.options_.autoplay,
      'playsinline': this.options_.playsinline,
      'preload': this.options_.preload,
      'loop': this.options_.loop,
      'muted': this.options_.muted,
      'poster': this.poster(),
      'language': this.language(),
      'playerElIngest': this.playerElIngest_ || false,
      'vtt.js': this.options_['vtt.js']
    };

    ALL.names.forEach(function (name$$1) {
      var props = ALL[name$$1];

      techOptions[props.getterName] = _this2[props.privateName];
    });

    assign(techOptions, this.options_[titleTechName]);
    assign(techOptions, this.options_[camelTechName]);
    assign(techOptions, this.options_[techName.toLowerCase()]);

    if (this.tag) {
      techOptions.tag = this.tag;
    }

    if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {
      techOptions.startTime = this.cache_.currentTime;
    }

    // Initialize tech instance
    var TechClass = Tech.getTech(techName);

    if (!TechClass) {
      throw new Error('No Tech named \'' + titleTechName + '\' exists! \'' + titleTechName + '\' should be registered using videojs.registerTech()\'');
    }

    this.tech_ = new TechClass(techOptions);

    // player.triggerReady is always async, so don't need this to be async
    this.tech_.ready(bind(this, this.handleTechReady_), true);

    textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);

    // Listen to all HTML5-defined events and trigger them on the player
    TECH_EVENTS_RETRIGGER.forEach(function (event) {
      _this2.on(_this2.tech_, event, _this2['handleTech' + toTitleCase(event) + '_']);
    });
    this.on(this.tech_, 'loadstart', this.handleTechLoadStart_);
    this.on(this.tech_, 'waiting', this.handleTechWaiting_);
    this.on(this.tech_, 'canplay', this.handleTechCanPlay_);
    this.on(this.tech_, 'canplaythrough', this.handleTechCanPlayThrough_);
    this.on(this.tech_, 'playing', this.handleTechPlaying_);
    this.on(this.tech_, 'ended', this.handleTechEnded_);
    this.on(this.tech_, 'seeking', this.handleTechSeeking_);
    this.on(this.tech_, 'seeked', this.handleTechSeeked_);
    this.on(this.tech_, 'play', this.handleTechPlay_);
    this.on(this.tech_, 'firstplay', this.handleTechFirstPlay_);
    this.on(this.tech_, 'pause', this.handleTechPause_);
    this.on(this.tech_, 'durationchange', this.handleTechDurationChange_);
    this.on(this.tech_, 'fullscreenchange', this.handleTechFullscreenChange_);
    this.on(this.tech_, 'error', this.handleTechError_);
    this.on(this.tech_, 'loadedmetadata', this.updateStyleEl_);
    this.on(this.tech_, 'posterchange', this.handleTechPosterChange_);
    this.on(this.tech_, 'textdata', this.handleTechTextData_);

    this.usingNativeControls(this.techGet_('controls'));

    if (this.controls() && !this.usingNativeControls()) {
      this.addTechControlsListeners_();
    }

    // Add the tech element in the DOM if it was not already there
    // Make sure to not insert the original video element if using Html5
    if (this.tech_.el().parentNode !== this.el() && (titleTechName !== 'Html5' || !this.tag)) {
      prependTo(this.tech_.el(), this.el());
    }

    // Get rid of the original video tag reference after the first tech is loaded
    if (this.tag) {
      this.tag.player = null;
      this.tag = null;
    }
  };

  /**
   * Unload and dispose of the current playback {@link Tech}.
   *
   * @private
   */


  Player.prototype.unloadTech_ = function unloadTech_() {
    var _this3 = this;

    // Save the current text tracks so that we can reuse the same text tracks with the next tech
    ALL.names.forEach(function (name$$1) {
      var props = ALL[name$$1];

      _this3[props.privateName] = _this3[props.getterName]();
    });
    this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);

    this.isReady_ = false;

    this.tech_.dispose();

    this.tech_ = false;
  };

  /**
   * Return a reference to the current {@link Tech}.
   * It will print a warning by default about the danger of using the tech directly
   * but any argument that is passed in will silence the warning.
   *
   * @param {*} [safety]
   *        Anything passed in to silence the warning
   *
   * @return {Tech}
   *         The Tech
   */


  Player.prototype.tech = function tech(safety) {
    if (safety === undefined) {
      log$1.warn(tsml(_templateObject$1));
    }

    return this.tech_;
  };

  /**
   * Set up click and touch listeners for the playback element
   *
   * - On desktops: a click on the video itself will toggle playback
   * - On mobile devices: a click on the video toggles controls
   *   which is done by toggling the user state between active and
   *   inactive
   * - A tap can signal that a user has become active or has become inactive
   *   e.g. a quick tap on an iPhone movie should reveal the controls. Another
   *   quick tap should hide them again (signaling the user is in an inactive
   *   viewing state)
   * - In addition to this, we still want the user to be considered inactive after
   *   a few seconds of inactivity.
   *
   * > Note: the only part of iOS interaction we can't mimic with this setup
   * is a touch and hold on the video element counting as activity in order to
   * keep the controls showing, but that shouldn't be an issue. A touch and hold
   * on any controls will still keep the user active
   *
   * @private
   */


  Player.prototype.addTechControlsListeners_ = function addTechControlsListeners_() {
    // Make sure to remove all the previous listeners in case we are called multiple times.
    this.removeTechControlsListeners_();

    // Some browsers (Chrome & IE) don't trigger a click on a flash swf, but do
    // trigger mousedown/up.
    // http://stackoverflow.com/questions/1444562/javascript-onclick-event-over-flash-object
    // Any touch events are set to block the mousedown event from happening
    this.on(this.tech_, 'mousedown', this.handleTechClick_);

    // If the controls were hidden we don't want that to change without a tap event
    // so we'll check if the controls were already showing before reporting user
    // activity
    this.on(this.tech_, 'touchstart', this.handleTechTouchStart_);
    this.on(this.tech_, 'touchmove', this.handleTechTouchMove_);
    this.on(this.tech_, 'touchend', this.handleTechTouchEnd_);

    // The tap listener needs to come after the touchend listener because the tap
    // listener cancels out any reportedUserActivity when setting userActive(false)
    this.on(this.tech_, 'tap', this.handleTechTap_);
  };

  /**
   * Remove the listeners used for click and tap controls. This is needed for
   * toggling to controls disabled, where a tap/touch should do nothing.
   *
   * @private
   */


  Player.prototype.removeTechControlsListeners_ = function removeTechControlsListeners_() {
    // We don't want to just use `this.off()` because there might be other needed
    // listeners added by techs that extend this.
    this.off(this.tech_, 'tap', this.handleTechTap_);
    this.off(this.tech_, 'touchstart', this.handleTechTouchStart_);
    this.off(this.tech_, 'touchmove', this.handleTechTouchMove_);
    this.off(this.tech_, 'touchend', this.handleTechTouchEnd_);
    this.off(this.tech_, 'mousedown', this.handleTechClick_);
  };

  /**
   * Player waits for the tech to be ready
   *
   * @private
   */


  Player.prototype.handleTechReady_ = function handleTechReady_() {
    this.triggerReady();

    // Keep the same volume as before
    if (this.cache_.volume) {
      this.techCall_('setVolume', this.cache_.volume);
    }

    // Look if the tech found a higher resolution poster while loading
    this.handleTechPosterChange_();

    // Update the duration if available
    this.handleTechDurationChange_();

    // Chrome and Safari both have issues with autoplay.
    // In Safari (5.1.1), when we move the video element into the container div, autoplay doesn't work.
    // In Chrome (15), if you have autoplay + a poster + no controls, the video gets hidden (but audio plays)
    // This fixes both issues. Need to wait for API, so it updates displays correctly
    if ((this.src() || this.currentSrc()) && this.tag && this.options_.autoplay && this.paused()) {
      try {
        // Chrome Fix. Fixed in Chrome v16.
        delete this.tag.poster;
      } catch (e) {
        log$1('deleting tag.poster throws in some browsers', e);
      }
    }
  };

  /**
   * Retrigger the `loadstart` event that was triggered by the {@link Tech}. This
   * function will also trigger {@link Player#firstplay} if it is the first loadstart
   * for a video.
   *
   * @fires Player#loadstart
   * @fires Player#firstplay
   * @listens Tech#loadstart
   * @private
   */


  Player.prototype.handleTechLoadStart_ = function handleTechLoadStart_() {
    // TODO: Update to use `emptied` event instead. See #1277.

    this.removeClass('vjs-ended');
    this.removeClass('vjs-seeking');

    // reset the error state
    this.error(null);

    // If it's already playing we want to trigger a firstplay event now.
    // The firstplay event relies on both the play and loadstart events
    // which can happen in any order for a new source
    if (!this.paused()) {
      /**
       * Fired when the user agent begins looking for media data
       *
       * @event Player#loadstart
       * @type {EventTarget~Event}
       */
      this.trigger('loadstart');
      this.trigger('firstplay');
    } else {
      // reset the hasStarted state
      this.hasStarted(false);
      this.trigger('loadstart');
    }
  };

  /**
   * Add/remove the vjs-has-started class
   *
   * @fires Player#firstplay
   *
   * @param {boolean} hasStarted
   *        - true: adds the class
   *        - false: remove the class
   *
   * @return {boolean}
   *         the boolean value of hasStarted
   */


  Player.prototype.hasStarted = function hasStarted(_hasStarted) {
    if (_hasStarted !== undefined) {
      // only update if this is a new value
      if (this.hasStarted_ !== _hasStarted) {
        this.hasStarted_ = _hasStarted;
        if (_hasStarted) {
          this.addClass('vjs-has-started');
          // trigger the firstplay event if this newly has played
          this.trigger('firstplay');
        } else {
          this.removeClass('vjs-has-started');
        }
      }
      return;
    }
    return !!this.hasStarted_;
  };

  /**
   * Fired whenever the media begins or resumes playback
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-play}
   * @fires Player#play
   * @listens Tech#play
   * @private
   */


  Player.prototype.handleTechPlay_ = function handleTechPlay_() {
    this.removeClass('vjs-ended');
    this.removeClass('vjs-paused');
    this.addClass('vjs-playing');

    // hide the poster when the user hits play
    this.hasStarted(true);
    /**
     * Triggered whenever an {@link Tech#play} event happens. Indicates that
     * playback has started or resumed.
     *
     * @event Player#play
     * @type {EventTarget~Event}
     */
    this.trigger('play');
  };

  /**
   * Retrigger the `waiting` event that was triggered by the {@link Tech}.
   *
   * @fires Player#waiting
   * @listens Tech#waiting
   * @private
   */


  Player.prototype.handleTechWaiting_ = function handleTechWaiting_() {
    var _this4 = this;

    this.addClass('vjs-waiting');
    /**
     * A readyState change on the DOM element has caused playback to stop.
     *
     * @event Player#waiting
     * @type {EventTarget~Event}
     */
    this.trigger('waiting');
    this.one('timeupdate', function () {
      return _this4.removeClass('vjs-waiting');
    });
  };

  /**
   * Retrigger the `canplay` event that was triggered by the {@link Tech}.
   * > Note: This is not consistent between browsers. See #1351
   *
   * @fires Player#canplay
   * @listens Tech#canplay
   * @private
   */


  Player.prototype.handleTechCanPlay_ = function handleTechCanPlay_() {
    this.removeClass('vjs-waiting');
    /**
     * The media has a readyState of HAVE_FUTURE_DATA or greater.
     *
     * @event Player#canplay
     * @type {EventTarget~Event}
     */
    this.trigger('canplay');
  };

  /**
   * Retrigger the `canplaythrough` event that was triggered by the {@link Tech}.
   *
   * @fires Player#canplaythrough
   * @listens Tech#canplaythrough
   * @private
   */


  Player.prototype.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {
    this.removeClass('vjs-waiting');
    /**
     * The media has a readyState of HAVE_ENOUGH_DATA or greater. This means that the
     * entire media file can be played without buffering.
     *
     * @event Player#canplaythrough
     * @type {EventTarget~Event}
     */
    this.trigger('canplaythrough');
  };

  /**
   * Retrigger the `playing` event that was triggered by the {@link Tech}.
   *
   * @fires Player#playing
   * @listens Tech#playing
   * @private
   */


  Player.prototype.handleTechPlaying_ = function handleTechPlaying_() {
    this.removeClass('vjs-waiting');
    /**
     * The media is no longer blocked from playback, and has started playing.
     *
     * @event Player#playing
     * @type {EventTarget~Event}
     */
    this.trigger('playing');
  };

  /**
   * Retrigger the `seeking` event that was triggered by the {@link Tech}.
   *
   * @fires Player#seeking
   * @listens Tech#seeking
   * @private
   */


  Player.prototype.handleTechSeeking_ = function handleTechSeeking_() {
    this.addClass('vjs-seeking');
    /**
     * Fired whenever the player is jumping to a new time
     *
     * @event Player#seeking
     * @type {EventTarget~Event}
     */
    this.trigger('seeking');
  };

  /**
   * Retrigger the `seeked` event that was triggered by the {@link Tech}.
   *
   * @fires Player#seeked
   * @listens Tech#seeked
   * @private
   */


  Player.prototype.handleTechSeeked_ = function handleTechSeeked_() {
    this.removeClass('vjs-seeking');
    /**
     * Fired when the player has finished jumping to a new time
     *
     * @event Player#seeked
     * @type {EventTarget~Event}
     */
    this.trigger('seeked');
  };

  /**
   * Retrigger the `firstplay` event that was triggered by the {@link Tech}.
   *
   * @fires Player#firstplay
   * @listens Tech#firstplay
   * @deprecated As of 6.0 firstplay event is deprecated.
   * @deprecated As of 6.0 passing the `starttime` option to the player and the firstplay event are deprecated.
   * @private
   */


  Player.prototype.handleTechFirstPlay_ = function handleTechFirstPlay_() {
    // If the first starttime attribute is specified
    // then we will start at the given offset in seconds
    if (this.options_.starttime) {
      log$1.warn('Passing the `starttime` option to the player will be deprecated in 6.0');
      this.currentTime(this.options_.starttime);
    }

    this.addClass('vjs-has-started');
    /**
     * Fired the first time a video is played. Not part of the HLS spec, and this is
     * probably not the best implementation yet, so use sparingly. If you don't have a
     * reason to prevent playback, use `myPlayer.one('play');` instead.
     *
     * @event Player#firstplay
     * @deprecated As of 6.0 firstplay event is deprecated.
     * @type {EventTarget~Event}
     */
    this.trigger('firstplay');
  };

  /**
   * Retrigger the `pause` event that was triggered by the {@link Tech}.
   *
   * @fires Player#pause
   * @listens Tech#pause
   * @private
   */


  Player.prototype.handleTechPause_ = function handleTechPause_() {
    this.removeClass('vjs-playing');
    this.addClass('vjs-paused');
    /**
     * Fired whenever the media has been paused
     *
     * @event Player#pause
     * @type {EventTarget~Event}
     */
    this.trigger('pause');
  };

  /**
   * Retrigger the `ended` event that was triggered by the {@link Tech}.
   *
   * @fires Player#ended
   * @listens Tech#ended
   * @private
   */


  Player.prototype.handleTechEnded_ = function handleTechEnded_() {
    this.addClass('vjs-ended');
    if (this.options_.loop) {
      this.currentTime(0);
      this.play();
    } else if (!this.paused()) {
      this.pause();
    }

    /**
     * Fired when the end of the media resource is reached (currentTime == duration)
     *
     * @event Player#ended
     * @type {EventTarget~Event}
     */
    this.trigger('ended');
  };

  /**
   * Fired when the duration of the media resource is first known or changed
   *
   * @listens Tech#durationchange
   * @private
   */


  Player.prototype.handleTechDurationChange_ = function handleTechDurationChange_() {
    this.duration(this.techGet_('duration'));
  };

  /**
   * Handle a click on the media element to play/pause
   *
   * @param {EventTarget~Event} event
   *        the event that caused this function to trigger
   *
   * @listens Tech#mousedown
   * @private
   */


  Player.prototype.handleTechClick_ = function handleTechClick_(event) {
    // We're using mousedown to detect clicks thanks to Flash, but mousedown
    // will also be triggered with right-clicks, so we need to prevent that
    if (event.button !== 0) {
      return;
    }

    // When controls are disabled a click should not toggle playback because
    // the click is considered a control
    if (this.controls()) {
      if (this.paused()) {
        this.play();
      } else {
        this.pause();
      }
    }
  };

  /**
   * Handle a tap on the media element. It will toggle the user
   * activity state, which hides and shows the controls.
   *
   * @listens Tech#tap
   * @private
   */


  Player.prototype.handleTechTap_ = function handleTechTap_() {
    this.userActive(!this.userActive());
  };

  /**
   * Handle touch to start
   *
   * @listens Tech#touchstart
   * @private
   */


  Player.prototype.handleTechTouchStart_ = function handleTechTouchStart_() {
    this.userWasActive = this.userActive();
  };

  /**
   * Handle touch to move
   *
   * @listens Tech#touchmove
   * @private
   */


  Player.prototype.handleTechTouchMove_ = function handleTechTouchMove_() {
    if (this.userWasActive) {
      this.reportUserActivity();
    }
  };

  /**
   * Handle touch to end
   *
   * @param {EventTarget~Event} event
   *        the touchend event that triggered
   *        this function
   *
   * @listens Tech#touchend
   * @private
   */


  Player.prototype.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {
    // Stop the mouse events from also happening
    event.preventDefault();
  };

  /**
   * Fired when the player switches in or out of fullscreen mode
   *
   * @private
   * @listens Player#fullscreenchange
   */


  Player.prototype.handleFullscreenChange_ = function handleFullscreenChange_() {
    if (this.isFullscreen()) {
      this.addClass('vjs-fullscreen');
    } else {
      this.removeClass('vjs-fullscreen');
    }
  };

  /**
   * native click events on the SWF aren't triggered on IE11, Win8.1RT
   * use stageclick events triggered from inside the SWF instead
   *
   * @private
   * @listens stageclick
   */


  Player.prototype.handleStageClick_ = function handleStageClick_() {
    this.reportUserActivity();
  };

  /**
   * Handle Tech Fullscreen Change
   *
   * @param {EventTarget~Event} event
   *        the fullscreenchange event that triggered this function
   *
   * @param {Object} data
   *        the data that was sent with the event
   *
   * @private
   * @listens Tech#fullscreenchange
   * @fires Player#fullscreenchange
   */


  Player.prototype.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {
    if (data) {
      this.isFullscreen(data.isFullscreen);
    }
    /**
     * Fired when going in and out of fullscreen.
     *
     * @event Player#fullscreenchange
     * @type {EventTarget~Event}
     */
    this.trigger('fullscreenchange');
  };

  /**
   * Fires when an error occurred during the loading of an audio/video.
   *
   * @private
   * @listens Tech#error
   */


  Player.prototype.handleTechError_ = function handleTechError_() {
    var error = this.tech_.error();

    this.error(error);
  };

  /**
   * Retrigger the `textdata` event that was triggered by the {@link Tech}.
   *
   * @fires Player#textdata
   * @listens Tech#textdata
   * @private
   */


  Player.prototype.handleTechTextData_ = function handleTechTextData_() {
    var data = null;

    if (arguments.length > 1) {
      data = arguments[1];
    }

    /**
     * Fires when we get a textdata event from tech
     *
     * @event Player#textdata
     * @type {EventTarget~Event}
     */
    this.trigger('textdata', data);
  };

  /**
   * Get object for cached values.
   *
   * @return {Object}
   *         get the current object cache
   */


  Player.prototype.getCache = function getCache() {
    return this.cache_;
  };

  /**
   * Pass values to the playback tech
   *
   * @param {string} [method]
   *        the method to call
   *
   * @param {Object} arg
   *        the argument to pass
   *
   * @private
   */


  Player.prototype.techCall_ = function techCall_(method, arg) {
    // If it's not ready yet, call method when it is

    this.ready(function () {
      if (method in allowedSetters) {
        return set$1(this.middleware_, this.tech_, method, arg);
      }

      try {
        if (this.tech_) {
          this.tech_[method](arg);
        }
      } catch (e) {
        log$1(e);
        throw e;
      }
    }, true);
  };

  /**
   * Get calls can't wait for the tech, and sometimes don't need to.
   *
   * @param {string} method
   *        Tech method
   *
   * @return {Function|undefined}
   *         the method or undefined
   *
   * @private
   */


  Player.prototype.techGet_ = function techGet_(method) {
    if (this.tech_ && this.tech_.isReady_) {

      if (method in allowedGetters) {
        return get$1(this.middleware_, this.tech_, method);
      }

      // Flash likes to die and reload when you hide or reposition it.
      // In these cases the object methods go away and we get errors.
      // When that happens we'll catch the errors and inform tech that it's not ready any more.
      try {
        return this.tech_[method]();
      } catch (e) {
        // When building additional tech libs, an expected method may not be defined yet
        if (this.tech_[method] === undefined) {
          log$1('Video.js: ' + method + ' method not defined for ' + this.techName_ + ' playback technology.', e);

          // When a method isn't available on the object it throws a TypeError
        } else if (e.name === 'TypeError') {
          log$1('Video.js: ' + method + ' unavailable on ' + this.techName_ + ' playback technology element.', e);
          this.tech_.isReady_ = false;
        } else {
          log$1(e);
        }
        throw e;
      }
    }

    return;
  };

  /**
   * start media playback
   *
   * @return {Promise|undefined}
   *         Returns a `Promise` if the browser returns one, for most browsers this will
   *         return undefined.
   */


  Player.prototype.play = function play() {
    if (this.changingSrc_) {
      this.ready(function () {
        var retval = this.techGet_('play');

        // silence errors (unhandled promise from play)
        if (retval !== undefined && typeof retval.then === 'function') {
          retval.then(null, function (e) {});
        }
      });

      // Only calls the tech's play if we already have a src loaded
    } else if (this.isReady_ && (this.src() || this.currentSrc())) {
      return this.techGet_('play');
    } else {
      this.ready(function () {
        this.tech_.one('loadstart', function () {
          var retval = this.play();

          // silence errors (unhandled promise from play)
          if (retval !== undefined && typeof retval.then === 'function') {
            retval.then(null, function (e) {});
          }
        });
      });
    }
  };

  /**
   * Pause the video playback
   *
   * @return {Player}
   *         A reference to the player object this function was called on
   */


  Player.prototype.pause = function pause() {
    this.techCall_('pause');
  };

  /**
   * Check if the player is paused or has yet to play
   *
   * @return {boolean}
   *         - false: if the media is currently playing
   *         - true: if media is not currently playing
   */


  Player.prototype.paused = function paused() {
    // The initial state of paused should be true (in Safari it's actually false)
    return this.techGet_('paused') === false ? false : true;
  };

  /**
   * Get a TimeRange object representing the current ranges of time that the user
   * has played.
   *
   * @return {TimeRange}
   *         A time range object that represents all the increments of time that have
   *         been played.
   */


  Player.prototype.played = function played() {
    return this.techGet_('played') || createTimeRanges(0, 0);
  };

  /**
   * Returns whether or not the user is "scrubbing". Scrubbing is
   * when the user has clicked the progress bar handle and is
   * dragging it along the progress bar.
   *
   * @param {boolean} [isScrubbing]
   *        wether the user is or is not scrubbing
   *
   * @return {boolean}
   *         The value of scrubbing when getting
   */


  Player.prototype.scrubbing = function scrubbing(isScrubbing) {
    if (typeof isScrubbing === 'undefined') {
      return this.scrubbing_;
    }
    this.scrubbing_ = !!isScrubbing;

    if (isScrubbing) {
      this.addClass('vjs-scrubbing');
    } else {
      this.removeClass('vjs-scrubbing');
    }
  };

  /**
   * Get or set the current time (in seconds)
   *
   * @param {number|string} [seconds]
   *        The time to seek to in seconds
   *
   * @return {number}
   *         - the current time in seconds when getting
   */


  Player.prototype.currentTime = function currentTime(seconds) {
    if (typeof seconds !== 'undefined') {
      this.techCall_('setCurrentTime', seconds);
      return;
    }

    // cache last currentTime and return. default to 0 seconds
    //
    // Caching the currentTime is meant to prevent a massive amount of reads on the tech's
    // currentTime when scrubbing, but may not provide much performance benefit afterall.
    // Should be tested. Also something has to read the actual current time or the cache will
    // never get updated.
    this.cache_.currentTime = this.techGet_('currentTime') || 0;
    return this.cache_.currentTime;
  };

  /**
   * Normally gets the length in time of the video in seconds;
   * in all but the rarest use cases an argument will NOT be passed to the method
   *
   * > **NOTE**: The video must have started loading before the duration can be
   * known, and in the case of Flash, may not be known until the video starts
   * playing.
   *
   * @fires Player#durationchange
   *
   * @param {number} [seconds]
   *        The duration of the video to set in seconds
   *
   * @return {number}
   *         - The duration of the video in seconds when getting
   */


  Player.prototype.duration = function duration(seconds) {
    if (seconds === undefined) {
      // return NaN if the duration is not known
      return this.cache_.duration !== undefined ? this.cache_.duration : NaN;
    }

    seconds = parseFloat(seconds);

    // Standardize on Inifity for signaling video is live
    if (seconds < 0) {
      seconds = Infinity;
    }

    if (seconds !== this.cache_.duration) {
      // Cache the last set value for optimized scrubbing (esp. Flash)
      this.cache_.duration = seconds;

      if (seconds === Infinity) {
        this.addClass('vjs-live');
      } else {
        this.removeClass('vjs-live');
      }
      /**
       * @event Player#durationchange
       * @type {EventTarget~Event}
       */
      this.trigger('durationchange');
    }
  };

  /**
   * Calculates how much time is left in the video. Not part
   * of the native video API.
   *
   * @return {number}
   *         The time remaining in seconds
   */


  Player.prototype.remainingTime = function remainingTime() {
    return this.duration() - this.currentTime();
  };

  //
  // Kind of like an array of portions of the video that have been downloaded.

  /**
   * Get a TimeRange object with an array of the times of the video
   * that have been downloaded. If you just want the percent of the
   * video that's been downloaded, use bufferedPercent.
   *
   * @see [Buffered Spec]{@link http://dev.w3.org/html5/spec/video.html#dom-media-buffered}
   *
   * @return {TimeRange}
   *         A mock TimeRange object (following HTML spec)
   */


  Player.prototype.buffered = function buffered() {
    var buffered = this.techGet_('buffered');

    if (!buffered || !buffered.length) {
      buffered = createTimeRanges(0, 0);
    }

    return buffered;
  };

  /**
   * Get the percent (as a decimal) of the video that's been downloaded.
   * This method is not a part of the native HTML video API.
   *
   * @return {number}
   *         A decimal between 0 and 1 representing the percent
   *         that is bufferred 0 being 0% and 1 being 100%
   */


  Player.prototype.bufferedPercent = function bufferedPercent$$1() {
    return bufferedPercent(this.buffered(), this.duration());
  };

  /**
   * Get the ending time of the last buffered time range
   * This is used in the progress bar to encapsulate all time ranges.
   *
   * @return {number}
   *         The end of the last buffered time range
   */


  Player.prototype.bufferedEnd = function bufferedEnd() {
    var buffered = this.buffered();
    var duration = this.duration();
    var end = buffered.end(buffered.length - 1);

    if (end > duration) {
      end = duration;
    }

    return end;
  };

  /**
   * Get or set the current volume of the media
   *
   * @param  {number} [percentAsDecimal]
   *         The new volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number}
   *         The current volume as a percent when getting
   */


  Player.prototype.volume = function volume(percentAsDecimal) {
    var vol = void 0;

    if (percentAsDecimal !== undefined) {
      // Force value to between 0 and 1
      vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));
      this.cache_.volume = vol;
      this.techCall_('setVolume', vol);

      if (vol > 0) {
        this.lastVolume_(vol);
      }

      return;
    }

    // Default to 1 when returning current volume.
    vol = parseFloat(this.techGet_('volume'));
    return isNaN(vol) ? 1 : vol;
  };

  /**
   * Get the current muted state, or turn mute on or off
   *
   * @param {boolean} [muted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean}
   *         - true if mute is on and getting
   *         - false if mute is off and getting
   */


  Player.prototype.muted = function muted(_muted) {
    if (_muted !== undefined) {
      this.techCall_('setMuted', _muted);
      return;
    }
    return this.techGet_('muted') || false;
  };

  /**
   * Get the current defaultMuted state, or turn defaultMuted on or off. defaultMuted
   * indicates the state of muted on intial playback.
   *
   * ```js
   *   var myPlayer = videojs('some-player-id');
   *
   *   myPlayer.src("http://www.example.com/path/to/video.mp4");
   *
   *   // get, should be false
   *   console.log(myPlayer.defaultMuted());
   *   // set to true
   *   myPlayer.defaultMuted(true);
   *   // get should be true
   *   console.log(myPlayer.defaultMuted());
   * ```
   *
   * @param {boolean} [defaultMuted]
   *        - true to mute
   *        - false to unmute
   *
   * @return {boolean|Player}
   *         - true if defaultMuted is on and getting
   *         - false if defaultMuted is off and getting
   *         - A reference to the current player when setting
   */


  Player.prototype.defaultMuted = function defaultMuted(_defaultMuted) {
    if (_defaultMuted !== undefined) {
      return this.techCall_('setDefaultMuted', _defaultMuted);
    }
    return this.techGet_('defaultMuted') || false;
  };

  /**
   * Get the last volume, or set it
   *
   * @param  {number} [percentAsDecimal]
   *         The new last volume as a decimal percent:
   *         - 0 is muted/0%/off
   *         - 1.0 is 100%/full
   *         - 0.5 is half volume or 50%
   *
   * @return {number}
   *         the current value of lastVolume as a percent when getting
   *
   * @private
   */


  Player.prototype.lastVolume_ = function lastVolume_(percentAsDecimal) {
    if (percentAsDecimal !== undefined && percentAsDecimal !== 0) {
      this.cache_.lastVolume = percentAsDecimal;
      return;
    }
    return this.cache_.lastVolume;
  };

  /**
   * Check if current tech can support native fullscreen
   * (e.g. with built in controls like iOS, so not our flash swf)
   *
   * @return {boolean}
   *         if native fullscreen is supported
   */


  Player.prototype.supportsFullScreen = function supportsFullScreen() {
    return this.techGet_('supportsFullScreen') || false;
  };

  /**
   * Check if the player is in fullscreen mode or tell the player that it
   * is or is not in fullscreen mode.
   *
   * > NOTE: As of the latest HTML5 spec, isFullscreen is no longer an official
   * property and instead document.fullscreenElement is used. But isFullscreen is
   * still a valuable property for internal player workings.
   *
   * @param  {boolean} [isFS]
   *         Set the players current fullscreen state
   *
   * @return {boolean}
   *         - true if fullscreen is on and getting
   *         - false if fullscreen is off and getting
   */


  Player.prototype.isFullscreen = function isFullscreen(isFS) {
    if (isFS !== undefined) {
      this.isFullscreen_ = !!isFS;
      return;
    }
    return !!this.isFullscreen_;
  };

  /**
   * Increase the size of the video to full screen
   * In some browsers, full screen is not supported natively, so it enters
   * "full window mode", where the video fills the browser window.
   * In browsers and devices that support native full screen, sometimes the
   * browser's default controls will be shown, and not the Video.js custom skin.
   * This includes most mobile devices (iOS, Android) and older versions of
   * Safari.
   *
   * @fires Player#fullscreenchange
   */


  Player.prototype.requestFullscreen = function requestFullscreen() {
    var fsApi = FullscreenApi;

    this.isFullscreen(true);

    if (fsApi.requestFullscreen) {
      // the browser supports going fullscreen at the element level so we can
      // take the controls fullscreen as well as the video

      // Trigger fullscreenchange event after change
      // We have to specifically add this each time, and remove
      // when canceling fullscreen. Otherwise if there's multiple
      // players on a page, they would all be reacting to the same fullscreen
      // events
      on(document_1, fsApi.fullscreenchange, bind(this, function documentFullscreenChange(e) {
        this.isFullscreen(document_1[fsApi.fullscreenElement]);

        // If cancelling fullscreen, remove event listener.
        if (this.isFullscreen() === false) {
          off(document_1, fsApi.fullscreenchange, documentFullscreenChange);
        }
        /**
         * @event Player#fullscreenchange
         * @type {EventTarget~Event}
         */
        this.trigger('fullscreenchange');
      }));

      this.el_[fsApi.requestFullscreen]();
    } else if (this.tech_.supportsFullScreen()) {
      // we can't take the video.js controls fullscreen but we can go fullscreen
      // with native controls
      this.techCall_('enterFullScreen');
    } else {
      // fullscreen isn't supported so we'll just stretch the video element to
      // fill the viewport
      this.enterFullWindow();
      /**
       * @event Player#fullscreenchange
       * @type {EventTarget~Event}
       */
      this.trigger('fullscreenchange');
    }
  };

  /**
   * Return the video to its normal size after having been in full screen mode
   *
   * @fires Player#fullscreenchange
   */


  Player.prototype.exitFullscreen = function exitFullscreen() {
    var fsApi = FullscreenApi;

    this.isFullscreen(false);

    // Check for browser element fullscreen support
    if (fsApi.requestFullscreen) {
      document_1[fsApi.exitFullscreen]();
    } else if (this.tech_.supportsFullScreen()) {
      this.techCall_('exitFullScreen');
    } else {
      this.exitFullWindow();
      /**
       * @event Player#fullscreenchange
       * @type {EventTarget~Event}
       */
      this.trigger('fullscreenchange');
    }
  };

  /**
   * When fullscreen isn't supported we can stretch the
   * video container to as wide as the browser will let us.
   *
   * @fires Player#enterFullWindow
   */


  Player.prototype.enterFullWindow = function enterFullWindow() {
    this.isFullWindow = true;

    // Storing original doc overflow value to return to when fullscreen is off
    this.docOrigOverflow = document_1.documentElement.style.overflow;

    // Add listener for esc key to exit fullscreen
    on(document_1, 'keydown', bind(this, this.fullWindowOnEscKey));

    // Hide any scroll bars
    document_1.documentElement.style.overflow = 'hidden';

    // Apply fullscreen styles
    addClass(document_1.body, 'vjs-full-window');

    /**
     * @event Player#enterFullWindow
     * @type {EventTarget~Event}
     */
    this.trigger('enterFullWindow');
  };

  /**
   * Check for call to either exit full window or
   * full screen on ESC key
   *
   * @param {string} event
   *        Event to check for key press
   */


  Player.prototype.fullWindowOnEscKey = function fullWindowOnEscKey(event) {
    if (event.keyCode === 27) {
      if (this.isFullscreen() === true) {
        this.exitFullscreen();
      } else {
        this.exitFullWindow();
      }
    }
  };

  /**
   * Exit full window
   *
   * @fires Player#exitFullWindow
   */


  Player.prototype.exitFullWindow = function exitFullWindow() {
    this.isFullWindow = false;
    off(document_1, 'keydown', this.fullWindowOnEscKey);

    // Unhide scroll bars.
    document_1.documentElement.style.overflow = this.docOrigOverflow;

    // Remove fullscreen styles
    removeClass(document_1.body, 'vjs-full-window');

    // Resize the box, controller, and poster to original sizes
    // this.positionAll();
    /**
     * @event Player#exitFullWindow
     * @type {EventTarget~Event}
     */
    this.trigger('exitFullWindow');
  };

  /**
   * Check whether the player can play a given mimetype
   *
   * @see https://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-navigator-canplaytype
   *
   * @param {string} type
   *        The mimetype to check
   *
   * @return {string}
   *         'probably', 'maybe', or '' (empty string)
   */


  Player.prototype.canPlayType = function canPlayType(type) {
    var can = void 0;

    // Loop through each playback technology in the options order
    for (var i = 0, j = this.options_.techOrder; i < j.length; i++) {
      var techName = j[i];
      var tech = Tech.getTech(techName);

      // Support old behavior of techs being registered as components.
      // Remove once that deprecated behavior is removed.
      if (!tech) {
        tech = Component.getComponent(techName);
      }

      // Check if the current tech is defined before continuing
      if (!tech) {
        log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
        continue;
      }

      // Check if the browser supports this technology
      if (tech.isSupported()) {
        can = tech.canPlayType(type);

        if (can) {
          return can;
        }
      }
    }

    return '';
  };

  /**
   * Select source based on tech-order or source-order
   * Uses source-order selection if `options.sourceOrder` is truthy. Otherwise,
   * defaults to tech-order selection
   *
   * @param {Array} sources
   *        The sources for a media asset
   *
   * @return {Object|boolean}
   *         Object of source and tech order or false
   */


  Player.prototype.selectSource = function selectSource(sources) {
    var _this5 = this;

    // Get only the techs specified in `techOrder` that exist and are supported by the
    // current platform
    var techs = this.options_.techOrder.map(function (techName) {
      return [techName, Tech.getTech(techName)];
    }).filter(function (_ref) {
      var techName = _ref[0],
          tech = _ref[1];

      // Check if the current tech is defined before continuing
      if (tech) {
        // Check if the browser supports this technology
        return tech.isSupported();
      }

      log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
      return false;
    });

    // Iterate over each `innerArray` element once per `outerArray` element and execute
    // `tester` with both. If `tester` returns a non-falsy value, exit early and return
    // that value.
    var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair(outerArray, innerArray, tester) {
      var found = void 0;

      outerArray.some(function (outerChoice) {
        return innerArray.some(function (innerChoice) {
          found = tester(outerChoice, innerChoice);

          if (found) {
            return true;
          }
        });
      });

      return found;
    };

    var foundSourceAndTech = void 0;
    var flip = function flip(fn) {
      return function (a, b) {
        return fn(b, a);
      };
    };
    var finder = function finder(_ref2, source) {
      var techName = _ref2[0],
          tech = _ref2[1];

      if (tech.canPlaySource(source, _this5.options_[techName.toLowerCase()])) {
        return { source: source, tech: techName };
      }
    };

    // Depending on the truthiness of `options.sourceOrder`, we swap the order of techs and sources
    // to select from them based on their priority.
    if (this.options_.sourceOrder) {
      // Source-first ordering
      foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder));
    } else {
      // Tech-first ordering
      foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
    }

    return foundSourceAndTech || false;
  };

  /**
   * Get or set the video source.
   *
   * @param {Tech~SourceObject|Tech~SourceObject[]|string} [source]
   *        A SourceObject, an array of SourceObjects, or a string referencing
   *        a URL to a media source. It is _highly recommended_ that an object
   *        or array of objects is used here, so that source selection
   *        algorithms can take the `type` into account.
   *
   *        If not provided, this method acts as a getter.
   *
   * @return {string|undefined}
   *         If the `source` argument is missing, returns the current source
   *         URL. Otherwise, returns nothing/undefined.
   */


  Player.prototype.src = function src(source) {
    var _this6 = this;

    // getter usage
    if (typeof source === 'undefined') {
      return this.cache_.src;
    }
    // filter out invalid sources and turn our source into
    // an array of source objects
    var sources = filterSource(source);

    // if a source was passed in then it is invalid because
    // it was filtered to a zero length Array. So we have to
    // show an error
    if (!sources.length) {
      this.setTimeout(function () {
        this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });
      }, 0);
      return;
    }

    // intial sources
    this.cache_.sources = sources;
    this.changingSrc_ = true;

    // intial source
    this.cache_.source = sources[0];

    // middlewareSource is the source after it has been changed by middleware
    setSource(this, sources[0], function (middlewareSource, mws) {
      _this6.middleware_ = mws;

      var err = _this6.src_(middlewareSource);

      if (err) {
        if (sources.length > 1) {
          return _this6.src(sources.slice(1));
        }

        // We need to wrap this in a timeout to give folks a chance to add error event handlers
        _this6.setTimeout(function () {
          this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) });
        }, 0);

        // we could not find an appropriate tech, but let's still notify the delegate that this is it
        // this needs a better comment about why this is needed
        _this6.triggerReady();

        return;
      }

      _this6.changingSrc_ = false;
      // video element listed source
      _this6.cache_.src = middlewareSource.src;

      setTech(mws, _this6.tech_);
    });
  };

  /**
   * Set the source object on the tech, returns a boolean that indicates wether
   * there is a tech that can play the source or not
   *
   * @param {Tech~SourceObject} source
   *        The source object to set on the Tech
   *
   * @return {Boolean}
   *         - True if there is no Tech to playback this source
   *         - False otherwise
   *
   * @private
   */


  Player.prototype.src_ = function src_(source) {
    var sourceTech = this.selectSource([source]);

    if (!sourceTech) {
      return true;
    }

    if (!titleCaseEquals(sourceTech.tech, this.techName_)) {
      this.changingSrc_ = true;

      // load this technology with the chosen source
      this.loadTech_(sourceTech.tech, sourceTech.source);
      return false;
    }

    // wait until the tech is ready to set the source
    this.ready(function () {

      // The setSource tech method was added with source handlers
      // so older techs won't support it
      // We need to check the direct prototype for the case where subclasses
      // of the tech do not support source handlers
      if (this.tech_.constructor.prototype.hasOwnProperty('setSource')) {
        this.techCall_('setSource', source);
      } else {
        this.techCall_('src', source.src);
      }

      if (this.options_.preload === 'auto') {
        this.load();
      }

      // Set the source synchronously if possible (#2326)
    }, true);

    return false;
  };

  /**
   * Begin loading the src data.
   */


  Player.prototype.load = function load() {
    this.techCall_('load');
  };

  /**
   * Reset the player. Loads the first tech in the techOrder,
   * and calls `reset` on the tech`.
   */


  Player.prototype.reset = function reset() {
    this.loadTech_(this.options_.techOrder[0], null);
    this.techCall_('reset');
  };

  /**
   * Returns all of the current source objects.
   *
   * @return {Tech~SourceObject[]}
   *         The current source objects
   */


  Player.prototype.currentSources = function currentSources() {
    var source = this.currentSource();
    var sources = [];

    // assume `{}` or `{ src }`
    if (Object.keys(source).length !== 0) {
      sources.push(source);
    }

    return this.cache_.sources || sources;
  };

  /**
   * Returns the current source object.
   *
   * @return {Tech~SourceObject}
   *         The current source object
   */


  Player.prototype.currentSource = function currentSource() {
    return this.cache_.source || {};
  };

  /**
   * Returns the fully qualified URL of the current source value e.g. http://mysite.com/video.mp4
   * Can be used in conjuction with `currentType` to assist in rebuilding the current source object.
   *
   * @return {string}
   *         The current source
   */


  Player.prototype.currentSrc = function currentSrc() {
    return this.currentSource() && this.currentSource().src || '';
  };

  /**
   * Get the current source type e.g. video/mp4
   * This can allow you rebuild the current source object so that you could load the same
   * source and tech later
   *
   * @return {string}
   *         The source MIME type
   */


  Player.prototype.currentType = function currentType() {
    return this.currentSource() && this.currentSource().type || '';
  };

  /**
   * Get or set the preload attribute
   *
   * @param {boolean} [value]
   *        - true means that we should preload
   *        - false maens that we should not preload
   *
   * @return {string}
   *         The preload attribute value when getting
   */


  Player.prototype.preload = function preload(value) {
    if (value !== undefined) {
      this.techCall_('setPreload', value);
      this.options_.preload = value;
      return;
    }
    return this.techGet_('preload');
  };

  /**
   * Get or set the autoplay attribute.
   *
   * @param {boolean} [value]
   *        - true means that we should autoplay
   *        - false means that we should not autoplay
   *
   * @return {string}
   *         The current value of autoplay when getting
   */


  Player.prototype.autoplay = function autoplay(value) {
    if (value !== undefined) {
      this.techCall_('setAutoplay', value);
      this.options_.autoplay = value;
      return;
    }
    return this.techGet_('autoplay', value);
  };

  /**
   * Set or unset the playsinline attribute.
   * Playsinline tells the browser that non-fullscreen playback is preferred.
   *
   * @param {boolean} [value]
   *        - true means that we should try to play inline by default
   *        - false means that we should use the browser's default playback mode,
   *          which in most cases is inline. iOS Safari is a notable exception
   *          and plays fullscreen by default.
   *
   * @return {string|Player}
   *         - the current value of playsinline
   *         - the player when setting
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */


  Player.prototype.playsinline = function playsinline(value) {
    if (value !== undefined) {
      this.techCall_('setPlaysinline', value);
      this.options_.playsinline = value;
      return this;
    }
    return this.techGet_('playsinline');
  };

  /**
   * Get or set the loop attribute on the video element.
   *
   * @param {boolean} [value]
   *        - true means that we should loop the video
   *        - false means that we should not loop the video
   *
   * @return {string}
   *         The current value of loop when getting
   */


  Player.prototype.loop = function loop(value) {
    if (value !== undefined) {
      this.techCall_('setLoop', value);
      this.options_.loop = value;
      return;
    }
    return this.techGet_('loop');
  };

  /**
   * Get or set the poster image source url
   *
   * @fires Player#posterchange
   *
   * @param {string} [src]
   *        Poster image source URL
   *
   * @return {string}
   *         The current value of poster when getting
   */


  Player.prototype.poster = function poster(src) {
    if (src === undefined) {
      return this.poster_;
    }

    // The correct way to remove a poster is to set as an empty string
    // other falsey values will throw errors
    if (!src) {
      src = '';
    }

    // update the internal poster variable
    this.poster_ = src;

    // update the tech's poster
    this.techCall_('setPoster', src);

    // alert components that the poster has been set
    /**
     * This event fires when the poster image is changed on the player.
     *
     * @event Player#posterchange
     * @type {EventTarget~Event}
     */
    this.trigger('posterchange');
  };

  /**
   * Some techs (e.g. YouTube) can provide a poster source in an
   * asynchronous way. We want the poster component to use this
   * poster source so that it covers up the tech's controls.
   * (YouTube's play button). However we only want to use this
   * source if the player user hasn't set a poster through
   * the normal APIs.
   *
   * @fires Player#posterchange
   * @listens Tech#posterchange
   * @private
   */


  Player.prototype.handleTechPosterChange_ = function handleTechPosterChange_() {
    if (!this.poster_ && this.tech_ && this.tech_.poster) {
      this.poster_ = this.tech_.poster() || '';

      // Let components know the poster has changed
      this.trigger('posterchange');
    }
  };

  /**
   * Get or set whether or not the controls are showing.
   *
   * @fires Player#controlsenabled
   *
   * @param {boolean} [bool]
   *        - true to turn controls on
   *        - false to turn controls off
   *
   * @return {boolean}
   *         The current value of controls when getting
   */


  Player.prototype.controls = function controls(bool) {
    if (bool !== undefined) {
      bool = !!bool;

      // Don't trigger a change event unless it actually changed
      if (this.controls_ !== bool) {
        this.controls_ = bool;

        if (this.usingNativeControls()) {
          this.techCall_('setControls', bool);
        }

        if (bool) {
          this.removeClass('vjs-controls-disabled');
          this.addClass('vjs-controls-enabled');
          /**
           * @event Player#controlsenabled
           * @type {EventTarget~Event}
           */
          this.trigger('controlsenabled');

          if (!this.usingNativeControls()) {
            this.addTechControlsListeners_();
          }
        } else {
          this.removeClass('vjs-controls-enabled');
          this.addClass('vjs-controls-disabled');
          /**
           * @event Player#controlsdisabled
           * @type {EventTarget~Event}
           */
          this.trigger('controlsdisabled');

          if (!this.usingNativeControls()) {
            this.removeTechControlsListeners_();
          }
        }
      }
      return;
    }
    return !!this.controls_;
  };

  /**
   * Toggle native controls on/off. Native controls are the controls built into
   * devices (e.g. default iPhone controls), Flash, or other techs
   * (e.g. Vimeo Controls)
   * **This should only be set by the current tech, because only the tech knows
   * if it can support native controls**
   *
   * @fires Player#usingnativecontrols
   * @fires Player#usingcustomcontrols
   *
   * @param {boolean} [bool]
   *        - true to turn native controls on
   *        - false to turn native controls off
   *
   * @return {boolean}
   *         The current value of native controls when getting
   */


  Player.prototype.usingNativeControls = function usingNativeControls(bool) {
    if (bool !== undefined) {
      bool = !!bool;

      // Don't trigger a change event unless it actually changed
      if (this.usingNativeControls_ !== bool) {
        this.usingNativeControls_ = bool;
        if (bool) {
          this.addClass('vjs-using-native-controls');

          /**
           * player is using the native device controls
           *
           * @event Player#usingnativecontrols
           * @type {EventTarget~Event}
           */
          this.trigger('usingnativecontrols');
        } else {
          this.removeClass('vjs-using-native-controls');

          /**
           * player is using the custom HTML controls
           *
           * @event Player#usingcustomcontrols
           * @type {EventTarget~Event}
           */
          this.trigger('usingcustomcontrols');
        }
      }
      return;
    }
    return !!this.usingNativeControls_;
  };

  /**
   * Set or get the current MediaError
   *
   * @fires Player#error
   *
   * @param  {MediaError|string|number} [err]
   *         A MediaError or a string/number to be turned
   *         into a MediaError
   *
   * @return {MediaError|null}
   *         The current MediaError when getting (or null)
   */


  Player.prototype.error = function error(err) {
    if (err === undefined) {
      return this.error_ || null;
    }

    // restoring to default
    if (err === null) {
      this.error_ = err;
      this.removeClass('vjs-error');
      if (this.errorDisplay) {
        this.errorDisplay.close();
      }
      return;
    }

    this.error_ = new MediaError(err);

    // add the vjs-error classname to the player
    this.addClass('vjs-error');

    // log the name of the error type and any message
    // ie8 just logs "[object object]" if you just log the error object
    log$1.error('(CODE:' + this.error_.code + ' ' + MediaError.errorTypes[this.error_.code] + ')', this.error_.message, this.error_);

    /**
     * @event Player#error
     * @type {EventTarget~Event}
     */
    this.trigger('error');

    return;
  };

  /**
   * Report user activity
   *
   * @param {Object} event
   *        Event object
   */


  Player.prototype.reportUserActivity = function reportUserActivity(event) {
    this.userActivity_ = true;
  };

  /**
   * Get/set if user is active
   *
   * @fires Player#useractive
   * @fires Player#userinactive
   *
   * @param {boolean} [bool]
   *        - true if the user is active
   *        - false if the user is inactive
   *
   * @return {boolean}
   *         The current value of userActive when getting
   */


  Player.prototype.userActive = function userActive(bool) {
    if (bool !== undefined) {
      bool = !!bool;
      if (bool !== this.userActive_) {
        this.userActive_ = bool;
        if (bool) {
          // If the user was inactive and is now active we want to reset the
          // inactivity timer
          this.userActivity_ = true;
          this.removeClass('vjs-user-inactive');
          this.addClass('vjs-user-active');
          /**
           * @event Player#useractive
           * @type {EventTarget~Event}
           */
          this.trigger('useractive');
        } else {
          // We're switching the state to inactive manually, so erase any other
          // activity
          this.userActivity_ = false;

          // Chrome/Safari/IE have bugs where when you change the cursor it can
          // trigger a mousemove event. This causes an issue when you're hiding
          // the cursor when the user is inactive, and a mousemove signals user
          // activity. Making it impossible to go into inactive mode. Specifically
          // this happens in fullscreen when we really need to hide the cursor.
          //
          // When this gets resolved in ALL browsers it can be removed
          // https://code.google.com/p/chromium/issues/detail?id=103041
          if (this.tech_) {
            this.tech_.one('mousemove', function (e) {
              e.stopPropagation();
              e.preventDefault();
            });
          }

          this.removeClass('vjs-user-active');
          this.addClass('vjs-user-inactive');
          /**
           * @event Player#userinactive
           * @type {EventTarget~Event}
           */
          this.trigger('userinactive');
        }
      }
      return;
    }
    return this.userActive_;
  };

  /**
   * Listen for user activity based on timeout value
   *
   * @private
   */


  Player.prototype.listenForUserActivity_ = function listenForUserActivity_() {
    var mouseInProgress = void 0;
    var lastMoveX = void 0;
    var lastMoveY = void 0;
    var handleActivity = bind(this, this.reportUserActivity);

    var handleMouseMove = function handleMouseMove(e) {
      // #1068 - Prevent mousemove spamming
      // Chrome Bug: https://code.google.com/p/chromium/issues/detail?id=366970
      if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
        lastMoveX = e.screenX;
        lastMoveY = e.screenY;
        handleActivity();
      }
    };

    var handleMouseDown = function handleMouseDown() {
      handleActivity();
      // For as long as the they are touching the device or have their mouse down,
      // we consider them active even if they're not moving their finger or mouse.
      // So we want to continue to update that they are active
      this.clearInterval(mouseInProgress);
      // Setting userActivity=true now and setting the interval to the same time
      // as the activityCheck interval (250) should ensure we never miss the
      // next activityCheck
      mouseInProgress = this.setInterval(handleActivity, 250);
    };

    var handleMouseUp = function handleMouseUp(event) {
      handleActivity();
      // Stop the interval that maintains activity if the mouse/touch is down
      this.clearInterval(mouseInProgress);
    };

    // Any mouse movement will be considered user activity
    this.on('mousedown', handleMouseDown);
    this.on('mousemove', handleMouseMove);
    this.on('mouseup', handleMouseUp);

    // Listen for keyboard navigation
    // Shouldn't need to use inProgress interval because of key repeat
    this.on('keydown', handleActivity);
    this.on('keyup', handleActivity);

    // Run an interval every 250 milliseconds instead of stuffing everything into
    // the mousemove/touchmove function itself, to prevent performance degradation.
    // `this.reportUserActivity` simply sets this.userActivity_ to true, which
    // then gets picked up by this loop
    // http://ejohn.org/blog/learning-from-twitter/
    var inactivityTimeout = void 0;

    this.setInterval(function () {
      // Check to see if mouse/touch activity has happened
      if (this.userActivity_) {
        // Reset the activity tracker
        this.userActivity_ = false;

        // If the user state was inactive, set the state to active
        this.userActive(true);

        // Clear any existing inactivity timeout to start the timer over
        this.clearTimeout(inactivityTimeout);

        var timeout = this.options_.inactivityTimeout;

        if (timeout > 0) {
          // In <timeout> milliseconds, if no more activity has occurred the
          // user will be considered inactive
          inactivityTimeout = this.setTimeout(function () {
            // Protect against the case where the inactivityTimeout can trigger just
            // before the next user activity is picked up by the activity check loop
            // causing a flicker
            if (!this.userActivity_) {
              this.userActive(false);
            }
          }, timeout);
        }
      }
    }, 250);
  };

  /**
   * Gets or sets the current playback rate. A playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed
   * playback, for instance.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-playbackrate
   *
   * @param {number} [rate]
   *       New playback rate to set.
   *
   * @return {number}
   *         The current playback rate when getting or 1.0
   */


  Player.prototype.playbackRate = function playbackRate(rate) {
    if (rate !== undefined) {
      this.techCall_('setPlaybackRate', rate);
      return;
    }

    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.techGet_('playbackRate');
    }
    return 1.0;
  };

  /**
   * Gets or sets the current default playback rate. A default playback rate of
   * 1.0 represents normal speed and 0.5 would indicate half-speed playback, for instance.
   * defaultPlaybackRate will only represent what the intial playbackRate of a video was, not
   * not the current playbackRate.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-defaultplaybackrate
   *
   * @param {number} [rate]
   *       New default playback rate to set.
   *
   * @return {number|Player}
   *         - The default playback rate when getting or 1.0
   *         - the player when setting
   */


  Player.prototype.defaultPlaybackRate = function defaultPlaybackRate(rate) {
    if (rate !== undefined) {
      return this.techCall_('setDefaultPlaybackRate', rate);
    }

    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.techGet_('defaultPlaybackRate');
    }
    return 1.0;
  };

  /**
   * Gets or sets the audio flag
   *
   * @param {boolean} bool
   *        - true signals that this is an audio player
   *        - false signals that this is not an audio player
   *
   * @return {boolean}
   *         The current value of isAudio when getting
   */


  Player.prototype.isAudio = function isAudio(bool) {
    if (bool !== undefined) {
      this.isAudio_ = !!bool;
      return;
    }

    return !!this.isAudio_;
  };

  /**
   * A helper method for adding a {@link TextTrack} to our
   * {@link TextTrackList}.
   *
   * In addition to the W3C settings we allow adding additional info through options.
   *
   * @see http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-addtexttrack
   *
   * @param {string} [kind]
   *        the kind of TextTrack you are adding
   *
   * @param {string} [label]
   *        the label to give the TextTrack label
   *
   * @param {string} [language]
   *        the language to set on the TextTrack
   *
   * @return {TextTrack|undefined}
   *         the TextTrack that was added or undefined
   *         if there is no tech
   */


  Player.prototype.addTextTrack = function addTextTrack(kind, label, language) {
    if (this.tech_) {
      return this.tech_.addTextTrack(kind, label, language);
    }
  };

  /**
   * Create a remote {@link TextTrack} and an {@link HTMLTrackElement}. It will
   * automatically removed from the video element whenever the source changes, unless
   * manualCleanup is set to false.
   *
   * @param {Object} options
   *        Options to pass to {@link HTMLTrackElement} during creation. See
   *        {@link HTMLTrackElement} for object properties that you should use.
   *
   * @param {boolean} [manualCleanup=true] if set to false, the TextTrack will be
   *
   * @return {HtmlTrackElement}
   *         the HTMLTrackElement that was created and added
   *         to the HtmlTrackElementList and the remote
   *         TextTrackList
   *
   * @deprecated The default value of the "manualCleanup" parameter will default
   *             to "false" in upcoming versions of Video.js
   */


  Player.prototype.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    if (this.tech_) {
      return this.tech_.addRemoteTextTrack(options, manualCleanup);
    }
  };

  /**
   * Remove a remote {@link TextTrack} from the respective
   * {@link TextTrackList} and {@link HtmlTrackElementList}.
   *
   * @param {Object} track
   *        Remote {@link TextTrack} to remove
   *
   * @return {undefined}
   *         does not return anything
   */


  Player.prototype.removeRemoteTextTrack = function removeRemoteTextTrack() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$track = _ref3.track,
        track = _ref3$track === undefined ? arguments[0] : _ref3$track;

    // destructure the input into an object with a track argument, defaulting to arguments[0]
    // default the whole argument to an empty object if nothing was passed in

    if (this.tech_) {
      return this.tech_.removeRemoteTextTrack(track);
    }
  };

  /**
   * Gets available media playback quality metrics as specified by the W3C's Media
   * Playback Quality API.
   *
   * @see [Spec]{@link https://wicg.github.io/media-playback-quality}
   *
   * @return {Object|undefined}
   *         An object with supported media playback quality metrics or undefined if there
   *         is no tech or the tech does not support it.
   */


  Player.prototype.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    return this.techGet_('getVideoPlaybackQuality');
  };

  /**
   * Get video width
   *
   * @return {number}
   *         current video width
   */


  Player.prototype.videoWidth = function videoWidth() {
    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
  };

  /**
   * Get video height
   *
   * @return {number}
   *         current video height
   */


  Player.prototype.videoHeight = function videoHeight() {
    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
  };

  /**
   * The player's language code
   * NOTE: The language should be set in the player options if you want the
   * the controls to be built with a specific language. Changing the lanugage
   * later will not update controls text.
   *
   * @param {string} [code]
   *        the language code to set the player to
   *
   * @return {string}
   *         The current language code when getting
   */


  Player.prototype.language = function language(code) {
    if (code === undefined) {
      return this.language_;
    }

    this.language_ = String(code).toLowerCase();
  };

  /**
   * Get the player's language dictionary
   * Merge every time, because a newly added plugin might call videojs.addLanguage() at any time
   * Languages specified directly in the player options have precedence
   *
   * @return {Array}
   *         An array of of supported languages
   */


  Player.prototype.languages = function languages() {
    return mergeOptions(Player.prototype.options_.languages, this.languages_);
  };

  /**
   * returns a JavaScript object reperesenting the current track
   * information. **DOES not return it as JSON**
   *
   * @return {Object}
   *         Object representing the current of track info
   */


  Player.prototype.toJSON = function toJSON() {
    var options = mergeOptions(this.options_);
    var tracks = options.tracks;

    options.tracks = [];

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];

      // deep merge tracks and null out player so no circular references
      track = mergeOptions(track);
      track.player = undefined;
      options.tracks[i] = track;
    }

    return options;
  };

  /**
   * Creates a simple modal dialog (an instance of the {@link ModalDialog}
   * component) that immediately overlays the player with arbitrary
   * content and removes itself when closed.
   *
   * @param {string|Function|Element|Array|null} content
   *        Same as {@link ModalDialog#content}'s param of the same name.
   *        The most straight-forward usage is to provide a string or DOM
   *        element.
   *
   * @param {Object} [options]
   *        Extra options which will be passed on to the {@link ModalDialog}.
   *
   * @return {ModalDialog}
   *         the {@link ModalDialog} that was created
   */


  Player.prototype.createModal = function createModal(content, options) {
    var _this7 = this;

    options = options || {};
    options.content = content || '';

    var modal = new ModalDialog(this, options);

    this.addChild(modal);
    modal.on('dispose', function () {
      _this7.removeChild(modal);
    });

    modal.open();
    return modal;
  };

  /**
   * Gets tag settings
   *
   * @param {Element} tag
   *        The player tag
   *
   * @return {Object}
   *         An object containing all of the settings
   *         for a player tag
   */


  Player.getTagSettings = function getTagSettings(tag) {
    var baseOptions = {
      sources: [],
      tracks: []
    };

    var tagOptions = getAttributes(tag);
    var dataSetup = tagOptions['data-setup'];

    if (hasClass(tag, 'vjs-fluid')) {
      tagOptions.fluid = true;
    }

    // Check if data-setup attr exists.
    if (dataSetup !== null) {
      // Parse options JSON
      // If empty string, make it a parsable json object.
      var _safeParseTuple = tuple(dataSetup || '{}'),
          err = _safeParseTuple[0],
          data = _safeParseTuple[1];

      if (err) {
        log$1.error(err);
      }
      assign(tagOptions, data);
    }

    assign(baseOptions, tagOptions);

    // Get tag children settings
    if (tag.hasChildNodes()) {
      var children = tag.childNodes;

      for (var i = 0, j = children.length; i < j; i++) {
        var child = children[i];
        // Change case needed: http://ejohn.org/blog/nodename-case-sensitivity/
        var childName = child.nodeName.toLowerCase();

        if (childName === 'source') {
          baseOptions.sources.push(getAttributes(child));
        } else if (childName === 'track') {
          baseOptions.tracks.push(getAttributes(child));
        }
      }
    }

    return baseOptions;
  };

  /**
   * Determine wether or not flexbox is supported
   *
   * @return {boolean}
   *         - true if flexbox is supported
   *         - false if flexbox is not supported
   */


  Player.prototype.flexNotSupported_ = function flexNotSupported_() {
    var elem = document_1.createElement('i');

    // Note: We don't actually use flexBasis (or flexOrder), but it's one of the more
    // common flex features that we can rely on when checking for flex support.
    return !('flexBasis' in elem.style || 'webkitFlexBasis' in elem.style || 'mozFlexBasis' in elem.style || 'msFlexBasis' in elem.style ||
    // IE10-specific (2012 flex spec)
    'msFlexOrder' in elem.style);
  };

  return Player;
}(Component);

/**
 * Get the {@link VideoTrackList}
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html#videotracklist
 *
 * @return {VideoTrackList}
 *         the current video track list
 *
 * @method Player.prototype.videoTracks
 */

/**
 * Get the {@link AudioTrackList}
 * @link https://html.spec.whatwg.org/multipage/embedded-content.html#audiotracklist
 *
 * @return {AudioTrackList}
 *         the current audio track list
 *
 * @method Player.prototype.audioTracks
 */

/**
 * Get the {@link TextTrackList}
 *
 * @link http://www.w3.org/html/wg/drafts/html/master/embedded-content-0.html#dom-media-texttracks
 *
 * @return {TextTrackList}
 *         the current text track list
 *
 * @method Player.prototype.textTracks
 */

/**
 * Get the remote {@link TextTrackList}
 *
 * @return {TextTrackList}
 *         The current remote text track list
 *
 * @method Player.prototype.remoteTextTracks
 */

/**
 * Get the remote {@link HtmlTrackElementList} tracks.
 *
 * @return {HtmlTrackElementList}
 *         The current remote text track element list
 *
 * @method Player.prototype.remoteTextTrackEls
 */

ALL.names.forEach(function (name$$1) {
  var props = ALL[name$$1];

  Player.prototype[props.getterName] = function () {
    if (this.tech_) {
      return this.tech_[props.getterName]();
    }

    // if we have not yet loadTech_, we create {video,audio,text}Tracks_
    // these will be passed to the tech during loading
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});

/**
 * Global player list
 *
 * @type {Object}
 */
Player.players = {};

var navigator$1 = window_1.navigator;

/*
 * Player instance options, surfaced using options
 * options = Player.prototype.options_
 * Make changes in options, not here.
 *
 * @type {Object}
 * @private
 */
Player.prototype.options_ = {
  // Default order of fallback technology
  techOrder: Tech.defaultTechOrder_,

  html5: {},
  flash: {},

  // default inactivity timeout
  inactivityTimeout: 2000,

  // default playback rates
  playbackRates: [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],

  // Included control sets
  children: ['mediaLoader', 'posterImage', 'textTrackDisplay', 'loadingSpinner', 'bigPlayButton', 'controlBar', 'errorDisplay', 'textTrackSettings'],

  language: navigator$1 && (navigator$1.languages && navigator$1.languages[0] || navigator$1.userLanguage || navigator$1.language) || 'en',

  // locales and their language translations
  languages: {},

  // Default message to show when a video cannot be played.
  notSupportedMessage: 'No compatible source was found for this media.'
};

[
/**
 * Returns whether or not the player is in the "ended" state.
 *
 * @return {Boolean} True if the player is in the ended state, false if not.
 * @method Player#ended
 */
'ended',
/**
 * Returns whether or not the player is in the "seeking" state.
 *
 * @return {Boolean} True if the player is in the seeking state, false if not.
 * @method Player#seeking
 */
'seeking',
/**
 * Returns the TimeRanges of the media that are currently available
 * for seeking to.
 *
 * @return {TimeRanges} the seekable intervals of the media timeline
 * @method Player#seekable
 */
'seekable',
/**
 * Returns the current state of network activity for the element, from
 * the codes in the list below.
 * - NETWORK_EMPTY (numeric value 0)
 *   The element has not yet been initialised. All attributes are in
 *   their initial states.
 * - NETWORK_IDLE (numeric value 1)
 *   The element's resource selection algorithm is active and has
 *   selected a resource, but it is not actually using the network at
 *   this time.
 * - NETWORK_LOADING (numeric value 2)
 *   The user agent is actively trying to download data.
 * - NETWORK_NO_SOURCE (numeric value 3)
 *   The element's resource selection algorithm is active, but it has
 *   not yet found a resource to use.
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
 * @return {number} the current network activity state
 * @method Player#networkState
 */
'networkState',
/**
 * Returns a value that expresses the current state of the element
 * with respect to rendering the current playback position, from the
 * codes in the list below.
 * - HAVE_NOTHING (numeric value 0)
 *   No information regarding the media resource is available.
 * - HAVE_METADATA (numeric value 1)
 *   Enough of the resource has been obtained that the duration of the
 *   resource is available.
 * - HAVE_CURRENT_DATA (numeric value 2)
 *   Data for the immediate current playback position is available.
 * - HAVE_FUTURE_DATA (numeric value 3)
 *   Data for the immediate current playback position is available, as
 *   well as enough data for the user agent to advance the current
 *   playback position in the direction of playback.
 * - HAVE_ENOUGH_DATA (numeric value 4)
 *   The user agent estimates that enough data is available for
 *   playback to proceed uninterrupted.
 *
 * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
 * @return {number} the current playback rendering state
 * @method Player#readyState
 */
'readyState'].forEach(function (fn) {
  Player.prototype[fn] = function () {
    return this.techGet_(fn);
  };
});

TECH_EVENTS_RETRIGGER.forEach(function (event) {
  Player.prototype['handleTech' + toTitleCase(event) + '_'] = function () {
    return this.trigger(event);
  };
});

/**
 * Fired when the player has initial duration and dimension information
 *
 * @event Player#loadedmetadata
 * @type {EventTarget~Event}
 */

/**
 * Fired when the player has downloaded data at the current playback position
 *
 * @event Player#loadeddata
 * @type {EventTarget~Event}
 */

/**
 * Fired when the current playback position has changed *
 * During playback this is fired every 15-250 milliseconds, depending on the
 * playback technology in use.
 *
 * @event Player#timeupdate
 * @type {EventTarget~Event}
 */

/**
 * Fired when the volume changes
 *
 * @event Player#volumechange
 * @type {EventTarget~Event}
 */

/**
 * Reports whether or not a player has a plugin available.
 *
 * This does not report whether or not the plugin has ever been initialized
 * on this player. For that, [usingPlugin]{@link Player#usingPlugin}.
 *
 * @method Player#hasPlugin
 * @param  {string}  name
 *         The name of a plugin.
 *
 * @return {boolean}
 *         Whether or not this player has the requested plugin available.
 */

/**
 * Reports whether or not a player is using a plugin by name.
 *
 * For basic plugins, this only reports whether the plugin has _ever_ been
 * initialized on this player.
 *
 * @method Player#usingPlugin
 * @param  {string} name
 *         The name of a plugin.
 *
 * @return {boolean}
 *         Whether or not this player is using the requested plugin.
 */

Component.registerComponent('Player', Player);

/**
 * @file plugin.js
 */
/**
 * The base plugin name.
 *
 * @private
 * @constant
 * @type {string}
 */
var BASE_PLUGIN_NAME = 'plugin';

/**
 * The key on which a player's active plugins cache is stored.
 *
 * @private
 * @constant
 * @type     {string}
 */
var PLUGIN_CACHE_KEY = 'activePlugins_';

/**
 * Stores registered plugins in a private space.
 *
 * @private
 * @type    {Object}
 */
var pluginStorage = {};

/**
 * Reports whether or not a plugin has been registered.
 *
 * @private
 * @param   {string} name
 *          The name of a plugin.
 *
 * @returns {boolean}
 *          Whether or not the plugin has been registered.
 */
var pluginExists = function pluginExists(name) {
  return pluginStorage.hasOwnProperty(name);
};

/**
 * Get a single registered plugin by name.
 *
 * @private
 * @param   {string} name
 *          The name of a plugin.
 *
 * @returns {Function|undefined}
 *          The plugin (or undefined).
 */
var getPlugin = function getPlugin(name) {
  return pluginExists(name) ? pluginStorage[name] : undefined;
};

/**
 * Marks a plugin as "active" on a player.
 *
 * Also, ensures that the player has an object for tracking active plugins.
 *
 * @private
 * @param   {Player} player
 *          A Video.js player instance.
 *
 * @param   {string} name
 *          The name of a plugin.
 */
var markPluginAsActive = function markPluginAsActive(player, name) {
  player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};
  player[PLUGIN_CACHE_KEY][name] = true;
};

/**
 * Triggers a pair of plugin setup events.
 *
 * @private
 * @param  {Player} player
 *         A Video.js player instance.
 *
 * @param  {Plugin~PluginEventHash} hash
 *         A plugin event hash.
 *
 * @param  {Boolean} [before]
 *         If true, prefixes the event name with "before". In other words,
 *         use this to trigger "beforepluginsetup" instead of "pluginsetup".
 */
var triggerSetupEvent = function triggerSetupEvent(player, hash, before) {
  var eventName = (before ? 'before' : '') + 'pluginsetup';

  player.trigger(eventName, hash);
  player.trigger(eventName + ':' + hash.name, hash);
};

/**
 * Takes a basic plugin function and returns a wrapper function which marks
 * on the player that the plugin has been activated.
 *
 * @private
 * @param   {string} name
 *          The name of the plugin.
 *
 * @param   {Function} plugin
 *          The basic plugin.
 *
 * @returns {Function}
 *          A wrapper function for the given plugin.
 */
var createBasicPlugin = function createBasicPlugin(name, plugin) {
  var basicPluginWrapper = function basicPluginWrapper() {

    // We trigger the "beforepluginsetup" and "pluginsetup" events on the player
    // regardless, but we want the hash to be consistent with the hash provided
    // for advanced plugins.
    //
    // The only potentially counter-intuitive thing here is the `instance` in
    // the "pluginsetup" event is the value returned by the `plugin` function.
    triggerSetupEvent(this, { name: name, plugin: plugin, instance: null }, true);

    var instance = plugin.apply(this, arguments);

    markPluginAsActive(this, name);
    triggerSetupEvent(this, { name: name, plugin: plugin, instance: instance });

    return instance;
  };

  Object.keys(plugin).forEach(function (prop) {
    basicPluginWrapper[prop] = plugin[prop];
  });

  return basicPluginWrapper;
};

/**
 * Takes a plugin sub-class and returns a factory function for generating
 * instances of it.
 *
 * This factory function will replace itself with an instance of the requested
 * sub-class of Plugin.
 *
 * @private
 * @param   {string} name
 *          The name of the plugin.
 *
 * @param   {Plugin} PluginSubClass
 *          The advanced plugin.
 *
 * @returns {Function}
 */
var createPluginFactory = function createPluginFactory(name, PluginSubClass) {

  // Add a `name` property to the plugin prototype so that each plugin can
  // refer to itself by name.
  PluginSubClass.prototype.name = name;

  return function () {
    triggerSetupEvent(this, { name: name, plugin: PluginSubClass, instance: null }, true);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var instance = new (Function.prototype.bind.apply(PluginSubClass, [null].concat([this].concat(args))))();

    // The plugin is replaced by a function that returns the current instance.
    this[name] = function () {
      return instance;
    };

    triggerSetupEvent(this, instance.getEventHash());

    return instance;
  };
};

/**
 * Parent class for all advanced plugins.
 *
 * @mixes   module:evented~EventedMixin
 * @mixes   module:stateful~StatefulMixin
 * @fires   Player#beforepluginsetup
 * @fires   Player#beforepluginsetup:$name
 * @fires   Player#pluginsetup
 * @fires   Player#pluginsetup:$name
 * @listens Player#dispose
 * @throws  {Error}
 *          If attempting to instantiate the base {@link Plugin} class
 *          directly instead of via a sub-class.
 */

var Plugin = function () {

  /**
   * Creates an instance of this class.
   *
   * Sub-classes should call `super` to ensure plugins are properly initialized.
   *
   * @param {Player} player
   *        A Video.js player instance.
   */
  function Plugin(player) {
    classCallCheck(this, Plugin);

    if (this.constructor === Plugin) {
      throw new Error('Plugin must be sub-classed; not directly instantiated.');
    }

    this.player = player;

    // Make this object evented, but remove the added `trigger` method so we
    // use the prototype version instead.
    evented(this);
    delete this.trigger;

    stateful(this, this.constructor.defaultState);
    markPluginAsActive(player, this.name);

    // Auto-bind the dispose method so we can use it as a listener and unbind
    // it later easily.
    this.dispose = bind(this, this.dispose);

    // If the player is disposed, dispose the plugin.
    player.on('dispose', this.dispose);
  }

  /**
   * Each event triggered by plugins includes a hash of additional data with
   * conventional properties.
   *
   * This returns that object or mutates an existing hash.
   *
   * @param   {Object} [hash={}]
   *          An object to be used as event an event hash.
   *
   * @returns {Plugin~PluginEventHash}
   *          An event hash object with provided properties mixed-in.
   */


  Plugin.prototype.getEventHash = function getEventHash() {
    var hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    hash.name = this.name;
    hash.plugin = this.constructor;
    hash.instance = this;
    return hash;
  };

  /**
   * Triggers an event on the plugin object and overrides
   * {@link module:evented~EventedMixin.trigger|EventedMixin.trigger}.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash={}]
   *          Additional data hash to merge with a
   *          {@link Plugin~PluginEventHash|PluginEventHash}.
   *
   * @returns {boolean}
   *          Whether or not default was prevented.
   */


  Plugin.prototype.trigger = function trigger$$1(event) {
    var hash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    return trigger(this.eventBusEl_, event, this.getEventHash(hash));
  };

  /**
   * Handles "statechanged" events on the plugin. No-op by default, override by
   * subclassing.
   *
   * @abstract
   * @param    {Event} e
   *           An event object provided by a "statechanged" event.
   *
   * @param    {Object} e.changes
   *           An object describing changes that occurred with the "statechanged"
   *           event.
   */


  Plugin.prototype.handleStateChanged = function handleStateChanged(e) {};

  /**
   * Disposes a plugin.
   *
   * Subclasses can override this if they want, but for the sake of safety,
   * it's probably best to subscribe the "dispose" event.
   *
   * @fires Plugin#dispose
   */


  Plugin.prototype.dispose = function dispose() {
    var name = this.name,
        player = this.player;

    /**
     * Signals that a advanced plugin is about to be disposed.
     *
     * @event Plugin#dispose
     * @type  {EventTarget~Event}
     */

    this.trigger('dispose');
    this.off();
    player.off('dispose', this.dispose);

    // Eliminate any possible sources of leaking memory by clearing up
    // references between the player and the plugin instance and nulling out
    // the plugin's state and replacing methods with a function that throws.
    player[PLUGIN_CACHE_KEY][name] = false;
    this.player = this.state = null;

    // Finally, replace the plugin name on the player with a new factory
    // function, so that the plugin is ready to be set up again.
    player[name] = createPluginFactory(name, pluginStorage[name]);
  };

  /**
   * Determines if a plugin is a basic plugin (i.e. not a sub-class of `Plugin`).
   *
   * @param   {string|Function} plugin
   *          If a string, matches the name of a plugin. If a function, will be
   *          tested directly.
   *
   * @returns {boolean}
   *          Whether or not a plugin is a basic plugin.
   */


  Plugin.isBasic = function isBasic(plugin) {
    var p = typeof plugin === 'string' ? getPlugin(plugin) : plugin;

    return typeof p === 'function' && !Plugin.prototype.isPrototypeOf(p.prototype);
  };

  /**
   * Register a Video.js plugin.
   *
   * @param   {string} name
   *          The name of the plugin to be registered. Must be a string and
   *          must not match an existing plugin or a method on the `Player`
   *          prototype.
   *
   * @param   {Function} plugin
   *          A sub-class of `Plugin` or a function for basic plugins.
   *
   * @returns {Function}
   *          For advanced plugins, a factory function for that plugin. For
   *          basic plugins, a wrapper function that initializes the plugin.
   */


  Plugin.registerPlugin = function registerPlugin(name, plugin) {
    if (typeof name !== 'string') {
      throw new Error('Illegal plugin name, "' + name + '", must be a string, was ' + (typeof name === 'undefined' ? 'undefined' : _typeof(name)) + '.');
    }

    if (pluginExists(name)) {
      log$1.warn('A plugin named "' + name + '" already exists. You may want to avoid re-registering plugins!');
    } else if (Player.prototype.hasOwnProperty(name)) {
      throw new Error('Illegal plugin name, "' + name + '", cannot share a name with an existing player method!');
    }

    if (typeof plugin !== 'function') {
      throw new Error('Illegal plugin for "' + name + '", must be a function, was ' + (typeof plugin === 'undefined' ? 'undefined' : _typeof(plugin)) + '.');
    }

    pluginStorage[name] = plugin;

    // Add a player prototype method for all sub-classed plugins (but not for
    // the base Plugin class).
    if (name !== BASE_PLUGIN_NAME) {
      if (Plugin.isBasic(plugin)) {
        Player.prototype[name] = createBasicPlugin(name, plugin);
      } else {
        Player.prototype[name] = createPluginFactory(name, plugin);
      }
    }

    return plugin;
  };

  /**
   * De-register a Video.js plugin.
   *
   * @param {string} name
   *        The name of the plugin to be deregistered.
   */


  Plugin.deregisterPlugin = function deregisterPlugin(name) {
    if (name === BASE_PLUGIN_NAME) {
      throw new Error('Cannot de-register base plugin.');
    }
    if (pluginExists(name)) {
      delete pluginStorage[name];
      delete Player.prototype[name];
    }
  };

  /**
   * Gets an object containing multiple Video.js plugins.
   *
   * @param   {Array} [names]
   *          If provided, should be an array of plugin names. Defaults to _all_
   *          plugin names.
   *
   * @returns {Object|undefined}
   *          An object containing plugin(s) associated with their name(s) or
   *          `undefined` if no matching plugins exist).
   */


  Plugin.getPlugins = function getPlugins() {
    var names = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.keys(pluginStorage);

    var result = void 0;

    names.forEach(function (name) {
      var plugin = getPlugin(name);

      if (plugin) {
        result = result || {};
        result[name] = plugin;
      }
    });

    return result;
  };

  /**
   * Gets a plugin's version, if available
   *
   * @param   {string} name
   *          The name of a plugin.
   *
   * @returns {string}
   *          The plugin's version or an empty string.
   */


  Plugin.getPluginVersion = function getPluginVersion(name) {
    var plugin = getPlugin(name);

    return plugin && plugin.VERSION || '';
  };

  return Plugin;
}();

/**
 * Gets a plugin by name if it exists.
 *
 * @static
 * @method   getPlugin
 * @memberOf Plugin
 * @param    {string} name
 *           The name of a plugin.
 *
 * @returns  {Function|undefined}
 *           The plugin (or `undefined`).
 */


Plugin.getPlugin = getPlugin;

/**
 * The name of the base plugin class as it is registered.
 *
 * @type {string}
 */
Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;

Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);

/**
 * Documented in player.js
 *
 * @ignore
 */
Player.prototype.usingPlugin = function (name) {
  return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;
};

/**
 * Documented in player.js
 *
 * @ignore
 */
Player.prototype.hasPlugin = function (name) {
  return !!pluginExists(name);
};

/**
 * Signals that a plugin is about to be set up on a player.
 *
 * @event    Player#beforepluginsetup
 * @type     {Plugin~PluginEventHash}
 */

/**
 * Signals that a plugin is about to be set up on a player - by name. The name
 * is the name of the plugin.
 *
 * @event    Player#beforepluginsetup:$name
 * @type     {Plugin~PluginEventHash}
 */

/**
 * Signals that a plugin has just been set up on a player.
 *
 * @event    Player#pluginsetup
 * @type     {Plugin~PluginEventHash}
 */

/**
 * Signals that a plugin has just been set up on a player - by name. The name
 * is the name of the plugin.
 *
 * @event    Player#pluginsetup:$name
 * @type     {Plugin~PluginEventHash}
 */

/**
 * @typedef  {Object} Plugin~PluginEventHash
 *
 * @property {string} instance
 *           For basic plugins, the return value of the plugin function. For
 *           advanced plugins, the plugin instance on which the event is fired.
 *
 * @property {string} name
 *           The name of the plugin.
 *
 * @property {string} plugin
 *           For basic plugins, the plugin function. For advanced plugins, the
 *           plugin class/constructor.
 */

/**
 * @file extend.js
 * @module extend
 */

/**
 * A combination of node inherits and babel's inherits (after transpile).
 * Both work the same but node adds `super_` to the subClass
 * and Bable adds the superClass as __proto__. Both seem useful.
 *
 * @param {Object} subClass
 *        The class to inherit to
 *
 * @param {Object} superClass
 *        The class to inherit from
 *
 * @private
 */
var _inherits = function _inherits(subClass, superClass) {
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError('Super expression must either be null or a function, not ' + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (superClass) {
    // node
    subClass.super_ = superClass;
  }
};

/**
 * Function for subclassing using the same inheritance that
 * videojs uses internally
 *
 * @static
 * @const
 *
 * @param {Object} superClass
 *        The class to inherit from
 *
 * @param {Object} [subClassMethods={}]
 *        The class to inherit to
 *
 * @return {Object}
 *         The new object with subClassMethods that inherited superClass.
 */
var extendFn = function extendFn(superClass) {
  var subClassMethods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var subClass = function subClass() {
    superClass.apply(this, arguments);
  };

  var methods = {};

  if ((typeof subClassMethods === 'undefined' ? 'undefined' : _typeof(subClassMethods)) === 'object') {
    if (subClassMethods.constructor !== Object.prototype.constructor) {
      subClass = subClassMethods.constructor;
    }
    methods = subClassMethods;
  } else if (typeof subClassMethods === 'function') {
    subClass = subClassMethods;
  }

  _inherits(subClass, superClass);

  // Extend subObj's prototype with functions and other properties from props
  for (var name in methods) {
    if (methods.hasOwnProperty(name)) {
      subClass.prototype[name] = methods[name];
    }
  }

  return subClass;
};

/**
 * @file video.js
 * @module videojs
 */
// Include the built-in techs
// HTML5 Element Shim for IE8
if (typeof HTMLVideoElement === 'undefined' && isReal()) {
  document_1.createElement('video');
  document_1.createElement('audio');
  document_1.createElement('track');
}

/**
 * Doubles as the main function for users to create a player instance and also
 * the main library object.
 * The `videojs` function can be used to initialize or retrieve a player.
  *
 * @param {string|Element} id
 *        Video element or video element ID
 *
 * @param {Object} [options]
 *        Optional options object for config/settings
 *
 * @param {Component~ReadyCallback} [ready]
 *        Optional ready callback
 *
 * @return {Player}
 *         A player instance
 */
function videojs(id, options, ready) {
  var tag = void 0;

  // Allow for element or ID to be passed in
  // String ID
  if (typeof id === 'string') {
    var players = videojs.getPlayers();

    // Adjust for jQuery ID syntax
    if (id.indexOf('#') === 0) {
      id = id.slice(1);
    }

    // If a player instance has already been created for this ID return it.
    if (players[id]) {

      // If options or ready function are passed, warn
      if (options) {
        log$1.warn('Player "' + id + '" is already initialised. Options will not be applied.');
      }

      if (ready) {
        players[id].ready(ready);
      }

      return players[id];
    }

    // Otherwise get element for ID
    tag = $('#' + id);

    // ID is a media element
  } else {
    tag = id;
  }

  // Check for a useable element
  // re: nodeName, could be a box div also
  if (!tag || !tag.nodeName) {
    throw new TypeError('The element or ID supplied is not valid. (videojs)');
  }

  // Element may have a player attr referring to an already created player instance.
  // If so return that otherwise set up a new player below
  if (tag.player || Player.players[tag.playerId]) {
    return tag.player || Player.players[tag.playerId];
  }

  options = options || {};

  videojs.hooks('beforesetup').forEach(function (hookFunction) {
    var opts = hookFunction(tag, mergeOptions(options));

    if (!isObject(opts) || Array.isArray(opts)) {
      log$1.error('please return an object in beforesetup hooks');
      return;
    }

    options = mergeOptions(options, opts);
  });

  var PlayerComponent = Component.getComponent('Player');
  // If not, set up a new player
  var player = new PlayerComponent(tag, options, ready);

  videojs.hooks('setup').forEach(function (hookFunction) {
    return hookFunction(player);
  });

  return player;
}

/**
 * An Object that contains lifecycle hooks as keys which point to an array
 * of functions that are run when a lifecycle is triggered
 */
videojs.hooks_ = {};

/**
 * Get a list of hooks for a specific lifecycle
 * @function videojs.hooks
 *
 * @param {string} type
 *        the lifecyle to get hooks from
 *
 * @param {Function} [fn]
 *        Optionally add a hook to the lifecycle that your are getting.
 *
 * @return {Array}
 *         an array of hooks, or an empty array if there are none.
 */
videojs.hooks = function (type, fn) {
  videojs.hooks_[type] = videojs.hooks_[type] || [];
  if (fn) {
    videojs.hooks_[type] = videojs.hooks_[type].concat(fn);
  }
  return videojs.hooks_[type];
};

/**
 * Add a function hook to a specific videojs lifecycle.
 *
 * @param {string} type
 *        the lifecycle to hook the function to.
 *
 * @param {Function|Function[]}
 *        The function or array of functions to attach.
 */
videojs.hook = function (type, fn) {
  videojs.hooks(type, fn);
};

/**
 * Remove a hook from a specific videojs lifecycle.
 *
 * @param {string} type
 *        the lifecycle that the function hooked to
 *
 * @param {Function} fn
 *        The hooked function to remove
 *
 * @return {boolean}
 *         The function that was removed or undef
 */
videojs.removeHook = function (type, fn) {
  var index = videojs.hooks(type).indexOf(fn);

  if (index <= -1) {
    return false;
  }

  videojs.hooks_[type] = videojs.hooks_[type].slice();
  videojs.hooks_[type].splice(index, 1);

  return true;
};

// Add default styles
if (window_1.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {
  var style = $('.vjs-styles-defaults');

  if (!style) {
    style = createStyleElement('vjs-styles-defaults');
    var head = $('head');

    if (head) {
      head.insertBefore(style, head.firstChild);
    }
    setTextContent(style, '\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid {\n        padding-top: 56.25%\n      }\n    ');
  }
}

// Run Auto-load players
// You have to wait at least once in case this script is loaded after your
// video in the DOM (weird behavior only with minified version)
autoSetupTimeout(1, videojs);

/**
 * Current software version. Follows semver.
 *
 * @type {string}
 */
videojs.VERSION = version;

/**
 * The global options object. These are the settings that take effect
 * if no overrides are specified when the player is created.
 *
 * @type {Object}
 */
videojs.options = Player.prototype.options_;

/**
 * Get an object with the currently created players, keyed by player ID
 *
 * @return {Object}
 *         The created players
 */
videojs.getPlayers = function () {
  return Player.players;
};

/**
 * Expose players object.
 *
 * @memberOf videojs
 * @property {Object} players
 */
videojs.players = Player.players;

/**
 * Get a component class object by name
 *
 * @borrows Component.getComponent as videojs.getComponent
 */
videojs.getComponent = Component.getComponent;

/**
 * Register a component so it can referred to by name. Used when adding to other
 * components, either through addChild `component.addChild('myComponent')` or through
 * default children options  `{ children: ['myComponent'] }`.
 *
 * > NOTE: You could also just initialize the component before adding.
 * `component.addChild(new MyComponent());`
 *
 * @param {string} name
 *        The class name of the component
 *
 * @param {Component} comp
 *        The component class
 *
 * @return {Component}
 *         The newly registered component
 */
videojs.registerComponent = function (name$$1, comp) {
  if (Tech.isTech(comp)) {
    log$1.warn('The ' + name$$1 + ' tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)');
  }

  Component.registerComponent.call(Component, name$$1, comp);
};

/**
 * Get a Tech class object by name
 *
 * @borrows Tech.getTech as videojs.getTech
 */
videojs.getTech = Tech.getTech;

/**
 * Register a Tech so it can referred to by name.
 * This is used in the tech order for the player.
 *
 * @borrows Tech.registerTech as videojs.registerTech
 */
videojs.registerTech = Tech.registerTech;

videojs.use = use;

/**
 * A suite of browser and device tests from {@link browser}.
 *
 * @type {Object}
 * @private
 */
videojs.browser = browser;

/**
 * Whether or not the browser supports touch events. Included for backward
 * compatibility with 4.x, but deprecated. Use `videojs.browser.TOUCH_ENABLED`
 * instead going forward.
 *
 * @deprecated since version 5.0
 * @type {boolean}
 */
videojs.TOUCH_ENABLED = TOUCH_ENABLED;

/**
 * Subclass an existing class
 * Mimics ES6 subclassing with the `extend` keyword
 *
 * @borrows extend:extendFn as videojs.extend
 */
videojs.extend = extendFn;

/**
 * Merge two options objects recursively
 * Performs a deep merge like lodash.merge but **only merges plain objects**
 * (not arrays, elements, anything else)
 * Other values will be copied directly from the second object.
 *
 * @borrows merge-options:mergeOptions as videojs.mergeOptions
 */
videojs.mergeOptions = mergeOptions;

/**
 * Change the context (this) of a function
 *
 * > NOTE: as of v5.0 we require an ES5 shim, so you should use the native
 * `function() {}.bind(newContext);` instead of this.
 *
 * @borrows fn:bind as videojs.bind
 */
videojs.bind = bind;

/**
 * Register a Video.js plugin.
 *
 * @borrows plugin:registerPlugin as videojs.registerPlugin
 * @method registerPlugin
 *
 * @param  {string} name
 *         The name of the plugin to be registered. Must be a string and
 *         must not match an existing plugin or a method on the `Player`
 *         prototype.
 *
 * @param  {Function} plugin
 *         A sub-class of `Plugin` or a function for basic plugins.
 *
 * @return {Function}
 *         For advanced plugins, a factory function for that plugin. For
 *         basic plugins, a wrapper function that initializes the plugin.
 */
videojs.registerPlugin = Plugin.registerPlugin;

/**
 * Deprecated method to register a plugin with Video.js
 *
 * @deprecated
 *        videojs.plugin() is deprecated; use videojs.registerPlugin() instead
 *
 * @param {string} name
 *        The plugin name
 *
 * @param {Plugin|Function} plugin
 *         The plugin sub-class or function
 */
videojs.plugin = function (name$$1, plugin) {
  log$1.warn('videojs.plugin() is deprecated; use videojs.registerPlugin() instead');
  return Plugin.registerPlugin(name$$1, plugin);
};

/**
 * Gets an object containing multiple Video.js plugins.
 *
 * @param  {Array} [names]
 *         If provided, should be an array of plugin names. Defaults to _all_
 *         plugin names.
 *
 * @return {Object|undefined}
 *         An object containing plugin(s) associated with their name(s) or
 *         `undefined` if no matching plugins exist).
 */
videojs.getPlugins = Plugin.getPlugins;

/**
 * Gets a plugin by name if it exists.
 *
 * @param  {string} name
 *         The name of a plugin.
 *
 * @return {Function|undefined}
 *         The plugin (or `undefined`).
 */
videojs.getPlugin = Plugin.getPlugin;

/**
 * Gets a plugin's version, if available
 *
 * @param  {string} name
 *         The name of a plugin.
 *
 * @return {string}
 *         The plugin's version or an empty string.
 */
videojs.getPluginVersion = Plugin.getPluginVersion;

/**
 * Adding languages so that they're available to all players.
 * Example: `videojs.addLanguage('es', { 'Hello': 'Hola' });`
 *
 * @param {string} code
 *        The language code or dictionary property
 *
 * @param {Object} data
 *        The data values to be translated
 *
 * @return {Object}
 *         The resulting language dictionary object
 */
videojs.addLanguage = function (code, data) {
  var _mergeOptions;

  code = ('' + code).toLowerCase();

  videojs.options.languages = mergeOptions(videojs.options.languages, (_mergeOptions = {}, _mergeOptions[code] = data, _mergeOptions));

  return videojs.options.languages[code];
};

/**
 * Log messages
 *
 * @borrows log:log as videojs.log
 */
videojs.log = log$1;

/**
 * Creates an emulated TimeRange object.
 *
 * @borrows time-ranges:createTimeRanges as videojs.createTimeRange
 */
/**
 * @borrows time-ranges:createTimeRanges as videojs.createTimeRanges
 */
videojs.createTimeRange = videojs.createTimeRanges = createTimeRanges;

/**
 * Format seconds as a time string, H:MM:SS or M:SS
 * Supplying a guide (in seconds) will force a number of leading zeros
 * to cover the length of the guide
 *
 * @borrows format-time:formatTime as videojs.formatTime
 */
videojs.formatTime = formatTime;

/**
 * Resolve and parse the elements of a URL
 *
 * @borrows url:parseUrl as videojs.parseUrl
 */
videojs.parseUrl = parseUrl;

/**
 * Returns whether the url passed is a cross domain request or not.
 *
 * @borrows url:isCrossOrigin as videojs.isCrossOrigin
 */
videojs.isCrossOrigin = isCrossOrigin;

/**
 * Event target class.
 *
 * @borrows EventTarget as videojs.EventTarget
 */
videojs.EventTarget = EventTarget;

/**
 * Add an event listener to element
 * It stores the handler function in a separate cache object
 * and adds a generic handler to the element's event,
 * along with a unique id (guid) to the element.
 *
 * @borrows events:on as videojs.on
 */
videojs.on = on;

/**
 * Trigger a listener only once for an event
 *
 * @borrows events:one as videojs.one
 */
videojs.one = one;

/**
 * Removes event listeners from an element
 *
 * @borrows events:off as videojs.off
 */
videojs.off = off;

/**
 * Trigger an event for an element
 *
 * @borrows events:trigger as videojs.trigger
 */
videojs.trigger = trigger;

/**
 * A cross-browser XMLHttpRequest wrapper. Here's a simple example:
 *
 * @param {Object} options
 *        settings for the request.
 *
 * @return {XMLHttpRequest|XDomainRequest}
 *         The request object.
 *
 * @see https://github.com/Raynos/xhr
 */
videojs.xhr = xhr;

/**
 * TextTrack class
 *
 * @borrows TextTrack as videojs.TextTrack
 */
videojs.TextTrack = TextTrack;

/**
 * export the AudioTrack class so that source handlers can create
 * AudioTracks and then add them to the players AudioTrackList
 *
 * @borrows AudioTrack as videojs.AudioTrack
 */
videojs.AudioTrack = AudioTrack;

/**
 * export the VideoTrack class so that source handlers can create
 * VideoTracks and then add them to the players VideoTrackList
 *
 * @borrows VideoTrack as videojs.VideoTrack
 */
videojs.VideoTrack = VideoTrack;

/**
 * Determines, via duck typing, whether or not a value is a DOM element.
 *
 * @borrows dom:isEl as videojs.isEl
 * @deprecated Use videojs.dom.isEl() instead
 */

/**
 * Determines, via duck typing, whether or not a value is a text node.
 *
 * @borrows dom:isTextNode as videojs.isTextNode
 * @deprecated Use videojs.dom.isTextNode() instead
 */

/**
 * Creates an element and applies properties.
 *
 * @borrows dom:createEl as videojs.createEl
 * @deprecated Use videojs.dom.createEl() instead
 */

/**
 * Check if an element has a CSS class
 *
 * @borrows dom:hasElClass as videojs.hasClass
 * @deprecated Use videojs.dom.hasClass() instead
 */

/**
 * Add a CSS class name to an element
 *
 * @borrows dom:addElClass as videojs.addClass
 * @deprecated Use videojs.dom.addClass() instead
 */

/**
 * Remove a CSS class name from an element
 *
 * @borrows dom:removeElClass as videojs.removeClass
 * @deprecated Use videojs.dom.removeClass() instead
 */

/**
 * Adds or removes a CSS class name on an element depending on an optional
 * condition or the presence/absence of the class name.
 *
 * @borrows dom:toggleElClass as videojs.toggleClass
 * @deprecated Use videojs.dom.toggleClass() instead
 */

/**
 * Apply attributes to an HTML element.
 *
 * @borrows dom:setElAttributes as videojs.setAttribute
 * @deprecated Use videojs.dom.setAttributes() instead
 */

/**
 * Get an element's attribute values, as defined on the HTML tag
 * Attributes are not the same as properties. They're defined on the tag
 * or with setAttribute (which shouldn't be used with HTML)
 * This will return true or false for boolean attributes.
 *
 * @borrows dom:getElAttributes as videojs.getAttributes
 * @deprecated Use videojs.dom.getAttributes() instead
 */

/**
 * Empties the contents of an element.
 *
 * @borrows dom:emptyEl as videojs.emptyEl
 * @deprecated Use videojs.dom.emptyEl() instead
 */

/**
 * Normalizes and appends content to an element.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * - String
 *   Normalized into a text node.
 *
 * - Element, TextNode
 *   Passed through.
 *
 * - Array
 *   A one-dimensional array of strings, elements, nodes, or functions (which
 *   return single strings, elements, or nodes).
 *
 * - Function
 *   If the sole argument, is expected to produce a string, element,
 *   node, or array.
 *
 * @borrows dom:appendContents as videojs.appendContet
 * @deprecated Use videojs.dom.appendContent() instead
 */

/**
 * Normalizes and inserts content into an element; this is identical to
 * `appendContent()`, except it empties the element first.
 *
 * The content for an element can be passed in multiple types and
 * combinations, whose behavior is as follows:
 *
 * - String
 *   Normalized into a text node.
 *
 * - Element, TextNode
 *   Passed through.
 *
 * - Array
 *   A one-dimensional array of strings, elements, nodes, or functions (which
 *   return single strings, elements, or nodes).
 *
 * - Function
 *   If the sole argument, is expected to produce a string, element,
 *   node, or array.
 *
 * @borrows dom:insertContent as videojs.insertContent
 * @deprecated Use videojs.dom.insertContent() instead
 */
['isEl', 'isTextNode', 'createEl', 'hasClass', 'addClass', 'removeClass', 'toggleClass', 'setAttributes', 'getAttributes', 'emptyEl', 'appendContent', 'insertContent'].forEach(function (k) {
  videojs[k] = function () {
    log$1.warn('videojs.' + k + '() is deprecated; use videojs.dom.' + k + '() instead');
    return Dom[k].apply(null, arguments);
  };
});

/**
 * A safe getComputedStyle with an IE8 fallback.
 *
 * This is because in Firefox, if the player is loaded in an iframe with `display:none`,
 * then `getComputedStyle` returns `null`, so, we do a null-check to make sure
 * that the player doesn't break in these cases.
 * See https://bugzilla.mozilla.org/show_bug.cgi?id=548397 for more details.
 *
 * @borrows computed-style:computedStyle as videojs.computedStyle
 */
videojs.computedStyle = computedStyle;

/**
 * Export the Dom utilities for use in external plugins
 * and Tech's
 */
videojs.dom = Dom;

/**
 * Export the Url utilities for use in external plugins
 * and Tech's
 */
videojs.url = Url;

return videojs;

})));

!function(){!function(a){var b=a&&a.videojs;b&&(b.CDN_VERSION="6.2.8")}(window),function(a,b,c,d,e,f,g){b&&!1!==b.HELP_IMPROVE_VIDEOJS&&(e.random()>.01||(f=b.location,g=b.videojs||{},a.src="//www.google-analytics.com/__utm.gif?utmwv=5.4.2&utmac=UA-16505296-3&utmn=1&utmhn="+d(f.hostname)+"&utmsr="+b.screen.availWidth+"x"+b.screen.availHeight+"&utmul="+(c.language||c.userLanguage||"").toLowerCase()+"&utmr="+d(f.href)+"&utmp="+d(f.hostname+f.pathname)+"&utmcc=__utma%3D1."+e.floor(1e10*e.random())+".1.1.1.1%3B&utme=8(vjsv*cdnv)9("+g.VERSION+"*"+g.CDN_VERSION+")"))}(new Image,window,navigator,encodeURIComponent,Math)}();
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJsaWJzL3ZpZGVvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBWaWRlby5qcyA2LjIuOCA8aHR0cDovL3ZpZGVvanMuY29tLz5cclxuICogQ29weXJpZ2h0IEJyaWdodGNvdmUsIEluYy4gPGh0dHBzOi8vd3d3LmJyaWdodGNvdmUuY29tLz5cclxuICogQXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wXHJcbiAqIDxodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9ibG9iL21hc3Rlci9MSUNFTlNFPlxyXG4gKlxyXG4gKiBJbmNsdWRlcyB2dHQuanMgPGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3Z0dC5qcz5cclxuICogQXZhaWxhYmxlIHVuZGVyIEFwYWNoZSBMaWNlbnNlIFZlcnNpb24gMi4wXHJcbiAqIDxodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS92dHQuanMvYmxvYi9tYXN0ZXIvTElDRU5TRT5cclxuICovXHJcblxyXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xyXG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcclxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxyXG5cdChnbG9iYWwudmlkZW9qcyA9IGZhY3RvcnkoKSk7XHJcbn0odGhpcywgKGZ1bmN0aW9uICgpIHtcclxuXHJcbnZhciB2ZXJzaW9uID0gXCI2LjIuOFwiO1xyXG5cclxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XHJcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xyXG59XHJcblxyXG52YXIgd2luO1xyXG5cclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIHdpbiA9IHdpbmRvdztcclxufSBlbHNlIGlmICh0eXBlb2YgY29tbW9uanNHbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIHdpbiA9IGNvbW1vbmpzR2xvYmFsO1xyXG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXtcclxuICAgIHdpbiA9IHNlbGY7XHJcbn0gZWxzZSB7XHJcbiAgICB3aW4gPSB7fTtcclxufVxyXG5cclxudmFyIHdpbmRvd18xID0gd2luO1xyXG5cclxudmFyIGVtcHR5ID0ge307XHJcblxyXG5cclxudmFyIGVtcHR5JDEgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcclxuXHQnZGVmYXVsdCc6IGVtcHR5XHJcbn0pO1xyXG5cclxudmFyIG1pbkRvYyA9ICggZW1wdHkkMSAmJiBlbXB0eSApIHx8IGVtcHR5JDE7XHJcblxyXG52YXIgdG9wTGV2ZWwgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgIT09ICd1bmRlZmluZWQnID8gY29tbW9uanNHbG9iYWwgOlxyXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fTtcclxuXHJcblxyXG52YXIgZG9jY3k7XHJcblxyXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgZG9jY3kgPSBkb2N1bWVudDtcclxufSBlbHNlIHtcclxuICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXTtcclxuXHJcbiAgICBpZiAoIWRvY2N5KSB7XHJcbiAgICAgICAgZG9jY3kgPSB0b3BMZXZlbFsnX19HTE9CQUxfRE9DVU1FTlRfQ0FDSEVANCddID0gbWluRG9jO1xyXG4gICAgfVxyXG59XHJcblxyXG52YXIgZG9jdW1lbnRfMSA9IGRvY2N5O1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIGJyb3dzZXIuanNcclxuICogQG1vZHVsZSBicm93c2VyXHJcbiAqL1xyXG52YXIgVVNFUl9BR0VOVCA9IHdpbmRvd18xLm5hdmlnYXRvciAmJiB3aW5kb3dfMS5uYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xyXG52YXIgd2Via2l0VmVyc2lvbk1hcCA9IC9BcHBsZVdlYktpdFxcLyhbXFxkLl0rKS9pLmV4ZWMoVVNFUl9BR0VOVCk7XHJcbnZhciBhcHBsZVdlYmtpdFZlcnNpb24gPSB3ZWJraXRWZXJzaW9uTWFwID8gcGFyc2VGbG9hdCh3ZWJraXRWZXJzaW9uTWFwLnBvcCgpKSA6IG51bGw7XHJcblxyXG4vKlxyXG4gKiBEZXZpY2UgaXMgYW4gaVBob25lXHJcbiAqXHJcbiAqIEB0eXBlIHtCb29sZWFufVxyXG4gKiBAY29uc3RhbnRcclxuICogQHByaXZhdGVcclxuICovXHJcbnZhciBJU19JUEFEID0gL2lQYWQvaS50ZXN0KFVTRVJfQUdFTlQpO1xyXG5cclxuLy8gVGhlIEZhY2Vib29rIGFwcCdzIFVJV2ViVmlldyBpZGVudGlmaWVzIGFzIGJvdGggYW4gaVBob25lIGFuZCBpUGFkLCBzb1xyXG4vLyB0byBpZGVudGlmeSBpUGhvbmVzLCB3ZSBuZWVkIHRvIGV4Y2x1ZGUgaVBhZHMuXHJcbi8vIGh0dHA6Ly9hcnRzeS5naXRodWIuaW8vYmxvZy8yMDEyLzEwLzE4L3RoZS1wZXJpbHMtb2YtaW9zLXVzZXItYWdlbnQtc25pZmZpbmcvXHJcbnZhciBJU19JUEhPTkUgPSAvaVBob25lL2kudGVzdChVU0VSX0FHRU5UKSAmJiAhSVNfSVBBRDtcclxudmFyIElTX0lQT0QgPSAvaVBvZC9pLnRlc3QoVVNFUl9BR0VOVCk7XHJcbnZhciBJU19JT1MgPSBJU19JUEhPTkUgfHwgSVNfSVBBRCB8fCBJU19JUE9EO1xyXG5cclxudmFyIElPU19WRVJTSU9OID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtYXRjaCA9IFVTRVJfQUdFTlQubWF0Y2goL09TIChcXGQrKV8vaSk7XHJcblxyXG4gIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkge1xyXG4gICAgcmV0dXJuIG1hdGNoWzFdO1xyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufSgpO1xyXG5cclxudmFyIElTX0FORFJPSUQgPSAvQW5kcm9pZC9pLnRlc3QoVVNFUl9BR0VOVCk7XHJcbnZhciBBTkRST0lEX1ZFUlNJT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgLy8gVGhpcyBtYXRjaGVzIEFuZHJvaWQgTWFqb3IuTWlub3IuUGF0Y2ggdmVyc2lvbnNcclxuICAvLyBBTkRST0lEX1ZFUlNJT04gaXMgTWFqb3IuTWlub3IgYXMgYSBOdW1iZXIsIGlmIE1pbm9yIGlzbid0IGF2YWlsYWJsZSwgdGhlbiBvbmx5IE1ham9yIGlzIHJldHVybmVkXHJcbiAgdmFyIG1hdGNoID0gVVNFUl9BR0VOVC5tYXRjaCgvQW5kcm9pZCAoXFxkKykoPzpcXC4oXFxkKykpPyg/OlxcLihcXGQrKSkqL2kpO1xyXG5cclxuICBpZiAoIW1hdGNoKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHZhciBtYWpvciA9IG1hdGNoWzFdICYmIHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xyXG4gIHZhciBtaW5vciA9IG1hdGNoWzJdICYmIHBhcnNlRmxvYXQobWF0Y2hbMl0pO1xyXG5cclxuICBpZiAobWFqb3IgJiYgbWlub3IpIHtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdGNoWzFdICsgJy4nICsgbWF0Y2hbMl0pO1xyXG4gIH0gZWxzZSBpZiAobWFqb3IpIHtcclxuICAgIHJldHVybiBtYWpvcjtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn0oKTtcclxuXHJcbi8vIE9sZCBBbmRyb2lkIGlzIGRlZmluZWQgYXMgVmVyc2lvbiBvbGRlciB0aGFuIDIuMywgYW5kIHJlcXVpcmluZyBhIHdlYmtpdCB2ZXJzaW9uIG9mIHRoZSBhbmRyb2lkIGJyb3dzZXJcclxudmFyIElTX09MRF9BTkRST0lEID0gSVNfQU5EUk9JRCAmJiAvd2Via2l0L2kudGVzdChVU0VSX0FHRU5UKSAmJiBBTkRST0lEX1ZFUlNJT04gPCAyLjM7XHJcbnZhciBJU19OQVRJVkVfQU5EUk9JRCA9IElTX0FORFJPSUQgJiYgQU5EUk9JRF9WRVJTSU9OIDwgNSAmJiBhcHBsZVdlYmtpdFZlcnNpb24gPCA1Mzc7XHJcblxyXG52YXIgSVNfRklSRUZPWCA9IC9GaXJlZm94L2kudGVzdChVU0VSX0FHRU5UKTtcclxudmFyIElTX0VER0UgPSAvRWRnZS9pLnRlc3QoVVNFUl9BR0VOVCk7XHJcbnZhciBJU19DSFJPTUUgPSAhSVNfRURHRSAmJiAvQ2hyb21lL2kudGVzdChVU0VSX0FHRU5UKTtcclxudmFyIENIUk9NRV9WRVJTSU9OID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBtYXRjaCA9IFVTRVJfQUdFTlQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xyXG5cclxuICBpZiAobWF0Y2ggJiYgbWF0Y2hbMV0pIHtcclxuICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn0oKTtcclxudmFyIElTX0lFOCA9IC9NU0lFXFxzOFxcLjAvLnRlc3QoVVNFUl9BR0VOVCk7XHJcbnZhciBJRV9WRVJTSU9OID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciByZXN1bHQgPSAvTVNJRVxccyhcXGQrKVxcLlxcZC8uZXhlYyhVU0VSX0FHRU5UKTtcclxuICB2YXIgdmVyc2lvbiA9IHJlc3VsdCAmJiBwYXJzZUZsb2F0KHJlc3VsdFsxXSk7XHJcblxyXG4gIGlmICghdmVyc2lvbiAmJiAvVHJpZGVudFxcLzcuMC9pLnRlc3QoVVNFUl9BR0VOVCkgJiYgL3J2OjExLjAvLnRlc3QoVVNFUl9BR0VOVCkpIHtcclxuICAgIC8vIElFIDExIGhhcyBhIGRpZmZlcmVudCB1c2VyIGFnZW50IHN0cmluZyB0aGFuIG90aGVyIElFIHZlcnNpb25zXHJcbiAgICB2ZXJzaW9uID0gMTEuMDtcclxuICB9XHJcblxyXG4gIHJldHVybiB2ZXJzaW9uO1xyXG59KCk7XHJcblxyXG52YXIgSVNfU0FGQVJJID0gL1NhZmFyaS9pLnRlc3QoVVNFUl9BR0VOVCkgJiYgIUlTX0NIUk9NRSAmJiAhSVNfQU5EUk9JRCAmJiAhSVNfRURHRTtcclxudmFyIElTX0FOWV9TQUZBUkkgPSBJU19TQUZBUkkgfHwgSVNfSU9TO1xyXG5cclxudmFyIFRPVUNIX0VOQUJMRUQgPSBpc1JlYWwoKSAmJiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93XzEgfHwgd2luZG93XzEuRG9jdW1lbnRUb3VjaCAmJiB3aW5kb3dfMS5kb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvd18xLkRvY3VtZW50VG91Y2gpO1xyXG5cclxudmFyIEJBQ0tHUk9VTkRfU0laRV9TVVBQT1JURUQgPSBpc1JlYWwoKSAmJiAnYmFja2dyb3VuZFNpemUnIGluIHdpbmRvd18xLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJykuc3R5bGU7XHJcblxyXG52YXIgYnJvd3NlciA9IChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkoe1xyXG5cdElTX0lQQUQ6IElTX0lQQUQsXHJcblx0SVNfSVBIT05FOiBJU19JUEhPTkUsXHJcblx0SVNfSVBPRDogSVNfSVBPRCxcclxuXHRJU19JT1M6IElTX0lPUyxcclxuXHRJT1NfVkVSU0lPTjogSU9TX1ZFUlNJT04sXHJcblx0SVNfQU5EUk9JRDogSVNfQU5EUk9JRCxcclxuXHRBTkRST0lEX1ZFUlNJT046IEFORFJPSURfVkVSU0lPTixcclxuXHRJU19PTERfQU5EUk9JRDogSVNfT0xEX0FORFJPSUQsXHJcblx0SVNfTkFUSVZFX0FORFJPSUQ6IElTX05BVElWRV9BTkRST0lELFxyXG5cdElTX0ZJUkVGT1g6IElTX0ZJUkVGT1gsXHJcblx0SVNfRURHRTogSVNfRURHRSxcclxuXHRJU19DSFJPTUU6IElTX0NIUk9NRSxcclxuXHRDSFJPTUVfVkVSU0lPTjogQ0hST01FX1ZFUlNJT04sXHJcblx0SVNfSUU4OiBJU19JRTgsXHJcblx0SUVfVkVSU0lPTjogSUVfVkVSU0lPTixcclxuXHRJU19TQUZBUkk6IElTX1NBRkFSSSxcclxuXHRJU19BTllfU0FGQVJJOiBJU19BTllfU0FGQVJJLFxyXG5cdFRPVUNIX0VOQUJMRUQ6IFRPVUNIX0VOQUJMRUQsXHJcblx0QkFDS0dST1VORF9TSVpFX1NVUFBPUlRFRDogQkFDS0dST1VORF9TSVpFX1NVUFBPUlRFRFxyXG59KTtcclxuXHJcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XHJcbn0gOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xyXG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG52YXIgaW5oZXJpdHMgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcclxuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcclxuICB9XHJcblxyXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xyXG4gICAgY29uc3RydWN0b3I6IHtcclxuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfVxyXG4gIH0pO1xyXG4gIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XHJcbiAgaWYgKCFzZWxmKSB7XHJcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG52YXIgdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UgPSBmdW5jdGlvbiAoc3RyaW5ncywgcmF3KSB7XHJcbiAgc3RyaW5ncy5yYXcgPSByYXc7XHJcbiAgcmV0dXJuIHN0cmluZ3M7XHJcbn07XHJcblxyXG4vKipcclxuICogQGZpbGUgb2JqLmpzXHJcbiAqIEBtb2R1bGUgb2JqXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBjYWxsYmFjayBvYmo6RWFjaENhbGxiYWNrXHJcbiAqXHJcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXHJcbiAqICAgICAgICBUaGUgY3VycmVudCBrZXkgZm9yIHRoZSBvYmplY3QgdGhhdCBpcyBiZWluZyBpdGVyYXRlZCBvdmVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XHJcbiAqICAgICAgICBUaGUgY3VycmVudCBrZXktdmFsdWUgZm9yIG9iamVjdCB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkIG92ZXJcclxuICovXHJcblxyXG4vKipcclxuICogQGNhbGxiYWNrIG9iajpSZWR1Y2VDYWxsYmFja1xyXG4gKlxyXG4gKiBAcGFyYW0ge01peGVkfSBhY2N1bVxyXG4gKiAgICAgICAgVGhlIHZhbHVlIHRoYXQgaXMgYWNjdW11bGF0aW5nIG92ZXIgdGhlIHJlZHVjZSBsb29wLlxyXG4gKlxyXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxyXG4gKiAgICAgICAgVGhlIGN1cnJlbnQga2V5IGZvciB0aGUgb2JqZWN0IHRoYXQgaXMgYmVpbmcgaXRlcmF0ZWQgb3Zlci5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxyXG4gKiAgICAgICAgVGhlIGN1cnJlbnQga2V5LXZhbHVlIGZvciBvYmplY3QgdGhhdCBpcyBiZWluZyBpdGVyYXRlZCBvdmVyXHJcbiAqXHJcbiAqIEByZXR1cm4ge01peGVkfVxyXG4gKiAgICAgICAgIFRoZSBuZXcgYWNjdW11bGF0ZWQgdmFsdWUuXHJcbiAqL1xyXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUga2V5cyBvZiBhbiBPYmplY3RcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9XHJcbiAqICAgICAgICBUaGUgT2JqZWN0IHRvIGdldCB0aGUga2V5cyBmcm9tXHJcbiAqXHJcbiAqIEByZXR1cm4ge3N0cmluZ1tdfVxyXG4gKiAgICAgICAgIEFuIGFycmF5IG9mIHRoZSBrZXlzIGZyb20gdGhlIG9iamVjdC4gUmV0dXJucyBhbiBlbXB0eSBhcnJheSBpZiB0aGVcclxuICogICAgICAgICBvYmplY3QgcGFzc2VkIGluIHdhcyBpbnZhbGlkIG9yIGhhZCBubyBrZXlzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxudmFyIGtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xyXG4gIHJldHVybiBpc09iamVjdChvYmplY3QpID8gT2JqZWN0LmtleXMob2JqZWN0KSA6IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFycmF5LWxpa2UgaXRlcmF0aW9uIGZvciBvYmplY3RzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XHJcbiAqICAgICAgICBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3ZlclxyXG4gKlxyXG4gKiBAcGFyYW0ge29iajpFYWNoQ2FsbGJhY2t9IGZuXHJcbiAqICAgICAgICBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGZvciBlYWNoIGtleSBpbiB0aGUgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gZWFjaChvYmplY3QsIGZuKSB7XHJcbiAga2V5cyhvYmplY3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgcmV0dXJuIGZuKG9iamVjdFtrZXldLCBrZXkpO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQXJyYXktbGlrZSByZWR1Y2UgZm9yIG9iamVjdHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcclxuICogICAgICAgIFRoZSBPYmplY3QgdGhhdCB5b3Ugd2FudCB0byByZWR1Y2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqICAgICAgICAgQSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZm9yIGVhY2gga2V5IGluIHRoZSBvYmplY3QuIEl0XHJcbiAqICAgICAgICAgcmVjZWl2ZXMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlIGFuZCB0aGUgcGVyLWl0ZXJhdGlvbiB2YWx1ZSBhbmQga2V5XHJcbiAqICAgICAgICAgYXMgYXJndW1lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge01peGVkfSBbaW5pdGlhbCA9IDBdXHJcbiAqICAgICAgICBTdGFydGluZyB2YWx1ZVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtNaXhlZH1cclxuICogICAgICAgICBUaGUgZmluYWwgYWNjdW11bGF0ZWQgdmFsdWUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWR1Y2Uob2JqZWN0LCBmbikge1xyXG4gIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xyXG5cclxuICByZXR1cm4ga2V5cyhvYmplY3QpLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGtleSkge1xyXG4gICAgcmV0dXJuIGZuKGFjY3VtLCBvYmplY3Rba2V5XSwga2V5KTtcclxuICB9LCBpbml0aWFsKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE9iamVjdC5hc3NpZ24tc3R5bGUgb2JqZWN0IHNoYWxsb3cgbWVyZ2UvZXh0ZW5kLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IC4uLnNvdXJjZXNcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKi9cclxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xyXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xyXG4gICAgc291cmNlc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgfVxyXG5cclxuICBpZiAoT2JqZWN0LmFzc2lnbikge1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBbdGFyZ2V0XS5jb25jYXQoc291cmNlcykpO1xyXG4gIH1cclxuXHJcbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgIGlmICghc291cmNlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBlYWNoKHNvdXJjZSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIGEgdmFsdWUgaXMgYW4gb2JqZWN0IG9mIGFueSBraW5kIC0gaW5jbHVkaW5nIERPTSBub2RlcyxcclxuICogYXJyYXlzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBldGMuIE5vdCBmdW5jdGlvbnMsIHRob3VnaC5cclxuICpcclxuICogVGhpcyBhdm9pZHMgdGhlIGdvdGNoYSB3aGVyZSB1c2luZyBgdHlwZW9mYCBvbiBhIGBudWxsYCB2YWx1ZVxyXG4gKiByZXN1bHRzIGluIGAnb2JqZWN0J2AuXHJcbiAqXHJcbiAqIEBwYXJhbSAge09iamVjdH0gdmFsdWVcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XHJcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PT0gJ29iamVjdCc7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGFwcGVhcnMgdG8gYmUgYSBcInBsYWluXCIgb2JqZWN0IC0gdGhhdCBpcywgYVxyXG4gKiBkaXJlY3QgaW5zdGFuY2Ugb2YgYE9iamVjdGAuXHJcbiAqXHJcbiAqIEBwYXJhbSAge09iamVjdH0gdmFsdWVcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzUGxhaW4odmFsdWUpIHtcclxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xyXG59XHJcblxyXG4vKipcclxuICogQGZpbGUgbG9nLmpzXHJcbiAqIEBtb2R1bGUgbG9nXHJcbiAqL1xyXG52YXIgbG9nID0gdm9pZCAwO1xyXG5cclxuLy8gVGhpcyBpcyB0aGUgcHJpdmF0ZSB0cmFja2luZyB2YXJpYWJsZSBmb3IgbG9nZ2luZyBsZXZlbC5cclxudmFyIGxldmVsID0gJ2FsbCc7XHJcblxyXG4vLyBUaGlzIGlzIHRoZSBwcml2YXRlIHRyYWNraW5nIHZhcmlhYmxlIGZvciB0aGUgbG9nZ2luZyBoaXN0b3J5LlxyXG52YXIgaGlzdG9yeSA9IFtdO1xyXG5cclxuLyoqXHJcbiAqIExvZyBtZXNzYWdlcyB0byB0aGUgY29uc29sZSBhbmQgaGlzdG9yeSBiYXNlZCBvbiB0aGUgdHlwZSBvZiBtZXNzYWdlXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gdHlwZVxyXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBjb25zb2xlIG1ldGhvZCB0byB1c2UuXHJcbiAqXHJcbiAqIEBwYXJhbSAge0FycmF5fSBhcmdzXHJcbiAqICAgICAgICAgVGhlIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gdGhlIG1hdGNoaW5nIGNvbnNvbGUgbWV0aG9kLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBbc3RyaW5naWZ5XVxyXG4gKiAgICAgICAgIEJ5IGRlZmF1bHQsIG9ubHkgb2xkIElFcyBzaG91bGQgZ2V0IGNvbnNvbGUgYXJndW1lbnQgc3RyaW5naWZpY2F0aW9uLFxyXG4gKiAgICAgICAgIGJ1dCB0aGlzIGlzIGV4cG9zZWQgYXMgYSBwYXJhbWV0ZXIgdG8gZmFjaWxpdGF0ZSB0ZXN0aW5nLlxyXG4gKi9cclxudmFyIGxvZ0J5VHlwZSA9IGZ1bmN0aW9uIGxvZ0J5VHlwZSh0eXBlLCBhcmdzKSB7XHJcbiAgdmFyIHN0cmluZ2lmeSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogISFJRV9WRVJTSU9OICYmIElFX1ZFUlNJT04gPCAxMTtcclxuXHJcbiAgdmFyIGx2bCA9IGxvZy5sZXZlbHNbbGV2ZWxdO1xyXG4gIHZhciBsdmxSZWdFeHAgPSBuZXcgUmVnRXhwKCdeKCcgKyBsdmwgKyAnKSQnKTtcclxuXHJcbiAgaWYgKHR5cGUgIT09ICdsb2cnKSB7XHJcblxyXG4gICAgLy8gQWRkIHRoZSB0eXBlIHRvIHRoZSBmcm9udCBvZiB0aGUgbWVzc2FnZSB3aGVuIGl0J3Mgbm90IFwibG9nXCIuXHJcbiAgICBhcmdzLnVuc2hpZnQodHlwZS50b1VwcGVyQ2FzZSgpICsgJzonKTtcclxuICB9XHJcblxyXG4gIC8vIEFkZCBhIGNsb25lIG9mIHRoZSBhcmdzIGF0IHRoaXMgcG9pbnQgdG8gaGlzdG9yeS5cclxuICBpZiAoaGlzdG9yeSkge1xyXG4gICAgaGlzdG9yeS5wdXNoKFtdLmNvbmNhdChhcmdzKSk7XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgY29uc29sZSBwcmVmaXggYWZ0ZXIgYWRkaW5nIHRvIGhpc3RvcnkuXHJcbiAgYXJncy51bnNoaWZ0KCdWSURFT0pTOicpO1xyXG5cclxuICAvLyBJZiB0aGVyZSdzIG5vIGNvbnNvbGUgdGhlbiBkb24ndCB0cnkgdG8gb3V0cHV0IG1lc3NhZ2VzLCBidXQgdGhleSB3aWxsXHJcbiAgLy8gc3RpbGwgYmUgc3RvcmVkIGluIGhpc3RvcnkuXHJcbiAgLy9cclxuICAvLyBXYXMgc2V0dGluZyB0aGVzZSBvbmNlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbiwgYnV0IGNvbnRhaW5pbmcgdGhlbVxyXG4gIC8vIGluIHRoZSBmdW5jdGlvbiBtYWtlcyBpdCBlYXNpZXIgdG8gdGVzdCBjYXNlcyB3aGVyZSBjb25zb2xlIGRvZXNuJ3QgZXhpc3RcclxuICAvLyB3aGVuIHRoZSBtb2R1bGUgaXMgZXhlY3V0ZWQuXHJcbiAgdmFyIGZuID0gd2luZG93XzEuY29uc29sZSAmJiB3aW5kb3dfMS5jb25zb2xlW3R5cGVdO1xyXG5cclxuICAvLyBCYWlsIG91dCBpZiB0aGVyZSdzIG5vIGNvbnNvbGUgb3IgaWYgdGhpcyB0eXBlIGlzIG5vdCBhbGxvd2VkIGJ5IHRoZVxyXG4gIC8vIGN1cnJlbnQgbG9nZ2luZyBsZXZlbC5cclxuICBpZiAoIWZuIHx8ICFsdmwgfHwgIWx2bFJlZ0V4cC50ZXN0KHR5cGUpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBJRXMgcHJldmlvdXMgdG8gMTEgbG9nIG9iamVjdHMgdXNlbGVzc2x5IGFzIFwiW29iamVjdCBPYmplY3RdXCI7IHNvLCBKU09OaWZ5XHJcbiAgLy8gb2JqZWN0cyBhbmQgYXJyYXlzIGZvciB0aG9zZSBsZXNzLWNhcGFibGUgYnJvd3NlcnMuXHJcbiAgaWYgKHN0cmluZ2lmeSkge1xyXG4gICAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgIGlmIChpc09iamVjdChhKSB8fCBBcnJheS5pc0FycmF5KGEpKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhKTtcclxuICAgICAgICB9IGNhdGNoICh4KSB7XHJcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2FzdCB0byBzdHJpbmcgYmVmb3JlIGpvaW5pbmcsIHNvIHdlIGdldCBudWxsIGFuZCB1bmRlZmluZWQgZXhwbGljaXRseVxyXG4gICAgICAvLyBpbmNsdWRlZCBpbiBvdXRwdXQgKGFzIHdlIHdvdWxkIGluIGEgbW9kZXJuIGNvbnNvbGUpLlxyXG4gICAgICByZXR1cm4gU3RyaW5nKGEpO1xyXG4gICAgfSkuam9pbignICcpO1xyXG4gIH1cclxuXHJcbiAgLy8gT2xkIElFIHZlcnNpb25zIGRvIG5vdCBhbGxvdyAuYXBwbHkoKSBmb3IgY29uc29sZSBtZXRob2RzICh0aGV5IGFyZVxyXG4gIC8vIHJlcG9ydGVkIGFzIG9iamVjdHMgcmF0aGVyIHRoYW4gZnVuY3Rpb25zKS5cclxuICBpZiAoIWZuLmFwcGx5KSB7XHJcbiAgICBmbihhcmdzKTtcclxuICB9IGVsc2Uge1xyXG4gICAgZm5bQXJyYXkuaXNBcnJheShhcmdzKSA/ICdhcHBseScgOiAnY2FsbCddKHdpbmRvd18xLmNvbnNvbGUsIGFyZ3MpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBMb2dzIHBsYWluIGRlYnVnIG1lc3NhZ2VzLiBTaW1pbGFyIHRvIGBjb25zb2xlLmxvZ2AuXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKiBAcGFyYW0gICAge01peGVkW119IGFyZ3NcclxuICogICAgICAgICAgIE9uZSBvciBtb3JlIG1lc3NhZ2VzIG9yIG9iamVjdHMgdGhhdCBzaG91bGQgYmUgbG9nZ2VkLlxyXG4gKi9cclxubG9nID0gZnVuY3Rpb24gbG9nKCkge1xyXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xyXG4gIH1cclxuXHJcbiAgbG9nQnlUeXBlKCdsb2cnLCBhcmdzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbnVtZXJhdGlvbiBvZiBhdmFpbGFibGUgbG9nZ2luZyBsZXZlbHMsIHdoZXJlIHRoZSBrZXlzIGFyZSB0aGUgbGV2ZWwgbmFtZXNcclxuICogYW5kIHRoZSB2YWx1ZXMgYXJlIGB8YC1zZXBhcmF0ZWQgc3RyaW5ncyBjb250YWluaW5nIGxvZ2dpbmcgbWV0aG9kcyBhbGxvd2VkXHJcbiAqIGluIHRoYXQgbG9nZ2luZyBsZXZlbC4gVGhlc2Ugc3RyaW5ncyBhcmUgdXNlZCB0byBjcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb25cclxuICogbWF0Y2hpbmcgdGhlIGZ1bmN0aW9uIG5hbWUgYmVpbmcgY2FsbGVkLlxyXG4gKlxyXG4gKiBMZXZlbHMgcHJvdmlkZWQgYnkgdmlkZW8uanMgYXJlOlxyXG4gKlxyXG4gKiAtIGBvZmZgOiBNYXRjaGVzIG5vIGNhbGxzLiBBbnkgdmFsdWUgdGhhdCBjYW4gYmUgY2FzdCB0byBgZmFsc2VgIHdpbGwgaGF2ZVxyXG4gKiAgIHRoaXMgZWZmZWN0LiBUaGUgbW9zdCByZXN0cmljdGl2ZS5cclxuICogLSBgYWxsYCAoZGVmYXVsdCk6IE1hdGNoZXMgb25seSBWaWRlby5qcy1wcm92aWRlZCBmdW5jdGlvbnMgKGBsb2dgLFxyXG4gKiAgIGBsb2cud2FybmAsIGFuZCBgbG9nLmVycm9yYCkuXHJcbiAqIC0gYHdhcm5gOiBNYXRjaGVzIGBsb2cud2FybmAgYW5kIGBsb2cuZXJyb3JgIGNhbGxzLlxyXG4gKiAtIGBlcnJvcmA6IE1hdGNoZXMgb25seSBgbG9nLmVycm9yYCBjYWxscy5cclxuICpcclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbmxvZy5sZXZlbHMgPSB7XHJcbiAgYWxsOiAnbG9nfHdhcm58ZXJyb3InLFxyXG4gIGVycm9yOiAnZXJyb3InLFxyXG4gIG9mZjogJycsXHJcbiAgd2FybjogJ3dhcm58ZXJyb3InLFxyXG4gIERFRkFVTFQ6IGxldmVsXHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IG9yIHNldCB0aGUgY3VycmVudCBsb2dnaW5nIGxldmVsLiBJZiBhIHN0cmluZyBtYXRjaGluZyBhIGtleSBmcm9tXHJcbiAqIHtAbGluayBsb2cubGV2ZWxzfSBpcyBwcm92aWRlZCwgYWN0cyBhcyBhIHNldHRlci4gUmVnYXJkbGVzcyBvZiBhcmd1bWVudCxcclxuICogcmV0dXJucyB0aGUgY3VycmVudCBsb2dnaW5nIGxldmVsLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IFtsdmxdXHJcbiAqICAgICAgICAgUGFzcyB0byBzZXQgYSBuZXcgbG9nZ2luZyBsZXZlbC5cclxuICpcclxuICogQHJldHVybiB7c3RyaW5nfVxyXG4gKiAgICAgICAgIFRoZSBjdXJyZW50IGxvZ2dpbmcgbGV2ZWwuXHJcbiAqL1xyXG5sb2cubGV2ZWwgPSBmdW5jdGlvbiAobHZsKSB7XHJcbiAgaWYgKHR5cGVvZiBsdmwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBpZiAoIWxvZy5sZXZlbHMuaGFzT3duUHJvcGVydHkobHZsKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGx2bCArICdcIiBpbiBub3QgYSB2YWxpZCBsb2cgbGV2ZWwnKTtcclxuICAgIH1cclxuICAgIGxldmVsID0gbHZsO1xyXG4gIH1cclxuICByZXR1cm4gbGV2ZWw7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGV2ZXJ5dGhpbmcgdGhhdCBoYXMgYmVlbiBsb2dnZWQgdG8gdGhlIGhpc3RvcnkuXHJcbiAqXHJcbiAqIFRoaXMgYXJyYXkgaXMgYSBzaGFsbG93IGNsb25lIG9mIHRoZSBpbnRlcm5hbCBoaXN0b3J5IHJlY29yZC4gSG93ZXZlciwgaXRzXHJcbiAqIGNvbnRlbnRzIGFyZSBfbm90XyBjbG9uZWQ7IHNvLCBtdXRhdGluZyBvYmplY3RzIGluc2lkZSB0aGlzIGFycmF5IHdpbGxcclxuICogbXV0YXRlIHRoZW0gaW4gaGlzdG9yeS5cclxuICpcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5sb2cuaGlzdG9yeSA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gaGlzdG9yeSA/IFtdLmNvbmNhdChoaXN0b3J5KSA6IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENsZWFycyB0aGUgaW50ZXJuYWwgaGlzdG9yeSB0cmFja2luZywgYnV0IGRvZXMgbm90IHByZXZlbnQgZnVydGhlciBoaXN0b3J5XHJcbiAqIHRyYWNraW5nLlxyXG4gKi9cclxubG9nLmhpc3RvcnkuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKGhpc3RvcnkpIHtcclxuICAgIGhpc3RvcnkubGVuZ3RoID0gMDtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRGlzYWJsZSBoaXN0b3J5IHRyYWNraW5nIGlmIGl0IGlzIGN1cnJlbnRseSBlbmFibGVkLlxyXG4gKi9cclxubG9nLmhpc3RvcnkuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICBpZiAoaGlzdG9yeSAhPT0gbnVsbCkge1xyXG4gICAgaGlzdG9yeS5sZW5ndGggPSAwO1xyXG4gICAgaGlzdG9yeSA9IG51bGw7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVuYWJsZSBoaXN0b3J5IHRyYWNraW5nIGlmIGl0IGlzIGN1cnJlbnRseSBkaXNhYmxlZC5cclxuICovXHJcbmxvZy5oaXN0b3J5LmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICBpZiAoaGlzdG9yeSA9PT0gbnVsbCkge1xyXG4gICAgaGlzdG9yeSA9IFtdO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBMb2dzIGVycm9yIG1lc3NhZ2VzLiBTaW1pbGFyIHRvIGBjb25zb2xlLmVycm9yYC5cclxuICpcclxuICogQHBhcmFtIHtNaXhlZFtdfSBhcmdzXHJcbiAqICAgICAgICBPbmUgb3IgbW9yZSBtZXNzYWdlcyBvciBvYmplY3RzIHRoYXQgc2hvdWxkIGJlIGxvZ2dlZCBhcyBhbiBlcnJvclxyXG4gKi9cclxubG9nLmVycm9yID0gZnVuY3Rpb24gKCkge1xyXG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XHJcbiAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbG9nQnlUeXBlKCdlcnJvcicsIGFyZ3MpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIExvZ3Mgd2FybmluZyBtZXNzYWdlcy4gU2ltaWxhciB0byBgY29uc29sZS53YXJuYC5cclxuICpcclxuICogQHBhcmFtIHtNaXhlZFtdfSBhcmdzXHJcbiAqICAgICAgICBPbmUgb3IgbW9yZSBtZXNzYWdlcyBvciBvYmplY3RzIHRoYXQgc2hvdWxkIGJlIGxvZ2dlZCBhcyBhIHdhcm5pbmcuXHJcbiAqL1xyXG5sb2cud2FybiA9IGZ1bmN0aW9uICgpIHtcclxuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xyXG4gICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGxvZ0J5VHlwZSgnd2FybicsIGFyZ3MpO1xyXG59O1xyXG5cclxudmFyIGxvZyQxID0gbG9nO1xyXG5cclxuZnVuY3Rpb24gY2xlYW4gKHMpIHtcclxuICByZXR1cm4gcy5yZXBsYWNlKC9cXG5cXHI/XFxzKi9nLCAnJylcclxufVxyXG5cclxuXHJcbnZhciB0c21sID0gZnVuY3Rpb24gdHNtbCAoc2EpIHtcclxuICB2YXIgcyA9ICcnXHJcbiAgICAsIGkgPSAwO1xyXG5cclxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgIHMgKz0gY2xlYW4oc2FbaV0pICsgKGFyZ3VtZW50c1tpICsgMV0gfHwgJycpO1xyXG5cclxuICByZXR1cm4gc1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIGNvbXB1dGVkLXN0eWxlLmpzXHJcbiAqIEBtb2R1bGUgY29tcHV0ZWQtc3R5bGVcclxuICovXHJcbi8qKlxyXG4gKiBBIHNhZmUgZ2V0Q29tcHV0ZWRTdHlsZSB3aXRoIGFuIElFOCBmYWxsYmFjay5cclxuICpcclxuICogVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBpbiBGaXJlZm94LCBpZiB0aGUgcGxheWVyIGlzIGxvYWRlZCBpbiBhbiBpZnJhbWUgd2l0aFxyXG4gKiBgZGlzcGxheTpub25lYCwgdGhlbiBgZ2V0Q29tcHV0ZWRTdHlsZWAgcmV0dXJucyBgbnVsbGAsIHNvLCB3ZSBkbyBhIG51bGwtY2hlY2sgdG9cclxuICogbWFrZSBzdXJlICB0aGF0IHRoZSBwbGF5ZXIgZG9lc24ndCBicmVhayBpbiB0aGVzZSBjYXNlcy5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxyXG4gKiAgICAgICAgVGhlIGVsZW1lbnQgeW91IHdhbnQgdGhlIGNvbXB1dGVkIHN0eWxlIG9mXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXHJcbiAqICAgICAgICBUaGUgcHJvcGVydHkgbmFtZSB5b3Ugd2FudFxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBjb25zdFxyXG4gKi9cclxuZnVuY3Rpb24gY29tcHV0ZWRTdHlsZShlbCwgcHJvcCkge1xyXG4gIGlmICghZWwgfHwgIXByb3ApIHtcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2Ygd2luZG93XzEuZ2V0Q29tcHV0ZWRTdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgdmFyIGNzID0gd2luZG93XzEuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XHJcblxyXG4gICAgcmV0dXJuIGNzID8gY3NbcHJvcF0gOiAnJztcclxuICB9XHJcblxyXG4gIHJldHVybiBlbC5jdXJyZW50U3R5bGVbcHJvcF0gfHwgJyc7XHJcbn1cclxuXHJcbnZhciBfdGVtcGxhdGVPYmplY3QgPSB0YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZShbJ1NldHRpbmcgYXR0cmlidXRlcyBpbiB0aGUgc2Vjb25kIGFyZ3VtZW50IG9mIGNyZWF0ZUVsKClcXG4gICAgICAgICAgICAgICAgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIHRoZSB0aGlyZCBhcmd1bWVudCBpbnN0ZWFkLlxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbCh0eXBlLCBwcm9wZXJ0aWVzLCBhdHRyaWJ1dGVzKS4gQXR0ZW1wdGluZyB0byBzZXQgJywgJyB0byAnLCAnLiddLCBbJ1NldHRpbmcgYXR0cmlidXRlcyBpbiB0aGUgc2Vjb25kIGFyZ3VtZW50IG9mIGNyZWF0ZUVsKClcXG4gICAgICAgICAgICAgICAgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIHRoZSB0aGlyZCBhcmd1bWVudCBpbnN0ZWFkLlxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbCh0eXBlLCBwcm9wZXJ0aWVzLCBhdHRyaWJ1dGVzKS4gQXR0ZW1wdGluZyB0byBzZXQgJywgJyB0byAnLCAnLiddKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBkb20uanNcclxuICogQG1vZHVsZSBkb21cclxuICovXHJcbi8qKlxyXG4gKiBEZXRlY3QgaWYgYSB2YWx1ZSBpcyBhIHN0cmluZyB3aXRoIGFueSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAqICAgICAgICBUaGUgc3RyaW5nIHRvIGNoZWNrXHJcbiAqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqICAgICAgICAgLSBUcnVlIGlmIHRoZSBzdHJpbmcgaXMgbm9uLWJsYW5rXHJcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGlzTm9uQmxhbmtTdHJpbmcoc3RyKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnICYmIC9cXFMvLnRlc3Qoc3RyKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcGFzc2VkIHN0cmluZyBoYXMgd2hpdGVzcGFjZS4gVGhpcyBpcyB1c2VkIGJ5XHJcbiAqIGNsYXNzIG1ldGhvZHMgdG8gYmUgcmVsYXRpdmVseSBjb25zaXN0ZW50IHdpdGggdGhlIGNsYXNzTGlzdCBBUEkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogICAgICAgICBUaGUgc3RyaW5nIHRvIGNoZWNrIGZvciB3aGl0ZXNwYWNlLlxyXG4gKlxyXG4gKiBAdGhyb3dzIHtFcnJvcn1cclxuICogICAgICAgICBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgaXMgd2hpdGVzcGFjZSBpbiB0aGUgc3RyaW5nLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gdGhyb3dJZldoaXRlc3BhY2Uoc3RyKSB7XHJcbiAgaWYgKC9cXHMvLnRlc3Qoc3RyKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGFzcyBoYXMgaWxsZWdhbCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMnKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQcm9kdWNlIGEgcmVndWxhciBleHByZXNzaW9uIGZvciBtYXRjaGluZyBhIGNsYXNzTmFtZSB3aXRoaW4gYW4gZWxlbWVudHMgY2xhc3NOYW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXHJcbiAqICAgICAgICAgVGhlIGNsYXNzTmFtZSB0byBnZW5lcmF0ZSB0aGUgUmVnRXhwIGZvci5cclxuICpcclxuICogQHJldHVybiB7UmVnRXhwfVxyXG4gKiAgICAgICAgIFRoZSBSZWdFeHAgdGhhdCB3aWxsIGNoZWNrIGZvciBhIHNwZWNpZmljIGBjbGFzc05hbWVgIGluIGFuIGVsZW1lbnRzXHJcbiAqICAgICAgICAgY2xhc3NOYW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gY2xhc3NSZWdFeHAoY2xhc3NOYW1lKSB7XHJcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBjbGFzc05hbWUgKyAnKCR8XFxcXHMpJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXaGV0aGVyIHRoZSBjdXJyZW50IERPTSBpbnRlcmZhY2UgYXBwZWFycyB0byBiZSByZWFsLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKi9cclxuZnVuY3Rpb24gaXNSZWFsKCkge1xyXG4gIHJldHVybiAoXHJcblxyXG4gICAgLy8gQm90aCBkb2N1bWVudCBhbmQgd2luZG93IHdpbGwgbmV2ZXIgYmUgdW5kZWZpbmVkIHRoYW5rcyB0byBgZ2xvYmFsYC5cclxuICAgIGRvY3VtZW50XzEgPT09IHdpbmRvd18xLmRvY3VtZW50ICYmXHJcblxyXG4gICAgLy8gSW4gSUUgPCA5LCBET00gbWV0aG9kcyByZXR1cm4gXCJvYmplY3RcIiBhcyB0aGVpciB0eXBlLCBzbyBhbGwgd2UgY2FuXHJcbiAgICAvLyBjb25maWRlbnRseSBjaGVjayBpcyB0aGF0IGl0IGV4aXN0cy5cclxuICAgIHR5cGVvZiBkb2N1bWVudF8xLmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMsIHZpYSBkdWNrIHR5cGluZywgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIERPTSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxyXG4gKiAgICAgICAgVGhlIHRoaW5nIHRvIGNoZWNrXHJcbiAqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqICAgICAgICAgLSBUcnVlIGlmIGl0IGlzIGEgRE9NIGVsZW1lbnRcclxuICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNFbCh2YWx1ZSkge1xyXG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGZ1bmN0aW9ucyB0byBxdWVyeSB0aGUgRE9NIHVzaW5nIGEgZ2l2ZW4gbWV0aG9kLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXHJcbiAqICAgICAgICAgVGhlIG1ldGhvZCB0byBjcmVhdGUgdGhlIHF1ZXJ5IHdpdGguXHJcbiAqXHJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxyXG4gKiAgICAgICAgIFRoZSBxdWVyeSBtZXRob2RcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVF1ZXJpZXIobWV0aG9kKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChzZWxlY3RvciwgY29udGV4dCkge1xyXG4gICAgaWYgKCFpc05vbkJsYW5rU3RyaW5nKHNlbGVjdG9yKSkge1xyXG4gICAgICByZXR1cm4gZG9jdW1lbnRfMVttZXRob2RdKG51bGwpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzTm9uQmxhbmtTdHJpbmcoY29udGV4dCkpIHtcclxuICAgICAgY29udGV4dCA9IGRvY3VtZW50XzEucXVlcnlTZWxlY3Rvcihjb250ZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY3R4ID0gaXNFbChjb250ZXh0KSA/IGNvbnRleHQgOiBkb2N1bWVudF8xO1xyXG5cclxuICAgIHJldHVybiBjdHhbbWV0aG9kXSAmJiBjdHhbbWV0aG9kXShzZWxlY3Rvcik7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gZWxlbWVudCBhbmQgYXBwbGllcyBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RhZ05hbWU9J2RpdiddXHJcbiAqICAgICAgICAgTmFtZSBvZiB0YWcgdG8gYmUgY3JlYXRlZC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XVxyXG4gKiAgICAgICAgIEVsZW1lbnQgcHJvcGVydGllcyB0byBiZSBhcHBsaWVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXM9e31dXHJcbiAqICAgICAgICAgRWxlbWVudCBhdHRyaWJ1dGVzIHRvIGJlIGFwcGxpZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8VGV4dE5vZGV8QXJyYXl8RnVuY3Rpb259IFtjb250ZW50XVxyXG4gKiAgICAgICAgIENvbnRlbnRzIGZvciB0aGUgZWxlbWVudCAoc2VlOiB7QGxpbmsgZG9tOm5vcm1hbGl6ZUNvbnRlbnR9KVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVFbCgpIHtcclxuICB2YXIgdGFnTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ2Rpdic7XHJcbiAgdmFyIHByb3BlcnRpZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xyXG4gIHZhciBhdHRyaWJ1dGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcclxuICB2YXIgY29udGVudCA9IGFyZ3VtZW50c1szXTtcclxuXHJcbiAgdmFyIGVsID0gZG9jdW1lbnRfMS5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xyXG5cclxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xyXG4gICAgdmFyIHZhbCA9IHByb3BlcnRpZXNbcHJvcE5hbWVdO1xyXG5cclxuICAgIC8vIFNlZSAjMjE3NlxyXG4gICAgLy8gV2Ugb3JpZ2luYWxseSB3ZXJlIGFjY2VwdGluZyBib3RoIHByb3BlcnRpZXMgYW5kIGF0dHJpYnV0ZXMgaW4gdGhlXHJcbiAgICAvLyBzYW1lIG9iamVjdCwgYnV0IHRoYXQgZG9lc24ndCB3b3JrIHNvIHdlbGwuXHJcbiAgICBpZiAocHJvcE5hbWUuaW5kZXhPZignYXJpYS0nKSAhPT0gLTEgfHwgcHJvcE5hbWUgPT09ICdyb2xlJyB8fCBwcm9wTmFtZSA9PT0gJ3R5cGUnKSB7XHJcbiAgICAgIGxvZyQxLndhcm4odHNtbChfdGVtcGxhdGVPYmplY3QsIHByb3BOYW1lLCB2YWwpKTtcclxuICAgICAgZWwuc2V0QXR0cmlidXRlKHByb3BOYW1lLCB2YWwpO1xyXG5cclxuICAgICAgLy8gSGFuZGxlIHRleHRDb250ZW50IHNpbmNlIGl0J3Mgbm90IHN1cHBvcnRlZCBldmVyeXdoZXJlIGFuZCB3ZSBoYXZlIGFcclxuICAgICAgLy8gbWV0aG9kIGZvciBpdC5cclxuICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgPT09ICd0ZXh0Q29udGVudCcpIHtcclxuICAgICAgdGV4dENvbnRlbnQoZWwsIHZhbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbFtwcm9wTmFtZV0gPSB2YWw7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJOYW1lKSB7XHJcbiAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJpYnV0ZXNbYXR0ck5hbWVdKTtcclxuICB9KTtcclxuXHJcbiAgaWYgKGNvbnRlbnQpIHtcclxuICAgIGFwcGVuZENvbnRlbnQoZWwsIGNvbnRlbnQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVsO1xyXG59XHJcblxyXG4vKipcclxuICogSW5qZWN0cyB0ZXh0IGludG8gYW4gZWxlbWVudCwgcmVwbGFjaW5nIGFueSBleGlzdGluZyBjb250ZW50cyBlbnRpcmVseS5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxyXG4gKiAgICAgICAgVGhlIGVsZW1lbnQgdG8gYWRkIHRleHQgY29udGVudCBpbnRvXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XHJcbiAqICAgICAgICBUaGUgdGV4dCBjb250ZW50IHRvIGFkZC5cclxuICpcclxuICogQHJldHVybiB7RWxlbWVudH1cclxuICogICAgICAgICBUaGUgZWxlbWVudCB3aXRoIGFkZGVkIHRleHQgY29udGVudC5cclxuICovXHJcbmZ1bmN0aW9uIHRleHRDb250ZW50KGVsLCB0ZXh0KSB7XHJcbiAgaWYgKHR5cGVvZiBlbC50ZXh0Q29udGVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGVsLmlubmVyVGV4dCA9IHRleHQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcclxuICB9XHJcbiAgcmV0dXJuIGVsO1xyXG59XHJcblxyXG4vKipcclxuICogSW5zZXJ0IGFuIGVsZW1lbnQgYXMgdGhlIGZpcnN0IGNoaWxkIG5vZGUgb2YgYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNoaWxkXHJcbiAqICAgICAgICBFbGVtZW50IHRvIGluc2VydFxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFxyXG4gKiAgICAgICAgRWxlbWVudCB0byBpbnNlcnQgY2hpbGQgaW50b1xyXG4gKi9cclxuZnVuY3Rpb24gcHJlcGVuZFRvKGNoaWxkLCBwYXJlbnQpIHtcclxuICBpZiAocGFyZW50LmZpcnN0Q2hpbGQpIHtcclxuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHBhcmVudC5maXJzdENoaWxkKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IGhhcyBhIENTUyBjbGFzc1xyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcclxuICogICAgICAgIEVsZW1lbnQgdG8gY2hlY2tcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9DaGVja1xyXG4gKiAgICAgICAgQ2xhc3MgbmFtZSB0byBjaGVjayBmb3JcclxuICpcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICogICAgICAgICAtIFRydWUgaWYgdGhlIGVsZW1lbnQgaGFkIHRoZSBjbGFzc1xyXG4gKiAgICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKlxyXG4gKiBAdGhyb3dzIHtFcnJvcn1cclxuICogICAgICAgICBUaHJvd3MgYW4gZXJyb3IgaWYgYGNsYXNzVG9DaGVja2AgaGFzIHdoaXRlIHNwYWNlLlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NUb0NoZWNrKSB7XHJcbiAgdGhyb3dJZldoaXRlc3BhY2UoY2xhc3NUb0NoZWNrKTtcclxuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcclxuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc1RvQ2hlY2spO1xyXG4gIH1cclxuICByZXR1cm4gY2xhc3NSZWdFeHAoY2xhc3NUb0NoZWNrKS50ZXN0KGVsZW1lbnQuY2xhc3NOYW1lKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFkZCBhIENTUyBjbGFzcyBuYW1lIHRvIGFuIGVsZW1lbnRcclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAqICAgICAgICBFbGVtZW50IHRvIGFkZCBjbGFzcyBuYW1lIHRvLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NUb0FkZFxyXG4gKiAgICAgICAgQ2xhc3MgbmFtZSB0byBhZGQuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAqICAgICAgICAgVGhlIGRvbSBlbGVtZW50IHdpdGggdGhlIGFkZGVkIGNsYXNzIG5hbWUuXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc1RvQWRkKSB7XHJcbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XHJcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NUb0FkZCk7XHJcblxyXG4gICAgLy8gRG9uJ3QgbmVlZCB0byBgdGhyb3dJZldoaXRlc3BhY2VgIGhlcmUgYmVjYXVzZSBgaGFzRWxDbGFzc2Agd2lsbCBkbyBpdFxyXG4gICAgLy8gaW4gdGhlIGNhc2Ugb2YgY2xhc3NMaXN0IG5vdCBiZWluZyBzdXBwb3J0ZWQuXHJcbiAgfSBlbHNlIGlmICghaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NUb0FkZCkpIHtcclxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gKGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnICsgY2xhc3NUb0FkZCkudHJpbSgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVsZW1lbnQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgYSBDU1MgY2xhc3MgbmFtZSBmcm9tIGFuIGVsZW1lbnRcclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XHJcbiAqICAgICAgICBFbGVtZW50IHRvIHJlbW92ZSBhIGNsYXNzIG5hbWUgZnJvbS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9SZW1vdmVcclxuICogICAgICAgIENsYXNzIG5hbWUgdG8gcmVtb3ZlXHJcbiAqXHJcbiAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAqICAgICAgICAgVGhlIGRvbSBlbGVtZW50IHdpdGggY2xhc3MgbmFtZSByZW1vdmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1JlbW92ZSkge1xyXG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xyXG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzVG9SZW1vdmUpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvd0lmV2hpdGVzcGFjZShjbGFzc1RvUmVtb3ZlKTtcclxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoL1xccysvKS5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcclxuICAgICAgcmV0dXJuIGMgIT09IGNsYXNzVG9SZW1vdmU7XHJcbiAgICB9KS5qb2luKCcgJyk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZWxlbWVudDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBjYWxsYmFjayBkZWZpbml0aW9uIGZvciB0b2dnbGVFbENsYXNzLlxyXG4gKlxyXG4gKiBAY2FsbGJhY2sgRG9tflByZWRpY2F0ZUNhbGxiYWNrXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gKiAgICAgICAgVGhlIERPTSBlbGVtZW50IG9mIHRoZSBDb21wb25lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvVG9nZ2xlXHJcbiAqICAgICAgICBUaGUgYGNsYXNzTmFtZWAgdGhhdCB3YW50cyB0byBiZSB0b2dnbGVkXHJcbiAqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfVxyXG4gKiAgICAgICAgIC0gSWYgdHJ1ZSB0aGUgYGNsYXNzVG9Ub2dnbGVgIHdpbGwgZ2V0IGFkZGVkIHRvIGBlbGVtZW50YC5cclxuICogICAgICAgICAtIElmIGZhbHNlIHRoZSBgY2xhc3NUb1RvZ2dsZWAgd2lsbCBnZXQgcmVtb3ZlZCBmcm9tIGBlbGVtZW50YC5cclxuICogICAgICAgICAtIElmIHVuZGVmaW5lZCB0aGlzIGNhbGxiYWNrIHdpbGwgYmUgaWdub3JlZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBZGRzIG9yIHJlbW92ZXMgYSBDU1MgY2xhc3MgbmFtZSBvbiBhbiBlbGVtZW50IGRlcGVuZGluZyBvbiBhbiBvcHRpb25hbFxyXG4gKiBjb25kaXRpb24gb3IgdGhlIHByZXNlbmNlL2Fic2VuY2Ugb2YgdGhlIGNsYXNzIG5hbWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gKiAgICAgICAgVGhlIGVsZW1lbnQgdG8gdG9nZ2xlIGEgY2xhc3MgbmFtZSBvbi5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9Ub2dnbGVcclxuICogICAgICAgIFRoZSBjbGFzcyB0aGF0IHNob3VsZCBiZSB0b2dnbGVkXHJcbiAqXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbnxQcmVkaWNhdGVDYWxsYmFja30gW3ByZWRpY2F0ZV1cclxuICogICAgICAgIFNlZSB0aGUgcmV0dXJuIHZhbHVlIGZvciB7QGxpbmsgRG9tflByZWRpY2F0ZUNhbGxiYWNrfVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHdpdGggYSBjbGFzcyB0aGF0IGhhcyBiZWVuIHRvZ2dsZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b2dnbGVDbGFzcyhlbGVtZW50LCBjbGFzc1RvVG9nZ2xlLCBwcmVkaWNhdGUpIHtcclxuXHJcbiAgLy8gVGhpcyBDQU5OT1QgdXNlIGBjbGFzc0xpc3RgIGludGVybmFsbHkgYmVjYXVzZSBJRSBkb2VzIG5vdCBzdXBwb3J0IHRoZVxyXG4gIC8vIHNlY29uZCBwYXJhbWV0ZXIgdG8gdGhlIGBjbGFzc0xpc3QudG9nZ2xlKClgIG1ldGhvZCEgV2hpY2ggaXMgZmluZSBiZWNhdXNlXHJcbiAgLy8gYGNsYXNzTGlzdGAgd2lsbCBiZSB1c2VkIGJ5IHRoZSBhZGQvcmVtb3ZlIGZ1bmN0aW9ucy5cclxuICB2YXIgaGFzID0gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSk7XHJcblxyXG4gIGlmICh0eXBlb2YgcHJlZGljYXRlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBwcmVkaWNhdGUgPSBwcmVkaWNhdGUoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSk7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICBwcmVkaWNhdGUgPSAhaGFzO1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgdGhlIG5lY2Vzc2FyeSBjbGFzcyBvcGVyYXRpb24gbWF0Y2hlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGVcclxuICAvLyBlbGVtZW50LCBubyBhY3Rpb24gaXMgcmVxdWlyZWQuXHJcbiAgaWYgKHByZWRpY2F0ZSA9PT0gaGFzKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAocHJlZGljYXRlKSB7XHJcbiAgICBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc1RvVG9nZ2xlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NUb1RvZ2dsZSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZWxlbWVudDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFwcGx5IGF0dHJpYnV0ZXMgdG8gYW4gSFRNTCBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXHJcbiAqICAgICAgICBFbGVtZW50IHRvIGFkZCBhdHRyaWJ1dGVzIHRvLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdXHJcbiAqICAgICAgICBBdHRyaWJ1dGVzIHRvIGJlIGFwcGxpZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsLCBhdHRyaWJ1dGVzKSB7XHJcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0ck5hbWUpIHtcclxuICAgIHZhciBhdHRyVmFsdWUgPSBhdHRyaWJ1dGVzW2F0dHJOYW1lXTtcclxuXHJcbiAgICBpZiAoYXR0clZhbHVlID09PSBudWxsIHx8IHR5cGVvZiBhdHRyVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IGF0dHJWYWx1ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlID09PSB0cnVlID8gJycgOiBhdHRyVmFsdWUpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGFuIGVsZW1lbnQncyBhdHRyaWJ1dGUgdmFsdWVzLCBhcyBkZWZpbmVkIG9uIHRoZSBIVE1MIHRhZ1xyXG4gKiBBdHRyaWJ1dGVzIGFyZSBub3QgdGhlIHNhbWUgYXMgcHJvcGVydGllcy4gVGhleSdyZSBkZWZpbmVkIG9uIHRoZSB0YWdcclxuICogb3Igd2l0aCBzZXRBdHRyaWJ1dGUgKHdoaWNoIHNob3VsZG4ndCBiZSB1c2VkIHdpdGggSFRNTClcclxuICogVGhpcyB3aWxsIHJldHVybiB0cnVlIG9yIGZhbHNlIGZvciBib29sZWFuIGF0dHJpYnV0ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFnXHJcbiAqICAgICAgICBFbGVtZW50IGZyb20gd2hpY2ggdG8gZ2V0IHRhZyBhdHRyaWJ1dGVzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqICAgICAgICAgQWxsIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVzKHRhZykge1xyXG4gIHZhciBvYmogPSB7fTtcclxuXHJcbiAgLy8ga25vd24gYm9vbGVhbiBhdHRyaWJ1dGVzXHJcbiAgLy8gd2UgY2FuIGNoZWNrIGZvciBtYXRjaGluZyBib29sZWFuIHByb3BlcnRpZXMsIGJ1dCBvbGRlciBicm93c2Vyc1xyXG4gIC8vIHdvbid0IGtub3cgYWJvdXQgSFRNTDUgYm9vbGVhbiBhdHRyaWJ1dGVzIHRoYXQgd2Ugc3RpbGwgcmVhZCBmcm9tXHJcbiAgdmFyIGtub3duQm9vbGVhbnMgPSAnLCcgKyAnYXV0b3BsYXksY29udHJvbHMscGxheXNpbmxpbmUsbG9vcCxtdXRlZCxkZWZhdWx0LGRlZmF1bHRNdXRlZCcgKyAnLCc7XHJcblxyXG4gIGlmICh0YWcgJiYgdGFnLmF0dHJpYnV0ZXMgJiYgdGFnLmF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgdmFyIGF0dHJzID0gdGFnLmF0dHJpYnV0ZXM7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IGF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIHZhciBhdHRyTmFtZSA9IGF0dHJzW2ldLm5hbWU7XHJcbiAgICAgIHZhciBhdHRyVmFsID0gYXR0cnNbaV0udmFsdWU7XHJcblxyXG4gICAgICAvLyBjaGVjayBmb3Iga25vd24gYm9vbGVhbnNcclxuICAgICAgLy8gdGhlIG1hdGNoaW5nIGVsZW1lbnQgcHJvcGVydHkgd2lsbCByZXR1cm4gYSB2YWx1ZSBmb3IgdHlwZW9mXHJcbiAgICAgIGlmICh0eXBlb2YgdGFnW2F0dHJOYW1lXSA9PT0gJ2Jvb2xlYW4nIHx8IGtub3duQm9vbGVhbnMuaW5kZXhPZignLCcgKyBhdHRyTmFtZSArICcsJykgIT09IC0xKSB7XHJcbiAgICAgICAgLy8gdGhlIHZhbHVlIG9mIGFuIGluY2x1ZGVkIGJvb2xlYW4gYXR0cmlidXRlIGlzIHR5cGljYWxseSBhbiBlbXB0eVxyXG4gICAgICAgIC8vIHN0cmluZyAoJycpIHdoaWNoIHdvdWxkIGVxdWFsIGZhbHNlIGlmIHdlIGp1c3QgY2hlY2sgZm9yIGEgZmFsc2UgdmFsdWUuXHJcbiAgICAgICAgLy8gd2UgYWxzbyBkb24ndCB3YW50IHN1cHBvcnQgYmFkIGNvZGUgbGlrZSBhdXRvcGxheT0nZmFsc2UnXHJcbiAgICAgICAgYXR0clZhbCA9IGF0dHJWYWwgIT09IG51bGwgPyB0cnVlIDogZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG9ialthdHRyTmFtZV0gPSBhdHRyVmFsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdmFsdWUgb2YgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZVxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXHJcbiAqICAgICAgICBBIERPTSBlbGVtZW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcclxuICogICAgICAgIEF0dHJpYnV0ZSB0byBnZXQgdGhlIHZhbHVlIG9mXHJcbiAqXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICogICAgICAgICB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGUoZWwsIGF0dHJpYnV0ZSkge1xyXG4gIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgdmFsdWUgb2YgYW4gZWxlbWVudCdzIGF0dHJpYnV0ZVxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXHJcbiAqICAgICAgICBBIERPTSBlbGVtZW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcclxuICogICAgICAgIEF0dHJpYnV0ZSB0byBzZXRcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXHJcbiAqICAgICAgICBWYWx1ZSB0byBzZXQgdGhlIGF0dHJpYnV0ZSB0b1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0QXR0cmlidXRlKGVsLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XHJcbiAgZWwuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGFuIGVsZW1lbnQncyBhdHRyaWJ1dGVcclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxyXG4gKiAgICAgICAgQSBET00gZWxlbWVudFxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXHJcbiAqICAgICAgICBBdHRyaWJ1dGUgdG8gcmVtb3ZlXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUoZWwsIGF0dHJpYnV0ZSkge1xyXG4gIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xyXG59XHJcblxyXG4vKipcclxuICogQXR0ZW1wdCB0byBibG9jayB0aGUgYWJpbGl0eSB0byBzZWxlY3QgdGV4dCB3aGlsZSBkcmFnZ2luZyBjb250cm9sc1xyXG4gKi9cclxuZnVuY3Rpb24gYmxvY2tUZXh0U2VsZWN0aW9uKCkge1xyXG4gIGRvY3VtZW50XzEuYm9keS5mb2N1cygpO1xyXG4gIGRvY3VtZW50XzEub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogVHVybiBvZmYgdGV4dCBzZWxlY3Rpb24gYmxvY2tpbmdcclxuICovXHJcbmZ1bmN0aW9uIHVuYmxvY2tUZXh0U2VsZWN0aW9uKCkge1xyXG4gIGRvY3VtZW50XzEub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJZGVudGljYWwgdG8gdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBmdW5jdGlvbiwgYnV0IGVuc3VyZXMgdGhhdFxyXG4gKiB0aGUgbWV0aG9kIGlzIHN1cHBvcnRlZCBhdCBhbGwgKGl0IGlzIGluIGFsbCBicm93c2VycyB3ZSBjbGFpbSB0byBzdXBwb3J0KVxyXG4gKiBhbmQgdGhhdCB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NIGJlZm9yZSBjb250aW51aW5nLlxyXG4gKlxyXG4gKiBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gYWxzbyBzaGltcyBwcm9wZXJ0aWVzIHdoaWNoIGFyZSBub3QgcHJvdmlkZWQgYnkgc29tZVxyXG4gKiBvbGRlciBicm93c2VycyAobmFtZWx5LCBJRTgpLlxyXG4gKlxyXG4gKiBBZGRpdGlvbmFsbHksIHNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgYWRkaW5nIHByb3BlcnRpZXMgdG8gYVxyXG4gKiBgQ2xpZW50UmVjdGAvYERPTVJlY3RgIG9iamVjdDsgc28sIHdlIHNoYWxsb3ctY29weSBpdCB3aXRoIHRoZSBzdGFuZGFyZFxyXG4gKiBwcm9wZXJ0aWVzIChleGNlcHQgYHhgIGFuZCBgeWAgd2hpY2ggYXJlIG5vdCB3aWRlbHkgc3VwcG9ydGVkKS4gVGhpcyBoZWxwc1xyXG4gKiBhdm9pZCBpbXBsZW1lbnRhdGlvbnMgd2hlcmUga2V5cyBhcmUgbm9uLWVudW1lcmFibGUuXHJcbiAqXHJcbiAqIEBwYXJhbSAge0VsZW1lbnR9IGVsXHJcbiAqICAgICAgICAgRWxlbWVudCB3aG9zZSBgQ2xpZW50UmVjdGAgd2Ugd2FudCB0byBjYWxjdWxhdGUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XHJcbiAqICAgICAgICAgQWx3YXlzIHJldHVybnMgYSBwbGFpblxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKSB7XHJcbiAgaWYgKGVsICYmIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlbC5wYXJlbnROb2RlKSB7XHJcbiAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG5cclxuICAgIFsnYm90dG9tJywgJ2hlaWdodCcsICdsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICd3aWR0aCddLmZvckVhY2goZnVuY3Rpb24gKGspIHtcclxuICAgICAgaWYgKHJlY3Rba10gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJlc3VsdFtrXSA9IHJlY3Rba107XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghcmVzdWx0LmhlaWdodCkge1xyXG4gICAgICByZXN1bHQuaGVpZ2h0ID0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlKGVsLCAnaGVpZ2h0JykpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghcmVzdWx0LndpZHRoKSB7XHJcbiAgICAgIHJlc3VsdC53aWR0aCA9IHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZShlbCwgJ3dpZHRoJykpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVGhlIHBvc3Rpb24gb2YgYSBET00gZWxlbWVudCBvbiB0aGUgcGFnZS5cclxuICpcclxuICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmRvbX5Qb3NpdGlvblxyXG4gKlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGVmdFxyXG4gKiAgICAgICAgICAgUGl4ZWxzIHRvIHRoZSBsZWZ0XHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3BcclxuICogICAgICAgICAgIFBpeGVscyBvbiB0b3BcclxuICovXHJcblxyXG4vKipcclxuICogT2Zmc2V0IExlZnQuXHJcbiAqIGdldEJvdW5kaW5nQ2xpZW50UmVjdCB0ZWNobmlxdWUgZnJvbVxyXG4gKiBKb2huIFJlc2lnXHJcbiAqXHJcbiAqIEBzZWUgaHR0cDovL2Vqb2huLm9yZy9ibG9nL2dldGJvdW5kaW5nY2xpZW50cmVjdC1pcy1hd2Vzb21lL1xyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXHJcbiAqICAgICAgICBFbGVtZW50IGZyb20gd2hpY2ggdG8gZ2V0IG9mZnNldFxyXG4gKlxyXG4gKiBAcmV0dXJuIHttb2R1bGU6ZG9tflBvc2l0aW9ufVxyXG4gKiAgICAgICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCB0aGF0IHdhcyBwYXNzZWQgaW4uXHJcbiAqL1xyXG5mdW5jdGlvbiBmaW5kUG9zaXRpb24oZWwpIHtcclxuICB2YXIgYm94ID0gdm9pZCAwO1xyXG5cclxuICBpZiAoZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICYmIGVsLnBhcmVudE5vZGUpIHtcclxuICAgIGJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFib3gpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxlZnQ6IDAsXHJcbiAgICAgIHRvcDogMFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHZhciBkb2NFbCA9IGRvY3VtZW50XzEuZG9jdW1lbnRFbGVtZW50O1xyXG4gIHZhciBib2R5ID0gZG9jdW1lbnRfMS5ib2R5O1xyXG5cclxuICB2YXIgY2xpZW50TGVmdCA9IGRvY0VsLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDA7XHJcbiAgdmFyIHNjcm9sbExlZnQgPSB3aW5kb3dfMS5wYWdlWE9mZnNldCB8fCBib2R5LnNjcm9sbExlZnQ7XHJcbiAgdmFyIGxlZnQgPSBib3gubGVmdCArIHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0O1xyXG5cclxuICB2YXIgY2xpZW50VG9wID0gZG9jRWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XHJcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbmRvd18xLnBhZ2VZT2Zmc2V0IHx8IGJvZHkuc2Nyb2xsVG9wO1xyXG4gIHZhciB0b3AgPSBib3gudG9wICsgc2Nyb2xsVG9wIC0gY2xpZW50VG9wO1xyXG5cclxuICAvLyBBbmRyb2lkIHNvbWV0aW1lcyByZXR1cm5zIHNsaWdodGx5IG9mZiBkZWNpbWFsIHZhbHVlcywgc28gbmVlZCB0byByb3VuZFxyXG4gIHJldHVybiB7XHJcbiAgICBsZWZ0OiBNYXRoLnJvdW5kKGxlZnQpLFxyXG4gICAgdG9wOiBNYXRoLnJvdW5kKHRvcClcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogeCBhbmQgeSBjb29yZGluYXRlcyBmb3IgYSBkb20gZWxlbWVudCBvciBtb3VzZSBwb2ludGVyXHJcbiAqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERvbX5Db29yZGluYXRlc1xyXG4gKlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0geFxyXG4gKiAgICAgICAgICAgeCBjb29yZGluYXRlIGluIHBpeGVsc1xyXG4gKlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0geVxyXG4gKiAgICAgICAgICAgeSBjb29yZGluYXRlIGluIHBpeGVsc1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBHZXQgcG9pbnRlciBwb3NpdGlvbiBpbiBlbGVtZW50XHJcbiAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggeCBhbmQgeSBjb29yZGluYXRlcy5cclxuICogVGhlIGJhc2Ugb24gdGhlIGNvb3JkaW5hdGVzIGFyZSB0aGUgYm90dG9tIGxlZnQgb2YgdGhlIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcclxuICogICAgICAgIEVsZW1lbnQgb24gd2hpY2ggdG8gZ2V0IHRoZSBwb2ludGVyIHBvc2l0aW9uIG9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAqICAgICAgICBFdmVudCBvYmplY3RcclxuICpcclxuICogQHJldHVybiB7RG9tfkNvb3JkaW5hdGVzfVxyXG4gKiAgICAgICAgIEEgQ29vcmRpbmF0ZXMgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1vdXNlIHBvc2l0aW9uLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UG9pbnRlclBvc2l0aW9uKGVsLCBldmVudCkge1xyXG4gIHZhciBwb3NpdGlvbiA9IHt9O1xyXG4gIHZhciBib3ggPSBmaW5kUG9zaXRpb24oZWwpO1xyXG4gIHZhciBib3hXID0gZWwub2Zmc2V0V2lkdGg7XHJcbiAgdmFyIGJveEggPSBlbC5vZmZzZXRIZWlnaHQ7XHJcblxyXG4gIHZhciBib3hZID0gYm94LnRvcDtcclxuICB2YXIgYm94WCA9IGJveC5sZWZ0O1xyXG4gIHZhciBwYWdlWSA9IGV2ZW50LnBhZ2VZO1xyXG4gIHZhciBwYWdlWCA9IGV2ZW50LnBhZ2VYO1xyXG5cclxuICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcclxuICAgIHBhZ2VYID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XHJcbiAgICBwYWdlWSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xyXG4gIH1cclxuXHJcbiAgcG9zaXRpb24ueSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIChib3hZIC0gcGFnZVkgKyBib3hIKSAvIGJveEgpKTtcclxuICBwb3NpdGlvbi54ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHBhZ2VYIC0gYm94WCkgLyBib3hXKSk7XHJcblxyXG4gIHJldHVybiBwb3NpdGlvbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMsIHZpYSBkdWNrIHR5cGluZywgd2hldGhlciBvciBub3QgYSB2YWx1ZSBpcyBhIHRleHQgbm9kZS5cclxuICpcclxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcclxuICogICAgICAgIENoZWNrIGlmIHRoaXMgdmFsdWUgaXMgYSB0ZXh0IG5vZGUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqICAgICAgICAgLSBUcnVlIGlmIGl0IGlzIGEgdGV4dCBub2RlXHJcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcclxuICovXHJcbmZ1bmN0aW9uIGlzVGV4dE5vZGUodmFsdWUpIHtcclxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAzO1xyXG59XHJcblxyXG4vKipcclxuICogRW1wdGllcyB0aGUgY29udGVudHMgb2YgYW4gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxyXG4gKiAgICAgICAgVGhlIGVsZW1lbnQgdG8gZW1wdHkgY2hpbGRyZW4gZnJvbVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHdpdGggbm8gY2hpbGRyZW5cclxuICovXHJcbmZ1bmN0aW9uIGVtcHR5RWwoZWwpIHtcclxuICB3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xyXG4gICAgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XHJcbiAgfVxyXG4gIHJldHVybiBlbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZXMgY29udGVudCBmb3IgZXZlbnR1YWwgaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cclxuICpcclxuICogVGhpcyBhbGxvd3MgYSB3aWRlIHJhbmdlIG9mIGNvbnRlbnQgZGVmaW5pdGlvbiBtZXRob2RzLCBidXQgcHJvdGVjdHNcclxuICogZnJvbSBmYWxsaW5nIGludG8gdGhlIHRyYXAgb2Ygc2ltcGx5IHdyaXRpbmcgdG8gYGlubmVySFRNTGAsIHdoaWNoIGlzXHJcbiAqIGFuIFhTUyBjb25jZXJuLlxyXG4gKlxyXG4gKiBUaGUgY29udGVudCBmb3IgYW4gZWxlbWVudCBjYW4gYmUgcGFzc2VkIGluIG11bHRpcGxlIHR5cGVzIGFuZFxyXG4gKiBjb21iaW5hdGlvbnMsIHdob3NlIGJlaGF2aW9yIGlzIGFzIGZvbGxvd3M6XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8VGV4dE5vZGV8QXJyYXl8RnVuY3Rpb259IGNvbnRlbnRcclxuICogICAgICAgIC0gU3RyaW5nOiBOb3JtYWxpemVkIGludG8gYSB0ZXh0IG5vZGUuXHJcbiAqICAgICAgICAtIEVsZW1lbnQvVGV4dE5vZGU6IFBhc3NlZCB0aHJvdWdoLlxyXG4gKiAgICAgICAgLSBBcnJheTogQSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2Ygc3RyaW5ncywgZWxlbWVudHMsIG5vZGVzLCBvciBmdW5jdGlvbnNcclxuICogICAgICAgICAgKHdoaWNoIHJldHVybiBzaW5nbGUgc3RyaW5ncywgZWxlbWVudHMsIG9yIG5vZGVzKS5cclxuICogICAgICAgIC0gRnVuY3Rpb246IElmIHRoZSBzb2xlIGFyZ3VtZW50LCBpcyBleHBlY3RlZCB0byBwcm9kdWNlIGEgc3RyaW5nLCBlbGVtZW50LFxyXG4gKiAgICAgICAgICBub2RlLCBvciBhcnJheSBhcyBkZWZpbmVkIGFib3ZlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogICAgICAgICBBbGwgb2YgdGhlIGNvbnRlbnQgdGhhdCB3YXMgcGFzc2VkIGluIG5vcm1hbGl6ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVDb250ZW50KGNvbnRlbnQpIHtcclxuXHJcbiAgLy8gRmlyc3QsIGludm9rZSBjb250ZW50IGlmIGl0IGlzIGEgZnVuY3Rpb24uIElmIGl0IHByb2R1Y2VzIGFuIGFycmF5LFxyXG4gIC8vIHRoYXQgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSBub3JtYWxpemF0aW9uLlxyXG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgY29udGVudCA9IGNvbnRlbnQoKTtcclxuICB9XHJcblxyXG4gIC8vIE5leHQgdXAsIG5vcm1hbGl6ZSB0byBhbiBhcnJheSwgc28gb25lIG9yIG1hbnkgaXRlbXMgY2FuIGJlIG5vcm1hbGl6ZWQsXHJcbiAgLy8gZmlsdGVyZWQsIGFuZCByZXR1cm5lZC5cclxuICByZXR1cm4gKEFycmF5LmlzQXJyYXkoY29udGVudCkgPyBjb250ZW50IDogW2NvbnRlbnRdKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XHJcblxyXG4gICAgLy8gRmlyc3QsIGludm9rZSB2YWx1ZSBpZiBpdCBpcyBhIGZ1bmN0aW9uIHRvIHByb2R1Y2UgYSBuZXcgdmFsdWUsXHJcbiAgICAvLyB3aGljaCB3aWxsIGJlIHN1YnNlcXVlbnRseSBub3JtYWxpemVkIHRvIGEgTm9kZSBvZiBzb21lIGtpbmQuXHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHZhbHVlID0gdmFsdWUoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNFbCh2YWx1ZSkgfHwgaXNUZXh0Tm9kZSh2YWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIC9cXFMvLnRlc3QodmFsdWUpKSB7XHJcbiAgICAgIHJldHVybiBkb2N1bWVudF8xLmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcclxuICAgIH1cclxuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemVzIGFuZCBhcHBlbmRzIGNvbnRlbnQgdG8gYW4gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxyXG4gKiAgICAgICAgRWxlbWVudCB0byBhcHBlbmQgbm9ybWFsaXplZCBjb250ZW50IHRvLlxyXG4gKlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fFRleHROb2RlfEFycmF5fEZ1bmN0aW9ufSBjb250ZW50XHJcbiAqICAgICAgICBTZWUgdGhlIGBjb250ZW50YCBhcmd1bWVudCBvZiB7QGxpbmsgZG9tOm5vcm1hbGl6ZUNvbnRlbnR9XHJcbiAqXHJcbiAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAqICAgICAgICAgVGhlIGVsZW1lbnQgd2l0aCBhcHBlbmRlZCBub3JtYWxpemVkIGNvbnRlbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBlbmRDb250ZW50KGVsLCBjb250ZW50KSB7XHJcbiAgbm9ybWFsaXplQ29udGVudChjb250ZW50KS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICByZXR1cm4gZWwuYXBwZW5kQ2hpbGQobm9kZSk7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGVsO1xyXG59XHJcblxyXG4vKipcclxuICogTm9ybWFsaXplcyBhbmQgaW5zZXJ0cyBjb250ZW50IGludG8gYW4gZWxlbWVudDsgdGhpcyBpcyBpZGVudGljYWwgdG9cclxuICogYGFwcGVuZENvbnRlbnQoKWAsIGV4Y2VwdCBpdCBlbXB0aWVzIHRoZSBlbGVtZW50IGZpcnN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXHJcbiAqICAgICAgICBFbGVtZW50IHRvIGluc2VydCBub3JtYWxpemVkIGNvbnRlbnQgaW50by5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxUZXh0Tm9kZXxBcnJheXxGdW5jdGlvbn0gY29udGVudFxyXG4gKiAgICAgICAgU2VlIHRoZSBgY29udGVudGAgYXJndW1lbnQgb2Yge0BsaW5rIGRvbTpub3JtYWxpemVDb250ZW50fVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gKiAgICAgICAgIFRoZSBlbGVtZW50IHdpdGggaW5zZXJ0ZWQgbm9ybWFsaXplZCBjb250ZW50LlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gaW5zZXJ0Q29udGVudChlbCwgY29udGVudCkge1xyXG4gIHJldHVybiBhcHBlbmRDb250ZW50KGVtcHR5RWwoZWwpLCBjb250ZW50KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmRzIGEgc2luZ2xlIERPTSBlbGVtZW50IG1hdGNoaW5nIGBzZWxlY3RvcmAgd2l0aGluIHRoZSBvcHRpb25hbFxyXG4gKiBgY29udGV4dGAgb2YgYW5vdGhlciBET00gZWxlbWVudCAoZGVmYXVsdGluZyB0byBgZG9jdW1lbnRgKS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXHJcbiAqICAgICAgICBBIHZhbGlkIENTUyBzZWxlY3Rvciwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYHF1ZXJ5U2VsZWN0b3JgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBbY29udGV4dD1kb2N1bWVudF1cclxuICogICAgICAgIEEgRE9NIGVsZW1lbnQgd2l0aGluIHdoaWNoIHRvIHF1ZXJ5LiBDYW4gYWxzbyBiZSBhIHNlbGVjdG9yXHJcbiAqICAgICAgICBzdHJpbmcgaW4gd2hpY2ggY2FzZSB0aGUgZmlyc3QgbWF0Y2hpbmcgZWxlbWVudCB3aWxsIGJlIHVzZWRcclxuICogICAgICAgIGFzIGNvbnRleHQuIElmIG1pc3NpbmcgKG9yIG5vIGVsZW1lbnQgbWF0Y2hlcyBzZWxlY3RvciksIGZhbGxzXHJcbiAqICAgICAgICBiYWNrIHRvIGBkb2N1bWVudGAuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0VsZW1lbnR8bnVsbH1cclxuICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBmb3VuZCBvciBudWxsLlxyXG4gKi9cclxudmFyICQgPSBjcmVhdGVRdWVyaWVyKCdxdWVyeVNlbGVjdG9yJyk7XHJcblxyXG4vKipcclxuICogRmluZHMgYSBhbGwgRE9NIGVsZW1lbnRzIG1hdGNoaW5nIGBzZWxlY3RvcmAgd2l0aGluIHRoZSBvcHRpb25hbFxyXG4gKiBgY29udGV4dGAgb2YgYW5vdGhlciBET00gZWxlbWVudCAoZGVmYXVsdGluZyB0byBgZG9jdW1lbnRgKS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXHJcbiAqICAgICAgICAgICBBIHZhbGlkIENTUyBzZWxlY3Rvciwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gYHF1ZXJ5U2VsZWN0b3JBbGxgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR8U3RyaW5nfSBbY29udGV4dD1kb2N1bWVudF1cclxuICogICAgICAgICAgIEEgRE9NIGVsZW1lbnQgd2l0aGluIHdoaWNoIHRvIHF1ZXJ5LiBDYW4gYWxzbyBiZSBhIHNlbGVjdG9yXHJcbiAqICAgICAgICAgICBzdHJpbmcgaW4gd2hpY2ggY2FzZSB0aGUgZmlyc3QgbWF0Y2hpbmcgZWxlbWVudCB3aWxsIGJlIHVzZWRcclxuICogICAgICAgICAgIGFzIGNvbnRleHQuIElmIG1pc3NpbmcgKG9yIG5vIGVsZW1lbnQgbWF0Y2hlcyBzZWxlY3RvciksIGZhbGxzXHJcbiAqICAgICAgICAgICBiYWNrIHRvIGBkb2N1bWVudGAuXHJcbiAqXHJcbiAqIEByZXR1cm4ge05vZGVMaXN0fVxyXG4gKiAgICAgICAgIEEgZWxlbWVudCBsaXN0IG9mIGVsZW1lbnRzIHRoYXQgd2VyZSBmb3VuZC4gV2lsbCBiZSBlbXB0eSBpZiBub25lIHdlcmUgZm91bmQuXHJcbiAqXHJcbiAqL1xyXG52YXIgJCQgPSBjcmVhdGVRdWVyaWVyKCdxdWVyeVNlbGVjdG9yQWxsJyk7XHJcblxyXG5cclxuXHJcbnZhciBEb20gPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcclxuXHRpc1JlYWw6IGlzUmVhbCxcclxuXHRpc0VsOiBpc0VsLFxyXG5cdGNyZWF0ZUVsOiBjcmVhdGVFbCxcclxuXHR0ZXh0Q29udGVudDogdGV4dENvbnRlbnQsXHJcblx0cHJlcGVuZFRvOiBwcmVwZW5kVG8sXHJcblx0aGFzQ2xhc3M6IGhhc0NsYXNzLFxyXG5cdGFkZENsYXNzOiBhZGRDbGFzcyxcclxuXHRyZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXHJcblx0dG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLFxyXG5cdHNldEF0dHJpYnV0ZXM6IHNldEF0dHJpYnV0ZXMsXHJcblx0Z2V0QXR0cmlidXRlczogZ2V0QXR0cmlidXRlcyxcclxuXHRnZXRBdHRyaWJ1dGU6IGdldEF0dHJpYnV0ZSxcclxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZSxcclxuXHRyZW1vdmVBdHRyaWJ1dGU6IHJlbW92ZUF0dHJpYnV0ZSxcclxuXHRibG9ja1RleHRTZWxlY3Rpb246IGJsb2NrVGV4dFNlbGVjdGlvbixcclxuXHR1bmJsb2NrVGV4dFNlbGVjdGlvbjogdW5ibG9ja1RleHRTZWxlY3Rpb24sXHJcblx0Z2V0Qm91bmRpbmdDbGllbnRSZWN0OiBnZXRCb3VuZGluZ0NsaWVudFJlY3QsXHJcblx0ZmluZFBvc2l0aW9uOiBmaW5kUG9zaXRpb24sXHJcblx0Z2V0UG9pbnRlclBvc2l0aW9uOiBnZXRQb2ludGVyUG9zaXRpb24sXHJcblx0aXNUZXh0Tm9kZTogaXNUZXh0Tm9kZSxcclxuXHRlbXB0eUVsOiBlbXB0eUVsLFxyXG5cdG5vcm1hbGl6ZUNvbnRlbnQ6IG5vcm1hbGl6ZUNvbnRlbnQsXHJcblx0YXBwZW5kQ29udGVudDogYXBwZW5kQ29udGVudCxcclxuXHRpbnNlcnRDb250ZW50OiBpbnNlcnRDb250ZW50LFxyXG5cdCQ6ICQsXHJcblx0JCQ6ICQkXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIGd1aWQuanNcclxuICogQG1vZHVsZSBndWlkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFVuaXF1ZSBJRCBmb3IgYW4gZWxlbWVudCBvciBmdW5jdGlvblxyXG4gKiBAdHlwZSB7TnVtYmVyfVxyXG4gKi9cclxudmFyIF9ndWlkID0gMTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSB1bmlxdWUgYXV0by1pbmNyZW1lbnRpbmcgSUQgYnkgbnVtYmVyIHRoYXQgaGFzIG5vdCBiZWVuIHJldHVybmVkIGJlZm9yZS5cclxuICpcclxuICogQHJldHVybiB7bnVtYmVyfVxyXG4gKiAgICAgICAgIEEgbmV3IHVuaXF1ZSBJRC5cclxuICovXHJcbmZ1bmN0aW9uIG5ld0dVSUQoKSB7XHJcbiAgcmV0dXJuIF9ndWlkKys7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBkb20tZGF0YS5qc1xyXG4gKiBAbW9kdWxlIGRvbS1kYXRhXHJcbiAqL1xyXG4vKipcclxuICogRWxlbWVudCBEYXRhIFN0b3JlLlxyXG4gKlxyXG4gKiBBbGxvd3MgZm9yIGJpbmRpbmcgZGF0YSB0byBhbiBlbGVtZW50IHdpdGhvdXQgcHV0dGluZyBpdCBkaXJlY3RseSBvbiB0aGVcclxuICogZWxlbWVudC4gRXguIEV2ZW50IGxpc3RlbmVycyBhcmUgc3RvcmVkIGhlcmUuXHJcbiAqIChhbHNvIGZyb20ganNuaW5qYS5jb20sIHNsaWdodGx5IG1vZGlmaWVkIGFuZCB1cGRhdGVkIGZvciBjbG9zdXJlIGNvbXBpbGVyKVxyXG4gKlxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxudmFyIGVsRGF0YSA9IHt9O1xyXG5cclxuLypcclxuICogVW5pcXVlIGF0dHJpYnV0ZSBuYW1lIHRvIHN0b3JlIGFuIGVsZW1lbnQncyBndWlkIGluXHJcbiAqXHJcbiAqIEB0eXBlIHtTdHJpbmd9XHJcbiAqIEBjb25zdGFudFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxudmFyIGVsSWRBdHRyID0gJ3ZkYXRhJyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNhY2hlIG9iamVjdCB3aGVyZSBkYXRhIGZvciBhbiBlbGVtZW50IGlzIHN0b3JlZFxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXHJcbiAqICAgICAgICBFbGVtZW50IHRvIHN0b3JlIGRhdGEgZm9yLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqICAgICAgICAgVGhlIGNhY2hlIG9iamVjdCBmb3IgdGhhdCBlbCB0aGF0IHdhcyBwYXNzZWQgaW4uXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREYXRhKGVsKSB7XHJcbiAgdmFyIGlkID0gZWxbZWxJZEF0dHJdO1xyXG5cclxuICBpZiAoIWlkKSB7XHJcbiAgICBpZCA9IGVsW2VsSWRBdHRyXSA9IG5ld0dVSUQoKTtcclxuICB9XHJcblxyXG4gIGlmICghZWxEYXRhW2lkXSkge1xyXG4gICAgZWxEYXRhW2lkXSA9IHt9O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGVsRGF0YVtpZF07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIGVsZW1lbnQgaGFzIGNhY2hlZCBkYXRhXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcclxuICogICAgICAgIENoZWNrIGlmIHRoaXMgZWxlbWVudCBoYXMgY2FjaGVkIGRhdGEuXHJcbiAqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqICAgICAgICAgLSBUcnVlIGlmIHRoZSBET00gZWxlbWVudCBoYXMgY2FjaGVkIGRhdGEuXHJcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNEYXRhKGVsKSB7XHJcbiAgdmFyIGlkID0gZWxbZWxJZEF0dHJdO1xyXG5cclxuICBpZiAoIWlkKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gISFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlbERhdGFbaWRdKS5sZW5ndGg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWxldGUgZGF0YSBmb3IgdGhlIGVsZW1lbnQgZnJvbSB0aGUgY2FjaGUgYW5kIHRoZSBndWlkIGF0dHIgZnJvbSBnZXRFbGVtZW50QnlJZFxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXHJcbiAqICAgICAgICBSZW1vdmUgY2FjaGVkIGRhdGEgZm9yIHRoaXMgZWxlbWVudC5cclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZURhdGEoZWwpIHtcclxuICB2YXIgaWQgPSBlbFtlbElkQXR0cl07XHJcblxyXG4gIGlmICghaWQpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSBhbGwgc3RvcmVkIGRhdGFcclxuICBkZWxldGUgZWxEYXRhW2lkXTtcclxuXHJcbiAgLy8gUmVtb3ZlIHRoZSBlbElkQXR0ciBwcm9wZXJ0eSBmcm9tIHRoZSBET00gbm9kZVxyXG4gIHRyeSB7XHJcbiAgICBkZWxldGUgZWxbZWxJZEF0dHJdO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGlmIChlbC5yZW1vdmVBdHRyaWJ1dGUpIHtcclxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGVsSWRBdHRyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIElFIGRvZXNuJ3QgYXBwZWFyIHRvIHN1cHBvcnQgcmVtb3ZlQXR0cmlidXRlIG9uIHRoZSBkb2N1bWVudCBlbGVtZW50XHJcbiAgICAgIGVsW2VsSWRBdHRyXSA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQGZpbGUgZXZlbnRzLmpzLiBBbiBFdmVudCBTeXN0ZW0gKEpvaG4gUmVzaWcgLSBTZWNyZXRzIG9mIGEgSlMgTmluamEgaHR0cDovL2pzbmluamEuY29tLylcclxuICogKE9yaWdpbmFsIGJvb2sgdmVyc2lvbiB3YXNuJ3QgY29tcGxldGVseSB1c2FibGUsIHNvIGZpeGVkIHNvbWUgdGhpbmdzIGFuZCBtYWRlIENsb3N1cmUgQ29tcGlsZXIgY29tcGF0aWJsZSlcclxuICogVGhpcyBzaG91bGQgd29yayB2ZXJ5IHNpbWlsYXJseSB0byBqUXVlcnkncyBldmVudHMsIGhvd2V2ZXIgaXQncyBiYXNlZCBvZmYgdGhlIGJvb2sgdmVyc2lvbiB3aGljaCBpc24ndCBhc1xyXG4gKiByb2J1c3QgYXMganF1ZXJ5J3MsIHNvIHRoZXJlJ3MgcHJvYmFibHkgc29tZSBkaWZmZXJlbmNlcy5cclxuICpcclxuICogQG1vZHVsZSBldmVudHNcclxuICovXHJcblxyXG4vKipcclxuICogQ2xlYW4gdXAgdGhlIGxpc3RlbmVyIGNhY2hlIGFuZCBkaXNwYXRjaGVyc1xyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXHJcbiAqICAgICAgICBFbGVtZW50IHRvIGNsZWFuIHVwXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXHJcbiAqICAgICAgICBUeXBlIG9mIGV2ZW50IHRvIGNsZWFuIHVwXHJcbiAqL1xyXG5mdW5jdGlvbiBfY2xlYW5VcEV2ZW50cyhlbGVtLCB0eXBlKSB7XHJcbiAgdmFyIGRhdGEgPSBnZXREYXRhKGVsZW0pO1xyXG5cclxuICAvLyBSZW1vdmUgdGhlIGV2ZW50cyBvZiBhIHBhcnRpY3VsYXIgdHlwZSBpZiB0aGVyZSBhcmUgbm9uZSBsZWZ0XHJcbiAgaWYgKGRhdGEuaGFuZGxlcnNbdHlwZV0ubGVuZ3RoID09PSAwKSB7XHJcbiAgICBkZWxldGUgZGF0YS5oYW5kbGVyc1t0eXBlXTtcclxuICAgIC8vIGRhdGEuaGFuZGxlcnNbdHlwZV0gPSBudWxsO1xyXG4gICAgLy8gU2V0dGluZyB0byBudWxsIHdhcyBjYXVzaW5nIGFuIGVycm9yIHdpdGggZGF0YS5oYW5kbGVyc1xyXG5cclxuICAgIC8vIFJlbW92ZSB0aGUgbWV0YS1oYW5kbGVyIGZyb20gdGhlIGVsZW1lbnRcclxuICAgIGlmIChlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGRhdGEuZGlzcGF0Y2hlciwgZmFsc2UpO1xyXG4gICAgfSBlbHNlIGlmIChlbGVtLmRldGFjaEV2ZW50KSB7XHJcbiAgICAgIGVsZW0uZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGRhdGEuZGlzcGF0Y2hlcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgdGhlIGV2ZW50cyBvYmplY3QgaWYgdGhlcmUgYXJlIG5vIHR5cGVzIGxlZnRcclxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGF0YS5oYW5kbGVycykubGVuZ3RoIDw9IDApIHtcclxuICAgIGRlbGV0ZSBkYXRhLmhhbmRsZXJzO1xyXG4gICAgZGVsZXRlIGRhdGEuZGlzcGF0Y2hlcjtcclxuICAgIGRlbGV0ZSBkYXRhLmRpc2FibGVkO1xyXG4gIH1cclxuXHJcbiAgLy8gRmluYWxseSByZW1vdmUgdGhlIGVsZW1lbnQgZGF0YSBpZiB0aGVyZSBpcyBubyBkYXRhIGxlZnRcclxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGF0YSkubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZW1vdmVEYXRhKGVsZW0pO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIExvb3BzIHRocm91Z2ggYW4gYXJyYXkgb2YgZXZlbnQgdHlwZXMgYW5kIGNhbGxzIHRoZSByZXF1ZXN0ZWQgbWV0aG9kIGZvciBlYWNoIHR5cGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqICAgICAgICBUaGUgZXZlbnQgbWV0aG9kIHdlIHdhbnQgdG8gdXNlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXHJcbiAqICAgICAgICBFbGVtZW50IG9yIG9iamVjdCB0byBiaW5kIGxpc3RlbmVycyB0b1xyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxyXG4gKiAgICAgICAgVHlwZSBvZiBldmVudCB0byBiaW5kIHRvLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGNhbGxiYWNrXHJcbiAqICAgICAgICBFdmVudCBsaXN0ZW5lci5cclxuICovXHJcbmZ1bmN0aW9uIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhmbiwgZWxlbSwgdHlwZXMsIGNhbGxiYWNrKSB7XHJcbiAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgLy8gQ2FsbCB0aGUgZXZlbnQgbWV0aG9kIGZvciBlYWNoIG9uZSBvZiB0aGUgdHlwZXNcclxuICAgIGZuKGVsZW0sIHR5cGUsIGNhbGxiYWNrKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpeCBhIG5hdGl2ZSBldmVudCB0byBoYXZlIHN0YW5kYXJkIHByb3BlcnR5IHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcclxuICogICAgICAgIEV2ZW50IG9iamVjdCB0byBmaXguXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogICAgICAgICBGaXhlZCBldmVudCBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBmaXhFdmVudChldmVudCkge1xyXG5cclxuICBmdW5jdGlvbiByZXR1cm5UcnVlKCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIFRlc3QgaWYgZml4aW5nIHVwIGlzIG5lZWRlZFxyXG4gIC8vIFVzZWQgdG8gY2hlY2sgaWYgIWV2ZW50LnN0b3BQcm9wYWdhdGlvbiBpbnN0ZWFkIG9mIGlzUHJvcGFnYXRpb25TdG9wcGVkXHJcbiAgLy8gQnV0IG5hdGl2ZSBldmVudHMgcmV0dXJuIHRydWUgZm9yIHN0b3BQcm9wYWdhdGlvbiwgYnV0IGRvbid0IGhhdmVcclxuICAvLyBvdGhlciBleHBlY3RlZCBtZXRob2RzIGxpa2UgaXNQcm9wYWdhdGlvblN0b3BwZWQuIFNlZW1zIHRvIGJlIGEgcHJvYmxlbVxyXG4gIC8vIHdpdGggdGhlIEphdmFzY3JpcHQgTmluamEgY29kZS4gU28gd2UncmUganVzdCBvdmVycmlkaW5nIGFsbCBldmVudHMgbm93LlxyXG4gIGlmICghZXZlbnQgfHwgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKSB7XHJcbiAgICB2YXIgb2xkID0gZXZlbnQgfHwgd2luZG93XzEuZXZlbnQ7XHJcblxyXG4gICAgZXZlbnQgPSB7fTtcclxuICAgIC8vIENsb25lIHRoZSBvbGQgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIG1vZGlmeSB0aGUgdmFsdWVzIGV2ZW50ID0ge307XHJcbiAgICAvLyBJRTggRG9lc24ndCBsaWtlIHdoZW4geW91IG1lc3Mgd2l0aCBuYXRpdmUgZXZlbnQgcHJvcGVydGllc1xyXG4gICAgLy8gRmlyZWZveCByZXR1cm5zIGZhbHNlIGZvciBldmVudC5oYXNPd25Qcm9wZXJ0eSgndHlwZScpIGFuZCBvdGhlciBwcm9wc1xyXG4gICAgLy8gIHdoaWNoIG1ha2VzIGNvcHlpbmcgbW9yZSBkaWZmaWN1bHQuXHJcbiAgICAvLyBUT0RPOiBQcm9iYWJseSBiZXN0IHRvIGNyZWF0ZSBhIHdoaXRlbGlzdCBvZiBldmVudCBwcm9wc1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9sZCkge1xyXG4gICAgICAvLyBTYWZhcmkgNi4wLjMgd2FybnMgeW91IGlmIHlvdSB0cnkgdG8gY29weSBkZXByZWNhdGVkIGxheWVyWC9ZXHJcbiAgICAgIC8vIENocm9tZSB3YXJucyB5b3UgaWYgeW91IHRyeSB0byBjb3B5IGRlcHJlY2F0ZWQga2V5Ym9hcmRFdmVudC5rZXlMb2NhdGlvblxyXG4gICAgICAvLyBhbmQgd2Via2l0TW92ZW1lbnRYL1lcclxuICAgICAgaWYgKGtleSAhPT0gJ2xheWVyWCcgJiYga2V5ICE9PSAnbGF5ZXJZJyAmJiBrZXkgIT09ICdrZXlMb2NhdGlvbicgJiYga2V5ICE9PSAnd2Via2l0TW92ZW1lbnRYJyAmJiBrZXkgIT09ICd3ZWJraXRNb3ZlbWVudFknKSB7XHJcbiAgICAgICAgLy8gQ2hyb21lIDMyKyB3YXJucyBpZiB5b3UgdHJ5IHRvIGNvcHkgZGVwcmVjYXRlZCByZXR1cm5WYWx1ZSwgYnV0XHJcbiAgICAgICAgLy8gd2Ugc3RpbGwgd2FudCB0byBpZiBwcmV2ZW50RGVmYXVsdCBpc24ndCBzdXBwb3J0ZWQgKElFOCkuXHJcbiAgICAgICAgaWYgKCEoa2V5ID09PSAncmV0dXJuVmFsdWUnICYmIG9sZC5wcmV2ZW50RGVmYXVsdCkpIHtcclxuICAgICAgICAgIGV2ZW50W2tleV0gPSBvbGRba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGUgZXZlbnQgb2NjdXJyZWQgb24gdGhpcyBlbGVtZW50XHJcbiAgICBpZiAoIWV2ZW50LnRhcmdldCkge1xyXG4gICAgICBldmVudC50YXJnZXQgPSBldmVudC5zcmNFbGVtZW50IHx8IGRvY3VtZW50XzE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxlIHdoaWNoIG90aGVyIGVsZW1lbnQgdGhlIGV2ZW50IGlzIHJlbGF0ZWQgdG9cclxuICAgIGlmICghZXZlbnQucmVsYXRlZFRhcmdldCkge1xyXG4gICAgICBldmVudC5yZWxhdGVkVGFyZ2V0ID0gZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnRhcmdldCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0b3AgdGhlIGRlZmF1bHQgYnJvd3NlciBhY3Rpb25cclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAob2xkLnByZXZlbnREZWZhdWx0KSB7XHJcbiAgICAgICAgb2xkLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIH1cclxuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuICAgICAgb2xkLnJldHVyblZhbHVlID0gZmFsc2U7XHJcbiAgICAgIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBldmVudC5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XHJcblxyXG4gICAgLy8gU3RvcCB0aGUgZXZlbnQgZnJvbSBidWJibGluZ1xyXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAob2xkLnN0b3BQcm9wYWdhdGlvbikge1xyXG4gICAgICAgIG9sZC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgfVxyXG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICBvbGQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVybkZhbHNlO1xyXG5cclxuICAgIC8vIFN0b3AgdGhlIGV2ZW50IGZyb20gYnViYmxpbmcgYW5kIGV4ZWN1dGluZyBvdGhlciBoYW5kbGVyc1xyXG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAob2xkLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xyXG4gICAgICAgIG9sZC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgfVxyXG4gICAgICBldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XHJcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVybkZhbHNlO1xyXG5cclxuICAgIC8vIEhhbmRsZSBtb3VzZSBwb3NpdGlvblxyXG4gICAgaWYgKGV2ZW50LmNsaWVudFggIT09IG51bGwgJiYgZXZlbnQuY2xpZW50WCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhciBkb2MgPSBkb2N1bWVudF8xLmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudF8xLmJvZHk7XHJcblxyXG4gICAgICBldmVudC5wYWdlWCA9IGV2ZW50LmNsaWVudFggKyAoZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDApIC0gKGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwKTtcclxuICAgICAgZXZlbnQucGFnZVkgPSBldmVudC5jbGllbnRZICsgKGRvYyAmJiBkb2Muc2Nyb2xsVG9wIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgfHwgMCkgLSAoZG9jICYmIGRvYy5jbGllbnRUb3AgfHwgYm9keSAmJiBib2R5LmNsaWVudFRvcCB8fCAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBIYW5kbGUga2V5IHByZXNzZXNcclxuICAgIGV2ZW50LndoaWNoID0gZXZlbnQuY2hhckNvZGUgfHwgZXZlbnQua2V5Q29kZTtcclxuXHJcbiAgICAvLyBGaXggYnV0dG9uIGZvciBtb3VzZSBjbGlja3M6XHJcbiAgICAvLyAwID09IGxlZnQ7IDEgPT0gbWlkZGxlOyAyID09IHJpZ2h0XHJcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSBudWxsICYmIGV2ZW50LmJ1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XHJcblxyXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGRpc2FibGVkIGJlY2F1c2UgaXQgZG9lcyBub3QgcGFzcyB2aWRlb2pzLXN0YW5kYXJkXHJcbiAgICAgIC8vIGFuZC4uLiB5aWtlcy5cclxuICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cclxuICAgICAgZXZlbnQuYnV0dG9uID0gZXZlbnQuYnV0dG9uICYgMSA/IDAgOiBldmVudC5idXR0b24gJiA0ID8gMSA6IGV2ZW50LmJ1dHRvbiAmIDIgPyAyIDogMDtcclxuICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJucyBmaXhlZC11cCBpbnN0YW5jZVxyXG4gIHJldHVybiBldmVudDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdoZXRoZXIgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMgYXJlIHN1cHBvcnRlZFxyXG4gKi9cclxudmFyIF9zdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgdHJ5IHtcclxuICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICAgICAgX3N1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHdpbmRvd18xLmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyBkaXNyZWdhcmRcclxuICB9XHJcbn0pKCk7XHJcblxyXG4vKipcclxuICogVG91Y2ggZXZlbnRzIENocm9tZSBleHBlY3RzIHRvIGJlIHBhc3NpdmVcclxuICovXHJcbnZhciBwYXNzaXZlRXZlbnRzID0gWyd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZSddO1xyXG5cclxuLyoqXHJcbiAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBlbGVtZW50XHJcbiAqIEl0IHN0b3JlcyB0aGUgaGFuZGxlciBmdW5jdGlvbiBpbiBhIHNlcGFyYXRlIGNhY2hlIG9iamVjdFxyXG4gKiBhbmQgYWRkcyBhIGdlbmVyaWMgaGFuZGxlciB0byB0aGUgZWxlbWVudCdzIGV2ZW50LFxyXG4gKiBhbG9uZyB3aXRoIGEgdW5pcXVlIGlkIChndWlkKSB0byB0aGUgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbVxyXG4gKiAgICAgICAgRWxlbWVudCBvciBvYmplY3QgdG8gYmluZCBsaXN0ZW5lcnMgdG9cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHR5cGVcclxuICogICAgICAgIFR5cGUgb2YgZXZlbnQgdG8gYmluZCB0by5cclxuICpcclxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBmblxyXG4gKiAgICAgICAgRXZlbnQgbGlzdGVuZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBvbihlbGVtLCB0eXBlLCBmbikge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XHJcbiAgICByZXR1cm4gX2hhbmRsZU11bHRpcGxlRXZlbnRzKG9uLCBlbGVtLCB0eXBlLCBmbik7XHJcbiAgfVxyXG5cclxuICB2YXIgZGF0YSA9IGdldERhdGEoZWxlbSk7XHJcblxyXG4gIC8vIFdlIG5lZWQgYSBwbGFjZSB0byBzdG9yZSBhbGwgb3VyIGhhbmRsZXIgZGF0YVxyXG4gIGlmICghZGF0YS5oYW5kbGVycykge1xyXG4gICAgZGF0YS5oYW5kbGVycyA9IHt9O1xyXG4gIH1cclxuXHJcbiAgaWYgKCFkYXRhLmhhbmRsZXJzW3R5cGVdKSB7XHJcbiAgICBkYXRhLmhhbmRsZXJzW3R5cGVdID0gW107XHJcbiAgfVxyXG5cclxuICBpZiAoIWZuLmd1aWQpIHtcclxuICAgIGZuLmd1aWQgPSBuZXdHVUlEKCk7XHJcbiAgfVxyXG5cclxuICBkYXRhLmhhbmRsZXJzW3R5cGVdLnB1c2goZm4pO1xyXG5cclxuICBpZiAoIWRhdGEuZGlzcGF0Y2hlcikge1xyXG4gICAgZGF0YS5kaXNhYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgIGRhdGEuZGlzcGF0Y2hlciA9IGZ1bmN0aW9uIChldmVudCwgaGFzaCkge1xyXG5cclxuICAgICAgaWYgKGRhdGEuZGlzYWJsZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGV2ZW50ID0gZml4RXZlbnQoZXZlbnQpO1xyXG5cclxuICAgICAgdmFyIGhhbmRsZXJzID0gZGF0YS5oYW5kbGVyc1tldmVudC50eXBlXTtcclxuXHJcbiAgICAgIGlmIChoYW5kbGVycykge1xyXG4gICAgICAgIC8vIENvcHkgaGFuZGxlcnMgc28gaWYgaGFuZGxlcnMgYXJlIGFkZGVkL3JlbW92ZWQgZHVyaW5nIHRoZSBwcm9jZXNzIGl0IGRvZXNuJ3QgdGhyb3cgZXZlcnl0aGluZyBvZmYuXHJcbiAgICAgICAgdmFyIGhhbmRsZXJzQ29weSA9IGhhbmRsZXJzLnNsaWNlKDApO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBtID0gMCwgbiA9IGhhbmRsZXJzQ29weS5sZW5ndGg7IG0gPCBuOyBtKyspIHtcclxuICAgICAgICAgIGlmIChldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBoYW5kbGVyc0NvcHlbbV0uY2FsbChlbGVtLCBldmVudCwgaGFzaCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICBsb2ckMS5lcnJvcihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGlmIChkYXRhLmhhbmRsZXJzW3R5cGVdLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICB2YXIgb3B0aW9ucyA9IGZhbHNlO1xyXG5cclxuICAgICAgaWYgKF9zdXBwb3J0c1Bhc3NpdmUgJiYgcGFzc2l2ZUV2ZW50cy5pbmRleE9mKHR5cGUpID4gLTEpIHtcclxuICAgICAgICBvcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07XHJcbiAgICAgIH1cclxuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGRhdGEuZGlzcGF0Y2hlciwgb3B0aW9ucyk7XHJcbiAgICB9IGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQpIHtcclxuICAgICAgZWxlbS5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgZGF0YS5kaXNwYXRjaGVyKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBmcm9tIGFuIGVsZW1lbnRcclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbVxyXG4gKiAgICAgICAgT2JqZWN0IHRvIHJlbW92ZSBsaXN0ZW5lcnMgZnJvbS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFt0eXBlXVxyXG4gKiAgICAgICAgVHlwZSBvZiBsaXN0ZW5lciB0byByZW1vdmUuIERvbid0IGluY2x1ZGUgdG8gcmVtb3ZlIGFsbCBldmVudHMgZnJvbSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IFtmbl1cclxuICogICAgICAgIFNwZWNpZmljIGxpc3RlbmVyIHRvIHJlbW92ZS4gRG9uJ3QgaW5jbHVkZSB0byByZW1vdmUgbGlzdGVuZXJzIGZvciBhbiBldmVudFxyXG4gKiAgICAgICAgdHlwZS5cclxuICovXHJcbmZ1bmN0aW9uIG9mZihlbGVtLCB0eXBlLCBmbikge1xyXG4gIC8vIERvbid0IHdhbnQgdG8gYWRkIGEgY2FjaGUgb2JqZWN0IHRocm91Z2ggZ2V0RWxEYXRhIGlmIG5vdCBuZWVkZWRcclxuICBpZiAoIWhhc0RhdGEoZWxlbSkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHZhciBkYXRhID0gZ2V0RGF0YShlbGVtKTtcclxuXHJcbiAgLy8gSWYgbm8gZXZlbnRzIGV4aXN0LCBub3RoaW5nIHRvIHVuYmluZFxyXG4gIGlmICghZGF0YS5oYW5kbGVycykge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcclxuICAgIHJldHVybiBfaGFuZGxlTXVsdGlwbGVFdmVudHMob2ZmLCBlbGVtLCB0eXBlLCBmbik7XHJcbiAgfVxyXG5cclxuICAvLyBVdGlsaXR5IGZ1bmN0aW9uXHJcbiAgdmFyIHJlbW92ZVR5cGUgPSBmdW5jdGlvbiByZW1vdmVUeXBlKHQpIHtcclxuICAgIGRhdGEuaGFuZGxlcnNbdF0gPSBbXTtcclxuICAgIF9jbGVhblVwRXZlbnRzKGVsZW0sIHQpO1xyXG4gIH07XHJcblxyXG4gIC8vIEFyZSB3ZSByZW1vdmluZyBhbGwgYm91bmQgZXZlbnRzP1xyXG4gIGlmICghdHlwZSkge1xyXG4gICAgZm9yICh2YXIgdCBpbiBkYXRhLmhhbmRsZXJzKSB7XHJcbiAgICAgIHJlbW92ZVR5cGUodCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgaGFuZGxlcnMgPSBkYXRhLmhhbmRsZXJzW3R5cGVdO1xyXG5cclxuICAvLyBJZiBubyBoYW5kbGVycyBleGlzdCwgbm90aGluZyB0byB1bmJpbmRcclxuICBpZiAoIWhhbmRsZXJzKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyBJZiBubyBsaXN0ZW5lciB3YXMgcHJvdmlkZWQsIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciB0eXBlXHJcbiAgaWYgKCFmbikge1xyXG4gICAgcmVtb3ZlVHlwZSh0eXBlKTtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIFdlJ3JlIG9ubHkgcmVtb3ZpbmcgYSBzaW5nbGUgaGFuZGxlclxyXG4gIGlmIChmbi5ndWlkKSB7XHJcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IGhhbmRsZXJzLmxlbmd0aDsgbisrKSB7XHJcbiAgICAgIGlmIChoYW5kbGVyc1tuXS5ndWlkID09PSBmbi5ndWlkKSB7XHJcbiAgICAgICAgaGFuZGxlcnMuc3BsaWNlKG4tLSwgMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9jbGVhblVwRXZlbnRzKGVsZW0sIHR5cGUpO1xyXG59XHJcblxyXG4vKipcclxuICogVHJpZ2dlciBhbiBldmVudCBmb3IgYW4gZWxlbWVudFxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXHJcbiAqICAgICAgICBFbGVtZW50IHRvIHRyaWdnZXIgYW4gZXZlbnQgb25cclxuICpcclxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudHxzdHJpbmd9IGV2ZW50XHJcbiAqICAgICAgICBBIHN0cmluZyAodGhlIHR5cGUpIG9yIGFuIGV2ZW50IG9iamVjdCB3aXRoIGEgdHlwZSBhdHRyaWJ1dGVcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFtoYXNoXVxyXG4gKiAgICAgICAgZGF0YSBoYXNoIHRvIHBhc3MgYWxvbmcgd2l0aCB0aGUgZXZlbnRcclxuICpcclxuICogQHJldHVybiB7Ym9vbGVhbnx1bmRlZmluZWR9XHJcbiAqICAgICAgICAgLSBSZXR1cm5zIHRoZSBvcHBvc2l0ZSBvZiBgZGVmYXVsdFByZXZlbnRlZGAgaWYgZGVmYXVsdCB3YXMgcHJldmVudGVkXHJcbiAqICAgICAgICAgLSBPdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWRcclxuICovXHJcbmZ1bmN0aW9uIHRyaWdnZXIoZWxlbSwgZXZlbnQsIGhhc2gpIHtcclxuICAvLyBGZXRjaGVzIGVsZW1lbnQgZGF0YSBhbmQgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCAoZm9yIGJ1YmJsaW5nKS5cclxuICAvLyBEb24ndCB3YW50IHRvIGFkZCBhIGRhdGEgb2JqZWN0IHRvIGNhY2hlIGZvciBldmVyeSBwYXJlbnQsXHJcbiAgLy8gc28gY2hlY2tpbmcgaGFzRWxEYXRhIGZpcnN0LlxyXG4gIHZhciBlbGVtRGF0YSA9IGhhc0RhdGEoZWxlbSkgPyBnZXREYXRhKGVsZW0pIDoge307XHJcbiAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSB8fCBlbGVtLm93bmVyRG9jdW1lbnQ7XHJcbiAgLy8gdHlwZSA9IGV2ZW50LnR5cGUgfHwgZXZlbnQsXHJcbiAgLy8gaGFuZGxlcjtcclxuXHJcbiAgLy8gSWYgYW4gZXZlbnQgbmFtZSB3YXMgcGFzc2VkIGFzIGEgc3RyaW5nLCBjcmVhdGVzIGFuIGV2ZW50IG91dCBvZiBpdFxyXG4gIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBldmVudCA9IHsgdHlwZTogZXZlbnQsIHRhcmdldDogZWxlbSB9O1xyXG4gIH1cclxuICAvLyBOb3JtYWxpemVzIHRoZSBldmVudCBwcm9wZXJ0aWVzLlxyXG4gIGV2ZW50ID0gZml4RXZlbnQoZXZlbnQpO1xyXG5cclxuICAvLyBJZiB0aGUgcGFzc2VkIGVsZW1lbnQgaGFzIGEgZGlzcGF0Y2hlciwgZXhlY3V0ZXMgdGhlIGVzdGFibGlzaGVkIGhhbmRsZXJzLlxyXG4gIGlmIChlbGVtRGF0YS5kaXNwYXRjaGVyKSB7XHJcbiAgICBlbGVtRGF0YS5kaXNwYXRjaGVyLmNhbGwoZWxlbSwgZXZlbnQsIGhhc2gpO1xyXG4gIH1cclxuXHJcbiAgLy8gVW5sZXNzIGV4cGxpY2l0bHkgc3RvcHBlZCBvciB0aGUgZXZlbnQgZG9lcyBub3QgYnViYmxlIChlLmcuIG1lZGlhIGV2ZW50cylcclxuICAvLyByZWN1cnNpdmVseSBjYWxscyB0aGlzIGZ1bmN0aW9uIHRvIGJ1YmJsZSB0aGUgZXZlbnQgdXAgdGhlIERPTS5cclxuICBpZiAocGFyZW50ICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICYmIGV2ZW50LmJ1YmJsZXMgPT09IHRydWUpIHtcclxuICAgIHRyaWdnZXIuY2FsbChudWxsLCBwYXJlbnQsIGV2ZW50LCBoYXNoKTtcclxuXHJcbiAgICAvLyBJZiBhdCB0aGUgdG9wIG9mIHRoZSBET00sIHRyaWdnZXJzIHRoZSBkZWZhdWx0IGFjdGlvbiB1bmxlc3MgZGlzYWJsZWQuXHJcbiAgfSBlbHNlIGlmICghcGFyZW50ICYmICFldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IGdldERhdGEoZXZlbnQudGFyZ2V0KTtcclxuXHJcbiAgICAvLyBDaGVja3MgaWYgdGhlIHRhcmdldCBoYXMgYSBkZWZhdWx0IGFjdGlvbiBmb3IgdGhpcyBldmVudC5cclxuICAgIGlmIChldmVudC50YXJnZXRbZXZlbnQudHlwZV0pIHtcclxuICAgICAgLy8gVGVtcG9yYXJpbHkgZGlzYWJsZXMgZXZlbnQgZGlzcGF0Y2hpbmcgb24gdGhlIHRhcmdldCBhcyB3ZSBoYXZlIGFscmVhZHkgZXhlY3V0ZWQgdGhlIGhhbmRsZXIuXHJcbiAgICAgIHRhcmdldERhdGEuZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAvLyBFeGVjdXRlcyB0aGUgZGVmYXVsdCBhY3Rpb24uXHJcbiAgICAgIGlmICh0eXBlb2YgZXZlbnQudGFyZ2V0W2V2ZW50LnR5cGVdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgZXZlbnQudGFyZ2V0W2V2ZW50LnR5cGVdKCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gUmUtZW5hYmxlcyBldmVudCBkaXNwYXRjaGluZy5cclxuICAgICAgdGFyZ2V0RGF0YS5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gSW5mb3JtIHRoZSB0cmlnZ2VyZXIgaWYgdGhlIGRlZmF1bHQgd2FzIHByZXZlbnRlZCBieSByZXR1cm5pbmcgZmFsc2VcclxuICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcmlnZ2VyIGEgbGlzdGVuZXIgb25seSBvbmNlIGZvciBhbiBldmVudFxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtXHJcbiAqICAgICAgICBFbGVtZW50IG9yIG9iamVjdCB0byBiaW5kIHRvLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdHlwZVxyXG4gKiAgICAgICAgTmFtZS90eXBlIG9mIGV2ZW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7RXZlbnR+RXZlbnRMaXN0ZW5lcn0gZm5cclxuICogICAgICAgIEV2ZW50IExpc3RlbmVyIGZ1bmN0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBvbmUoZWxlbSwgdHlwZSwgZm4pIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xyXG4gICAgcmV0dXJuIF9oYW5kbGVNdWx0aXBsZUV2ZW50cyhvbmUsIGVsZW0sIHR5cGUsIGZuKTtcclxuICB9XHJcbiAgdmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKCkge1xyXG4gICAgb2ZmKGVsZW0sIHR5cGUsIGZ1bmMpO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9O1xyXG5cclxuICAvLyBjb3B5IHRoZSBndWlkIHRvIHRoZSBuZXcgZnVuY3Rpb24gc28gaXQgY2FuIHJlbW92ZWQgdXNpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uJ3MgSURcclxuICBmdW5jLmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBuZXdHVUlEKCk7XHJcbiAgb24oZWxlbSwgdHlwZSwgZnVuYyk7XHJcbn1cclxuXHJcbnZhciBFdmVudHMgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcclxuXHRmaXhFdmVudDogZml4RXZlbnQsXHJcblx0b246IG9uLFxyXG5cdG9mZjogb2ZmLFxyXG5cdHRyaWdnZXI6IHRyaWdnZXIsXHJcblx0b25lOiBvbmVcclxufSk7XHJcblxyXG4vKipcclxuICogQGZpbGUgc2V0dXAuanMgLSBGdW5jdGlvbnMgZm9yIHNldHRpbmcgdXAgYSBwbGF5ZXIgd2l0aG91dFxyXG4gKiB1c2VyIGludGVyYWN0aW9uIGJhc2VkIG9uIHRoZSBkYXRhLXNldHVwIGBhdHRyaWJ1dGVgIG9mIHRoZSB2aWRlbyB0YWcuXHJcbiAqXHJcbiAqIEBtb2R1bGUgc2V0dXBcclxuICovXHJcbnZhciBfd2luZG93TG9hZGVkID0gZmFsc2U7XHJcbnZhciB2aWRlb2pzJDIgPSB2b2lkIDA7XHJcblxyXG4vKipcclxuICogU2V0IHVwIGFueSB0YWdzIHRoYXQgaGF2ZSBhIGRhdGEtc2V0dXAgYGF0dHJpYnV0ZWAgd2hlbiB0aGUgcGxheWVyIGlzIHN0YXJ0ZWQuXHJcbiAqL1xyXG52YXIgYXV0b1NldHVwID0gZnVuY3Rpb24gYXV0b1NldHVwKCkge1xyXG5cclxuICAvLyBQcm90ZWN0IGFnYWluc3QgYnJlYWthZ2UgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLlxyXG4gIGlmICghaXNSZWFsKCkpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIC8vIE9uZSBkYXksIHdoZW4gd2Ugc3RvcCBzdXBwb3J0aW5nIElFOCwgZ28gYmFjayB0byB0aGlzLCBidXQgaW4gdGhlIG1lYW50aW1lLi4uKmhhY2sgaGFjayBoYWNrKlxyXG4gIC8vIHZhciB2aWRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpZGVvJykpO1xyXG4gIC8vIHZhciBhdWRpb3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYXVkaW8nKSk7XHJcbiAgLy8gdmFyIG1lZGlhRWxzID0gdmlkcy5jb25jYXQoYXVkaW9zKTtcclxuXHJcbiAgLy8gQmVjYXVzZSBJRTggZG9lc24ndCBzdXBwb3J0IGNhbGxpbmcgc2xpY2Ugb24gYSBub2RlIGxpc3QsIHdlIG5lZWQgdG8gbG9vcFxyXG4gIC8vIHRocm91Z2ggZWFjaCBsaXN0IG9mIGVsZW1lbnRzIHRvIGJ1aWxkIHVwIGEgbmV3LCBjb21iaW5lZCBsaXN0IG9mIGVsZW1lbnRzLlxyXG4gIHZhciB2aWRzID0gZG9jdW1lbnRfMS5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKTtcclxuICB2YXIgYXVkaW9zID0gZG9jdW1lbnRfMS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYXVkaW8nKTtcclxuICB2YXIgbWVkaWFFbHMgPSBbXTtcclxuXHJcbiAgaWYgKHZpZHMgJiYgdmlkcy5sZW5ndGggPiAwKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgZSA9IHZpZHMubGVuZ3RoOyBpIDwgZTsgaSsrKSB7XHJcbiAgICAgIG1lZGlhRWxzLnB1c2godmlkc1tpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoYXVkaW9zICYmIGF1ZGlvcy5sZW5ndGggPiAwKSB7XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9lID0gYXVkaW9zLmxlbmd0aDsgX2kgPCBfZTsgX2krKykge1xyXG4gICAgICBtZWRpYUVscy5wdXNoKGF1ZGlvc1tfaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgaWYgYW55IG1lZGlhIGVsZW1lbnRzIGV4aXN0XHJcbiAgaWYgKG1lZGlhRWxzICYmIG1lZGlhRWxzLmxlbmd0aCA+IDApIHtcclxuXHJcbiAgICBmb3IgKHZhciBfaTIgPSAwLCBfZTIgPSBtZWRpYUVscy5sZW5ndGg7IF9pMiA8IF9lMjsgX2kyKyspIHtcclxuICAgICAgdmFyIG1lZGlhRWwgPSBtZWRpYUVsc1tfaTJdO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgZWxlbWVudCBleGlzdHMsIGhhcyBnZXRBdHRyaWJ1dGUgZnVuYy5cclxuICAgICAgLy8gSUUgc2VlbXMgdG8gY29uc2lkZXIgdHlwZW9mIGVsLmdldEF0dHJpYnV0ZSA9PSAnb2JqZWN0JyBpbnN0ZWFkIG9mXHJcbiAgICAgIC8vICdmdW5jdGlvbicgbGlrZSBleHBlY3RlZCwgYXQgbGVhc3Qgd2hlbiBsb2FkaW5nIHRoZSBwbGF5ZXIgaW1tZWRpYXRlbHkuXHJcbiAgICAgIGlmIChtZWRpYUVsICYmIG1lZGlhRWwuZ2V0QXR0cmlidXRlKSB7XHJcblxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIHBsYXllciBoYXNuJ3QgYWxyZWFkeSBiZWVuIHNldCB1cC5cclxuICAgICAgICBpZiAobWVkaWFFbC5wbGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSBtZWRpYUVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zZXR1cCcpO1xyXG5cclxuICAgICAgICAgIC8vIENoZWNrIGlmIGRhdGEtc2V0dXAgYXR0ciBleGlzdHMuXHJcbiAgICAgICAgICAvLyBXZSBvbmx5IGF1dG8tc2V0dXAgaWYgdGhleSd2ZSBhZGRlZCB0aGUgZGF0YS1zZXR1cCBhdHRyLlxyXG4gICAgICAgICAgaWYgKG9wdGlvbnMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyB2aWRlby5qcyBpbnN0YW5jZS5cclxuICAgICAgICAgICAgdmlkZW9qcyQyKG1lZGlhRWwpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgZ2V0QXR0cmlidXRlIGlzbid0IGRlZmluZWQsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIERPTS5cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhdXRvU2V0dXBUaW1lb3V0KDEpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm8gdmlkZW9zIHdlcmUgZm91bmQsIHNvIGtlZXAgbG9vcGluZyB1bmxlc3MgcGFnZSBpcyBmaW5pc2hlZCBsb2FkaW5nLlxyXG4gIH0gZWxzZSBpZiAoIV93aW5kb3dMb2FkZWQpIHtcclxuICAgIGF1dG9TZXR1cFRpbWVvdXQoMSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdhaXQgdW50aWwgdGhlIHBhZ2UgaXMgbG9hZGVkIGJlZm9yZSBydW5uaW5nIGF1dG9TZXR1cC4gVGhpcyB3aWxsIGJlIGNhbGxlZCBpblxyXG4gKiBhdXRvU2V0dXAgaWYgYGhhc0xvYWRlZGAgcmV0dXJucyBmYWxzZS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHdhaXRcclxuICogICAgICAgIEhvdyBsb25nIHRvIHdhaXQgaW4gbXNcclxuICpcclxuICogQHBhcmFtIHttb2R1bGU6dmlkZW9qc30gW3Zqc11cclxuICogICAgICAgIFRoZSB2aWRlb2pzIGxpYnJhcnkgZnVuY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGF1dG9TZXR1cFRpbWVvdXQod2FpdCwgdmpzKSB7XHJcbiAgaWYgKHZqcykge1xyXG4gICAgdmlkZW9qcyQyID0gdmpzO1xyXG4gIH1cclxuXHJcbiAgd2luZG93XzEuc2V0VGltZW91dChhdXRvU2V0dXAsIHdhaXQpO1xyXG59XHJcblxyXG5pZiAoaXNSZWFsKCkgJiYgZG9jdW1lbnRfMS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgX3dpbmRvd0xvYWRlZCA9IHRydWU7XHJcbn0gZWxzZSB7XHJcbiAgLyoqXHJcbiAgICogTGlzdGVuIGZvciB0aGUgbG9hZCBldmVudCBvbiB3aW5kb3csIGFuZCBzZXQgX3dpbmRvd0xvYWRlZCB0byB0cnVlLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgbG9hZFxyXG4gICAqL1xyXG4gIG9uZSh3aW5kb3dfMSwgJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBfd2luZG93TG9hZGVkID0gdHJ1ZTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmaWxlIHN0eWxlc2hlZXQuanNcclxuICogQG1vZHVsZSBzdHlsZXNoZWV0XHJcbiAqL1xyXG4vKipcclxuICogQ3JlYXRlIGEgRE9NIHN5bGUgZWxlbWVudCBnaXZlbiBhIGNsYXNzTmFtZSBmb3IgaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcclxuICogICAgICAgIFRoZSBjbGFzc05hbWUgdG8gYWRkIHRvIHRoZSBjcmVhdGVkIHN0eWxlIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cclxuICovXHJcbnZhciBjcmVhdGVTdHlsZUVsZW1lbnQgPSBmdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQoY2xhc3NOYW1lKSB7XHJcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnRfMS5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG5cclxuICBzdHlsZS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XHJcblxyXG4gIHJldHVybiBzdHlsZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgdGV4dCB0byBhIERPTSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXHJcbiAqICAgICAgICBUaGUgRWxlbWVudCB0byBhZGQgdGV4dCBjb250ZW50IHRvLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxyXG4gKiAgICAgICAgVGhlIHRleHQgdG8gYWRkIHRvIHRoZSBlbGVtZW50LlxyXG4gKi9cclxudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQoZWwsIGNvbnRlbnQpIHtcclxuICBpZiAoZWwuc3R5bGVTaGVldCkge1xyXG4gICAgZWwuc3R5bGVTaGVldC5jc3NUZXh0ID0gY29udGVudDtcclxuICB9IGVsc2Uge1xyXG4gICAgZWwudGV4dENvbnRlbnQgPSBjb250ZW50O1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBmbi5qc1xyXG4gKiBAbW9kdWxlIGZuXHJcbiAqL1xyXG4vKipcclxuICogQmluZCAoYS5rLmEgcHJveHkgb3IgQ29udGV4dCkuIEEgc2ltcGxlIG1ldGhvZCBmb3IgY2hhbmdpbmcgdGhlIGNvbnRleHQgb2YgYSBmdW5jdGlvblxyXG4gKiBJdCBhbHNvIHN0b3JlcyBhIHVuaXF1ZSBpZCBvbiB0aGUgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGVhc2lseSByZW1vdmVkIGZyb20gZXZlbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge01peGVkfSBjb250ZXh0XHJcbiAqICAgICAgICBUaGUgb2JqZWN0IHRvIGJpbmQgYXMgc2NvcGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gYmUgYm91bmQgdG8gYSBzY29wZS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IFt1aWRdXHJcbiAqICAgICAgICBBbiBvcHRpb25hbCB1bmlxdWUgSUQgZm9yIHRoZSBmdW5jdGlvbiB0byBiZSBzZXRcclxuICpcclxuICogQHJldHVybiB7RnVuY3Rpb259XHJcbiAqICAgICAgICAgVGhlIG5ldyBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgYm91bmQgaW50byB0aGUgY29udGV4dCBnaXZlblxyXG4gKi9cclxudmFyIGJpbmQgPSBmdW5jdGlvbiBiaW5kKGNvbnRleHQsIGZuLCB1aWQpIHtcclxuICAvLyBNYWtlIHN1cmUgdGhlIGZ1bmN0aW9uIGhhcyBhIHVuaXF1ZSBJRFxyXG4gIGlmICghZm4uZ3VpZCkge1xyXG4gICAgZm4uZ3VpZCA9IG5ld0dVSUQoKTtcclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZSB0aGUgbmV3IGZ1bmN0aW9uIHRoYXQgY2hhbmdlcyB0aGUgY29udGV4dFxyXG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uIGJvdW5kKCkge1xyXG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQWxsb3cgZm9yIHRoZSBhYmlsaXR5IHRvIGluZGl2aWR1YWxpemUgdGhpcyBmdW5jdGlvblxyXG4gIC8vIE5lZWRlZCBpbiB0aGUgY2FzZSB3aGVyZSBtdWx0aXBsZSBvYmplY3RzIG1pZ2h0IHNoYXJlIHRoZSBzYW1lIHByb3RvdHlwZVxyXG4gIC8vIElGIGJvdGggaXRlbXMgYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHdpdGggdGhlIHNhbWUgZnVuY3Rpb24sIHRoZW4geW91IHRyeSB0byByZW1vdmUganVzdCBvbmVcclxuICAvLyBpdCB3aWxsIHJlbW92ZSBib3RoIGJlY2F1c2UgdGhleSBib3RoIGhhdmUgdGhlIHNhbWUgZ3VpZC5cclxuICAvLyB3aGVuIHVzaW5nIHRoaXMsIHlvdSBuZWVkIHRvIHVzZSB0aGUgYmluZCBtZXRob2Qgd2hlbiB5b3UgcmVtb3ZlIHRoZSBsaXN0ZW5lciBhcyB3ZWxsLlxyXG4gIC8vIGN1cnJlbnRseSB1c2VkIGluIHRleHQgdHJhY2tzXHJcbiAgYm91bmQuZ3VpZCA9IHVpZCA/IHVpZCArICdfJyArIGZuLmd1aWQgOiBmbi5ndWlkO1xyXG5cclxuICByZXR1cm4gYm91bmQ7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JhcHMgdGhlIGdpdmVuIGZ1bmN0aW9uLCBgZm5gLCB3aXRoIGEgbmV3IGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmbmBcclxuICogYXQgbW9zdCBvbmNlIHBlciBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm5cclxuICogICAgICAgICBUaGUgZnVuY3Rpb24gdG8gYmUgdGhyb3R0bGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgd2FpdFxyXG4gKiAgICAgICAgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGJ5IHdoaWNoIHRvIHRocm90dGxlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cclxuICovXHJcbnZhciB0aHJvdHRsZSA9IGZ1bmN0aW9uIHRocm90dGxlKGZuLCB3YWl0KSB7XHJcbiAgdmFyIGxhc3QgPSBEYXRlLm5vdygpO1xyXG5cclxuICB2YXIgdGhyb3R0bGVkID0gZnVuY3Rpb24gdGhyb3R0bGVkKCkge1xyXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XHJcblxyXG4gICAgaWYgKG5vdyAtIGxhc3QgPj0gd2FpdCkge1xyXG4gICAgICBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XHJcbiAgICAgIGxhc3QgPSBub3c7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHRocm90dGxlZDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBzcmMvanMvZXZlbnQtdGFyZ2V0LmpzXHJcbiAqL1xyXG4vKipcclxuICogYEV2ZW50VGFyZ2V0YCBpcyBhIGNsYXNzIHRoYXQgY2FuIGhhdmUgdGhlIHNhbWUgQVBJIGFzIHRoZSBET00gYEV2ZW50VGFyZ2V0YC4gSXRcclxuICogYWRkcyBzaG9ydGhhbmQgZnVuY3Rpb25zIHRoYXQgd3JhcCBhcm91bmQgbGVuZ3RoeSBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxyXG4gKiB0aGUgYG9uYCBmdW5jdGlvbiBpcyBhIHdyYXBwZXIgYXJvdW5kIGBhZGRFdmVudExpc3RlbmVyYC5cclxuICpcclxuICogQHNlZSBbRXZlbnRUYXJnZXQgU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXR9XHJcbiAqIEBjbGFzcyBFdmVudFRhcmdldFxyXG4gKi9cclxudmFyIEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIEN1c3RvbSBET00gZXZlbnQuXHJcbiAqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEV2ZW50VGFyZ2V0fkV2ZW50XHJcbiAqIEBzZWUgW1Byb3BlcnRpZXNde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudH1cclxuICovXHJcblxyXG4vKipcclxuICogQWxsIGV2ZW50IGxpc3RlbmVycyBzaG91bGQgZm9sbG93IHRoZSBmb2xsb3dpbmcgZm9ybWF0LlxyXG4gKlxyXG4gKiBAY2FsbGJhY2sgRXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lclxyXG4gKiBAdGhpcyB7RXZlbnRUYXJnZXR9XHJcbiAqXHJcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAqICAgICAgICB0aGUgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2hhc2hdXHJcbiAqICAgICAgICBoYXNoIG9mIGRhdGEgc2VudCBkdXJpbmcgdGhlIGV2ZW50XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEFuIG9iamVjdCBjb250YWluaW5nIGV2ZW50IG5hbWVzIGFzIGtleXMgYW5kIGJvb2xlYW5zIGFzIHZhbHVlcy5cclxuICpcclxuICogPiBOT1RFOiBJZiBhbiBldmVudCBuYW1lIGlzIHNldCB0byBhIHRydWUgdmFsdWUgaGVyZSB7QGxpbmsgRXZlbnRUYXJnZXQjdHJpZ2dlcn1cclxuICogICAgICAgICB3aWxsIGhhdmUgZXh0cmEgZnVuY3Rpb25hbGl0eS4gU2VlIHRoYXQgZnVuY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSBFdmVudFRhcmdldC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c19cclxuICogQHByaXZhdGVcclxuICovXHJcbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hbGxvd2VkRXZlbnRzXyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50IGxpc3RlbmVyYCB0byBhbiBpbnN0YW5jZSBvZiBhbiBgRXZlbnRUYXJnZXRgLiBBbiBgZXZlbnQgbGlzdGVuZXJgIGlzIGFcclxuICogZnVuY3Rpb24gdGhhdCB3aWxsIGdldCBjYWxsZWQgd2hlbiBhbiBldmVudCB3aXRoIGEgY2VydGFpbiBuYW1lIGdldHMgdHJpZ2dlcmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gdHlwZVxyXG4gKiAgICAgICAgQW4gZXZlbnQgbmFtZSBvciBhbiBhcnJheSBvZiBldmVudCBuYW1lcy5cclxuICpcclxuICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBmblxyXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBgRXZlbnRUYXJnZXRgc1xyXG4gKi9cclxuRXZlbnRUYXJnZXQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHR5cGUsIGZuKSB7XHJcbiAgLy8gUmVtb3ZlIHRoZSBhZGRFdmVudExpc3RlbmVyIGFsaWFzIGJlZm9yZSBjYWxsaW5nIEV2ZW50cy5vblxyXG4gIC8vIHNvIHdlIGRvbid0IGdldCBpbnRvIGFuIGluZmluaXRlIHR5cGUgbG9vcFxyXG4gIHZhciBhZWwgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXI7XHJcblxyXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHt9O1xyXG4gIG9uKHRoaXMsIHR5cGUsIGZuKTtcclxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBhZWw7XHJcbn07XHJcblxyXG4vKipcclxuICogQW4gYWxpYXMgb2Yge0BsaW5rIEV2ZW50VGFyZ2V0I29ufS4gQWxsb3dzIGBFdmVudFRhcmdldGAgdG8gbWltaWNcclxuICogdGhlIHN0YW5kYXJkIERPTSBBUEkuXHJcbiAqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAc2VlIHtAbGluayBFdmVudFRhcmdldCNvbn1cclxuICovXHJcbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLm9uO1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYW4gYGV2ZW50IGxpc3RlbmVyYCBmb3IgYSBzcGVjaWZpYyBldmVudCBmcm9tIGFuIGluc3RhbmNlIG9mIGBFdmVudFRhcmdldGAuXHJcbiAqIFRoaXMgbWFrZXMgaXQgc28gdGhhdCB0aGUgYGV2ZW50IGxpc3RlbmVyYCB3aWxsIG5vIGxvbmdlciBnZXQgY2FsbGVkIHdoZW4gdGhlXHJcbiAqIG5hbWVkIGV2ZW50IGhhcHBlbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlXHJcbiAqICAgICAgICBBbiBldmVudCBuYW1lIG9yIGFuIGFycmF5IG9mIGV2ZW50IG5hbWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50TGlzdGVuZXJ9IGZuXHJcbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdG8gcmVtb3ZlLlxyXG4gKi9cclxuRXZlbnRUYXJnZXQucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xyXG4gIG9mZih0aGlzLCB0eXBlLCBmbik7XHJcbn07XHJcblxyXG4vKipcclxuICogQW4gYWxpYXMgb2Yge0BsaW5rIEV2ZW50VGFyZ2V0I29mZn0uIEFsbG93cyBgRXZlbnRUYXJnZXRgIHRvIG1pbWljXHJcbiAqIHRoZSBzdGFuZGFyZCBET00gQVBJLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHNlZSB7QGxpbmsgRXZlbnRUYXJnZXQjb2ZmfVxyXG4gKi9cclxuRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUub2ZmO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhZGQgYW4gYGV2ZW50IGxpc3RlbmVyYCB0aGF0IGdldHMgdHJpZ2dlcmVkIG9ubHkgb25jZS4gQWZ0ZXIgdGhlXHJcbiAqIGZpcnN0IHRyaWdnZXIgaXQgd2lsbCBnZXQgcmVtb3ZlZC4gVGhpcyBpcyBsaWtlIGFkZGluZyBhbiBgZXZlbnQgbGlzdGVuZXJgXHJcbiAqIHdpdGgge0BsaW5rIEV2ZW50VGFyZ2V0I29ufSB0aGF0IGNhbGxzIHtAbGluayBFdmVudFRhcmdldCNvZmZ9IG9uIGl0c2VsZi5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHR5cGVcclxuICogICAgICAgIEFuIGV2ZW50IG5hbWUgb3IgYW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcn0gZm5cclxuICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBldmVudCBuYW1lLlxyXG4gKi9cclxuRXZlbnRUYXJnZXQucHJvdG90eXBlLm9uZSA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xyXG4gIC8vIFJlbW92ZSB0aGUgYWRkRXZlbnRMaXN0ZW5lciBhbGlhbGluZyBFdmVudHMub25cclxuICAvLyBzbyB3ZSBkb24ndCBnZXQgaW50byBhbiBpbmZpbml0ZSB0eXBlIGxvb3BcclxuICB2YXIgYWVsID0gdGhpcy5hZGRFdmVudExpc3RlbmVyO1xyXG5cclxuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7fTtcclxuICBvbmUodGhpcywgdHlwZSwgZm4pO1xyXG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGFlbDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGNhdXNlcyBhbiBldmVudCB0byBoYXBwZW4uIFRoaXMgd2lsbCB0aGVuIGNhdXNlIGFueSBgZXZlbnQgbGlzdGVuZXJzYFxyXG4gKiB0aGF0IGFyZSB3YWl0aW5nIGZvciB0aGF0IGV2ZW50LCB0byBnZXQgY2FsbGVkLiBJZiB0aGVyZSBhcmUgbm8gYGV2ZW50IGxpc3RlbmVyc2BcclxuICogZm9yIGFuIGV2ZW50IHRoZW4gbm90aGluZyB3aWxsIGhhcHBlbi5cclxuICpcclxuICogSWYgdGhlIG5hbWUgb2YgdGhlIGBFdmVudGAgdGhhdCBpcyBiZWluZyB0cmlnZ2VyZWQgaXMgaW4gYEV2ZW50VGFyZ2V0LmFsbG93ZWRFdmVudHNfYC5cclxuICogVHJpZ2dlciB3aWxsIGFsc28gY2FsbCB0aGUgYG9uYCArIGB1cHBlcmNhc2VFdmVudE5hbWVgIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKiAnY2xpY2snIGlzIGluIGBFdmVudFRhcmdldC5hbGxvd2VkRXZlbnRzX2AsIHNvLCB0cmlnZ2VyIHdpbGwgYXR0ZW1wdCB0byBjYWxsXHJcbiAqIGBvbkNsaWNrYCBpZiBpdCBleGlzdHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfEV2ZW50VGFyZ2V0fkV2ZW50fE9iamVjdH0gZXZlbnRcclxuICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBldmVudCwgYW4gYEV2ZW50YCwgb3IgYW4gb2JqZWN0IHdpdGggYSBrZXkgb2YgdHlwZSBzZXQgdG9cclxuICogICAgICAgIGFuIGV2ZW50IG5hbWUuXHJcbiAqL1xyXG5FdmVudFRhcmdldC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCBldmVudDtcclxuXHJcbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcclxuICAgIGV2ZW50ID0geyB0eXBlOiB0eXBlIH07XHJcbiAgfVxyXG4gIGV2ZW50ID0gZml4RXZlbnQoZXZlbnQpO1xyXG5cclxuICBpZiAodGhpcy5hbGxvd2VkRXZlbnRzX1t0eXBlXSAmJiB0aGlzWydvbicgKyB0eXBlXSkge1xyXG4gICAgdGhpc1snb24nICsgdHlwZV0oZXZlbnQpO1xyXG4gIH1cclxuXHJcbiAgdHJpZ2dlcih0aGlzLCBldmVudCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQW4gYWxpYXMgb2Yge0BsaW5rIEV2ZW50VGFyZ2V0I3RyaWdnZXJ9LiBBbGxvd3MgYEV2ZW50VGFyZ2V0YCB0byBtaW1pY1xyXG4gKiB0aGUgc3RhbmRhcmQgRE9NIEFQSS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBzZWUge0BsaW5rIEV2ZW50VGFyZ2V0I3RyaWdnZXJ9XHJcbiAqL1xyXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS50cmlnZ2VyO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIG1peGlucy9ldmVudGVkLmpzXHJcbiAqIEBtb2R1bGUgZXZlbnRlZFxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGhhcyBoYWQgdGhlIGV2ZW50ZWQgbWl4aW4gYXBwbGllZC5cclxuICpcclxuICogQHBhcmFtICB7T2JqZWN0fSBvYmplY3RcclxuICogICAgICAgICBBbiBvYmplY3QgdG8gdGVzdC5cclxuICpcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICogICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGFwcGVhcnMgdG8gYmUgZXZlbnRlZC5cclxuICovXHJcbnZhciBpc0V2ZW50ZWQgPSBmdW5jdGlvbiBpc0V2ZW50ZWQob2JqZWN0KSB7XHJcbiAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0IHx8ICEhb2JqZWN0LmV2ZW50QnVzRWxfICYmIFsnb24nLCAnb25lJywgJ29mZicsICd0cmlnZ2VyJ10uZXZlcnkoZnVuY3Rpb24gKGspIHtcclxuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0W2tdID09PSAnZnVuY3Rpb24nO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdoZXRoZXIgYSB2YWx1ZSBpcyBhIHZhbGlkIGV2ZW50IHR5cGUgLSBub24tZW1wdHkgc3RyaW5nIG9yIGFycmF5LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl9IHR5cGVcclxuICogICAgICAgICBUaGUgdHlwZSB2YWx1ZSB0byB0ZXN0LlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKiAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSB0eXBlIGlzIGEgdmFsaWQgZXZlbnQgdHlwZS5cclxuICovXHJcbnZhciBpc1ZhbGlkRXZlbnRUeXBlID0gZnVuY3Rpb24gaXNWYWxpZEV2ZW50VHlwZSh0eXBlKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIC8vIFRoZSByZWdleCBoZXJlIHZlcmlmaWVzIHRoYXQgdGhlIGB0eXBlYCBjb250YWlucyBhdCBsZWFzdCBvbmUgbm9uLVxyXG4gICAgLy8gd2hpdGVzcGFjZSBjaGFyYWN0ZXIuXHJcbiAgICB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgJiYgL1xcUy8udGVzdCh0eXBlKSB8fCBBcnJheS5pc0FycmF5KHR5cGUpICYmICEhdHlwZS5sZW5ndGhcclxuICApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBhIHZhbHVlIHRvIGRldGVybWluZSBpZiBpdCBpcyBhIHZhbGlkIGV2ZW50IHRhcmdldC4gVGhyb3dzIGlmIG5vdC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHRocm93cyB7RXJyb3J9XHJcbiAqICAgICAgICAgSWYgdGhlIHRhcmdldCBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSB2YWxpZCBldmVudCB0YXJnZXQuXHJcbiAqXHJcbiAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XHJcbiAqICAgICAgICAgVGhlIG9iamVjdCB0byB0ZXN0LlxyXG4gKi9cclxudmFyIHZhbGlkYXRlVGFyZ2V0ID0gZnVuY3Rpb24gdmFsaWRhdGVUYXJnZXQodGFyZ2V0KSB7XHJcbiAgaWYgKCF0YXJnZXQubm9kZU5hbWUgJiYgIWlzRXZlbnRlZCh0YXJnZXQpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFyZ2V0OyBtdXN0IGJlIGEgRE9NIG5vZGUgb3IgZXZlbnRlZCBvYmplY3QuJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBhIHZhbHVlIHRvIGRldGVybWluZSBpZiBpdCBpcyBhIHZhbGlkIGV2ZW50IHRhcmdldC4gVGhyb3dzIGlmIG5vdC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHRocm93cyB7RXJyb3J9XHJcbiAqICAgICAgICAgSWYgdGhlIHR5cGUgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgdmFsaWQgZXZlbnQgdHlwZS5cclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfEFycmF5fSB0eXBlXHJcbiAqICAgICAgICAgVGhlIHR5cGUgdG8gdGVzdC5cclxuICovXHJcbnZhciB2YWxpZGF0ZUV2ZW50VHlwZSA9IGZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRUeXBlKHR5cGUpIHtcclxuICBpZiAoIWlzVmFsaWRFdmVudFR5cGUodHlwZSkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBldmVudCB0eXBlOyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciBhcnJheS4nKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVmFsaWRhdGVzIGEgdmFsdWUgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGEgdmFsaWQgbGlzdGVuZXIuIFRocm93cyBpZiBub3QuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEB0aHJvd3Mge0Vycm9yfVxyXG4gKiAgICAgICAgIElmIHRoZSBsaXN0ZW5lciBpcyBub3QgYSBmdW5jdGlvbi5cclxuICpcclxuICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXHJcbiAqICAgICAgICAgVGhlIGxpc3RlbmVyIHRvIHRlc3QuXHJcbiAqL1xyXG52YXIgdmFsaWRhdGVMaXN0ZW5lciA9IGZ1bmN0aW9uIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdGVuZXI7IG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogVGFrZXMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIGdpdmVuIHRvIGBvbigpYCBvciBgb25lKClgLCB2YWxpZGF0ZXMgdGhlbSwgYW5kXHJcbiAqIG5vcm1hbGl6ZXMgdGhlbSBpbnRvIGFuIG9iamVjdC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtICB7T2JqZWN0fSBzZWxmXHJcbiAqICAgICAgICAgVGhlIGV2ZW50ZWQgb2JqZWN0IG9uIHdoaWNoIGBvbigpYCBvciBgb25lKClgIHdhcyBjYWxsZWQuIFRoaXNcclxuICogICAgICAgICBvYmplY3Qgd2lsbCBiZSBib3VuZCBhcyB0aGUgYHRoaXNgIHZhbHVlIGZvciB0aGUgbGlzdGVuZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSAge0FycmF5fSBhcmdzXHJcbiAqICAgICAgICAgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHBhc3NlZCB0byBgb24oKWAgb3IgYG9uZSgpYC5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHVzZWZ1bCB2YWx1ZXMgZm9yIGBvbigpYCBvciBgb25lKClgIGNhbGxzLlxyXG4gKi9cclxudmFyIG5vcm1hbGl6ZUxpc3RlbkFyZ3MgPSBmdW5jdGlvbiBub3JtYWxpemVMaXN0ZW5BcmdzKHNlbGYsIGFyZ3MpIHtcclxuXHJcbiAgLy8gSWYgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgaXMgbGVzcyB0aGFuIDMsIHRoZSB0YXJnZXQgaXMgYWx3YXlzIHRoZVxyXG4gIC8vIGV2ZW50ZWQgb2JqZWN0IGl0c2VsZi5cclxuICB2YXIgaXNUYXJnZXRpbmdTZWxmID0gYXJncy5sZW5ndGggPCAzIHx8IGFyZ3NbMF0gPT09IHNlbGYgfHwgYXJnc1swXSA9PT0gc2VsZi5ldmVudEJ1c0VsXztcclxuICB2YXIgdGFyZ2V0ID0gdm9pZCAwO1xyXG4gIHZhciB0eXBlID0gdm9pZCAwO1xyXG4gIHZhciBsaXN0ZW5lciA9IHZvaWQgMDtcclxuXHJcbiAgaWYgKGlzVGFyZ2V0aW5nU2VsZikge1xyXG4gICAgdGFyZ2V0ID0gc2VsZi5ldmVudEJ1c0VsXztcclxuXHJcbiAgICAvLyBEZWFsIHdpdGggY2FzZXMgd2hlcmUgd2UgZ290IDMgYXJndW1lbnRzLCBidXQgd2UgYXJlIHN0aWxsIGxpc3RlbmluZyB0b1xyXG4gICAgLy8gdGhlIGV2ZW50ZWQgb2JqZWN0IGl0c2VsZi5cclxuICAgIGlmIChhcmdzLmxlbmd0aCA+PSAzKSB7XHJcbiAgICAgIGFyZ3Muc2hpZnQoKTtcclxuICAgIH1cclxuXHJcbiAgICB0eXBlID0gYXJnc1swXTtcclxuICAgIGxpc3RlbmVyID0gYXJnc1sxXTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGFyZ2V0ID0gYXJnc1swXTtcclxuICAgIHR5cGUgPSBhcmdzWzFdO1xyXG4gICAgbGlzdGVuZXIgPSBhcmdzWzJdO1xyXG4gIH1cclxuXHJcbiAgdmFsaWRhdGVUYXJnZXQodGFyZ2V0KTtcclxuICB2YWxpZGF0ZUV2ZW50VHlwZSh0eXBlKTtcclxuICB2YWxpZGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcclxuXHJcbiAgbGlzdGVuZXIgPSBiaW5kKHNlbGYsIGxpc3RlbmVyKTtcclxuXHJcbiAgcmV0dXJuIHsgaXNUYXJnZXRpbmdTZWxmOiBpc1RhcmdldGluZ1NlbGYsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIHRoZSBsaXN0ZW5lciB0byB0aGUgZXZlbnQgdHlwZShzKSBvbiB0aGUgdGFyZ2V0LCBub3JtYWxpemluZyBmb3JcclxuICogdGhlIHR5cGUgb2YgdGFyZ2V0LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0gIHtFbGVtZW50fE9iamVjdH0gdGFyZ2V0XHJcbiAqICAgICAgICAgQSBET00gbm9kZSBvciBldmVudGVkIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSBtZXRob2RcclxuICogICAgICAgICBUaGUgZXZlbnQgYmluZGluZyBtZXRob2QgdG8gdXNlIChcIm9uXCIgb3IgXCJvbmVcIikuXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ3xBcnJheX0gdHlwZVxyXG4gKiAgICAgICAgIE9uZSBvciBtb3JlIGV2ZW50IHR5cGUocykuXHJcbiAqXHJcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxyXG4gKiAgICAgICAgIEEgbGlzdGVuZXIgZnVuY3Rpb24uXHJcbiAqL1xyXG52YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgbWV0aG9kLCB0eXBlLCBsaXN0ZW5lcikge1xyXG4gIHZhbGlkYXRlVGFyZ2V0KHRhcmdldCk7XHJcblxyXG4gIGlmICh0YXJnZXQubm9kZU5hbWUpIHtcclxuICAgIEV2ZW50c1ttZXRob2RdKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0YXJnZXRbbWV0aG9kXSh0eXBlLCBsaXN0ZW5lcik7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnRhaW5zIG1ldGhvZHMgdGhhdCBwcm92aWRlIGV2ZW50IGNhcGFiaWxpdGVzIHRvIGFuIG9iamVjdCB3aGljaCBpcyBwYXNzZWRcclxuICogdG8ge0BsaW5rIG1vZHVsZTpldmVudGVkfGV2ZW50ZWR9LlxyXG4gKlxyXG4gKiBAbWl4aW4gRXZlbnRlZE1peGluXHJcbiAqL1xyXG52YXIgRXZlbnRlZE1peGluID0ge1xyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSBsaXN0ZW5lciB0byBhbiBldmVudCAob3IgZXZlbnRzKSBvbiB0aGlzIG9iamVjdCBvciBhbm90aGVyIGV2ZW50ZWRcclxuICAgKiBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8RWxlbWVudHxPYmplY3R9IHRhcmdldE9yVHlwZVxyXG4gICAqICAgICAgICAgSWYgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSwgaXQgcmVwcmVzZW50cyB0aGUgZXZlbnQgdHlwZShzKVxyXG4gICAqICAgICAgICAgdGhhdCB3aWxsIHRyaWdnZXIgdGhlIGxpc3RlbmVyLlxyXG4gICAqXHJcbiAgICogICAgICAgICBBbm90aGVyIGV2ZW50ZWQgb2JqZWN0IGNhbiBiZSBwYXNzZWQgaGVyZSBpbnN0ZWFkLCB3aGljaCB3aWxsXHJcbiAgICogICAgICAgICBjYXVzZSB0aGUgbGlzdGVuZXIgdG8gbGlzdGVuIGZvciBldmVudHMgb24gX3RoYXRfIG9iamVjdC5cclxuICAgKlxyXG4gICAqICAgICAgICAgSW4gZWl0aGVyIGNhc2UsIHRoZSBsaXN0ZW5lcidzIGB0aGlzYCB2YWx1ZSB3aWxsIGJlIGJvdW5kIHRvXHJcbiAgICogICAgICAgICB0aGlzIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge3N0cmluZ3xBcnJheXxGdW5jdGlvbn0gdHlwZU9yTGlzdGVuZXJcclxuICAgKiAgICAgICAgIElmIHRoZSBmaXJzdCBhcmd1bWVudCB3YXMgYSBzdHJpbmcgb3IgYXJyYXksIHRoaXMgc2hvdWxkIGJlIHRoZVxyXG4gICAqICAgICAgICAgbGlzdGVuZXIgZnVuY3Rpb24uIE90aGVyd2lzZSwgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSBvZiBldmVudFxyXG4gICAqICAgICAgICAgdHlwZShzKS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbbGlzdGVuZXJdXHJcbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGFub3RoZXIgZXZlbnRlZCBvYmplY3QsIHRoaXMgd2lsbCBiZVxyXG4gICAqICAgICAgICAgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIG9uOiBmdW5jdGlvbiBvbiQkMSgpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX25vcm1hbGl6ZUxpc3RlbkFyZ3MgPSBub3JtYWxpemVMaXN0ZW5BcmdzKHRoaXMsIGFyZ3MpLFxyXG4gICAgICAgIGlzVGFyZ2V0aW5nU2VsZiA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzLmlzVGFyZ2V0aW5nU2VsZixcclxuICAgICAgICB0YXJnZXQgPSBfbm9ybWFsaXplTGlzdGVuQXJncy50YXJnZXQsXHJcbiAgICAgICAgdHlwZSA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzLnR5cGUsXHJcbiAgICAgICAgbGlzdGVuZXIgPSBfbm9ybWFsaXplTGlzdGVuQXJncy5saXN0ZW5lcjtcclxuXHJcbiAgICBsaXN0ZW4odGFyZ2V0LCAnb24nLCB0eXBlLCBsaXN0ZW5lcik7XHJcblxyXG4gICAgLy8gSWYgdGhpcyBvYmplY3QgaXMgbGlzdGVuaW5nIHRvIGFub3RoZXIgZXZlbnRlZCBvYmplY3QuXHJcbiAgICBpZiAoIWlzVGFyZ2V0aW5nU2VsZikge1xyXG5cclxuICAgICAgLy8gSWYgdGhpcyBvYmplY3QgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgbGlzdGVuZXIuXHJcbiAgICAgIHZhciByZW1vdmVMaXN0ZW5lck9uRGlzcG9zZSA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyT25EaXNwb3NlKCkge1xyXG4gICAgICAgIHJldHVybiBfdGhpcy5vZmYodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcik7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgZnVuY3Rpb24gSUQgYXMgdGhlIGxpc3RlbmVyIHNvIHdlIGNhbiByZW1vdmUgaXQgbGF0ZXIgaXRcclxuICAgICAgLy8gdXNpbmcgdGhlIElEIG9mIHRoZSBvcmlnaW5hbCBsaXN0ZW5lci5cclxuICAgICAgcmVtb3ZlTGlzdGVuZXJPbkRpc3Bvc2UuZ3VpZCA9IGxpc3RlbmVyLmd1aWQ7XHJcblxyXG4gICAgICAvLyBBZGQgYSBsaXN0ZW5lciB0byB0aGUgdGFyZ2V0J3MgZGlzcG9zZSBldmVudCBhcyB3ZWxsLiBUaGlzIGVuc3VyZXNcclxuICAgICAgLy8gdGhhdCBpZiB0aGUgdGFyZ2V0IGlzIGRpc3Bvc2VkIEJFRk9SRSB0aGlzIG9iamVjdCwgd2UgcmVtb3ZlIHRoZVxyXG4gICAgICAvLyByZW1vdmFsIGxpc3RlbmVyIHRoYXQgd2FzIGp1c3QgYWRkZWQuIE90aGVyd2lzZSwgd2UgY3JlYXRlIGEgbWVtb3J5IGxlYWsuXHJcbiAgICAgIHZhciByZW1vdmVSZW1vdmVyT25UYXJnZXREaXNwb3NlID0gZnVuY3Rpb24gcmVtb3ZlUmVtb3Zlck9uVGFyZ2V0RGlzcG9zZSgpIHtcclxuICAgICAgICByZXR1cm4gX3RoaXMub2ZmKCdkaXNwb3NlJywgcmVtb3ZlTGlzdGVuZXJPbkRpc3Bvc2UpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gVXNlIHRoZSBzYW1lIGZ1bmN0aW9uIElEIGFzIHRoZSBsaXN0ZW5lciBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGxhdGVyXHJcbiAgICAgIC8vIGl0IHVzaW5nIHRoZSBJRCBvZiB0aGUgb3JpZ2luYWwgbGlzdGVuZXIuXHJcbiAgICAgIHJlbW92ZVJlbW92ZXJPblRhcmdldERpc3Bvc2UuZ3VpZCA9IGxpc3RlbmVyLmd1aWQ7XHJcblxyXG4gICAgICBsaXN0ZW4odGhpcywgJ29uJywgJ2Rpc3Bvc2UnLCByZW1vdmVMaXN0ZW5lck9uRGlzcG9zZSk7XHJcbiAgICAgIGxpc3Rlbih0YXJnZXQsICdvbicsICdkaXNwb3NlJywgcmVtb3ZlUmVtb3Zlck9uVGFyZ2V0RGlzcG9zZSk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIGxpc3RlbmVyIHRvIGFuIGV2ZW50IChvciBldmVudHMpIG9uIHRoaXMgb2JqZWN0IG9yIGFub3RoZXIgZXZlbnRlZFxyXG4gICAqIG9iamVjdC4gVGhlIGxpc3RlbmVyIHdpbGwgb25seSBiZSBjYWxsZWQgb25jZSBhbmQgdGhlbiByZW1vdmVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfEFycmF5fEVsZW1lbnR8T2JqZWN0fSB0YXJnZXRPclR5cGVcclxuICAgKiAgICAgICAgIElmIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXksIGl0IHJlcHJlc2VudHMgdGhlIGV2ZW50IHR5cGUocylcclxuICAgKiAgICAgICAgIHRoYXQgd2lsbCB0cmlnZ2VyIHRoZSBsaXN0ZW5lci5cclxuICAgKlxyXG4gICAqICAgICAgICAgQW5vdGhlciBldmVudGVkIG9iamVjdCBjYW4gYmUgcGFzc2VkIGhlcmUgaW5zdGVhZCwgd2hpY2ggd2lsbFxyXG4gICAqICAgICAgICAgY2F1c2UgdGhlIGxpc3RlbmVyIHRvIGxpc3RlbiBmb3IgZXZlbnRzIG9uIF90aGF0XyBvYmplY3QuXHJcbiAgICpcclxuICAgKiAgICAgICAgIEluIGVpdGhlciBjYXNlLCB0aGUgbGlzdGVuZXIncyBgdGhpc2AgdmFsdWUgd2lsbCBiZSBib3VuZCB0b1xyXG4gICAqICAgICAgICAgdGhpcyBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd8QXJyYXl8RnVuY3Rpb259IHR5cGVPckxpc3RlbmVyXHJcbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGEgc3RyaW5nIG9yIGFycmF5LCB0aGlzIHNob3VsZCBiZSB0aGVcclxuICAgKiAgICAgICAgIGxpc3RlbmVyIGZ1bmN0aW9uLiBPdGhlcndpc2UsIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXkgb2YgZXZlbnRcclxuICAgKiAgICAgICAgIHR5cGUocykuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2xpc3RlbmVyXVxyXG4gICAqICAgICAgICAgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LCB0aGlzIHdpbGwgYmVcclxuICAgKiAgICAgICAgIHRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cclxuICAgKi9cclxuICBvbmU6IGZ1bmN0aW9uIG9uZSQkMSgpIHtcclxuICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG5cclxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XHJcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX25vcm1hbGl6ZUxpc3RlbkFyZ3MyID0gbm9ybWFsaXplTGlzdGVuQXJncyh0aGlzLCBhcmdzKSxcclxuICAgICAgICBpc1RhcmdldGluZ1NlbGYgPSBfbm9ybWFsaXplTGlzdGVuQXJnczIuaXNUYXJnZXRpbmdTZWxmLFxyXG4gICAgICAgIHRhcmdldCA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzMi50YXJnZXQsXHJcbiAgICAgICAgdHlwZSA9IF9ub3JtYWxpemVMaXN0ZW5BcmdzMi50eXBlLFxyXG4gICAgICAgIGxpc3RlbmVyID0gX25vcm1hbGl6ZUxpc3RlbkFyZ3MyLmxpc3RlbmVyO1xyXG5cclxuICAgIC8vIFRhcmdldGluZyB0aGlzIGV2ZW50ZWQgb2JqZWN0LlxyXG5cclxuXHJcbiAgICBpZiAoaXNUYXJnZXRpbmdTZWxmKSB7XHJcbiAgICAgIGxpc3Rlbih0YXJnZXQsICdvbmUnLCB0eXBlLCBsaXN0ZW5lcik7XHJcblxyXG4gICAgICAvLyBUYXJnZXRpbmcgYW5vdGhlciBldmVudGVkIG9iamVjdC5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24gd3JhcHBlcigpIHtcclxuICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGxhcmdzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcclxuICAgICAgICAgIGxhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfdGhpczIub2ZmKHRhcmdldCwgdHlwZSwgd3JhcHBlcik7XHJcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkobnVsbCwgbGFyZ3MpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gVXNlIHRoZSBzYW1lIGZ1bmN0aW9uIElEIGFzIHRoZSBsaXN0ZW5lciBzbyB3ZSBjYW4gcmVtb3ZlIGl0IGxhdGVyXHJcbiAgICAgIC8vIGl0IHVzaW5nIHRoZSBJRCBvZiB0aGUgb3JpZ2luYWwgbGlzdGVuZXIuXHJcbiAgICAgIHdyYXBwZXIuZ3VpZCA9IGxpc3RlbmVyLmd1aWQ7XHJcbiAgICAgIGxpc3Rlbih0YXJnZXQsICdvbmUnLCB0eXBlLCB3cmFwcGVyKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBsaXN0ZW5lcihzKSBmcm9tIGV2ZW50KHMpIG9uIGFuIGV2ZW50ZWQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfEFycmF5fEVsZW1lbnR8T2JqZWN0fSBbdGFyZ2V0T3JUeXBlXVxyXG4gICAqICAgICAgICAgSWYgdGhpcyBpcyBhIHN0cmluZyBvciBhcnJheSwgaXQgcmVwcmVzZW50cyB0aGUgZXZlbnQgdHlwZShzKS5cclxuICAgKlxyXG4gICAqICAgICAgICAgQW5vdGhlciBldmVudGVkIG9iamVjdCBjYW4gYmUgcGFzc2VkIGhlcmUgaW5zdGVhZCwgaW4gd2hpY2ggY2FzZVxyXG4gICAqICAgICAgICAgQUxMIDMgYXJndW1lbnRzIGFyZSBfcmVxdWlyZWRfLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7c3RyaW5nfEFycmF5fEZ1bmN0aW9ufSBbdHlwZU9yTGlzdGVuZXJdXHJcbiAgICogICAgICAgICBJZiB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGEgc3RyaW5nIG9yIGFycmF5LCB0aGlzIG1heSBiZSB0aGVcclxuICAgKiAgICAgICAgIGxpc3RlbmVyIGZ1bmN0aW9uLiBPdGhlcndpc2UsIHRoaXMgaXMgYSBzdHJpbmcgb3IgYXJyYXkgb2YgZXZlbnRcclxuICAgKiAgICAgICAgIHR5cGUocykuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2xpc3RlbmVyXVxyXG4gICAqICAgICAgICAgSWYgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LCB0aGlzIHdpbGwgYmVcclxuICAgKiAgICAgICAgIHRoZSBsaXN0ZW5lciBmdW5jdGlvbjsgb3RoZXJ3aXNlLCBfYWxsXyBsaXN0ZW5lcnMgYm91bmQgdG8gdGhlXHJcbiAgICogICAgICAgICBldmVudCB0eXBlKHMpIHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgKi9cclxuICBvZmY6IGZ1bmN0aW9uIG9mZiQkMSh0YXJnZXRPclR5cGUsIHR5cGVPckxpc3RlbmVyLCBsaXN0ZW5lcikge1xyXG5cclxuICAgIC8vIFRhcmdldGluZyB0aGlzIGV2ZW50ZWQgb2JqZWN0LlxyXG4gICAgaWYgKCF0YXJnZXRPclR5cGUgfHwgaXNWYWxpZEV2ZW50VHlwZSh0YXJnZXRPclR5cGUpKSB7XHJcbiAgICAgIG9mZih0aGlzLmV2ZW50QnVzRWxfLCB0YXJnZXRPclR5cGUsIHR5cGVPckxpc3RlbmVyKTtcclxuXHJcbiAgICAgIC8vIFRhcmdldGluZyBhbm90aGVyIGV2ZW50ZWQgb2JqZWN0LlxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHRhcmdldCA9IHRhcmdldE9yVHlwZTtcclxuICAgICAgdmFyIHR5cGUgPSB0eXBlT3JMaXN0ZW5lcjtcclxuXHJcbiAgICAgIC8vIEZhaWwgZmFzdCBhbmQgaW4gYSBtZWFuaW5nZnVsIHdheSFcclxuICAgICAgdmFsaWRhdGVUYXJnZXQodGFyZ2V0KTtcclxuICAgICAgdmFsaWRhdGVFdmVudFR5cGUodHlwZSk7XHJcbiAgICAgIHZhbGlkYXRlTGlzdGVuZXIobGlzdGVuZXIpO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHRoZXJlJ3MgYXQgbGVhc3QgYSBndWlkLCBldmVuIGlmIHRoZSBmdW5jdGlvbiBoYXNuJ3QgYmVlbiB1c2VkXHJcbiAgICAgIGxpc3RlbmVyID0gYmluZCh0aGlzLCBsaXN0ZW5lcik7XHJcblxyXG4gICAgICAvLyBSZW1vdmUgdGhlIGRpc3Bvc2UgbGlzdGVuZXIgb24gdGhpcyBldmVudGVkIG9iamVjdCwgd2hpY2ggd2FzIGdpdmVuXHJcbiAgICAgIC8vIHRoZSBzYW1lIGd1aWQgYXMgdGhlIGV2ZW50IGxpc3RlbmVyIGluIG9uKCkuXHJcbiAgICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgbGlzdGVuZXIpO1xyXG5cclxuICAgICAgaWYgKHRhcmdldC5ub2RlTmFtZSkge1xyXG4gICAgICAgIG9mZih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKTtcclxuICAgICAgICBvZmYodGFyZ2V0LCAnZGlzcG9zZScsIGxpc3RlbmVyKTtcclxuICAgICAgfSBlbHNlIGlmIChpc0V2ZW50ZWQodGFyZ2V0KSkge1xyXG4gICAgICAgIHRhcmdldC5vZmYodHlwZSwgbGlzdGVuZXIpO1xyXG4gICAgICAgIHRhcmdldC5vZmYoJ2Rpc3Bvc2UnLCBsaXN0ZW5lcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogRmlyZSBhbiBldmVudCBvbiB0aGlzIGV2ZW50ZWQgb2JqZWN0LCBjYXVzaW5nIGl0cyBsaXN0ZW5lcnMgdG8gYmUgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICAge3N0cmluZ3xPYmplY3R9IGV2ZW50XHJcbiAgICogICAgICAgICAgQW4gZXZlbnQgdHlwZSBvciBhbiBvYmplY3Qgd2l0aCBhIHR5cGUgcHJvcGVydHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSBbaGFzaF1cclxuICAgKiAgICAgICAgICBBbiBhZGRpdGlvbmFsIG9iamVjdCB0byBwYXNzIGFsb25nIHRvIGxpc3RlbmVycy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqICAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdhcyBwcmV2ZW50ZWQuXHJcbiAgICovXHJcbiAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlciQkMShldmVudCwgaGFzaCkge1xyXG4gICAgcmV0dXJuIHRyaWdnZXIodGhpcy5ldmVudEJ1c0VsXywgZXZlbnQsIGhhc2gpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIHtAbGluayBtb2R1bGU6ZXZlbnRlZH5FdmVudGVkTWl4aW58RXZlbnRlZE1peGlufSB0byBhIHRhcmdldCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XHJcbiAqICAgICAgICAgVGhlIG9iamVjdCB0byB3aGljaCB0byBhZGQgZXZlbnQgbWV0aG9kcy5cclxuICpcclxuICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucz17fV1cclxuICogICAgICAgICBPcHRpb25zIGZvciBjdXN0b21pemluZyB0aGUgbWl4aW4gYmVoYXZpb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSAge1N0cmluZ30gW29wdGlvbnMuZXZlbnRCdXNLZXldXHJcbiAqICAgICAgICAgQnkgZGVmYXVsdCwgYWRkcyBhIGBldmVudEJ1c0VsX2AgRE9NIGVsZW1lbnQgdG8gdGhlIHRhcmdldCBvYmplY3QsXHJcbiAqICAgICAgICAgd2hpY2ggaXMgdXNlZCBhcyBhbiBldmVudCBidXMuIElmIHRoZSB0YXJnZXQgb2JqZWN0IGFscmVhZHkgaGFzIGFcclxuICogICAgICAgICBET00gZWxlbWVudCB0aGF0IHNob3VsZCBiZSB1c2VkLCBwYXNzIGl0cyBrZXkgaGVyZS5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiAgICAgICAgIFRoZSB0YXJnZXQgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gZXZlbnRlZCh0YXJnZXQpIHtcclxuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XHJcbiAgdmFyIGV2ZW50QnVzS2V5ID0gb3B0aW9ucy5ldmVudEJ1c0tleTtcclxuXHJcbiAgLy8gU2V0IG9yIGNyZWF0ZSB0aGUgZXZlbnRCdXNFbF8uXHJcblxyXG4gIGlmIChldmVudEJ1c0tleSkge1xyXG4gICAgaWYgKCF0YXJnZXRbZXZlbnRCdXNLZXldLm5vZGVOYW1lKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGV2ZW50QnVzS2V5IFwiJyArIGV2ZW50QnVzS2V5ICsgJ1wiIGRvZXMgbm90IHJlZmVyIHRvIGFuIGVsZW1lbnQuJyk7XHJcbiAgICB9XHJcbiAgICB0YXJnZXQuZXZlbnRCdXNFbF8gPSB0YXJnZXRbZXZlbnRCdXNLZXldO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0YXJnZXQuZXZlbnRCdXNFbF8gPSBjcmVhdGVFbCgnc3BhbicsIHsgY2xhc3NOYW1lOiAndmpzLWV2ZW50LWJ1cycgfSk7XHJcbiAgfVxyXG5cclxuICBhc3NpZ24odGFyZ2V0LCBFdmVudGVkTWl4aW4pO1xyXG5cclxuICAvLyBXaGVuIGFueSBldmVudGVkIG9iamVjdCBpcyBkaXNwb3NlZCwgaXQgcmVtb3ZlcyBhbGwgaXRzIGxpc3RlbmVycy5cclxuICB0YXJnZXQub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGFyZ2V0Lm9mZigpO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcblxyXG4vKipcclxuICogQGZpbGUgbWl4aW5zL3N0YXRlZnVsLmpzXHJcbiAqIEBtb2R1bGUgc3RhdGVmdWxcclxuICovXHJcbi8qKlxyXG4gKiBDb250YWlucyBtZXRob2RzIHRoYXQgcHJvdmlkZSBzdGF0ZWZ1bG5lc3MgdG8gYW4gb2JqZWN0IHdoaWNoIGlzIHBhc3NlZFxyXG4gKiB0byB7QGxpbmsgbW9kdWxlOnN0YXRlZnVsfS5cclxuICpcclxuICogQG1peGluIFN0YXRlZnVsTWl4aW5cclxuICovXHJcbnZhciBTdGF0ZWZ1bE1peGluID0ge1xyXG5cclxuICAvKipcclxuICAgKiBBIGhhc2ggY29udGFpbmluZyBhcmJpdHJhcnkga2V5cyBhbmQgdmFsdWVzIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2ZcclxuICAgKiB0aGUgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cclxuICBzdGF0ZToge30sXHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgc3RhdGUgb2YgYW4gb2JqZWN0IGJ5IG11dGF0aW5nIGl0c1xyXG4gICAqIHtAbGluayBtb2R1bGU6c3RhdGVmdWx+U3RhdGVmdWxNaXhpbi5zdGF0ZXxzdGF0ZX0gb2JqZWN0IGluIHBsYWNlLlxyXG4gICAqXHJcbiAgICogQGZpcmVzICAgbW9kdWxlOnN0YXRlZnVsflN0YXRlZnVsTWl4aW4jc3RhdGVjaGFuZ2VkXHJcbiAgICogQHBhcmFtICAge09iamVjdHxGdW5jdGlvbn0gc3RhdGVVcGRhdGVzXHJcbiAgICogICAgICAgICAgQSBuZXcgc2V0IG9mIHByb3BlcnRpZXMgdG8gc2hhbGxvdy1tZXJnZSBpbnRvIHRoZSBwbHVnaW4gc3RhdGUuXHJcbiAgICogICAgICAgICAgQ2FuIGJlIGEgcGxhaW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgcGxhaW4gb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9XHJcbiAgICogICAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgY2hhbmdlcyB0aGF0IG9jY3VycmVkLiBJZiBubyBjaGFuZ2VzXHJcbiAgICogICAgICAgICAgb2NjdXJyZWQsIHJldHVybnMgYHVuZGVmaW5lZGAuXHJcbiAgICovXHJcbiAgc2V0U3RhdGU6IGZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlVXBkYXRlcykge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAvLyBTdXBwb3J0IHByb3ZpZGluZyB0aGUgYHN0YXRlVXBkYXRlc2Agc3RhdGUgYXMgYSBmdW5jdGlvbi5cclxuICAgIGlmICh0eXBlb2Ygc3RhdGVVcGRhdGVzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHN0YXRlVXBkYXRlcyA9IHN0YXRlVXBkYXRlcygpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjaGFuZ2VzID0gdm9pZCAwO1xyXG5cclxuICAgIGVhY2goc3RhdGVVcGRhdGVzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG5cclxuICAgICAgLy8gUmVjb3JkIHRoZSBjaGFuZ2UgaWYgdGhlIHZhbHVlIGlzIGRpZmZlcmVudCBmcm9tIHdoYXQncyBpbiB0aGVcclxuICAgICAgLy8gY3VycmVudCBzdGF0ZS5cclxuICAgICAgaWYgKF90aGlzLnN0YXRlW2tleV0gIT09IHZhbHVlKSB7XHJcbiAgICAgICAgY2hhbmdlcyA9IGNoYW5nZXMgfHwge307XHJcbiAgICAgICAgY2hhbmdlc1trZXldID0ge1xyXG4gICAgICAgICAgZnJvbTogX3RoaXMuc3RhdGVba2V5XSxcclxuICAgICAgICAgIHRvOiB2YWx1ZVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF90aGlzLnN0YXRlW2tleV0gPSB2YWx1ZTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIE9ubHkgdHJpZ2dlciBcInN0YXRlY2hhbmdlXCIgaWYgdGhlcmUgd2VyZSBjaGFuZ2VzIEFORCB3ZSBoYXZlIGEgdHJpZ2dlclxyXG4gICAgLy8gZnVuY3Rpb24uIFRoaXMgYWxsb3dzIHVzIHRvIG5vdCByZXF1aXJlIHRoYXQgdGhlIHRhcmdldCBvYmplY3QgYmUgYW5cclxuICAgIC8vIGV2ZW50ZWQgb2JqZWN0LlxyXG4gICAgaWYgKGNoYW5nZXMgJiYgaXNFdmVudGVkKHRoaXMpKSB7XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQW4gZXZlbnQgdHJpZ2dlcmVkIG9uIGFuIG9iamVjdCB0aGF0IGlzIGJvdGhcclxuICAgICAgICoge0BsaW5rIG1vZHVsZTpzdGF0ZWZ1bHxzdGF0ZWZ1bH0gYW5kIHtAbGluayBtb2R1bGU6ZXZlbnRlZHxldmVudGVkfVxyXG4gICAgICAgKiBpbmRpY2F0aW5nIHRoYXQgaXRzIHN0YXRlIGhhcyBjaGFuZ2VkLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZXZlbnQgICAgbW9kdWxlOnN0YXRlZnVsflN0YXRlZnVsTWl4aW4jc3RhdGVjaGFuZ2VkXHJcbiAgICAgICAqIEB0eXBlICAgICB7T2JqZWN0fVxyXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gY2hhbmdlc1xyXG4gICAgICAgKiAgICAgICAgICAgQSBoYXNoIGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgdGhhdCB3ZXJlIGNoYW5nZWQgYW5kXHJcbiAgICAgICAqICAgICAgICAgICB0aGUgdmFsdWVzIHRoZXkgd2VyZSBjaGFuZ2VkIGBmcm9tYCBhbmQgYHRvYC5cclxuICAgICAgICovXHJcbiAgICAgIHRoaXMudHJpZ2dlcih7XHJcbiAgICAgICAgY2hhbmdlczogY2hhbmdlcyxcclxuICAgICAgICB0eXBlOiAnc3RhdGVjaGFuZ2VkJ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2hhbmdlcztcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogQXBwbGllcyB7QGxpbmsgbW9kdWxlOnN0YXRlZnVsflN0YXRlZnVsTWl4aW58U3RhdGVmdWxNaXhpbn0gdG8gYSB0YXJnZXRcclxuICogb2JqZWN0LlxyXG4gKlxyXG4gKiBJZiB0aGUgdGFyZ2V0IG9iamVjdCBpcyB7QGxpbmsgbW9kdWxlOmV2ZW50ZWR8ZXZlbnRlZH0gYW5kIGhhcyBhXHJcbiAqIGBoYW5kbGVTdGF0ZUNoYW5nZWRgIG1ldGhvZCwgdGhhdCBtZXRob2Qgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kIHRvIHRoZVxyXG4gKiBgc3RhdGVjaGFuZ2VkYCBldmVudCBvbiBpdHNlbGYuXHJcbiAqXHJcbiAqIEBwYXJhbSAgIHtPYmplY3R9IHRhcmdldFxyXG4gKiAgICAgICAgICBUaGUgb2JqZWN0IHRvIGJlIG1hZGUgc3RhdGVmdWwuXHJcbiAqXHJcbiAqIEBwYXJhbSAgIHtPYmplY3R9IFtkZWZhdWx0U3RhdGVdXHJcbiAqICAgICAgICAgIEEgZGVmYXVsdCBzZXQgb2YgcHJvcGVydGllcyB0byBwb3B1bGF0ZSB0aGUgbmV3bHktc3RhdGVmdWwgb2JqZWN0J3NcclxuICogICAgICAgICAgYHN0YXRlYCBwcm9wZXJ0eS5cclxuICpcclxuICogQHJldHVybnMge09iamVjdH1cclxuICogICAgICAgICAgUmV0dXJucyB0aGUgYHRhcmdldGAuXHJcbiAqL1xyXG5mdW5jdGlvbiBzdGF0ZWZ1bCh0YXJnZXQsIGRlZmF1bHRTdGF0ZSkge1xyXG4gIGFzc2lnbih0YXJnZXQsIFN0YXRlZnVsTWl4aW4pO1xyXG5cclxuICAvLyBUaGlzIGhhcHBlbnMgYWZ0ZXIgdGhlIG1peGluZy1pbiBiZWNhdXNlIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgYHN0YXRlYFxyXG4gIC8vIGFkZGVkIGluIHRoYXQgc3RlcC5cclxuICB0YXJnZXQuc3RhdGUgPSBhc3NpZ24oe30sIHRhcmdldC5zdGF0ZSwgZGVmYXVsdFN0YXRlKTtcclxuXHJcbiAgLy8gQXV0by1iaW5kIHRoZSBgaGFuZGxlU3RhdGVDaGFuZ2VkYCBtZXRob2Qgb2YgdGhlIHRhcmdldCBvYmplY3QgaWYgaXQgZXhpc3RzLlxyXG4gIGlmICh0eXBlb2YgdGFyZ2V0LmhhbmRsZVN0YXRlQ2hhbmdlZCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0V2ZW50ZWQodGFyZ2V0KSkge1xyXG4gICAgdGFyZ2V0Lm9uKCdzdGF0ZWNoYW5nZWQnLCB0YXJnZXQuaGFuZGxlU3RhdGVDaGFuZ2VkKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZmlsZSB0by10aXRsZS1jYXNlLmpzXHJcbiAqIEBtb2R1bGUgdG8tdGl0bGUtY2FzZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBVcHBlcmNhc2UgdGhlIGZpcnN0IGxldHRlciBvZiBhIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xyXG4gKiAgICAgICAgU3RyaW5nIHRvIGJlIHVwcGVyY2FzZWRcclxuICpcclxuICogQHJldHVybiB7c3RyaW5nfVxyXG4gKiAgICAgICAgIFRoZSBzdHJpbmcgd2l0aCBhbiB1cHBlcmNhc2VkIGZpcnN0IGxldHRlclxyXG4gKi9cclxuZnVuY3Rpb24gdG9UaXRsZUNhc2Uoc3RyaW5nKSB7XHJcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gc3RyaW5nO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoZSBUaXRsZUNhc2UgdmVyc2lvbnMgb2YgdGhlIHR3byBzdHJpbmdzIGZvciBlcXVhbGl0eS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cjFcclxuICogICAgICAgIFRoZSBmaXJzdCBzdHJpbmcgdG8gY29tcGFyZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyMlxyXG4gKiAgICAgICAgVGhlIHNlY29uZCBzdHJpbmcgdG8gY29tcGFyZVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKiAgICAgICAgIFdoZXRoZXIgdGhlIFRpdGxlQ2FzZSB2ZXJzaW9ucyBvZiB0aGUgc3RyaW5ncyBhcmUgZXF1YWxcclxuICovXHJcbmZ1bmN0aW9uIHRpdGxlQ2FzZUVxdWFscyhzdHIxLCBzdHIyKSB7XHJcbiAgcmV0dXJuIHRvVGl0bGVDYXNlKHN0cjEpID09PSB0b1RpdGxlQ2FzZShzdHIyKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmaWxlIG1lcmdlLW9wdGlvbnMuanNcclxuICogQG1vZHVsZSBtZXJnZS1vcHRpb25zXHJcbiAqL1xyXG4vKipcclxuICogRGVlcC1tZXJnZSBvbmUgb3IgbW9yZSBvcHRpb25zIG9iamVjdHMsIHJlY3Vyc2l2ZWx5IG1lcmdpbmcgKipvbmx5KiogcGxhaW5cclxuICogb2JqZWN0IHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSAgIHtPYmplY3RbXX0gc291cmNlc1xyXG4gKiAgICAgICAgICBPbmUgb3IgbW9yZSBvYmplY3RzIHRvIG1lcmdlIGludG8gYSBuZXcgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gKiAgICAgICAgICBBIG5ldyBvYmplY3QgdGhhdCBpcyB0aGUgbWVyZ2VkIHJlc3VsdCBvZiBhbGwgc291cmNlcy5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucygpIHtcclxuICB2YXIgcmVzdWx0ID0ge307XHJcblxyXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICBzb3VyY2VzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xyXG4gIH1cclxuXHJcbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgIGlmICghc291cmNlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBlYWNoKHNvdXJjZSwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgaWYgKCFpc1BsYWluKHZhbHVlKSkge1xyXG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIWlzUGxhaW4ocmVzdWx0W2tleV0pKSB7XHJcbiAgICAgICAgcmVzdWx0W2tleV0gPSB7fTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZU9wdGlvbnMocmVzdWx0W2tleV0sIHZhbHVlKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogUGxheWVyIENvbXBvbmVudCAtIEJhc2UgY2xhc3MgZm9yIGFsbCBVSSBvYmplY3RzXHJcbiAqXHJcbiAqIEBmaWxlIGNvbXBvbmVudC5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBVSSBDb21wb25lbnRzLlxyXG4gKiBDb21wb25lbnRzIGFyZSBVSSBvYmplY3RzIHdoaWNoIHJlcHJlc2VudCBib3RoIGEgamF2YXNjcmlwdCBvYmplY3QgYW5kIGFuIGVsZW1lbnRcclxuICogaW4gdGhlIERPTS4gVGhleSBjYW4gYmUgY2hpbGRyZW4gb2Ygb3RoZXIgY29tcG9uZW50cywgYW5kIGNhbiBoYXZlXHJcbiAqIGNoaWxkcmVuIHRoZW1zZWx2ZXMuXHJcbiAqXHJcbiAqIENvbXBvbmVudHMgY2FuIGFsc28gdXNlIG1ldGhvZHMgZnJvbSB7QGxpbmsgRXZlbnRUYXJnZXR9XHJcbiAqL1xyXG5cclxudmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlYWR5LiBEb2VzIG5vdCBoYXZlIGFueVxyXG4gICAqIHBhcmFtdGVycyBhbmQgYW55IGNhbGxiYWNrIHZhbHVlIHdpbGwgYmUgaWdub3JlZC5cclxuICAgKlxyXG4gICAqIEBjYWxsYmFjayBDb21wb25lbnR+UmVhZHlDYWxsYmFja1xyXG4gICAqIEB0aGlzIENvbXBvbmVudFxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXHJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3RbXX0gW29wdGlvbnMuY2hpbGRyZW5dXHJcbiAgICogICAgICAgIEFuIGFycmF5IG9mIGNoaWxkcmVuIG9iamVjdHMgdG8gaW50aWFsaXplIHRoaXMgY29tcG9uZW50IHdpdGguIENoaWxkcmVuIG9iamVjdHMgaGF2ZVxyXG4gICAqICAgICAgICBhIG5hbWUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIHVzZWQgaWYgbW9yZSB0aGFuIG9uZSBjb21wb25lbnQgb2YgdGhlIHNhbWUgdHlwZSBuZWVkcyB0byBiZVxyXG4gICAqICAgICAgICBhZGRlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cclxuICAgKiAgICAgICAgRnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCB3aGVuIHRoZSBgQ29tcG9uZW50YCBpcyByZWFkeS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBDb21wb25lbnQocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcG9uZW50KTtcclxuXHJcblxyXG4gICAgLy8gVGhlIGNvbXBvbmVudCBtaWdodCBiZSB0aGUgcGxheWVyIGl0c2VsZiBhbmQgd2UgY2FuJ3QgcGFzcyBgdGhpc2AgdG8gc3VwZXJcclxuICAgIGlmICghcGxheWVyICYmIHRoaXMucGxheSkge1xyXG4gICAgICB0aGlzLnBsYXllcl8gPSBwbGF5ZXIgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnBsYXllcl8gPSBwbGF5ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFrZSBhIGNvcHkgb2YgcHJvdG90eXBlLm9wdGlvbnNfIHRvIHByb3RlY3QgYWdhaW5zdCBvdmVycmlkaW5nIGRlZmF1bHRzXHJcbiAgICB0aGlzLm9wdGlvbnNfID0gbWVyZ2VPcHRpb25zKHt9LCB0aGlzLm9wdGlvbnNfKTtcclxuXHJcbiAgICAvLyBVcGRhdGVkIG9wdGlvbnMgd2l0aCBzdXBwbGllZCBvcHRpb25zXHJcbiAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zXyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnNfLCBvcHRpb25zKTtcclxuXHJcbiAgICAvLyBHZXQgSUQgZnJvbSBvcHRpb25zIG9yIG9wdGlvbnMgZWxlbWVudCBpZiBvbmUgaXMgc3VwcGxpZWRcclxuICAgIHRoaXMuaWRfID0gb3B0aW9ucy5pZCB8fCBvcHRpb25zLmVsICYmIG9wdGlvbnMuZWwuaWQ7XHJcblxyXG4gICAgLy8gSWYgdGhlcmUgd2FzIG5vIElEIGZyb20gdGhlIG9wdGlvbnMsIGdlbmVyYXRlIG9uZVxyXG4gICAgaWYgKCF0aGlzLmlkXykge1xyXG4gICAgICAvLyBEb24ndCByZXF1aXJlIHRoZSBwbGF5ZXIgSUQgZnVuY3Rpb24gaW4gdGhlIGNhc2Ugb2YgbW9jayBwbGF5ZXJzXHJcbiAgICAgIHZhciBpZCA9IHBsYXllciAmJiBwbGF5ZXIuaWQgJiYgcGxheWVyLmlkKCkgfHwgJ25vX3BsYXllcic7XHJcblxyXG4gICAgICB0aGlzLmlkXyA9IGlkICsgJ19jb21wb25lbnRfJyArIG5ld0dVSUQoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLm5hbWVfID0gb3B0aW9ucy5uYW1lIHx8IG51bGw7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGVsZW1lbnQgaWYgb25lIHdhc24ndCBwcm92aWRlZCBpbiBvcHRpb25zXHJcbiAgICBpZiAob3B0aW9ucy5lbCkge1xyXG4gICAgICB0aGlzLmVsXyA9IG9wdGlvbnMuZWw7XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuY3JlYXRlRWwgIT09IGZhbHNlKSB7XHJcbiAgICAgIHRoaXMuZWxfID0gdGhpcy5jcmVhdGVFbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1ha2UgdGhpcyBhbiBldmVudGVkIG9iamVjdCBhbmQgdXNlIGBlbF9gLCBpZiBhdmFpbGFibGUsIGFzIGl0cyBldmVudCBidXNcclxuICAgIGV2ZW50ZWQodGhpcywgeyBldmVudEJ1c0tleTogdGhpcy5lbF8gPyAnZWxfJyA6IG51bGwgfSk7XHJcbiAgICBzdGF0ZWZ1bCh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRTdGF0ZSk7XHJcblxyXG4gICAgdGhpcy5jaGlsZHJlbl8gPSBbXTtcclxuICAgIHRoaXMuY2hpbGRJbmRleF8gPSB7fTtcclxuICAgIHRoaXMuY2hpbGROYW1lSW5kZXhfID0ge307XHJcblxyXG4gICAgLy8gQWRkIGFueSBjaGlsZCBjb21wb25lbnRzIGluIG9wdGlvbnNcclxuICAgIGlmIChvcHRpb25zLmluaXRDaGlsZHJlbiAhPT0gZmFsc2UpIHtcclxuICAgICAgdGhpcy5pbml0Q2hpbGRyZW4oKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJlYWR5KHJlYWR5KTtcclxuICAgIC8vIERvbid0IHdhbnQgdG8gdHJpZ2dlciByZWFkeSBoZXJlIG9yIGl0IHdpbGwgYmVmb3JlIGluaXQgaXMgYWN0dWFsbHlcclxuICAgIC8vIGZpbmlzaGVkIGZvciBhbGwgY2hpbGRyZW4gdGhhdCBydW4gdGhpcyBjb25zdHJ1Y3RvclxyXG5cclxuICAgIGlmIChvcHRpb25zLnJlcG9ydFRvdWNoQWN0aXZpdHkgIT09IGZhbHNlKSB7XHJcbiAgICAgIHRoaXMuZW5hYmxlVG91Y2hBY3Rpdml0eSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcG9zZSBvZiB0aGUgYENvbXBvbmVudGAgYW5kIGFsbCBjaGlsZCBjb21wb25lbnRzLlxyXG4gICAqXHJcbiAgICogQGZpcmVzIENvbXBvbmVudCNkaXNwb3NlXHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gYSBgQ29tcG9uZW50YCBpcyBkaXNwb3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnQgQ29tcG9uZW50I2Rpc3Bvc2VcclxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAqXHJcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtidWJibGVzPWZhbHNlXVxyXG4gICAgICogICAgICAgICAgIHNldCB0byBmYWxzZSBzbyB0aGF0IHRoZSBjbG9zZSBldmVudCBkb2VzIG5vdFxyXG4gICAgICogICAgICAgICAgIGJ1YmJsZSB1cFxyXG4gICAgICovXHJcbiAgICB0aGlzLnRyaWdnZXIoeyB0eXBlOiAnZGlzcG9zZScsIGJ1YmJsZXM6IGZhbHNlIH0pO1xyXG5cclxuICAgIC8vIERpc3Bvc2UgYWxsIGNoaWxkcmVuLlxyXG4gICAgaWYgKHRoaXMuY2hpbGRyZW5fKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNoaWxkcmVuXy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuX1tpXS5kaXNwb3NlKSB7XHJcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuX1tpXS5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGVsZXRlIGNoaWxkIHJlZmVyZW5jZXNcclxuICAgIHRoaXMuY2hpbGRyZW5fID0gbnVsbDtcclxuICAgIHRoaXMuY2hpbGRJbmRleF8gPSBudWxsO1xyXG4gICAgdGhpcy5jaGlsZE5hbWVJbmRleF8gPSBudWxsO1xyXG5cclxuICAgIGlmICh0aGlzLmVsXykge1xyXG4gICAgICAvLyBSZW1vdmUgZWxlbWVudCBmcm9tIERPTVxyXG4gICAgICBpZiAodGhpcy5lbF8ucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIHRoaXMuZWxfLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbF8pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZW1vdmVEYXRhKHRoaXMuZWxfKTtcclxuICAgICAgdGhpcy5lbF8gPSBudWxsO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUge0BsaW5rIFBsYXllcn0gdGhhdCB0aGUgYENvbXBvbmVudGAgaGFzIGF0dGFjaGVkIHRvLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7UGxheWVyfVxyXG4gICAqICAgICAgICAgVGhlIHBsYXllciB0aGF0IHRoaXMgYENvbXBvbmVudGAgaGFzIGF0dGFjaGVkIHRvLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS5wbGF5ZXIgPSBmdW5jdGlvbiBwbGF5ZXIoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXJfO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIERlZXAgbWVyZ2Ugb2Ygb3B0aW9ucyBvYmplY3RzIHdpdGggbmV3IG9wdGlvbnMuXHJcbiAgICogPiBOb3RlOiBXaGVuIGJvdGggYG9iamAgYW5kIGBvcHRpb25zYCBjb250YWluIHByb3BlcnRpZXMgd2hvc2UgdmFsdWVzIGFyZSBvYmplY3RzLlxyXG4gICAqICAgICAgICAgVGhlIHR3byBwcm9wZXJ0aWVzIGdldCBtZXJnZWQgdXNpbmcge0BsaW5rIG1vZHVsZTptZXJnZU9wdGlvbnN9XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAgICogICAgICAgIFRoZSBvYmplY3QgdGhhdCBjb250YWlucyBuZXcgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKiAgICAgICAgIEEgbmV3IG9iamVjdCBvZiBgdGhpcy5vcHRpb25zX2AgYW5kIGBvYmpgIG1lcmdlZCB0b2dldGhlci5cclxuICAgKlxyXG4gICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gNVxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24gb3B0aW9ucyhvYmopIHtcclxuICAgIGxvZyQxLndhcm4oJ3RoaXMub3B0aW9ucygpIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgbW92ZWQgdG8gdGhlIGNvbnN0cnVjdG9yIGluIDYuMCcpO1xyXG5cclxuICAgIGlmICghb2JqKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNfO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMub3B0aW9uc18gPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zXywgb2JqKTtcclxuICAgIHJldHVybiB0aGlzLm9wdGlvbnNfO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgYENvbXBvbmVudGBzIERPTSBlbGVtZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gICAqICAgICAgICAgVGhlIERPTSBlbGVtZW50IGZvciB0aGlzIGBDb21wb25lbnRgLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS5lbCA9IGZ1bmN0aW9uIGVsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZWxfO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGBzIERPTSBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0YWdOYW1lXVxyXG4gICAqICAgICAgICBFbGVtZW50J3MgRE9NIG5vZGUgdHlwZS4gZS5nLiAnZGl2J1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxyXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBzZXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdXHJcbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHNldC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSh0YWdOYW1lLCBwcm9wZXJ0aWVzLCBhdHRyaWJ1dGVzKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlRWwodGFnTmFtZSwgcHJvcGVydGllcywgYXR0cmlidXRlcyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogTG9jYWxpemUgYSBzdHJpbmcgZ2l2ZW4gdGhlIHN0cmluZyBpbiBlbmdsaXNoLlxyXG4gICAqXHJcbiAgICogSWYgdG9rZW5zIGFyZSBwcm92aWRlZCwgaXQnbGwgdHJ5IGFuZCBydW4gYSBzaW1wbGUgdG9rZW4gcmVwbGFjZW1lbnQgb24gdGhlIHByb3ZpZGVkIHN0cmluZy5cclxuICAgKiBUaGUgdG9rZW5zIGl0IGxvb29rcyBmb3IgbG9vayBsaWtlIGB7MX1gIHdpdGggdGhlIGluZGV4IGJlaW5nIDEtaW5kZXhlZCBpbnRvIHRoZSB0b2tlbnMgYXJyYXkuXHJcbiAgICpcclxuICAgKiBJZiBhIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBpdCdsbCB1c2UgdGhhdCBvdmVyIGBzdHJpbmdgLFxyXG4gICAqIGlmIGEgdmFsdWUgaXNuJ3QgZm91bmQgaW4gcHJvdmlkZWQgbGFuZ3VhZ2UgZmlsZXMuXHJcbiAgICogVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gaGF2ZSBhIGRlc2NyaXB0aXZlIGtleSBmb3IgdG9rZW4gcmVwbGFjZW1lbnRcclxuICAgKiBidXQgaGF2ZSBhIHN1Y2NpbmN0IGxvY2FsaXplZCBzdHJpbmcgYW5kIG5vdCByZXF1aXJlIGBlbi5qc29uYCB0byBiZSBpbmNsdWRlZC5cclxuICAgKlxyXG4gICAqIEN1cnJlbnRseSwgaXQgaXMgdXNlZCBmb3IgdGhlIHByb2dyZXNzIGJhciB0aW1pbmcuXHJcbiAgICogYGBganNcclxuICAgKiB7XHJcbiAgICogICBcInByb2dyZXNzIGJhciB0aW1pbmc6IGN1cnJlbnRUaW1lPXsxfSBkdXJhdGlvbj17Mn1cIjogXCJ7MX0gb2YgezJ9XCJcclxuICAgKiB9XHJcbiAgICogYGBgXHJcbiAgICogSXQgaXMgdGhlbiB1c2VkIGxpa2Ugc286XHJcbiAgICogYGBganNcclxuICAgKiB0aGlzLmxvY2FsaXplKCdwcm9ncmVzcyBiYXIgdGltaW5nOiBjdXJyZW50VGltZT17MX0gZHVyYXRpb257Mn0nLFxyXG4gICAqICAgICAgICAgICAgICAgW3RoaXMucGxheWVyXy5jdXJyZW50VGltZSgpLCB0aGlzLnBsYXllcl8uZHVyYXRpb24oKV0sXHJcbiAgICogICAgICAgICAgICAgICAnezF9IG9mIHsyfScpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogV2hpY2ggb3V0cHV0cyBzb21ldGhpbmcgbGlrZTogYDAxOjIzIG9mIDI0OjU2YC5cclxuICAgKlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xyXG4gICAqICAgICAgICBUaGUgc3RyaW5nIHRvIGxvY2FsaXplIGFuZCB0aGUga2V5IHRvIGxvb2t1cCBpbiB0aGUgbGFuZ3VhZ2UgZmlsZXMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3Rva2Vuc11cclxuICAgKiAgICAgICAgSWYgdGhlIGN1cnJlbnQgaXRlbSBoYXMgdG9rZW4gcmVwbGFjZW1lbnRzLCBwcm92aWRlIHRoZSB0b2tlbnMgaGVyZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2RlZmF1bHRWYWx1ZV1cclxuICAgKiAgICAgICAgRGVmYXVsdHMgdG8gYHN0cmluZ2AuIENhbiBiZSBhIGRlZmF1bHQgdmFsdWUgdG8gdXNlIGZvciB0b2tlbiByZXBsYWNlbWVudFxyXG4gICAqICAgICAgICBpZiB0aGUgbG9va3VwIGtleSBpcyBuZWVkZWQgdG8gYmUgc2VwYXJhdGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICogICAgICAgICBUaGUgbG9jYWxpemVkIHN0cmluZyBvciBpZiBubyBsb2NhbGl6YXRpb24gZXhpc3RzIHRoZSBlbmdsaXNoIHN0cmluZy5cclxuICAgKi9cclxuXHJcblxyXG4gIENvbXBvbmVudC5wcm90b3R5cGUubG9jYWxpemUgPSBmdW5jdGlvbiBsb2NhbGl6ZShzdHJpbmcsIHRva2Vucykge1xyXG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogc3RyaW5nO1xyXG5cclxuICAgIHZhciBjb2RlID0gdGhpcy5wbGF5ZXJfLmxhbmd1YWdlICYmIHRoaXMucGxheWVyXy5sYW5ndWFnZSgpO1xyXG4gICAgdmFyIGxhbmd1YWdlcyA9IHRoaXMucGxheWVyXy5sYW5ndWFnZXMgJiYgdGhpcy5wbGF5ZXJfLmxhbmd1YWdlcygpO1xyXG4gICAgdmFyIGxhbmd1YWdlID0gbGFuZ3VhZ2VzICYmIGxhbmd1YWdlc1tjb2RlXTtcclxuICAgIHZhciBwcmltYXJ5Q29kZSA9IGNvZGUgJiYgY29kZS5zcGxpdCgnLScpWzBdO1xyXG4gICAgdmFyIHByaW1hcnlMYW5nID0gbGFuZ3VhZ2VzICYmIGxhbmd1YWdlc1twcmltYXJ5Q29kZV07XHJcblxyXG4gICAgdmFyIGxvY2FsaXplZFN0cmluZyA9IGRlZmF1bHRWYWx1ZTtcclxuXHJcbiAgICBpZiAobGFuZ3VhZ2UgJiYgbGFuZ3VhZ2Vbc3RyaW5nXSkge1xyXG4gICAgICBsb2NhbGl6ZWRTdHJpbmcgPSBsYW5ndWFnZVtzdHJpbmddO1xyXG4gICAgfSBlbHNlIGlmIChwcmltYXJ5TGFuZyAmJiBwcmltYXJ5TGFuZ1tzdHJpbmddKSB7XHJcbiAgICAgIGxvY2FsaXplZFN0cmluZyA9IHByaW1hcnlMYW5nW3N0cmluZ107XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRva2Vucykge1xyXG4gICAgICBsb2NhbGl6ZWRTdHJpbmcgPSBsb2NhbGl6ZWRTdHJpbmcucmVwbGFjZSgvXFx7KFxcZCspXFx9L2csIGZ1bmN0aW9uIChtYXRjaCwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbnNbaW5kZXggLSAxXTtcclxuICAgICAgICB2YXIgcmV0ID0gdmFsdWU7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICByZXQgPSBtYXRjaDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsb2NhbGl6ZWRTdHJpbmc7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBgQ29tcG9uZW50YHMgRE9NIGVsZW1lbnQuIFRoaXMgaXMgd2hlcmUgY2hpbGRyZW4gZ2V0IGluc2VydGVkLlxyXG4gICAqIFRoaXMgd2lsbCB1c3VhbGx5IGJlIHRoZSB0aGUgc2FtZSBhcyB0aGUgZWxlbWVudCByZXR1cm5lZCBpbiB7QGxpbmsgQ29tcG9uZW50I2VsfS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgY29udGVudCBlbGVtZW50IGZvciB0aGlzIGBDb21wb25lbnRgLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jb250ZW50RWwgPSBmdW5jdGlvbiBjb250ZW50RWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb250ZW50RWxfIHx8IHRoaXMuZWxfO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGlzIGBDb21wb25lbnRgcyBJRFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqICAgICAgICAgVGhlIGlkIG9mIHRoaXMgYENvbXBvbmVudGBcclxuICAgKi9cclxuXHJcblxyXG4gIENvbXBvbmVudC5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbiBpZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmlkXztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGBDb21wb25lbnRgcyBuYW1lLiBUaGUgbmFtZSBnZXRzIHVzZWQgdG8gcmVmZXJlbmNlIHRoZSBgQ29tcG9uZW50YFxyXG4gICAqIGFuZCBpcyBzZXQgZHVyaW5nIHJlZ2lzdHJhdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKiAgICAgICAgIFRoZSBuYW1lIG9mIHRoaXMgYENvbXBvbmVudGAuXHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbiBuYW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubmFtZV87XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFuIGFycmF5IG9mIGFsbCBjaGlsZCBjb21wb25lbnRzXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtBcnJheX1cclxuICAgKiAgICAgICAgIFRoZSBjaGlsZHJlblxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uIGNoaWxkcmVuKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGNoaWxkIGBDb21wb25lbnRgIHdpdGggdGhlIGdpdmVuIGBpZGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcclxuICAgKiAgICAgICAgVGhlIGlkIG9mIHRoZSBjaGlsZCBgQ29tcG9uZW50YCB0byBnZXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR8dW5kZWZpbmVkfVxyXG4gICAqICAgICAgICAgVGhlIGNoaWxkIGBDb21wb25lbnRgIHdpdGggdGhlIGdpdmVuIGBpZGAgb3IgdW5kZWZpbmVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXRDaGlsZEJ5SWQgPSBmdW5jdGlvbiBnZXRDaGlsZEJ5SWQoaWQpIHtcclxuICAgIHJldHVybiB0aGlzLmNoaWxkSW5kZXhfW2lkXTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZCBgQ29tcG9uZW50YCB3aXRoIHRoZSBnaXZlbiBgbmFtZWAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgY2hpbGQgYENvbXBvbmVudGAgdG8gZ2V0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Q29tcG9uZW50fHVuZGVmaW5lZH1cclxuICAgKiAgICAgICAgIFRoZSBjaGlsZCBgQ29tcG9uZW50YCB3aXRoIHRoZSBnaXZlbiBgbmFtZWAgb3IgdW5kZWZpbmVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIGdldENoaWxkKG5hbWUpIHtcclxuICAgIGlmICghbmFtZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbmFtZSA9IHRvVGl0bGVDYXNlKG5hbWUpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLmNoaWxkTmFtZUluZGV4X1tuYW1lXTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSBjaGlsZCBgQ29tcG9uZW50YCBpbnNpZGUgdGhlIGN1cnJlbnQgYENvbXBvbmVudGAuXHJcbiAgICpcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfENvbXBvbmVudH0gY2hpbGRcclxuICAgKiAgICAgICAgVGhlIG5hbWUgb3IgaW5zdGFuY2Ugb2YgYSBjaGlsZCB0byBhZGQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXHJcbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2Ygb3B0aW9ucyB0aGF0IHdpbGwgZ2V0IHBhc3NlZCB0byBjaGlsZHJlbiBvZlxyXG4gICAqICAgICAgICB0aGUgY2hpbGQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PXRoaXMuY2hpbGRyZW5fLmxlbmd0aF1cclxuICAgKiAgICAgICAgVGhlIGluZGV4IHRvIGF0dGVtcHQgdG8gYWRkIGEgY2hpbGQgaW50by5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cclxuICAgKiAgICAgICAgIFRoZSBgQ29tcG9uZW50YCB0aGF0IGdldHMgYWRkZWQgYXMgYSBjaGlsZC4gV2hlbiB1c2luZyBhIHN0cmluZyB0aGVcclxuICAgKiAgICAgICAgIGBDb21wb25lbnRgIHdpbGwgZ2V0IGNyZWF0ZWQgYnkgdGhpcyBwcm9jZXNzLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIGFkZENoaWxkKGNoaWxkKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XHJcbiAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuY2hpbGRyZW5fLmxlbmd0aDtcclxuXHJcbiAgICB2YXIgY29tcG9uZW50ID0gdm9pZCAwO1xyXG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSB2b2lkIDA7XHJcblxyXG4gICAgLy8gSWYgY2hpbGQgaXMgYSBzdHJpbmcsIGNyZWF0ZSBjb21wb25lbnQgd2l0aCBvcHRpb25zXHJcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJykge1xyXG4gICAgICBjb21wb25lbnROYW1lID0gdG9UaXRsZUNhc2UoY2hpbGQpO1xyXG5cclxuICAgICAgdmFyIGNvbXBvbmVudENsYXNzTmFtZSA9IG9wdGlvbnMuY29tcG9uZW50Q2xhc3MgfHwgY29tcG9uZW50TmFtZTtcclxuXHJcbiAgICAgIC8vIFNldCBuYW1lIHRocm91Z2ggb3B0aW9uc1xyXG4gICAgICBvcHRpb25zLm5hbWUgPSBjb21wb25lbnROYW1lO1xyXG5cclxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IG9iamVjdCAmIGVsZW1lbnQgZm9yIHRoaXMgY29udHJvbHMgc2V0XHJcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gLnBsYXllcl8sIHRoaXMgaXMgYSBwbGF5ZXJcclxuICAgICAgdmFyIENvbXBvbmVudENsYXNzID0gQ29tcG9uZW50LmdldENvbXBvbmVudChjb21wb25lbnRDbGFzc05hbWUpO1xyXG5cclxuICAgICAgaWYgKCFDb21wb25lbnRDbGFzcykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50ICcgKyBjb21wb25lbnRDbGFzc05hbWUgKyAnIGRvZXMgbm90IGV4aXN0Jyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGRhdGEgc3RvcmVkIGRpcmVjdGx5IG9uIHRoZSB2aWRlb2pzIG9iamVjdCBtYXkgYmVcclxuICAgICAgLy8gbWlzaWRlbnRpZmllZCBhcyBhIGNvbXBvbmVudCB0byByZXRhaW5cclxuICAgICAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2l0aCA0LnguIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGVcclxuICAgICAgLy8gY29tcG9uZW50IGNsYXNzIGNhbiBiZSBpbnN0YW50aWF0ZWQuXHJcbiAgICAgIGlmICh0eXBlb2YgQ29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudENsYXNzKHRoaXMucGxheWVyXyB8fCB0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgICAgIC8vIGNoaWxkIGlzIGEgY29tcG9uZW50IGluc3RhbmNlXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb21wb25lbnQgPSBjaGlsZDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNoaWxkcmVuXy5zcGxpY2UoaW5kZXgsIDAsIGNvbXBvbmVudCk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQuaWQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhpcy5jaGlsZEluZGV4X1tjb21wb25lbnQuaWQoKV0gPSBjb21wb25lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgYSBuYW1lIHdhc24ndCB1c2VkIHRvIGNyZWF0ZSB0aGUgY29tcG9uZW50LCBjaGVjayBpZiB3ZSBjYW4gdXNlIHRoZVxyXG4gICAgLy8gbmFtZSBmdW5jdGlvbiBvZiB0aGUgY29tcG9uZW50XHJcbiAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBjb21wb25lbnQubmFtZSAmJiB0b1RpdGxlQ2FzZShjb21wb25lbnQubmFtZSgpKTtcclxuXHJcbiAgICBpZiAoY29tcG9uZW50TmFtZSkge1xyXG4gICAgICB0aGlzLmNoaWxkTmFtZUluZGV4X1tjb21wb25lbnROYW1lXSA9IGNvbXBvbmVudDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdGhlIFVJIG9iamVjdCdzIGVsZW1lbnQgdG8gdGhlIGNvbnRhaW5lciBkaXYgKGJveClcclxuICAgIC8vIEhhdmluZyBhbiBlbGVtZW50IGlzIG5vdCByZXF1aXJlZFxyXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQuZWwgPT09ICdmdW5jdGlvbicgJiYgY29tcG9uZW50LmVsKCkpIHtcclxuICAgICAgdmFyIGNoaWxkTm9kZXMgPSB0aGlzLmNvbnRlbnRFbCgpLmNoaWxkcmVuO1xyXG4gICAgICB2YXIgcmVmTm9kZSA9IGNoaWxkTm9kZXNbaW5kZXhdIHx8IG51bGw7XHJcblxyXG4gICAgICB0aGlzLmNvbnRlbnRFbCgpLmluc2VydEJlZm9yZShjb21wb25lbnQuZWwoKSwgcmVmTm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJuIHNvIGl0IGNhbiBzdG9yZWQgb24gcGFyZW50IG9iamVjdCBpZiBkZXNpcmVkLlxyXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgYSBjaGlsZCBgQ29tcG9uZW50YCBmcm9tIHRoaXMgYENvbXBvbmVudGBzIGxpc3Qgb2YgY2hpbGRyZW4uIEFsc28gcmVtb3Zlc1xyXG4gICAqIHRoZSBjaGlsZCBgQ29tcG9uZW50YHMgZWxlbWVudCBmcm9tIHRoaXMgYENvbXBvbmVudGBzIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gY29tcG9uZW50XHJcbiAgICogICAgICAgIFRoZSBjaGlsZCBgQ29tcG9uZW50YCB0byByZW1vdmUuXHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQoY29tcG9uZW50KSB7XHJcbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgY29tcG9uZW50ID0gdGhpcy5nZXRDaGlsZChjb21wb25lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY29tcG9uZW50IHx8ICF0aGlzLmNoaWxkcmVuXykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNoaWxkRm91bmQgPSBmYWxzZTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gdGhpcy5jaGlsZHJlbl8ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5fW2ldID09PSBjb21wb25lbnQpIHtcclxuICAgICAgICBjaGlsZEZvdW5kID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuXy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWNoaWxkRm91bmQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuY2hpbGRJbmRleF9bY29tcG9uZW50LmlkKCldID0gbnVsbDtcclxuICAgIHRoaXMuY2hpbGROYW1lSW5kZXhfW2NvbXBvbmVudC5uYW1lKCldID0gbnVsbDtcclxuXHJcbiAgICB2YXIgY29tcEVsID0gY29tcG9uZW50LmVsKCk7XHJcblxyXG4gICAgaWYgKGNvbXBFbCAmJiBjb21wRWwucGFyZW50Tm9kZSA9PT0gdGhpcy5jb250ZW50RWwoKSkge1xyXG4gICAgICB0aGlzLmNvbnRlbnRFbCgpLnJlbW92ZUNoaWxkKGNvbXBvbmVudC5lbCgpKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBZGQgYW5kIGluaXRpYWxpemUgZGVmYXVsdCBjaGlsZCBgQ29tcG9uZW50YHMgYmFzZWQgdXBvbiBvcHRpb25zLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS5pbml0Q2hpbGRyZW4gPSBmdW5jdGlvbiBpbml0Q2hpbGRyZW4oKSB7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMub3B0aW9uc18uY2hpbGRyZW47XHJcblxyXG4gICAgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgIC8vIGB0aGlzYCBpcyBgcGFyZW50YFxyXG4gICAgICB2YXIgcGFyZW50T3B0aW9ucyA9IHRoaXMub3B0aW9uc187XHJcblxyXG4gICAgICB2YXIgaGFuZGxlQWRkID0gZnVuY3Rpb24gaGFuZGxlQWRkKGNoaWxkKSB7XHJcbiAgICAgICAgdmFyIG5hbWUgPSBjaGlsZC5uYW1lO1xyXG4gICAgICAgIHZhciBvcHRzID0gY2hpbGQub3B0cztcclxuXHJcbiAgICAgICAgLy8gQWxsb3cgb3B0aW9ucyBmb3IgY2hpbGRyZW4gdG8gYmUgc2V0IGF0IHRoZSBwYXJlbnQgb3B0aW9uc1xyXG4gICAgICAgIC8vIGUuZy4gdmlkZW9qcyhpZCwgeyBjb250cm9sQmFyOiBmYWxzZSB9KTtcclxuICAgICAgICAvLyBpbnN0ZWFkIG9mIHZpZGVvanMoaWQsIHsgY2hpbGRyZW46IHsgY29udHJvbEJhcjogZmFsc2UgfSk7XHJcbiAgICAgICAgaWYgKHBhcmVudE9wdGlvbnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgb3B0cyA9IHBhcmVudE9wdGlvbnNbbmFtZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBbGxvdyBmb3IgZGlzYWJsaW5nIGRlZmF1bHQgY29tcG9uZW50c1xyXG4gICAgICAgIC8vIGUuZy4gb3B0aW9uc1snY2hpbGRyZW4nXVsncG9zdGVySW1hZ2UnXSA9IGZhbHNlXHJcbiAgICAgICAgaWYgKG9wdHMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBbGxvdyBvcHRpb25zIHRvIGJlIHBhc3NlZCBhcyBhIHNpbXBsZSBib29sZWFuIGlmIG5vIGNvbmZpZ3VyYXRpb25cclxuICAgICAgICAvLyBpcyBuZWNlc3NhcnkuXHJcbiAgICAgICAgaWYgKG9wdHMgPT09IHRydWUpIHtcclxuICAgICAgICAgIG9wdHMgPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdlIGFsc28gd2FudCB0byBwYXNzIHRoZSBvcmlnaW5hbCBwbGF5ZXIgb3B0aW9uc1xyXG4gICAgICAgIC8vIHRvIGVhY2ggY29tcG9uZW50IGFzIHdlbGwgc28gdGhleSBkb24ndCBuZWVkIHRvXHJcbiAgICAgICAgLy8gcmVhY2ggYmFjayBpbnRvIHRoZSBwbGF5ZXIgZm9yIG9wdGlvbnMgbGF0ZXIuXHJcbiAgICAgICAgb3B0cy5wbGF5ZXJPcHRpb25zID0gX3RoaXMub3B0aW9uc18ucGxheWVyT3B0aW9ucztcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgdGhlIGNoaWxkIGNvbXBvbmVudC5cclxuICAgICAgICAvLyBBZGQgYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBjaGlsZCBieSBuYW1lIG9uIHRoZSBwYXJlbnQgaW5zdGFuY2UuXHJcbiAgICAgICAgLy8gSWYgdHdvIG9mIHRoZSBzYW1lIGNvbXBvbmVudCBhcmUgdXNlZCwgZGlmZmVyZW50IG5hbWVzIHNob3VsZCBiZSBzdXBwbGllZFxyXG4gICAgICAgIC8vIGZvciBlYWNoXHJcbiAgICAgICAgdmFyIG5ld0NoaWxkID0gX3RoaXMuYWRkQ2hpbGQobmFtZSwgb3B0cyk7XHJcblxyXG4gICAgICAgIGlmIChuZXdDaGlsZCkge1xyXG4gICAgICAgICAgX3RoaXNbbmFtZV0gPSBuZXdDaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBBbGxvdyBmb3IgYW4gYXJyYXkgb2YgY2hpbGRyZW4gZGV0YWlscyB0byBwYXNzZWQgaW4gdGhlIG9wdGlvbnNcclxuICAgICAgdmFyIHdvcmtpbmdDaGlsZHJlbiA9IHZvaWQgMDtcclxuICAgICAgdmFyIFRlY2ggPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KCdUZWNoJyk7XHJcblxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICB3b3JraW5nQ2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB3b3JraW5nQ2hpbGRyZW4gPSBPYmplY3Qua2V5cyhjaGlsZHJlbik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHdvcmtpbmdDaGlsZHJlblxyXG4gICAgICAvLyBjaGlsZHJlbiB0aGF0IGFyZSBpbiB0aGlzLm9wdGlvbnNfIGJ1dCBhbHNvIGluIHdvcmtpbmdDaGlsZHJlbiAgd291bGRcclxuICAgICAgLy8gZ2l2ZSB1cyBleHRyYSBjaGlsZHJlbiB3ZSBkbyBub3Qgd2FudC4gU28sIHdlIHdhbnQgdG8gZmlsdGVyIHRoZW0gb3V0LlxyXG4gICAgICAuY29uY2F0KE9iamVjdC5rZXlzKHRoaXMub3B0aW9uc18pLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICByZXR1cm4gIXdvcmtpbmdDaGlsZHJlbi5zb21lKGZ1bmN0aW9uICh3Y2hpbGQpIHtcclxuICAgICAgICAgIGlmICh0eXBlb2Ygd2NoaWxkID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQgPT09IHdjaGlsZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBjaGlsZCA9PT0gd2NoaWxkLm5hbWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pKS5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgdmFyIG5hbWUgPSB2b2lkIDA7XHJcbiAgICAgICAgdmFyIG9wdHMgPSB2b2lkIDA7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBuYW1lID0gY2hpbGQ7XHJcbiAgICAgICAgICBvcHRzID0gY2hpbGRyZW5bbmFtZV0gfHwgX3RoaXMub3B0aW9uc19bbmFtZV0gfHwge307XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5hbWUgPSBjaGlsZC5uYW1lO1xyXG4gICAgICAgICAgb3B0cyA9IGNoaWxkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgb3B0czogb3B0cyB9O1xyXG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCBjaGlsZC5uYW1lIGlzbid0IGluIHRoZSB0ZWNoT3JkZXIgc2luY2VcclxuICAgICAgICAvLyB0ZWNocyBhcmUgcmVnaXN0ZXJkIGFzIENvbXBvbmVudHMgYnV0IGNhbid0IGFyZW4ndCBjb21wYXRpYmxlXHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlb2pzL3ZpZGVvLmpzL2lzc3Vlcy8yNzcyXHJcbiAgICAgICAgdmFyIGMgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KGNoaWxkLm9wdHMuY29tcG9uZW50Q2xhc3MgfHwgdG9UaXRsZUNhc2UoY2hpbGQubmFtZSkpO1xyXG5cclxuICAgICAgICByZXR1cm4gYyAmJiAhVGVjaC5pc1RlY2goYyk7XHJcbiAgICAgIH0pLmZvckVhY2goaGFuZGxlQWRkKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGNsYXNzIG5hbWUuIFNob3VsZCBiZSBvdmVycmlkZW4gYnkgc3ViLWNvbXBvbmVudHMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICogICAgICAgICBUaGUgRE9NIGNsYXNzIG5hbWUgZm9yIHRoaXMgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xyXG4gICAgLy8gQ2hpbGQgY2xhc3NlcyBjYW4gaW5jbHVkZSBhIGZ1bmN0aW9uIHRoYXQgZG9lczpcclxuICAgIC8vIHJldHVybiAnQ0xBU1MgTkFNRScgKyB0aGlzLl9zdXBlcigpO1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEJpbmQgYSBsaXN0ZW5lciB0byB0aGUgY29tcG9uZW50J3MgcmVhZHkgc3RhdGUuXHJcbiAgICogRGlmZmVyZW50IGZyb20gZXZlbnQgbGlzdGVuZXJzIGluIHRoYXQgaWYgdGhlIHJlYWR5IGV2ZW50IGhhcyBhbHJlYWR5IGhhcHBlbmVkXHJcbiAgICogaXQgd2lsbCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBpbW1lZGlhdGVseS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cclxuICAgKiAgICAgICAgIFJldHVybnMgaXRzZWxmOyBtZXRob2QgY2FuIGJlIGNoYWluZWQuXHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLnJlYWR5ID0gZnVuY3Rpb24gcmVhZHkoZm4pIHtcclxuICAgIHZhciBzeW5jID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcclxuXHJcbiAgICBpZiAoZm4pIHtcclxuICAgICAgaWYgKHRoaXMuaXNSZWFkeV8pIHtcclxuICAgICAgICBpZiAoc3luYykge1xyXG4gICAgICAgICAgZm4uY2FsbCh0aGlzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gQ2FsbCB0aGUgZnVuY3Rpb24gYXN5bmNocm9ub3VzbHkgYnkgZGVmYXVsdCBmb3IgY29uc2lzdGVuY3lcclxuICAgICAgICAgIHRoaXMuc2V0VGltZW91dChmbiwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMucmVhZHlRdWV1ZV8gPSB0aGlzLnJlYWR5UXVldWVfIHx8IFtdO1xyXG4gICAgICAgIHRoaXMucmVhZHlRdWV1ZV8ucHVzaChmbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUcmlnZ2VyIGFsbCB0aGUgcmVhZHkgbGlzdGVuZXJzIGZvciB0aGlzIGBDb21wb25lbnRgLlxyXG4gICAqXHJcbiAgICogQGZpcmVzIENvbXBvbmVudCNyZWFkeVxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyUmVhZHkgPSBmdW5jdGlvbiB0cmlnZ2VyUmVhZHkoKSB7XHJcbiAgICB0aGlzLmlzUmVhZHlfID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBFbnN1cmUgcmVhZHkgaXMgdHJpZ2dlcmQgYXN5bmNocm9ub3VzbHlcclxuICAgIHRoaXMuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciByZWFkeVF1ZXVlID0gdGhpcy5yZWFkeVF1ZXVlXztcclxuXHJcbiAgICAgIC8vIFJlc2V0IFJlYWR5IFF1ZXVlXHJcbiAgICAgIHRoaXMucmVhZHlRdWV1ZV8gPSBbXTtcclxuXHJcbiAgICAgIGlmIChyZWFkeVF1ZXVlICYmIHJlYWR5UXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJlYWR5UXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICAgIGZuLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFsbG93IGZvciB1c2luZyBldmVudCBsaXN0ZW5lcnMgYWxzb1xyXG4gICAgICAvKipcclxuICAgICAgICogVHJpZ2dlcmVkIHdoZW4gYSBgQ29tcG9uZW50YCBpcyByZWFkeS5cclxuICAgICAgICpcclxuICAgICAgICogQGV2ZW50IENvbXBvbmVudCNyZWFkeVxyXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAgICAgICAqL1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ3JlYWR5Jyk7XHJcbiAgICB9LCAxKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBGaW5kIGEgc2luZ2xlIERPTSBlbGVtZW50IG1hdGNoaW5nIGEgYHNlbGVjdG9yYC4gVGhpcyBjYW4gYmUgd2l0aGluIHRoZSBgQ29tcG9uZW50YHNcclxuICAgKiBgY29udGVudEVsKClgIG9yIGFub3RoZXIgY3VzdG9tIGNvbnRleHQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcclxuICAgKiAgICAgICAgQSB2YWxpZCBDU1Mgc2VsZWN0b3IsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGBxdWVyeVNlbGVjdG9yYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IFtjb250ZXh0PXRoaXMuY29udGVudEVsKCldXHJcbiAgICogICAgICAgIEEgRE9NIGVsZW1lbnQgd2l0aGluIHdoaWNoIHRvIHF1ZXJ5LiBDYW4gYWxzbyBiZSBhIHNlbGVjdG9yIHN0cmluZyBpblxyXG4gICAqICAgICAgICB3aGljaCBjYXNlIHRoZSBmaXJzdCBtYXRjaGluZyBlbGVtZW50IHdpbGwgZ2V0IHVzZWQgYXMgY29udGV4dC4gSWZcclxuICAgKiAgICAgICAgbWlzc2luZyBgdGhpcy5jb250ZW50RWwoKWAgZ2V0cyB1c2VkLiBJZiAgYHRoaXMuY29udGVudEVsKClgIHJldHVybnNcclxuICAgKiAgICAgICAgbm90aGluZyBpdCBmYWxscyBiYWNrIHRvIGBkb2N1bWVudGAuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fG51bGx9XHJcbiAgICogICAgICAgICB0aGUgZG9tIGVsZW1lbnQgdGhhdCB3YXMgZm91bmQsIG9yIG51bGxcclxuICAgKlxyXG4gICAqIEBzZWUgW0luZm9ybWF0aW9uIG9uIENTUyBTZWxlY3RvcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0NTUy9HZXR0aW5nX1N0YXJ0ZWQvU2VsZWN0b3JzKVxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS4kID0gZnVuY3Rpb24gJCQkMShzZWxlY3RvciwgY29udGV4dCkge1xyXG4gICAgcmV0dXJuICQoc2VsZWN0b3IsIGNvbnRleHQgfHwgdGhpcy5jb250ZW50RWwoKSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRmluZHMgYWxsIERPTSBlbGVtZW50IG1hdGNoaW5nIGEgYHNlbGVjdG9yYC4gVGhpcyBjYW4gYmUgd2l0aGluIHRoZSBgQ29tcG9uZW50YHNcclxuICAgKiBgY29udGVudEVsKClgIG9yIGFub3RoZXIgY3VzdG9tIGNvbnRleHQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcclxuICAgKiAgICAgICAgQSB2YWxpZCBDU1Mgc2VsZWN0b3IsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGBxdWVyeVNlbGVjdG9yQWxsYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IFtjb250ZXh0PXRoaXMuY29udGVudEVsKCldXHJcbiAgICogICAgICAgIEEgRE9NIGVsZW1lbnQgd2l0aGluIHdoaWNoIHRvIHF1ZXJ5LiBDYW4gYWxzbyBiZSBhIHNlbGVjdG9yIHN0cmluZyBpblxyXG4gICAqICAgICAgICB3aGljaCBjYXNlIHRoZSBmaXJzdCBtYXRjaGluZyBlbGVtZW50IHdpbGwgZ2V0IHVzZWQgYXMgY29udGV4dC4gSWZcclxuICAgKiAgICAgICAgbWlzc2luZyBgdGhpcy5jb250ZW50RWwoKWAgZ2V0cyB1c2VkLiBJZiAgYHRoaXMuY29udGVudEVsKClgIHJldHVybnNcclxuICAgKiAgICAgICAgbm90aGluZyBpdCBmYWxscyBiYWNrIHRvIGBkb2N1bWVudGAuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtOb2RlTGlzdH1cclxuICAgKiAgICAgICAgIGEgbGlzdCBvZiBkb20gZWxlbWVudHMgdGhhdCB3ZXJlIGZvdW5kXHJcbiAgICpcclxuICAgKiBAc2VlIFtJbmZvcm1hdGlvbiBvbiBDU1MgU2VsZWN0b3JzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9DU1MvR2V0dGluZ19TdGFydGVkL1NlbGVjdG9ycylcclxuICAgKi9cclxuXHJcblxyXG4gIENvbXBvbmVudC5wcm90b3R5cGUuJCQgPSBmdW5jdGlvbiAkJCQkMShzZWxlY3RvciwgY29udGV4dCkge1xyXG4gICAgcmV0dXJuICQkKHNlbGVjdG9yLCBjb250ZXh0IHx8IHRoaXMuY29udGVudEVsKCkpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgY29tcG9uZW50J3MgZWxlbWVudCBoYXMgYSBDU1MgY2xhc3MgbmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc1RvQ2hlY2tcclxuICAgKiAgICAgICAgQ1NTIGNsYXNzIG5hbWUgdG8gY2hlY2suXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqICAgICAgICAgLSBUcnVlIGlmIHRoZSBgQ29tcG9uZW50YCBoYXMgdGhlIGNsYXNzLlxyXG4gICAqICAgICAgICAgLSBGYWxzZSBpZiB0aGUgYENvbXBvbmVudGAgZG9lcyBub3QgaGF2ZSB0aGUgY2xhc3NgXHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLmhhc0NsYXNzID0gZnVuY3Rpb24gaGFzQ2xhc3MkJDEoY2xhc3NUb0NoZWNrKSB7XHJcbiAgICByZXR1cm4gaGFzQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9DaGVjayk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgQ1NTIGNsYXNzIG5hbWUgdG8gdGhlIGBDb21wb25lbnRgcyBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9BZGRcclxuICAgKiAgICAgICAgQ1NTIGNsYXNzIG5hbWUgdG8gYWRkXHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3MkJDEoY2xhc3NUb0FkZCkge1xyXG4gICAgYWRkQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9BZGQpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhIENTUyBjbGFzcyBuYW1lIGZyb20gdGhlIGBDb21wb25lbnRgcyBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzVG9SZW1vdmVcclxuICAgKiAgICAgICAgQ1NTIGNsYXNzIG5hbWUgdG8gcmVtb3ZlXHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gcmVtb3ZlQ2xhc3MkJDEoY2xhc3NUb1JlbW92ZSkge1xyXG4gICAgcmVtb3ZlQ2xhc3ModGhpcy5lbF8sIGNsYXNzVG9SZW1vdmUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBvciByZW1vdmUgYSBDU1MgY2xhc3MgbmFtZSBmcm9tIHRoZSBjb21wb25lbnQncyBlbGVtZW50LlxyXG4gICAqIC0gYGNsYXNzVG9Ub2dnbGVgIGdldHMgYWRkZWQgd2hlbiB7QGxpbmsgQ29tcG9uZW50I2hhc0NsYXNzfSB3b3VsZCByZXR1cm4gZmFsc2UuXHJcbiAgICogLSBgY2xhc3NUb1RvZ2dsZWAgZ2V0cyByZW1vdmVkIHdoZW4ge0BsaW5rIENvbXBvbmVudCNoYXNDbGFzc30gd291bGQgcmV0dXJuIHRydWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNsYXNzVG9Ub2dnbGVcclxuICAgKiAgICAgICAgIFRoZSBjbGFzcyB0byBhZGQgb3IgcmVtb3ZlIGJhc2VkIG9uIChAbGluayBDb21wb25lbnQjaGFzQ2xhc3N9XHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtib29sZWFufERvbX5wcmVkaWNhdGV9IFtwcmVkaWNhdGVdXHJcbiAgICogICAgICAgICBBbiB7QGxpbmsgRG9tfnByZWRpY2F0ZX0gZnVuY3Rpb24gb3IgYSBib29sZWFuXHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLnRvZ2dsZUNsYXNzID0gZnVuY3Rpb24gdG9nZ2xlQ2xhc3MkJDEoY2xhc3NUb1RvZ2dsZSwgcHJlZGljYXRlKSB7XHJcbiAgICB0b2dnbGVDbGFzcyh0aGlzLmVsXywgY2xhc3NUb1RvZ2dsZSwgcHJlZGljYXRlKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTaG93IHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudCBpZiBpdCBpcyBoaWRkZW4gYnkgcmVtb3ZpbmcgdGhlXHJcbiAgICogJ3Zqcy1oaWRkZW4nIGNsYXNzIG5hbWUgZnJvbSBpdC5cclxuICAgKi9cclxuXHJcblxyXG4gIENvbXBvbmVudC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7XHJcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtaGlkZGVuJyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSGlkZSB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQgaWYgaXQgaXMgY3VycmVudGx5IHNob3dpbmcgYnkgYWRkaW5nIHRoZVxyXG4gICAqICd2anMtaGlkZGVuYCBjbGFzcyBuYW1lIHRvIGl0LlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcclxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBMb2NrIGEgYENvbXBvbmVudGBzIGVsZW1lbnQgaW4gaXRzIHZpc2libGUgc3RhdGUgYnkgYWRkaW5nIHRoZSAndmpzLWxvY2stc2hvd2luZydcclxuICAgKiBjbGFzcyBuYW1lIHRvIGl0LiBVc2VkIGR1cmluZyBmYWRlSW4vZmFkZU91dC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLmxvY2tTaG93aW5nID0gZnVuY3Rpb24gbG9ja1Nob3dpbmcoKSB7XHJcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtbG9jay1zaG93aW5nJyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVW5sb2NrIGEgYENvbXBvbmVudGBzIGVsZW1lbnQgZnJvbSBpdHMgdmlzaWJsZSBzdGF0ZSBieSByZW1vdmluZyB0aGUgJ3Zqcy1sb2NrLXNob3dpbmcnXHJcbiAgICogY2xhc3MgbmFtZSBmcm9tIGl0LiBVc2VkIGR1cmluZyBmYWRlSW4vZmFkZU91dC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLnVubG9ja1Nob3dpbmcgPSBmdW5jdGlvbiB1bmxvY2tTaG93aW5nKCkge1xyXG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWxvY2stc2hvd2luZycpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIHRoZSBgQ29tcG9uZW50YHMgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcclxuICAgKiAgICAgICAgTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGdldCB0aGUgdmFsdWUgZnJvbS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxyXG4gICAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSB0aGF0IHdhcyBhc2tlZCBmb3IuXHJcbiAgICogICAgICAgICAtIENhbiBiZSBhbiBlbXB0eSBzdHJpbmcgb24gc29tZSBicm93c2VycyBpZiB0aGUgYXR0cmlidXRlIGRvZXMgbm90IGV4aXN0XHJcbiAgICogICAgICAgICAgIG9yIGhhcyBubyB2YWx1ZVxyXG4gICAqICAgICAgICAgLSBNb3N0IGJyb3dzZXJzIHdpbGwgcmV0dXJuIG51bGwgaWYgdGhlIGF0dGlidXRlIGRvZXMgbm90IGV4aXN0IG9yIGhhc1xyXG4gICAqICAgICAgICAgICBubyB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEBzZWUgW0RPTSBBUElde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEF0dHJpYnV0ZX1cclxuICAgKi9cclxuXHJcblxyXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24gZ2V0QXR0cmlidXRlJCQxKGF0dHJpYnV0ZSkge1xyXG4gICAgcmV0dXJuIGdldEF0dHJpYnV0ZSh0aGlzLmVsXywgYXR0cmlidXRlKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSBvbiB0aGUgYENvbXBvbmVudGAncyBlbGVtZW50XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXHJcbiAgICogICAgICAgIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBzZXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcclxuICAgKiAgICAgICAgVmFsdWUgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgdG8uXHJcbiAgICpcclxuICAgKiBAc2VlIFtET00gQVBJXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9zZXRBdHRyaWJ1dGV9XHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZSQkMShhdHRyaWJ1dGUsIHZhbHVlKSB7XHJcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5lbF8sIGF0dHJpYnV0ZSwgdmFsdWUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXHJcbiAgICogICAgICAgIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byByZW1vdmUuXHJcbiAgICpcclxuICAgKiBAc2VlIFtET00gQVBJXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9yZW1vdmVBdHRyaWJ1dGV9XHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZSQkMShhdHRyaWJ1dGUpIHtcclxuICAgIHJlbW92ZUF0dHJpYnV0ZSh0aGlzLmVsXywgYXR0cmlidXRlKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgb3Igc2V0IHRoZSB3aWR0aCBvZiB0aGUgY29tcG9uZW50IGJhc2VkIHVwb24gdGhlIENTUyBzdHlsZXMuXHJcbiAgICogU2VlIHtAbGluayBDb21wb25lbnQjZGltZW5zaW9ufSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW251bV1cclxuICAgKiAgICAgICAgVGhlIHdpZHRoIHRoYXQgeW91IHdhbnQgdG8gc2V0IHBvc3RmaXhlZCB3aXRoICclJywgJ3B4JyBvciBub3RoaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcExpc3RlbmVyc11cclxuICAgKiAgICAgICAgU2tpcCB0aGUgY29tcG9uZW50cmVzaXplIGV2ZW50IHRyaWdnZXJcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcnxzdHJpbmd9XHJcbiAgICogICAgICAgICBUaGUgd2lkdGggd2hlbiBnZXR0aW5nLCB6ZXJvIGlmIHRoZXJlIGlzIG5vIHdpZHRoLiBDYW4gYmUgYSBzdHJpbmdcclxuICAgKiAgICAgICAgICAgcG9zdHBpeGVkIHdpdGggJyUnIG9yICdweCcuXHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gd2lkdGgobnVtLCBza2lwTGlzdGVuZXJzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24oJ3dpZHRoJywgbnVtLCBza2lwTGlzdGVuZXJzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgb3Igc2V0IHRoZSBoZWlnaHQgb2YgdGhlIGNvbXBvbmVudCBiYXNlZCB1cG9uIHRoZSBDU1Mgc3R5bGVzLlxyXG4gICAqIFNlZSB7QGxpbmsgQ29tcG9uZW50I2RpbWVuc2lvbn0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtudW1dXHJcbiAgICogICAgICAgIFRoZSBoZWlnaHQgdGhhdCB5b3Ugd2FudCB0byBzZXQgcG9zdGZpeGVkIHdpdGggJyUnLCAncHgnIG9yIG5vdGhpbmcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwTGlzdGVuZXJzXVxyXG4gICAqICAgICAgICBTa2lwIHRoZSBjb21wb25lbnRyZXNpemUgZXZlbnQgdHJpZ2dlclxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfHN0cmluZ31cclxuICAgKiAgICAgICAgIFRoZSB3aWR0aCB3aGVuIGdldHRpbmcsIHplcm8gaWYgdGhlcmUgaXMgbm8gd2lkdGguIENhbiBiZSBhIHN0cmluZ1xyXG4gICAqICAgICAgICAgcG9zdHBpeGVkIHdpdGggJyUnIG9yICdweCcuXHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uIGhlaWdodChudW0sIHNraXBMaXN0ZW5lcnMpIHtcclxuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbignaGVpZ2h0JywgbnVtLCBza2lwTGlzdGVuZXJzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTZXQgYm90aCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgYENvbXBvbmVudGAgZWxlbWVudCBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfHN0cmluZ30gd2lkdGhcclxuICAgKiAgICAgICAgIFdpZHRoIHRvIHNldCB0aGUgYENvbXBvbmVudGBzIGVsZW1lbnQgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ8c3RyaW5nfSBoZWlnaHRcclxuICAgKiAgICAgICAgIEhlaWdodCB0byBzZXQgdGhlIGBDb21wb25lbnRgcyBlbGVtZW50IHRvLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS5kaW1lbnNpb25zID0gZnVuY3Rpb24gZGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAvLyBTa2lwIGNvbXBvbmVudHJlc2l6ZSBsaXN0ZW5lcnMgb24gd2lkdGggZm9yIG9wdGltaXphdGlvblxyXG4gICAgdGhpcy53aWR0aCh3aWR0aCwgdHJ1ZSk7XHJcbiAgICB0aGlzLmhlaWdodChoZWlnaHQpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBvciBzZXQgd2lkdGggb3IgaGVpZ2h0IG9mIHRoZSBgQ29tcG9uZW50YCBlbGVtZW50LiBUaGlzIGlzIHRoZSBzaGFyZWQgY29kZVxyXG4gICAqIGZvciB0aGUge0BsaW5rIENvbXBvbmVudCN3aWR0aH0gYW5kIHtAbGluayBDb21wb25lbnQjaGVpZ2h0fS5cclxuICAgKlxyXG4gICAqIFRoaW5ncyB0byBrbm93OlxyXG4gICAqIC0gSWYgdGhlIHdpZHRoIG9yIGhlaWdodCBpbiBhbiBudW1iZXIgdGhpcyB3aWxsIHJldHVybiB0aGUgbnVtYmVyIHBvc3RmaXhlZCB3aXRoICdweCcuXHJcbiAgICogLSBJZiB0aGUgd2lkdGgvaGVpZ2h0IGlzIGEgcGVyY2VudCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBwZXJjZW50IHBvc3RmaXhlZCB3aXRoICclJ1xyXG4gICAqIC0gSGlkZGVuIGVsZW1lbnRzIGhhdmUgYSB3aWR0aCBvZiAwIHdpdGggYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC4gVGhpcyBmdW5jdGlvblxyXG4gICAqICAgZGVmYXVsdHMgdG8gdGhlIGBDb21wb25lbnRgcyBgc3R5bGUud2lkdGhgIGFuZCBmYWxscyBiYWNrIHRvIGB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZWAuXHJcbiAgICogICBTZWUgW3RoaXNde0BsaW5rIGh0dHA6Ly93d3cuZm9saW90ZWsuY29tL2RldmJsb2cvZ2V0dGluZy10aGUtd2lkdGgtb2YtYS1oaWRkZW4tZWxlbWVudC13aXRoLWpxdWVyeS11c2luZy13aWR0aC99XHJcbiAgICogICBmb3IgbW9yZSBpbmZvcm1hdGlvblxyXG4gICAqIC0gSWYgeW91IHdhbnQgdGhlIGNvbXB1dGVkIHN0eWxlIG9mIHRoZSBjb21wb25lbnQsIHVzZSB7QGxpbmsgQ29tcG9uZW50I2N1cnJlbnRXaWR0aH1cclxuICAgKiAgIGFuZCB7QGxpbmsge0NvbXBvbmVudCNjdXJyZW50SGVpZ2h0fVxyXG4gICAqXHJcbiAgICogQGZpcmVzIENvbXBvbmVudCNjb21wb25lbnRyZXNpemVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB3aWR0aE9ySGVpZ2h0XHJcbiAgIDggICAgICAgICd3aWR0aCcgb3IgJ2hlaWdodCdcclxuICAgKlxyXG4gICAqIEBwYXJhbSAge251bWJlcnxzdHJpbmd9IFtudW1dXHJcbiAgIDggICAgICAgICBOZXcgZGltZW5zaW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbc2tpcExpc3RlbmVyc11cclxuICAgKiAgICAgICAgIFNraXAgY29tcG9uZW50cmVzaXplIGV2ZW50IHRyaWdnZXJcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKiAgICAgICAgIFRoZSBkaW1lbnNpb24gd2hlbiBnZXR0aW5nIG9yIDAgaWYgdW5zZXRcclxuICAgKi9cclxuXHJcblxyXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gZGltZW5zaW9uKHdpZHRoT3JIZWlnaHQsIG51bSwgc2tpcExpc3RlbmVycykge1xyXG4gICAgaWYgKG51bSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIC8vIFNldCB0byB6ZXJvIGlmIG51bGwgb3IgbGl0ZXJhbGx5IE5hTiAoTmFOICE9PSBOYU4pXHJcbiAgICAgIGlmIChudW0gPT09IG51bGwgfHwgbnVtICE9PSBudW0pIHtcclxuICAgICAgICBudW0gPSAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiB1c2luZyBjc3Mgd2lkdGgvaGVpZ2h0ICglIG9yIHB4KSBhbmQgYWRqdXN0XHJcbiAgICAgIGlmICgoJycgKyBudW0pLmluZGV4T2YoJyUnKSAhPT0gLTEgfHwgKCcnICsgbnVtKS5pbmRleE9mKCdweCcpICE9PSAtMSkge1xyXG4gICAgICAgIHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdID0gbnVtO1xyXG4gICAgICB9IGVsc2UgaWYgKG51bSA9PT0gJ2F1dG8nKSB7XHJcbiAgICAgICAgdGhpcy5lbF8uc3R5bGVbd2lkdGhPckhlaWdodF0gPSAnJztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmVsXy5zdHlsZVt3aWR0aE9ySGVpZ2h0XSA9IG51bSArICdweCc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHNraXBMaXN0ZW5lcnMgYWxsb3dzIHVzIHRvIGF2b2lkIHRyaWdnZXJpbmcgdGhlIHJlc2l6ZSBldmVudCB3aGVuIHNldHRpbmcgYm90aCB3aWR0aCBhbmQgaGVpZ2h0XHJcbiAgICAgIGlmICghc2tpcExpc3RlbmVycykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlc2l6ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXZlbnQgQ29tcG9uZW50I2NvbXBvbmVudHJlc2l6ZVxyXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NvbXBvbmVudHJlc2l6ZScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm90IHNldHRpbmcgYSB2YWx1ZSwgc28gZ2V0dGluZyBpdFxyXG4gICAgLy8gTWFrZSBzdXJlIGVsZW1lbnQgZXhpc3RzXHJcbiAgICBpZiAoIXRoaXMuZWxfKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBkaW1lbnNpb24gdmFsdWUgZnJvbSBzdHlsZVxyXG4gICAgdmFyIHZhbCA9IHRoaXMuZWxfLnN0eWxlW3dpZHRoT3JIZWlnaHRdO1xyXG4gICAgdmFyIHB4SW5kZXggPSB2YWwuaW5kZXhPZigncHgnKTtcclxuXHJcbiAgICBpZiAocHhJbmRleCAhPT0gLTEpIHtcclxuICAgICAgLy8gUmV0dXJuIHRoZSBwaXhlbCB2YWx1ZSB3aXRoIG5vICdweCdcclxuICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbC5zbGljZSgwLCBweEluZGV4KSwgMTApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vIHB4IHNvIHVzaW5nICUgb3Igbm8gc3R5bGUgd2FzIHNldCwgc28gZmFsbGluZyBiYWNrIHRvIG9mZnNldFdpZHRoL2hlaWdodFxyXG4gICAgLy8gSWYgY29tcG9uZW50IGhhcyBkaXNwbGF5Om5vbmUsIG9mZnNldCB3aWxsIHJldHVybiAwXHJcbiAgICAvLyBUT0RPOiBoYW5kbGUgZGlzcGxheTpub25lIGFuZCBubyBkaW1lbnNpb24gc3R5bGUgdXNpbmcgcHhcclxuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmVsX1snb2Zmc2V0JyArIHRvVGl0bGVDYXNlKHdpZHRoT3JIZWlnaHQpXSwgMTApO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgd2lkdGggb3IgdGhlIGhlaWdodCBvZiB0aGUgYENvbXBvbmVudGAgZWxlbWVudHMgY29tcHV0ZWQgc3R5bGUuIFVzZXNcclxuICAgKiBgd2luZG93LmdldENvbXB1dGVkU3R5bGVgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHdpZHRoT3JIZWlnaHRcclxuICAgKiAgICAgICAgQSBzdHJpbmcgY29udGFpbmluZyAnd2lkdGgnIG9yICdoZWlnaHQnLiBXaGljaGV2ZXIgb25lIHlvdSB3YW50IHRvIGdldC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKiAgICAgICAgIFRoZSBkaW1lbnNpb24gdGhhdCBnZXRzIGFza2VkIGZvciBvciAwIGlmIG5vdGhpbmcgd2FzIHNldFxyXG4gICAqICAgICAgICAgZm9yIHRoYXQgZGltZW5zaW9uLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jdXJyZW50RGltZW5zaW9uID0gZnVuY3Rpb24gY3VycmVudERpbWVuc2lvbih3aWR0aE9ySGVpZ2h0KSB7XHJcbiAgICB2YXIgY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID0gMDtcclxuXHJcbiAgICBpZiAod2lkdGhPckhlaWdodCAhPT0gJ3dpZHRoJyAmJiB3aWR0aE9ySGVpZ2h0ICE9PSAnaGVpZ2h0Jykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnREaW1lbnNpb24gb25seSBhY2NlcHRzIHdpZHRoIG9yIGhlaWdodCB2YWx1ZScpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2Ygd2luZG93XzEuZ2V0Q29tcHV0ZWRTdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvd18xLmdldENvbXB1dGVkU3R5bGUodGhpcy5lbF8pO1xyXG5cclxuICAgICAgY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHdpZHRoT3JIZWlnaHQpIHx8IGNvbXB1dGVkU3R5bGVbd2lkdGhPckhlaWdodF07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmVtb3ZlICdweCcgZnJvbSB2YXJpYWJsZSBhbmQgcGFyc2UgYXMgaW50ZWdlclxyXG4gICAgY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID0gcGFyc2VGbG9hdChjb21wdXRlZFdpZHRoT3JIZWlnaHQpO1xyXG5cclxuICAgIC8vIGlmIHRoZSBjb21wdXRlZCB2YWx1ZSBpcyBzdGlsbCAwLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGJyb3dzZXIgaXMgbHlpbmdcclxuICAgIC8vIGFuZCB3ZSB3YW50IHRvIGNoZWNrIHRoZSBvZmZzZXQgdmFsdWVzLlxyXG4gICAgLy8gVGhpcyBjb2RlIGFsc28gcnVucyBvbiBJRTggYW5kIHdoZXJldmVyIGdldENvbXB1dGVkU3R5bGUgZG9lc24ndCBleGlzdC5cclxuICAgIGlmIChjb21wdXRlZFdpZHRoT3JIZWlnaHQgPT09IDApIHtcclxuICAgICAgdmFyIHJ1bGUgPSAnb2Zmc2V0JyArIHRvVGl0bGVDYXNlKHdpZHRoT3JIZWlnaHQpO1xyXG5cclxuICAgICAgY29tcHV0ZWRXaWR0aE9ySGVpZ2h0ID0gdGhpcy5lbF9bcnVsZV07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbXB1dGVkV2lkdGhPckhlaWdodDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBbiBvYmplY3QgdGhhdCBjb250YWlucyB3aWR0aCBhbmQgaGVpZ2h0IHZhbHVlcyBvZiB0aGUgYENvbXBvbmVudGBzXHJcbiAgICogY29tcHV0ZWQgc3R5bGUuIFVzZXMgYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cclxuICAgKlxyXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IENvbXBvbmVudH5EaW1lbnNpb25PYmplY3RcclxuICAgKlxyXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aFxyXG4gICAqICAgICAgICAgICBUaGUgd2lkdGggb2YgdGhlIGBDb21wb25lbnRgcyBjb21wdXRlZCBzdHlsZS5cclxuICAgKlxyXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHRcclxuICAgKiAgICAgICAgICAgVGhlIGhlaWdodCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLlxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgb2YgdGhlIGBDb21wb25lbnRgc1xyXG4gICAqIGNvbXB1dGVkIHN0eWxlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Q29tcG9uZW50fkRpbWVuc2lvbk9iamVjdH1cclxuICAgKiAgICAgICAgIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBjb21wb25lbnRzIGVsZW1lbnRcclxuICAgKi9cclxuXHJcblxyXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY3VycmVudERpbWVuc2lvbnMgPSBmdW5jdGlvbiBjdXJyZW50RGltZW5zaW9ucygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHdpZHRoOiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ3dpZHRoJyksXHJcbiAgICAgIGhlaWdodDogdGhpcy5jdXJyZW50RGltZW5zaW9uKCdoZWlnaHQnKVxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBgQ29tcG9uZW50YHMgY29tcHV0ZWQgc3R5bGUuIFVzZXMgYHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlYC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gd2lkdGhcclxuICAgKiAgICAgICAgICAgVGhlIHdpZHRoIG9mIHRoZSBgQ29tcG9uZW50YHMgY29tcHV0ZWQgc3R5bGUuXHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLmN1cnJlbnRXaWR0aCA9IGZ1bmN0aW9uIGN1cnJlbnRXaWR0aCgpIHtcclxuICAgIHJldHVybiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ3dpZHRoJyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBoZWlnaHQgb2YgdGhlIGBDb21wb25lbnRgcyBjb21wdXRlZCBzdHlsZS4gVXNlcyBgd2luZG93LmdldENvbXB1dGVkU3R5bGVgLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSBoZWlnaHRcclxuICAgKiAgICAgICAgICAgVGhlIGhlaWdodCBvZiB0aGUgYENvbXBvbmVudGBzIGNvbXB1dGVkIHN0eWxlLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS5jdXJyZW50SGVpZ2h0ID0gZnVuY3Rpb24gY3VycmVudEhlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLmN1cnJlbnREaW1lbnNpb24oJ2hlaWdodCcpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgZm9jdXMgdG8gdGhpcyBjb21wb25lbnRcclxuICAgKi9cclxuXHJcblxyXG4gIENvbXBvbmVudC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiBmb2N1cygpIHtcclxuICAgIHRoaXMuZWxfLmZvY3VzKCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHRoZSBmb2N1cyBmcm9tIHRoaXMgY29tcG9uZW50XHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiBibHVyKCkge1xyXG4gICAgdGhpcy5lbF8uYmx1cigpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEVtaXQgYSAndGFwJyBldmVudHMgd2hlbiB0b3VjaCBldmVudCBzdXBwb3J0IGdldHMgZGV0ZWN0ZWQuIFRoaXMgZ2V0cyB1c2VkIHRvXHJcbiAgICogc3VwcG9ydCB0b2dnbGluZyB0aGUgY29udHJvbHMgdGhyb3VnaCBhIHRhcCBvbiB0aGUgdmlkZW8uIFRoZXkgZ2V0IGVuYWJsZWRcclxuICAgKiBiZWNhdXNlIGV2ZXJ5IHN1Yi1jb21wb25lbnQgd291bGQgaGF2ZSBleHRyYSBvdmVyaGVhZCBvdGhlcndpc2UuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBmaXJlcyBDb21wb25lbnQjdGFwXHJcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNoc3RhcnRcclxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2htb3ZlXHJcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNobGVhdmVcclxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hjYW5jZWxcclxuICAgKiBAbGlzdGVucyBDb21wb25lbnQjdG91Y2hlbmRcclxuICAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLmVtaXRUYXBFdmVudHMgPSBmdW5jdGlvbiBlbWl0VGFwRXZlbnRzKCkge1xyXG4gICAgLy8gVHJhY2sgdGhlIHN0YXJ0IHRpbWUgc28gd2UgY2FuIGRldGVybWluZSBob3cgbG9uZyB0aGUgdG91Y2ggbGFzdGVkXHJcbiAgICB2YXIgdG91Y2hTdGFydCA9IDA7XHJcbiAgICB2YXIgZmlyc3RUb3VjaCA9IG51bGw7XHJcblxyXG4gICAgLy8gTWF4aW11bSBtb3ZlbWVudCBhbGxvd2VkIGR1cmluZyBhIHRvdWNoIGV2ZW50IHRvIHN0aWxsIGJlIGNvbnNpZGVyZWQgYSB0YXBcclxuICAgIC8vIE90aGVyIHBvcHVsYXIgbGlicyB1c2UgYW55d2hlcmUgZnJvbSAyIChoYW1tZXIuanMpIHRvIDE1LFxyXG4gICAgLy8gc28gMTAgc2VlbXMgbGlrZSBhIG5pY2UsIHJvdW5kIG51bWJlci5cclxuICAgIHZhciB0YXBNb3ZlbWVudFRocmVzaG9sZCA9IDEwO1xyXG5cclxuICAgIC8vIFRoZSBtYXhpbXVtIGxlbmd0aCBhIHRvdWNoIGNhbiBiZSB3aGlsZSBzdGlsbCBiZWluZyBjb25zaWRlcmVkIGEgdGFwXHJcbiAgICB2YXIgdG91Y2hUaW1lVGhyZXNob2xkID0gMjAwO1xyXG5cclxuICAgIHZhciBjb3VsZEJlVGFwID0gdm9pZCAwO1xyXG5cclxuICAgIHRoaXMub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSBmaW5nZXIsIGRvbid0IGNvbnNpZGVyIHRyZWF0aW5nIHRoaXMgYXMgYSBjbGlja1xyXG4gICAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAvLyBDb3B5IHBhZ2VYL3BhZ2VZIGZyb20gdGhlIG9iamVjdFxyXG4gICAgICAgIGZpcnN0VG91Y2ggPSB7XHJcbiAgICAgICAgICBwYWdlWDogZXZlbnQudG91Y2hlc1swXS5wYWdlWCxcclxuICAgICAgICAgIHBhZ2VZOiBldmVudC50b3VjaGVzWzBdLnBhZ2VZXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBSZWNvcmQgc3RhcnQgdGltZSBzbyB3ZSBjYW4gZGV0ZWN0IGEgdGFwIHZzLiBcInRvdWNoIGFuZCBob2xkXCJcclxuICAgICAgICB0b3VjaFN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgLy8gUmVzZXQgY291bGRCZVRhcCB0cmFja2luZ1xyXG4gICAgICAgIGNvdWxkQmVUYXAgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLm9uKCd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSBmaW5nZXIsIGRvbid0IGNvbnNpZGVyIHRyZWF0aW5nIHRoaXMgYXMgYSBjbGlja1xyXG4gICAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgY291bGRCZVRhcCA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2UgaWYgKGZpcnN0VG91Y2gpIHtcclxuICAgICAgICAvLyBTb21lIGRldmljZXMgd2lsbCB0aHJvdyB0b3VjaG1vdmVzIGZvciBhbGwgYnV0IHRoZSBzbGlnaHRlc3Qgb2YgdGFwcy5cclxuICAgICAgICAvLyBTbywgaWYgd2UgbW92ZWQgb25seSBhIHNtYWxsIGRpc3RhbmNlLCB0aGlzIGNvdWxkIHN0aWxsIGJlIGEgdGFwXHJcbiAgICAgICAgdmFyIHhkaWZmID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWCAtIGZpcnN0VG91Y2gucGFnZVg7XHJcbiAgICAgICAgdmFyIHlkaWZmID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWSAtIGZpcnN0VG91Y2gucGFnZVk7XHJcbiAgICAgICAgdmFyIHRvdWNoRGlzdGFuY2UgPSBNYXRoLnNxcnQoeGRpZmYgKiB4ZGlmZiArIHlkaWZmICogeWRpZmYpO1xyXG5cclxuICAgICAgICBpZiAodG91Y2hEaXN0YW5jZSA+IHRhcE1vdmVtZW50VGhyZXNob2xkKSB7XHJcbiAgICAgICAgICBjb3VsZEJlVGFwID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgbm9UYXAgPSBmdW5jdGlvbiBub1RhcCgpIHtcclxuICAgICAgY291bGRCZVRhcCA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUT0RPOiBMaXN0ZW4gdG8gdGhlIG9yaWdpbmFsIHRhcmdldC4gaHR0cDovL3lvdXR1LmJlL0R1amZwWE9LVXA4P3Q9MTNtOHNcclxuICAgIHRoaXMub24oJ3RvdWNobGVhdmUnLCBub1RhcCk7XHJcbiAgICB0aGlzLm9uKCd0b3VjaGNhbmNlbCcsIG5vVGFwKTtcclxuXHJcbiAgICAvLyBXaGVuIHRoZSB0b3VjaCBlbmRzLCBtZWFzdXJlIGhvdyBsb25nIGl0IHRvb2sgYW5kIHRyaWdnZXIgdGhlIGFwcHJvcHJpYXRlXHJcbiAgICAvLyBldmVudFxyXG4gICAgdGhpcy5vbigndG91Y2hlbmQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgZmlyc3RUb3VjaCA9IG51bGw7XHJcbiAgICAgIC8vIFByb2NlZWQgb25seSBpZiB0aGUgdG91Y2htb3ZlL2xlYXZlL2NhbmNlbCBldmVudCBkaWRuJ3QgaGFwcGVuXHJcbiAgICAgIGlmIChjb3VsZEJlVGFwID09PSB0cnVlKSB7XHJcbiAgICAgICAgLy8gTWVhc3VyZSBob3cgbG9uZyB0aGUgdG91Y2ggbGFzdGVkXHJcbiAgICAgICAgdmFyIHRvdWNoVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdG91Y2hTdGFydDtcclxuXHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSB0b3VjaCB3YXMgbGVzcyB0aGFuIHRoZSB0aHJlc2hvbGQgdG8gYmUgY29uc2lkZXJlZCBhIHRhcFxyXG4gICAgICAgIGlmICh0b3VjaFRpbWUgPCB0b3VjaFRpbWVUaHJlc2hvbGQpIHtcclxuICAgICAgICAgIC8vIERvbid0IGxldCBicm93c2VyIHR1cm4gdGhpcyBpbnRvIGEgY2xpY2tcclxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgYENvbXBvbmVudGAgaXMgdGFwcGVkLlxyXG4gICAgICAgICAgICpcclxuICAgICAgICAgICAqIEBldmVudCBDb21wb25lbnQjdGFwXHJcbiAgICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIHRoaXMudHJpZ2dlcigndGFwJyk7XHJcbiAgICAgICAgICAvLyBJdCBtYXkgYmUgZ29vZCB0byBjb3B5IHRoZSB0b3VjaGVuZCBldmVudCBvYmplY3QgYW5kIGNoYW5nZSB0aGVcclxuICAgICAgICAgIC8vIHR5cGUgdG8gdGFwLCBpZiB0aGUgb3RoZXIgZXZlbnQgcHJvcGVydGllcyBhcmVuJ3QgZXhhY3QgYWZ0ZXJcclxuICAgICAgICAgIC8vIEV2ZW50cy5maXhFdmVudCBydW5zIChlLmcuIGV2ZW50LnRhcmdldClcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gcmVwb3J0cyB1c2VyIGFjdGl2aXR5IHdoZW5ldmVyIHRvdWNoIGV2ZW50cyBoYXBwZW4uIFRoaXMgY2FuIGdldFxyXG4gICAqIHR1cm5lZCBvZmYgYnkgYW55IHN1Yi1jb21wb25lbnRzIHRoYXQgd2FudHMgdG91Y2ggZXZlbnRzIHRvIGFjdCBhbm90aGVyIHdheS5cclxuICAgKlxyXG4gICAqIFJlcG9ydCB1c2VyIHRvdWNoIGFjdGl2aXR5IHdoZW4gdG91Y2ggZXZlbnRzIG9jY3VyLiBVc2VyIGFjdGl2aXR5IGdldHMgdXNlZCB0b1xyXG4gICAqIGRldGVybWluZSB3aGVuIGNvbnRyb2xzIHNob3VsZCBzaG93L2hpZGUuIEl0IGlzIHNpbXBsZSB3aGVuIGl0IGNvbWVzIHRvIG1vdXNlXHJcbiAgICogZXZlbnRzLCBiZWNhdXNlIGFueSBtb3VzZSBldmVudCBzaG91bGQgc2hvdyB0aGUgY29udHJvbHMuIFNvIHdlIGNhcHR1cmUgbW91c2VcclxuICAgKiBldmVudHMgdGhhdCBidWJibGUgdXAgdG8gdGhlIHBsYXllciBhbmQgcmVwb3J0IGFjdGl2aXR5IHdoZW4gdGhhdCBoYXBwZW5zLlxyXG4gICAqIFdpdGggdG91Y2ggZXZlbnRzIGl0IGlzbid0IGFzIGVhc3kgYXMgYHRvdWNoc3RhcnRgIGFuZCBgdG91Y2hlbmRgIHRvZ2dsZSBwbGF5ZXJcclxuICAgKiBjb250cm9scy4gU28gdG91Y2ggZXZlbnRzIGNhbid0IGhlbHAgdXMgYXQgdGhlIHBsYXllciBsZXZlbCBlaXRoZXIuXHJcbiAgICpcclxuICAgKiBVc2VyIGFjdGl2aXR5IGdldHMgY2hlY2tlZCBhc3luY2hyb25vdXNseS4gU28gd2hhdCBjb3VsZCBoYXBwZW4gaXMgYSB0YXAgZXZlbnRcclxuICAgKiBvbiB0aGUgdmlkZW8gdHVybnMgdGhlIGNvbnRyb2xzIG9mZi4gVGhlbiB0aGUgYHRvdWNoZW5kYCBldmVudCBidWJibGVzIHVwIHRvXHJcbiAgICogdGhlIHBsYXllci4gV2hpY2gsIGlmIGl0IHJlcG9ydGVkIHVzZXIgYWN0aXZpdHksIHdvdWxkIHR1cm4gdGhlIGNvbnRyb2xzIHJpZ2h0XHJcbiAgICogYmFjayBvbi4gV2UgYWxzbyBkb24ndCB3YW50IHRvIGNvbXBsZXRlbHkgYmxvY2sgdG91Y2ggZXZlbnRzIGZyb20gYnViYmxpbmcgdXAuXHJcbiAgICogRnVydGhlcm1vcmUgYSBgdG91Y2htb3ZlYCBldmVudCBhbmQgYW55dGhpbmcgb3RoZXIgdGhhbiBhIHRhcCwgc2hvdWxkIG5vdCB0dXJuXHJcbiAgICogY29udHJvbHMgYmFjayBvbi5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaHN0YXJ0XHJcbiAgICogQGxpc3RlbnMgQ29tcG9uZW50I3RvdWNobW92ZVxyXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaGVuZFxyXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCN0b3VjaGNhbmNlbFxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS5lbmFibGVUb3VjaEFjdGl2aXR5ID0gZnVuY3Rpb24gZW5hYmxlVG91Y2hBY3Rpdml0eSgpIHtcclxuICAgIC8vIERvbid0IGNvbnRpbnVlIGlmIHRoZSByb290IHBsYXllciBkb2Vzbid0IHN1cHBvcnQgcmVwb3J0aW5nIHVzZXIgYWN0aXZpdHlcclxuICAgIGlmICghdGhpcy5wbGF5ZXIoKSB8fCAhdGhpcy5wbGF5ZXIoKS5yZXBvcnRVc2VyQWN0aXZpdHkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGxpc3RlbmVyIGZvciByZXBvcnRpbmcgdGhhdCB0aGUgdXNlciBpcyBhY3RpdmVcclxuICAgIHZhciByZXBvcnQgPSBiaW5kKHRoaXMucGxheWVyKCksIHRoaXMucGxheWVyKCkucmVwb3J0VXNlckFjdGl2aXR5KTtcclxuXHJcbiAgICB2YXIgdG91Y2hIb2xkaW5nID0gdm9pZCAwO1xyXG5cclxuICAgIHRoaXMub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJlcG9ydCgpO1xyXG4gICAgICAvLyBGb3IgYXMgbG9uZyBhcyB0aGUgdGhleSBhcmUgdG91Y2hpbmcgdGhlIGRldmljZSBvciBoYXZlIHRoZWlyIG1vdXNlIGRvd24sXHJcbiAgICAgIC8vIHdlIGNvbnNpZGVyIHRoZW0gYWN0aXZlIGV2ZW4gaWYgdGhleSdyZSBub3QgbW92aW5nIHRoZWlyIGZpbmdlciBvciBtb3VzZS5cclxuICAgICAgLy8gU28gd2Ugd2FudCB0byBjb250aW51ZSB0byB1cGRhdGUgdGhhdCB0aGV5IGFyZSBhY3RpdmVcclxuICAgICAgdGhpcy5jbGVhckludGVydmFsKHRvdWNoSG9sZGluZyk7XHJcbiAgICAgIC8vIHJlcG9ydCBhdCB0aGUgc2FtZSBpbnRlcnZhbCBhcyBhY3Rpdml0eUNoZWNrXHJcbiAgICAgIHRvdWNoSG9sZGluZyA9IHRoaXMuc2V0SW50ZXJ2YWwocmVwb3J0LCAyNTApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIHRvdWNoRW5kID0gZnVuY3Rpb24gdG91Y2hFbmQoZXZlbnQpIHtcclxuICAgICAgcmVwb3J0KCk7XHJcbiAgICAgIC8vIHN0b3AgdGhlIGludGVydmFsIHRoYXQgbWFpbnRhaW5zIGFjdGl2aXR5IGlmIHRoZSB0b3VjaCBpcyBob2xkaW5nXHJcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbCh0b3VjaEhvbGRpbmcpO1xyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLm9uKCd0b3VjaG1vdmUnLCByZXBvcnQpO1xyXG4gICAgdGhpcy5vbigndG91Y2hlbmQnLCB0b3VjaEVuZCk7XHJcbiAgICB0aGlzLm9uKCd0b3VjaGNhbmNlbCcsIHRvdWNoRW5kKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBIGNhbGxiYWNrIHRoYXQgaGFzIG5vIHBhcmFtZXRlcnMgYW5kIGlzIGJvdW5kIGludG8gYENvbXBvbmVudGBzIGNvbnRleHQuXHJcbiAgICpcclxuICAgKiBAY2FsbGJhY2sgQ29tcG9uZW50fkdlbmVyaWNDYWxsYmFja1xyXG4gICAqIEB0aGlzIENvbXBvbmVudFxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBydW5zIGFmdGVyIGFuIGB4YCBtaWxsaXNlY29uZCB0aW1lb3V0LiBUaGlzIGZ1bmN0aW9uIGlzIGFcclxuICAgKiB3cmFwcGVyIGFyb3VuZCBgd2luZG93LnNldFRpbWVvdXRgLiBUaGVyZSBhcmUgYSBmZXcgcmVhc29ucyB0byB1c2UgdGhpcyBvbmVcclxuICAgKiBpbnN0ZWFkIHRob3VnaDpcclxuICAgKiAxLiBJdCBnZXRzIGNsZWFyZWQgdmlhICB7QGxpbmsgQ29tcG9uZW50I2NsZWFyVGltZW91dH0gd2hlblxyXG4gICAqICAgIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0gZ2V0cyBjYWxsZWQuXHJcbiAgICogMi4gVGhlIGZ1bmN0aW9uIGNhbGxiYWNrIHdpbGwgZ2V0cyB0dXJuZWQgaW50byBhIHtAbGluayBDb21wb25lbnR+R2VuZXJpY0NhbGxiYWNrfVxyXG4gICAqXHJcbiAgICogPiBOb3RlOiBZb3UgY2FuIHVzZSBgd2luZG93LmNsZWFyVGltZW91dGAgb24gdGhlIGlkIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24uIFRoaXNcclxuICAgKiAgICAgICAgIHdpbGwgY2F1c2UgaXRzIGRpc3Bvc2UgbGlzdGVuZXIgbm90IHRvIGdldCBjbGVhbmVkIHVwISBQbGVhc2UgdXNlXHJcbiAgICogICAgICAgICB7QGxpbmsgQ29tcG9uZW50I2NsZWFyVGltZW91dH0gb3Ige0BsaW5rIENvbXBvbmVudCNkaXNwb3NlfS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50fkdlbmVyaWNDYWxsYmFja30gZm5cclxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBydW4gYWZ0ZXIgYHRpbWVvdXRgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcclxuICAgKiAgICAgICAgVGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgYmVmb3JlIGV4ZWN1dGluZyB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqICAgICAgICAgUmV0dXJucyBhIHRpbWVvdXQgSUQgdGhhdCBnZXRzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHRpbWVvdXQuIEl0IGNhbiBhbHNvXHJcbiAgICogICAgICAgICBnZXQgdXNlZCBpbiB7QGxpbmsgQ29tcG9uZW50I2NsZWFyVGltZW91dH0gdG8gY2xlYXIgdGhlIHRpbWVvdXQgdGhhdFxyXG4gICAqICAgICAgICAgd2FzIHNldC5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCNkaXNwb3NlXHJcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd1RpbWVycy9zZXRUaW1lb3V0fVxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ29tcG9uZW50LnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gc2V0VGltZW91dChmbiwgdGltZW91dCkge1xyXG4gICAgZm4gPSBiaW5kKHRoaXMsIGZuKTtcclxuXHJcbiAgICB2YXIgdGltZW91dElkID0gd2luZG93XzEuc2V0VGltZW91dChmbiwgdGltZW91dCk7XHJcbiAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge1xyXG4gICAgICB0aGlzLmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtdGltZW91dC0nICsgdGltZW91dElkO1xyXG5cclxuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xyXG5cclxuICAgIHJldHVybiB0aW1lb3V0SWQ7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYXJzIGEgdGltZW91dCB0aGF0IGdldHMgY3JlYXRlZCB2aWEgYHdpbmRvdy5zZXRUaW1lb3V0YCBvclxyXG4gICAqIHtAbGluayBDb21wb25lbnQjc2V0VGltZW91dH0uIElmIHlvdSBzZXQgYSB0aW1lb3V0IHZpYSB7QGxpbmsgQ29tcG9uZW50I3NldFRpbWVvdXR9XHJcbiAgICogdXNlIHRoaXMgZnVuY3Rpb24gaW5zdGVhZCBvZiBgd2luZG93LmNsZWFyVGltb3V0YC4gSWYgeW91IGRvbid0IHlvdXIgZGlzcG9zZVxyXG4gICAqIGxpc3RlbmVyIHdpbGwgbm90IGdldCBjbGVhbmVkIHVwIHVudGlsIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0hXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dElkXHJcbiAgICogICAgICAgIFRoZSBpZCBvZiB0aGUgdGltZW91dCB0byBjbGVhci4gVGhlIHJldHVybiB2YWx1ZSBvZlxyXG4gICAqICAgICAgICB7QGxpbmsgQ29tcG9uZW50I3NldFRpbWVvdXR9IG9yIGB3aW5kb3cuc2V0VGltZW91dGAuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICogICAgICAgICBSZXR1cm5zIHRoZSB0aW1lb3V0IGlkIHRoYXQgd2FzIGNsZWFyZWQuXHJcbiAgICpcclxuICAgKiBAc2VlIFtTaW1pbGFyIHRvXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93VGltZXJzL2NsZWFyVGltZW91dH1cclxuICAgKi9cclxuXHJcblxyXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCkge1xyXG4gICAgd2luZG93XzEuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XHJcblxyXG4gICAgdmFyIGRpc3Bvc2VGbiA9IGZ1bmN0aW9uIGRpc3Bvc2VGbigpIHt9O1xyXG5cclxuICAgIGRpc3Bvc2VGbi5ndWlkID0gJ3Zqcy10aW1lb3V0LScgKyB0aW1lb3V0SWQ7XHJcblxyXG4gICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xyXG5cclxuICAgIHJldHVybiB0aW1lb3V0SWQ7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyBydW4gZXZlcnkgYHhgIG1pbGxpc2Vjb25kcy4gVGhpcyBmdW5jdGlvbiBpcyBhIHdyYXBwZXJcclxuICAgKiBhcm91bmQgYHdpbmRvdy5zZXRJbnRlcnZhbGAuIFRoZXJlIGFyZSBhIGZldyByZWFzb25zIHRvIHVzZSB0aGlzIG9uZSBpbnN0ZWFkIHRob3VnaC5cclxuICAgKiAxLiBJdCBnZXRzIGNsZWFyZWQgdmlhICB7QGxpbmsgQ29tcG9uZW50I2NsZWFySW50ZXJ2YWx9IHdoZW5cclxuICAgKiAgICB7QGxpbmsgQ29tcG9uZW50I2Rpc3Bvc2V9IGdldHMgY2FsbGVkLlxyXG4gICAqIDIuIFRoZSBmdW5jdGlvbiBjYWxsYmFjayB3aWxsIGJlIGEge0BsaW5rIENvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9IGZuXHJcbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBydW4gZXZlcnkgYHhgIHNlY29uZHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWxcclxuICAgKiAgICAgICAgRXhlY3V0ZSB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGV2ZXJ5IGB4YCBtaWxsaXNlY29uZHMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICogICAgICAgICBSZXR1cm5zIGFuIGlkIHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGludGVydmFsLiBJdCBjYW4gYWxzbyBiZSBiZSB1c2VkIGluXHJcbiAgICogICAgICAgICB7QGxpbmsgQ29tcG9uZW50I2NsZWFySW50ZXJ2YWx9IHRvIGNsZWFyIHRoZSBpbnRlcnZhbC5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCNkaXNwb3NlXHJcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvd1RpbWVycy9zZXRJbnRlcnZhbH1cclxuICAgKi9cclxuXHJcblxyXG4gIENvbXBvbmVudC5wcm90b3R5cGUuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiBzZXRJbnRlcnZhbChmbiwgaW50ZXJ2YWwpIHtcclxuICAgIGZuID0gYmluZCh0aGlzLCBmbik7XHJcblxyXG4gICAgdmFyIGludGVydmFsSWQgPSB3aW5kb3dfMS5zZXRJbnRlcnZhbChmbiwgaW50ZXJ2YWwpO1xyXG5cclxuICAgIHZhciBkaXNwb3NlRm4gPSBmdW5jdGlvbiBkaXNwb3NlRm4oKSB7XHJcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcclxuICAgIH07XHJcblxyXG4gICAgZGlzcG9zZUZuLmd1aWQgPSAndmpzLWludGVydmFsLScgKyBpbnRlcnZhbElkO1xyXG5cclxuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xyXG5cclxuICAgIHJldHVybiBpbnRlcnZhbElkO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFycyBhbiBpbnRlcnZhbCB0aGF0IGdldHMgY3JlYXRlZCB2aWEgYHdpbmRvdy5zZXRJbnRlcnZhbGAgb3JcclxuICAgKiB7QGxpbmsgQ29tcG9uZW50I3NldEludGVydmFsfS4gSWYgeW91IHNldCBhbiBpbnRldmFsIHZpYSB7QGxpbmsgQ29tcG9uZW50I3NldEludGVydmFsfVxyXG4gICAqIHVzZSB0aGlzIGZ1bmN0aW9uIGluc3RlYWQgb2YgYHdpbmRvdy5jbGVhckludGVydmFsYC4gSWYgeW91IGRvbid0IHlvdXIgZGlzcG9zZVxyXG4gICAqIGxpc3RlbmVyIHdpbGwgbm90IGdldCBjbGVhbmVkIHVwIHVudGlsIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0hXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWxJZFxyXG4gICAqICAgICAgICBUaGUgaWQgb2YgdGhlIGludGVydmFsIHRvIGNsZWFyLiBUaGUgcmV0dXJuIHZhbHVlIG9mXHJcbiAgICogICAgICAgIHtAbGluayBDb21wb25lbnQjc2V0SW50ZXJ2YWx9IG9yIGB3aW5kb3cuc2V0SW50ZXJ2YWxgLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqICAgICAgICAgUmV0dXJucyB0aGUgaW50ZXJ2YWwgaWQgdGhhdCB3YXMgY2xlYXJlZC5cclxuICAgKlxyXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3dUaW1lcnMvY2xlYXJJbnRlcnZhbH1cclxuICAgKi9cclxuXHJcblxyXG4gIENvbXBvbmVudC5wcm90b3R5cGUuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCkge1xyXG4gICAgd2luZG93XzEuY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcclxuXHJcbiAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge307XHJcblxyXG4gICAgZGlzcG9zZUZuLmd1aWQgPSAndmpzLWludGVydmFsLScgKyBpbnRlcnZhbElkO1xyXG5cclxuICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcclxuXHJcbiAgICByZXR1cm4gaW50ZXJ2YWxJZDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBRdWV1ZXMgdXAgYSBjYWxsYmFjayB0byBiZSBwYXNzZWQgdG8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChyQUYpLCBidXRcclxuICAgKiB3aXRoIGEgZmV3IGV4dHJhIGJvbnVzZXM6XHJcbiAgICpcclxuICAgKiAtIFN1cHBvcnRzIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgckFGIGJ5IGZhbGxpbmcgYmFjayB0b1xyXG4gICAqICAge0BsaW5rIENvbXBvbmVudCNzZXRUaW1lb3V0fS5cclxuICAgKlxyXG4gICAqIC0gVGhlIGNhbGxiYWNrIGlzIHR1cm5lZCBpbnRvIGEge0BsaW5rIENvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9IChpLmUuXHJcbiAgICogICBib3VuZCB0byB0aGUgY29tcG9uZW50KS5cclxuICAgKlxyXG4gICAqIC0gQXV0b21hdGljIGNhbmNlbGxhdGlvbiBvZiB0aGUgckFGIGNhbGxiYWNrIGlzIGhhbmRsZWQgaWYgdGhlIGNvbXBvbmVudFxyXG4gICAqICAgaXMgZGlzcG9zZWQgYmVmb3JlIGl0IGlzIGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge0NvbXBvbmVudH5HZW5lcmljQ2FsbGJhY2t9IGZuXHJcbiAgICogICAgICAgICBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBib3VuZCB0byB0aGlzIGNvbXBvbmVudCBhbmQgZXhlY3V0ZWQganVzdFxyXG4gICAqICAgICAgICAgYmVmb3JlIHRoZSBicm93c2VyJ3MgbmV4dCByZXBhaW50LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqICAgICAgICAgUmV0dXJucyBhbiByQUYgSUQgdGhhdCBnZXRzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIHRpbWVvdXQuIEl0IGNhblxyXG4gICAqICAgICAgICAgYWxzbyBiZSB1c2VkIGluIHtAbGluayBDb21wb25lbnQjY2FuY2VsQW5pbWF0aW9uRnJhbWV9IHRvIGNhbmNlbFxyXG4gICAqICAgICAgICAgdGhlIGFuaW1hdGlvbiBmcmFtZSBjYWxsYmFjay5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIENvbXBvbmVudCNkaXNwb3NlXHJcbiAgICogQHNlZSBbU2ltaWxhciB0b117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWV9XHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShmbikge1xyXG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XHJcblxyXG4gICAgaWYgKHRoaXMuc3VwcG9ydHNSYWZfKSB7XHJcbiAgICAgIGZuID0gYmluZCh0aGlzLCBmbik7XHJcblxyXG4gICAgICB2YXIgaWQgPSB3aW5kb3dfMS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xyXG4gICAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge1xyXG4gICAgICAgIHJldHVybiBfdGhpczIuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgZGlzcG9zZUZuLmd1aWQgPSAndmpzLXJhZi0nICsgaWQ7XHJcbiAgICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBkaXNwb3NlRm4pO1xyXG5cclxuICAgICAgcmV0dXJuIGlkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZhbGwgYmFjayB0byB1c2luZyBhIHRpbWVyLlxyXG4gICAgcmV0dXJuIHRoaXMuc2V0VGltZW91dChmbiwgMTAwMCAvIDYwKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDYW5jZWxzIGEgcXVldWVkIGNhbGxiYWNrIHBhc3NlZCB0byB7QGxpbmsgQ29tcG9uZW50I3JlcXVlc3RBbmltYXRpb25GcmFtZX1cclxuICAgKiAockFGKS5cclxuICAgKlxyXG4gICAqIElmIHlvdSBxdWV1ZSBhbiByQUYgY2FsbGJhY2sgdmlhIHtAbGluayBDb21wb25lbnQjcmVxdWVzdEFuaW1hdGlvbkZyYW1lfSxcclxuICAgKiB1c2UgdGhpcyBmdW5jdGlvbiBpbnN0ZWFkIG9mIGB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWVgLiBJZiB5b3UgZG9uJ3QsXHJcbiAgICogeW91ciBkaXNwb3NlIGxpc3RlbmVyIHdpbGwgbm90IGdldCBjbGVhbmVkIHVwIHVudGlsIHtAbGluayBDb21wb25lbnQjZGlzcG9zZX0hXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaWRcclxuICAgKiAgICAgICAgVGhlIHJBRiBJRCB0byBjbGVhci4gVGhlIHJldHVybiB2YWx1ZSBvZiB7QGxpbmsgQ29tcG9uZW50I3JlcXVlc3RBbmltYXRpb25GcmFtZX0uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICogICAgICAgICBSZXR1cm5zIHRoZSByQUYgSUQgdGhhdCB3YXMgY2xlYXJlZC5cclxuICAgKlxyXG4gICAqIEBzZWUgW1NpbWlsYXIgdG9de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS93aW5kb3cvY2FuY2VsQW5pbWF0aW9uRnJhbWV9XHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQucHJvdG90eXBlLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpIHtcclxuICAgIGlmICh0aGlzLnN1cHBvcnRzUmFmXykge1xyXG4gICAgICB3aW5kb3dfMS5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XHJcblxyXG4gICAgICB2YXIgZGlzcG9zZUZuID0gZnVuY3Rpb24gZGlzcG9zZUZuKCkge307XHJcblxyXG4gICAgICBkaXNwb3NlRm4uZ3VpZCA9ICd2anMtcmFmLScgKyBpZDtcclxuXHJcbiAgICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgZGlzcG9zZUZuKTtcclxuXHJcbiAgICAgIHJldHVybiBpZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGYWxsIGJhY2sgdG8gdXNpbmcgYSB0aW1lci5cclxuICAgIHJldHVybiB0aGlzLmNsZWFyVGltZW91dChpZCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVnaXN0ZXIgYSBgQ29tcG9uZW50YCB3aXRoIGB2aWRlb2pzYCBnaXZlbiB0aGUgbmFtZSBhbmQgdGhlIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqID4gTk9URToge0BsaW5rIFRlY2h9cyBzaG91bGQgbm90IGJlIHJlZ2lzdGVyZWQgYXMgYSBgQ29tcG9uZW50YC4ge0BsaW5rIFRlY2h9c1xyXG4gICAqICAgICAgICAgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgdXNpbmcge0BsaW5rIFRlY2gucmVnaXN0ZXJUZWNofSBvclxyXG4gICAqICAgICAgICAge0BsaW5rIHZpZGVvanM6dmlkZW9qcy5yZWdpc3RlclRlY2h9LlxyXG4gICAqXHJcbiAgICogPiBOT1RFOiBUaGlzIGZ1bmN0aW9uIGNhbiBhbHNvIGJlIHNlZW4gb24gdmlkZW9qcyBhc1xyXG4gICAqICAgICAgICAge0BsaW5rIHZpZGVvanM6dmlkZW9qcy5yZWdpc3RlckNvbXBvbmVudH0uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgYENvbXBvbmVudGAgdG8gcmVnaXN0ZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH0gQ29tcG9uZW50VG9SZWdpc3RlclxyXG4gICAqICAgICAgICBUaGUgYENvbXBvbmVudGAgY2xhc3MgdG8gcmVnaXN0ZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XHJcbiAgICogICAgICAgICBUaGUgYENvbXBvbmVudGAgdGhhdCB3YXMgcmVnaXN0ZXJlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIENvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCA9IGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50KG5hbWUsIENvbXBvbmVudFRvUmVnaXN0ZXIpIHtcclxuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgIW5hbWUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNvbXBvbmVudCBuYW1lLCBcIicgKyBuYW1lICsgJ1wiOyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy4nKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgVGVjaCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoJ1RlY2gnKTtcclxuXHJcbiAgICAvLyBXZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGlzIGNoZWNrIGlzIG9ubHkgZG9uZSBpZiBUZWNoIGhhcyBiZWVuIHJlZ2lzdGVyZWQuXHJcbiAgICB2YXIgaXNUZWNoID0gVGVjaCAmJiBUZWNoLmlzVGVjaChDb21wb25lbnRUb1JlZ2lzdGVyKTtcclxuICAgIHZhciBpc0NvbXAgPSBDb21wb25lbnQgPT09IENvbXBvbmVudFRvUmVnaXN0ZXIgfHwgQ29tcG9uZW50LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKENvbXBvbmVudFRvUmVnaXN0ZXIucHJvdG90eXBlKTtcclxuXHJcbiAgICBpZiAoaXNUZWNoIHx8ICFpc0NvbXApIHtcclxuICAgICAgdmFyIHJlYXNvbiA9IHZvaWQgMDtcclxuXHJcbiAgICAgIGlmIChpc1RlY2gpIHtcclxuICAgICAgICByZWFzb24gPSAndGVjaHMgbXVzdCBiZSByZWdpc3RlcmVkIHVzaW5nIFRlY2gucmVnaXN0ZXJUZWNoKCknO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlYXNvbiA9ICdtdXN0IGJlIGEgQ29tcG9uZW50IHN1YmNsYXNzJztcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNvbXBvbmVudCwgXCInICsgbmFtZSArICdcIjsgJyArIHJlYXNvbiArICcuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgbmFtZSA9IHRvVGl0bGVDYXNlKG5hbWUpO1xyXG5cclxuICAgIGlmICghQ29tcG9uZW50LmNvbXBvbmVudHNfKSB7XHJcbiAgICAgIENvbXBvbmVudC5jb21wb25lbnRzXyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBQbGF5ZXIgPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KCdQbGF5ZXInKTtcclxuXHJcbiAgICBpZiAobmFtZSA9PT0gJ1BsYXllcicgJiYgUGxheWVyICYmIFBsYXllci5wbGF5ZXJzKSB7XHJcbiAgICAgIHZhciBwbGF5ZXJzID0gUGxheWVyLnBsYXllcnM7XHJcbiAgICAgIHZhciBwbGF5ZXJOYW1lcyA9IE9iamVjdC5rZXlzKHBsYXllcnMpO1xyXG5cclxuICAgICAgLy8gSWYgd2UgaGF2ZSBwbGF5ZXJzIHRoYXQgd2VyZSBkaXNwb3NlZCwgdGhlbiB0aGVpciBuYW1lIHdpbGwgc3RpbGwgYmVcclxuICAgICAgLy8gaW4gUGxheWVycy5wbGF5ZXJzLiBTbywgd2UgbXVzdCBsb29wIHRocm91Z2ggYW5kIHZlcmlmeSB0aGF0IHRoZSB2YWx1ZVxyXG4gICAgICAvLyBmb3IgZWFjaCBpdGVtIGlzIG5vdCBudWxsLiBUaGlzIGFsbG93cyByZWdpc3RyYXRpb24gb2YgdGhlIFBsYXllciBjb21wb25lbnRcclxuICAgICAgLy8gYWZ0ZXIgYWxsIHBsYXllcnMgaGF2ZSBiZWVuIGRpc3Bvc2VkIG9yIGJlZm9yZSBhbnkgd2VyZSBjcmVhdGVkLlxyXG4gICAgICBpZiAocGxheWVycyAmJiBwbGF5ZXJOYW1lcy5sZW5ndGggPiAwICYmIHBsYXllck5hbWVzLm1hcChmdW5jdGlvbiAocG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gcGxheWVyc1twbmFtZV07XHJcbiAgICAgIH0pLmV2ZXJ5KEJvb2xlYW4pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IHJlZ2lzdGVyIFBsYXllciBjb21wb25lbnQgYWZ0ZXIgcGxheWVyIGhhcyBiZWVuIGNyZWF0ZWQuJyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV0gPSBDb21wb25lbnRUb1JlZ2lzdGVyO1xyXG5cclxuICAgIHJldHVybiBDb21wb25lbnRUb1JlZ2lzdGVyO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhIGBDb21wb25lbnRgIGJhc2VkIG9uIHRoZSBuYW1lIGl0IHdhcyByZWdpc3RlcmVkIHdpdGguXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAqICAgICAgICBUaGUgTmFtZSBvZiB0aGUgY29tcG9uZW50IHRvIGdldC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0NvbXBvbmVudH1cclxuICAgKiAgICAgICAgIFRoZSBgQ29tcG9uZW50YCB0aGF0IGdvdCByZWdpc3RlcmVkIHVuZGVyIHRoZSBnaXZlbiBuYW1lLlxyXG4gICAqXHJcbiAgICogQGRlcHJlY2F0ZWQgSW4gYHZpZGVvanNgIDYgdGhpcyB3aWxsIG5vdCByZXR1cm4gYENvbXBvbmVudGBzIHRoYXQgd2VyZSBub3RcclxuICAgKiAgICAgICAgICAgICByZWdpc3RlcmVkIHVzaW5nIHtAbGluayBDb21wb25lbnQucmVnaXN0ZXJDb21wb25lbnR9LiBDdXJyZW50bHkgd2VcclxuICAgKiAgICAgICAgICAgICBjaGVjayB0aGUgZ2xvYmFsIGB2aWRlb2pzYCBvYmplY3QgZm9yIGEgYENvbXBvbmVudGAgbmFtZSBhbmRcclxuICAgKiAgICAgICAgICAgICByZXR1cm4gdGhhdCBpZiBpdCBleGlzdHMuXHJcbiAgICovXHJcblxyXG5cclxuICBDb21wb25lbnQuZ2V0Q29tcG9uZW50ID0gZnVuY3Rpb24gZ2V0Q29tcG9uZW50KG5hbWUpIHtcclxuICAgIGlmICghbmFtZSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbmFtZSA9IHRvVGl0bGVDYXNlKG5hbWUpO1xyXG5cclxuICAgIGlmIChDb21wb25lbnQuY29tcG9uZW50c18gJiYgQ29tcG9uZW50LmNvbXBvbmVudHNfW25hbWVdKSB7XHJcbiAgICAgIHJldHVybiBDb21wb25lbnQuY29tcG9uZW50c19bbmFtZV07XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIENvbXBvbmVudDtcclxufSgpO1xyXG5cclxuLyoqXHJcbiAqIFdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9uZW50IHN1cHBvcnRzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLlxyXG4gKlxyXG4gKiBUaGlzIGlzIGV4cG9zZWQgcHJpbWFyaWx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAdHlwZSB7Qm9vbGVhbn1cclxuICovXHJcblxyXG5cclxuQ29tcG9uZW50LnByb3RvdHlwZS5zdXBwb3J0c1JhZl8gPSB0eXBlb2Ygd2luZG93XzEucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB3aW5kb3dfMS5jYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJztcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ29tcG9uZW50JywgQ29tcG9uZW50KTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSB0aW1lLXJhbmdlcy5qc1xyXG4gKiBAbW9kdWxlIHRpbWUtcmFuZ2VzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHRpbWUgZm9yIHRoZSBzcGVjaWZpZWQgaW5kZXggYXQgdGhlIHN0YXJ0IG9yIGVuZFxyXG4gKiBvZiBhIFRpbWVSYW5nZSBvYmplY3QuXHJcbiAqXHJcbiAqIEBmdW5jdGlvbiB0aW1lLXJhbmdlczppbmRleEZ1bmN0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MF1cclxuICogICAgICAgIFRoZSByYW5nZSBudW1iZXIgdG8gcmV0dXJuIHRoZSB0aW1lIGZvci5cclxuICpcclxuICogQHJldHVybiB7bnVtYmVyfVxyXG4gKiAgICAgICAgIFRoZSB0aW1lIHRoYXQgb2Zmc2V0IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXHJcbiAqXHJcbiAqIEBkZXByaWNhdGVkIGluZGV4IG11c3QgYmUgc2V0IHRvIGEgdmFsdWUsIGluIHRoZSBmdXR1cmUgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgdGhhdCBjb250YWlucyByYW5nZXMgb2YgdGltZSBmb3IgdmFyaW91cyByZWFzb25zLlxyXG4gKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUaW1lUmFuZ2VcclxuICpcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlbmd0aFxyXG4gKiAgICAgICAgICAgVGhlIG51bWJlciBvZiB0aW1lIHJhbmdlcyByZXByZXNlbnRlZCBieSB0aGlzIE9iamVjdFxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3RpbWUtcmFuZ2VzOmluZGV4RnVuY3Rpb259IHN0YXJ0XHJcbiAqICAgICAgICAgICBSZXR1cm5zIHRoZSB0aW1lIG9mZnNldCBhdCB3aGljaCBhIHNwZWNpZmllZCB0aW1lIHJhbmdlIGJlZ2lucy5cclxuICpcclxuICogQHByb3BlcnR5IHt0aW1lLXJhbmdlczppbmRleEZ1bmN0aW9ufSBlbmRcclxuICogICAgICAgICAgIFJldHVybnMgdGhlIHRpbWUgb2Zmc2V0IGF0IHdoaWNoIGEgc3BlY2lmaWVkIHRpbWUgcmFuZ2UgYmVnaW5zLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UaW1lUmFuZ2VzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGFueSBvZiB0aGUgdGltZSByYW5nZXMgYXJlIG92ZXIgdGhlIG1heGltdW0gaW5kZXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcclxuICogICAgICAgIFRoZSBmdW5jdGlvbiBuYW1lIHRvIHVzZSBmb3IgbG9nZ2luZ1xyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICogICAgICAgIFRoZSBpbmRleCB0byBjaGVja1xyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4SW5kZXhcclxuICogICAgICAgIFRoZSBtYXhpbXVtIHBvc3NpYmxlIGluZGV4XHJcbiAqXHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgdGltZVJhbmdlcyBwcm92aWRlZCBhcmUgb3ZlciB0aGUgbWF4SW5kZXhcclxuICovXHJcbmZ1bmN0aW9uIHJhbmdlQ2hlY2soZm5OYW1lLCBpbmRleCwgbWF4SW5kZXgpIHtcclxuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJyB8fCBpbmRleCA8IDAgfHwgaW5kZXggPiBtYXhJbmRleCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZXhlY3V0ZSBcXCcnICsgZm5OYW1lICsgJ1xcJyBvbiBcXCdUaW1lUmFuZ2VzXFwnOiBUaGUgaW5kZXggcHJvdmlkZWQgKCcgKyBpbmRleCArICcpIGlzIG5vbi1udW1lcmljIG9yIG91dCBvZiBib3VuZHMgKDAtJyArIG1heEluZGV4ICsgJykuJyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYW55IG9mIHRoZSB0aW1lIHJhbmdlcyBhcmUgb3ZlciB0aGUgbWF4aW11bSBpbmRleC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxyXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIG5hbWUgdG8gdXNlIGZvciBsb2dnaW5nXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZUluZGV4XHJcbiAqICAgICAgICBUaGUgcHJvcHJldHkgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBnZXQgdGhlIHRpbWUuIHNob3VsZCBiZSAnc3RhcnQnIG9yICdlbmQnXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHJhbmdlc1xyXG4gKiAgICAgICAgQW4gYXJyYXkgb2YgdGltZSByYW5nZXNcclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gW3JhbmdlSW5kZXg9MF1cclxuICogICAgICAgIFRoZSBpbmRleCB0byBzdGFydCB0aGUgc2VhcmNoIGF0XHJcbiAqXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICogICAgICAgICBUaGUgdGltZSB0aGF0IG9mZnNldCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxyXG4gKlxyXG4gKlxyXG4gKiBAZGVwcmljYXRlZCByYW5nZUluZGV4IG11c3QgYmUgc2V0IHRvIGEgdmFsdWUsIGluIHRoZSBmdXR1cmUgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yLlxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgcmFuZ2VJbmRleCBpcyBtb3JlIHRoYW4gdGhlIGxlbmd0aCBvZiByYW5nZXNcclxuICovXHJcbmZ1bmN0aW9uIGdldFJhbmdlKGZuTmFtZSwgdmFsdWVJbmRleCwgcmFuZ2VzLCByYW5nZUluZGV4KSB7XHJcbiAgcmFuZ2VDaGVjayhmbk5hbWUsIHJhbmdlSW5kZXgsIHJhbmdlcy5sZW5ndGggLSAxKTtcclxuICByZXR1cm4gcmFuZ2VzW3JhbmdlSW5kZXhdW3ZhbHVlSW5kZXhdO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgdGltZSByYW5nZSBvYmplY3QgZ2l2ZW50IHJhbmdlcyBvZiB0aW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBbcmFuZ2VzXVxyXG4gKiAgICAgICAgQW4gYXJyYXkgb2YgdGltZSByYW5nZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVUaW1lUmFuZ2VzT2JqKHJhbmdlcykge1xyXG4gIGlmIChyYW5nZXMgPT09IHVuZGVmaW5lZCB8fCByYW5nZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsZW5ndGg6IDAsXHJcbiAgICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgVGltZVJhbmdlcyBvYmplY3QgaXMgZW1wdHknKTtcclxuICAgICAgfSxcclxuICAgICAgZW5kOiBmdW5jdGlvbiBlbmQoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIFRpbWVSYW5nZXMgb2JqZWN0IGlzIGVtcHR5Jyk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiB7XHJcbiAgICBsZW5ndGg6IHJhbmdlcy5sZW5ndGgsXHJcbiAgICBzdGFydDogZ2V0UmFuZ2UuYmluZChudWxsLCAnc3RhcnQnLCAwLCByYW5nZXMpLFxyXG4gICAgZW5kOiBnZXRSYW5nZS5iaW5kKG51bGwsICdlbmQnLCAxLCByYW5nZXMpXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNob3VsZCBjcmVhdGUgYSBmYWtlIGBUaW1lUmFuZ2VgIG9iamVjdCB3aGljaCBtaW1pY3MgYW4gSFRNTDUgdGltZSByYW5nZSBpbnN0YW5jZS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ8QXJyYXl9IHN0YXJ0XHJcbiAqICAgICAgICBUaGUgc3RhcnQgb2YgYSBzaW5nbGUgcmFuZ2Ugb3IgYW4gYXJyYXkgb2YgcmFuZ2VzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcclxuICogICAgICAgIFRoZSBlbmQgb2YgYSBzaW5nbGUgcmFuZ2UuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVUaW1lUmFuZ2VzKHN0YXJ0LCBlbmQpIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShzdGFydCkpIHtcclxuICAgIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzT2JqKHN0YXJ0KTtcclxuICB9IGVsc2UgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgZW5kID09PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzT2JqKCk7XHJcbiAgfVxyXG4gIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzT2JqKFtbc3RhcnQsIGVuZF1dKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmaWxlIGJ1ZmZlci5qc1xyXG4gKiBAbW9kdWxlIGJ1ZmZlclxyXG4gKi9cclxuLyoqXHJcbiAqIENvbXB1dGUgdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIG1lZGlhIHRoYXQgaGFzIGJlZW4gYnVmZmVyZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7VGltZVJhbmdlfSBidWZmZXJlZFxyXG4gKiAgICAgICAgVGhlIGN1cnJlbnQgYFRpbWVSYW5nZWAgb2JqZWN0IHJlcHJlc2VudGluZyBidWZmZXJlZCB0aW1lIHJhbmdlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25cclxuICogICAgICAgIFRvdGFsIGR1cmF0aW9uIG9mIHRoZSBtZWRpYVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAqICAgICAgICAgUGVyY2VudCBidWZmZXJlZCBvZiB0aGUgdG90YWwgZHVyYXRpb24gaW4gZGVjaW1hbCBmb3JtLlxyXG4gKi9cclxuZnVuY3Rpb24gYnVmZmVyZWRQZXJjZW50KGJ1ZmZlcmVkLCBkdXJhdGlvbikge1xyXG4gIHZhciBidWZmZXJlZER1cmF0aW9uID0gMDtcclxuICB2YXIgc3RhcnQgPSB2b2lkIDA7XHJcbiAgdmFyIGVuZCA9IHZvaWQgMDtcclxuXHJcbiAgaWYgKCFkdXJhdGlvbikge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICBpZiAoIWJ1ZmZlcmVkIHx8ICFidWZmZXJlZC5sZW5ndGgpIHtcclxuICAgIGJ1ZmZlcmVkID0gY3JlYXRlVGltZVJhbmdlcygwLCAwKTtcclxuICB9XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyZWQubGVuZ3RoOyBpKyspIHtcclxuICAgIHN0YXJ0ID0gYnVmZmVyZWQuc3RhcnQoaSk7XHJcbiAgICBlbmQgPSBidWZmZXJlZC5lbmQoaSk7XHJcblxyXG4gICAgLy8gYnVmZmVyZWQgZW5kIGNhbiBiZSBiaWdnZXIgdGhhbiBkdXJhdGlvbiBieSBhIHZlcnkgc21hbGwgZnJhY3Rpb25cclxuICAgIGlmIChlbmQgPiBkdXJhdGlvbikge1xyXG4gICAgICBlbmQgPSBkdXJhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBidWZmZXJlZER1cmF0aW9uICs9IGVuZCAtIHN0YXJ0O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGJ1ZmZlcmVkRHVyYXRpb24gLyBkdXJhdGlvbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmaWxlIGZ1bGxzY3JlZW4tYXBpLmpzXHJcbiAqIEBtb2R1bGUgZnVsbHNjcmVlbi1hcGlcclxuICogQHByaXZhdGVcclxuICovXHJcbi8qKlxyXG4gKiBTdG9yZSB0aGUgYnJvd3Nlci1zcGVjaWZpYyBtZXRob2RzIGZvciB0aGUgZnVsbHNjcmVlbiBBUEkuXHJcbiAqXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqIEBzZWUgW1NwZWNpZmljYXRpb25de0BsaW5rIGh0dHBzOi8vZnVsbHNjcmVlbi5zcGVjLndoYXR3Zy5vcmd9XHJcbiAqIEBzZWUgW01hcCBBcHByb2FjaCBGcm9tIFNjcmVlbmZ1bGwuanNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvc2NyZWVuZnVsbC5qc31cclxuICovXHJcbnZhciBGdWxsc2NyZWVuQXBpID0ge307XHJcblxyXG4vLyBicm93c2VyIEFQSSBtZXRob2RzXHJcbnZhciBhcGlNYXAgPSBbWydyZXF1ZXN0RnVsbHNjcmVlbicsICdleGl0RnVsbHNjcmVlbicsICdmdWxsc2NyZWVuRWxlbWVudCcsICdmdWxsc2NyZWVuRW5hYmxlZCcsICdmdWxsc2NyZWVuY2hhbmdlJywgJ2Z1bGxzY3JlZW5lcnJvciddLFxyXG4vLyBXZWJLaXRcclxuWyd3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbicsICd3ZWJraXRFeGl0RnVsbHNjcmVlbicsICd3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCcsICd3ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCcsICd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgJ3dlYmtpdGZ1bGxzY3JlZW5lcnJvciddLFxyXG4vLyBPbGQgV2ViS2l0IChTYWZhcmkgNS4xKVxyXG5bJ3dlYmtpdFJlcXVlc3RGdWxsU2NyZWVuJywgJ3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLCAnd2Via2l0Q3VycmVudEZ1bGxTY3JlZW5FbGVtZW50JywgJ3dlYmtpdENhbmNlbEZ1bGxTY3JlZW4nLCAnd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsICd3ZWJraXRmdWxsc2NyZWVuZXJyb3InXSxcclxuLy8gTW96aWxsYVxyXG5bJ21velJlcXVlc3RGdWxsU2NyZWVuJywgJ21vekNhbmNlbEZ1bGxTY3JlZW4nLCAnbW96RnVsbFNjcmVlbkVsZW1lbnQnLCAnbW96RnVsbFNjcmVlbkVuYWJsZWQnLCAnbW96ZnVsbHNjcmVlbmNoYW5nZScsICdtb3pmdWxsc2NyZWVuZXJyb3InXSxcclxuLy8gTWljcm9zb2Z0XHJcblsnbXNSZXF1ZXN0RnVsbHNjcmVlbicsICdtc0V4aXRGdWxsc2NyZWVuJywgJ21zRnVsbHNjcmVlbkVsZW1lbnQnLCAnbXNGdWxsc2NyZWVuRW5hYmxlZCcsICdNU0Z1bGxzY3JlZW5DaGFuZ2UnLCAnTVNGdWxsc2NyZWVuRXJyb3InXV07XHJcblxyXG52YXIgc3BlY0FwaSA9IGFwaU1hcFswXTtcclxudmFyIGJyb3dzZXJBcGkgPSB2b2lkIDA7XHJcblxyXG4vLyBkZXRlcm1pbmUgdGhlIHN1cHBvcnRlZCBzZXQgb2YgZnVuY3Rpb25zXHJcbmZvciAodmFyIGkgPSAwOyBpIDwgYXBpTWFwLmxlbmd0aDsgaSsrKSB7XHJcbiAgLy8gY2hlY2sgZm9yIGV4aXRGdWxsc2NyZWVuIGZ1bmN0aW9uXHJcbiAgaWYgKGFwaU1hcFtpXVsxXSBpbiBkb2N1bWVudF8xKSB7XHJcbiAgICBicm93c2VyQXBpID0gYXBpTWFwW2ldO1xyXG4gICAgYnJlYWs7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBtYXAgdGhlIGJyb3dzZXIgQVBJIG5hbWVzIHRvIHRoZSBzcGVjIEFQSSBuYW1lc1xyXG5pZiAoYnJvd3NlckFwaSkge1xyXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBicm93c2VyQXBpLmxlbmd0aDsgX2krKykge1xyXG4gICAgRnVsbHNjcmVlbkFwaVtzcGVjQXBpW19pXV0gPSBicm93c2VyQXBpW19pXTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBtZWRpYS1lcnJvci5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIEEgQ3VzdG9tIGBNZWRpYUVycm9yYCBjbGFzcyB3aGljaCBtaW1pY3MgdGhlIHN0YW5kYXJkIEhUTUw1IGBNZWRpYUVycm9yYCBjbGFzcy5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfE9iamVjdHxNZWRpYUVycm9yfSB2YWx1ZVxyXG4gKiAgICAgICAgVGhpcyBjYW4gYmUgb2YgbXVsdGlwbGUgdHlwZXM6XHJcbiAqICAgICAgICAtIG51bWJlcjogc2hvdWxkIGJlIGEgc3RhbmRhcmQgZXJyb3IgY29kZVxyXG4gKiAgICAgICAgLSBzdHJpbmc6IGFuIGVycm9yIG1lc3NhZ2UgKHRoZSBjb2RlIHdpbGwgYmUgMClcclxuICogICAgICAgIC0gT2JqZWN0OiBhcmJpdHJhcnkgcHJvcGVydGllc1xyXG4gKiAgICAgICAgLSBgTWVkaWFFcnJvcmAgKG5hdGl2ZSk6IHVzZWQgdG8gcG9wdWxhdGUgYSB2aWRlby5qcyBgTWVkaWFFcnJvcmAgb2JqZWN0XHJcbiAqICAgICAgICAtIGBNZWRpYUVycm9yYCAodmlkZW8uanMpOiB3aWxsIHJldHVybiBpdHNlbGYgaWYgaXQncyBhbHJlYWR5IGFcclxuICogICAgICAgICAgdmlkZW8uanMgYE1lZGlhRXJyb3JgIG9iamVjdC5cclxuICpcclxuICogQHNlZSBbTWVkaWFFcnJvciBTcGVjXXtAbGluayBodHRwczovL2Rldi53My5vcmcvaHRtbDUvc3BlYy1hdXRob3Itdmlldy92aWRlby5odG1sI21lZGlhZXJyb3J9XHJcbiAqIEBzZWUgW0VuY3J5cHRlZCBNZWRpYUVycm9yIFNwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELWVuY3J5cHRlZC1tZWRpYS0yMDEzMDUxMC8jZXJyb3ItY29kZXN9XHJcbiAqXHJcbiAqIEBjbGFzcyBNZWRpYUVycm9yXHJcbiAqL1xyXG5mdW5jdGlvbiBNZWRpYUVycm9yKHZhbHVlKSB7XHJcblxyXG4gIC8vIEFsbG93IHJlZHVuZGFudCBjYWxscyB0byB0aGlzIGNvbnN0cnVjdG9yIHRvIGF2b2lkIGhhdmluZyBgaW5zdGFuY2VvZmBcclxuICAvLyBjaGVja3MgcGVwcGVyZWQgYXJvdW5kIHRoZSBjb2RlLlxyXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1lZGlhRXJyb3IpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICB0aGlzLmNvZGUgPSB2YWx1ZTtcclxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgIC8vIGRlZmF1bHQgY29kZSBpcyB6ZXJvLCBzbyB0aGlzIGlzIGEgY3VzdG9tIGVycm9yXHJcbiAgICB0aGlzLm1lc3NhZ2UgPSB2YWx1ZTtcclxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xyXG5cclxuICAgIC8vIFdlIGFzc2lnbiB0aGUgYGNvZGVgIHByb3BlcnR5IG1hbnVhbGx5IGJlY2F1c2UgbmF0aXZlIGBNZWRpYUVycm9yYCBvYmplY3RzXHJcbiAgICAvLyBkbyBub3QgZXhwb3NlIGl0IGFzIGFuIG93bi9lbnVtZXJhYmxlIHByb3BlcnR5IG9mIHRoZSBvYmplY3QuXHJcbiAgICBpZiAodHlwZW9mIHZhbHVlLmNvZGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIHRoaXMuY29kZSA9IHZhbHVlLmNvZGU7XHJcbiAgICB9XHJcblxyXG4gICAgYXNzaWduKHRoaXMsIHZhbHVlKTtcclxuICB9XHJcblxyXG4gIGlmICghdGhpcy5tZXNzYWdlKSB7XHJcbiAgICB0aGlzLm1lc3NhZ2UgPSBNZWRpYUVycm9yLmRlZmF1bHRNZXNzYWdlc1t0aGlzLmNvZGVdIHx8ICcnO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBlcnJvciBjb2RlIHRoYXQgcmVmZXJzIHR3byBvbmUgb2YgdGhlIGRlZmluZWQgYE1lZGlhRXJyb3JgIHR5cGVzXHJcbiAqXHJcbiAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAqL1xyXG5NZWRpYUVycm9yLnByb3RvdHlwZS5jb2RlID0gMDtcclxuXHJcbi8qKlxyXG4gKiBBbiBvcHRpb25hbCBtZXNzYWdlIHRoYXQgdG8gc2hvdyB3aXRoIHRoZSBlcnJvci4gTWVzc2FnZSBpcyBub3QgcGFydCBvZiB0aGUgSFRNTDVcclxuICogdmlkZW8gc3BlYyBidXQgYWxsb3dzIGZvciBtb3JlIGluZm9ybWF0aXZlIGN1c3RvbSBlcnJvcnMuXHJcbiAqXHJcbiAqIEB0eXBlIHtTdHJpbmd9XHJcbiAqL1xyXG5NZWRpYUVycm9yLnByb3RvdHlwZS5tZXNzYWdlID0gJyc7XHJcblxyXG4vKipcclxuICogQW4gb3B0aW9uYWwgc3RhdHVzIGNvZGUgdGhhdCBjYW4gYmUgc2V0IGJ5IHBsdWdpbnMgdG8gYWxsb3cgZXZlbiBtb3JlIGRldGFpbCBhYm91dFxyXG4gKiB0aGUgZXJyb3IuIEZvciBleGFtcGxlIGEgcGx1Z2luIG1pZ2h0IHByb3ZpZGUgYSBzcGVjaWZpYyBIVFRQIHN0YXR1cyBjb2RlIGFuZCBhblxyXG4gKiBlcnJvciBtZXNzYWdlIGZvciB0aGF0IGNvZGUuIFRoZW4gd2hlbiB0aGUgcGx1Z2luIGdldHMgdGhhdCBlcnJvciB0aGlzIGNsYXNzIHdpbGxcclxuICoga25vdyBob3cgdG8gZGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIGZvciBpdC4gVGhpcyBhbGxvd3MgYSBjdXN0b20gbWVzc2FnZSB0byBzaG93XHJcbiAqIHVwIG9uIHRoZSBgUGxheWVyYCBlcnJvciBvdmVybGF5LlxyXG4gKlxyXG4gKiBAdHlwZSB7QXJyYXl9XHJcbiAqL1xyXG5NZWRpYUVycm9yLnByb3RvdHlwZS5zdGF0dXMgPSBudWxsO1xyXG5cclxuLyoqXHJcbiAqIEVycm9ycyBpbmRleGVkIGJ5IHRoZSBXM0Mgc3RhbmRhcmQuIFRoZSBvcmRlciAqKkNBTk5PVCBDSEFOR0UqKiEgU2VlIHRoZVxyXG4gKiBzcGVjaWZpY2F0aW9uIGxpc3RlZCB1bmRlciB7QGxpbmsgTWVkaWFFcnJvcn0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIEBlbnVtIHthcnJheX1cclxuICogQHJlYWRvbmx5XHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAwIC0gTUVESUFfRVJSX0NVU1RPTVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gMSAtIE1FRElBX0VSUl9DVVNUT01cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IDIgLSBNRURJQV9FUlJfQUJPUlRFRFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gMyAtIE1FRElBX0VSUl9ORVRXT1JLXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSA0IC0gTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSA1IC0gTUVESUFfRVJSX0VOQ1JZUFRFRFxyXG4gKi9cclxuTWVkaWFFcnJvci5lcnJvclR5cGVzID0gWydNRURJQV9FUlJfQ1VTVE9NJywgJ01FRElBX0VSUl9BQk9SVEVEJywgJ01FRElBX0VSUl9ORVRXT1JLJywgJ01FRElBX0VSUl9ERUNPREUnLCAnTUVESUFfRVJSX1NSQ19OT1RfU1VQUE9SVEVEJywgJ01FRElBX0VSUl9FTkNSWVBURUQnXTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBgTWVkaWFFcnJvcmAgbWVzc2FnZXMgYmFzZWQgb24gdGhlIHtAbGluayBNZWRpYUVycm9yLmVycm9yVHlwZXN9LlxyXG4gKlxyXG4gKiBAdHlwZSB7QXJyYXl9XHJcbiAqIEBjb25zdGFudFxyXG4gKi9cclxuTWVkaWFFcnJvci5kZWZhdWx0TWVzc2FnZXMgPSB7XHJcbiAgMTogJ1lvdSBhYm9ydGVkIHRoZSBtZWRpYSBwbGF5YmFjaycsXHJcbiAgMjogJ0EgbmV0d29yayBlcnJvciBjYXVzZWQgdGhlIG1lZGlhIGRvd25sb2FkIHRvIGZhaWwgcGFydC13YXkuJyxcclxuICAzOiAnVGhlIG1lZGlhIHBsYXliYWNrIHdhcyBhYm9ydGVkIGR1ZSB0byBhIGNvcnJ1cHRpb24gcHJvYmxlbSBvciBiZWNhdXNlIHRoZSBtZWRpYSB1c2VkIGZlYXR1cmVzIHlvdXIgYnJvd3NlciBkaWQgbm90IHN1cHBvcnQuJyxcclxuICA0OiAnVGhlIG1lZGlhIGNvdWxkIG5vdCBiZSBsb2FkZWQsIGVpdGhlciBiZWNhdXNlIHRoZSBzZXJ2ZXIgb3IgbmV0d29yayBmYWlsZWQgb3IgYmVjYXVzZSB0aGUgZm9ybWF0IGlzIG5vdCBzdXBwb3J0ZWQuJyxcclxuICA1OiAnVGhlIG1lZGlhIGlzIGVuY3J5cHRlZCBhbmQgd2UgZG8gbm90IGhhdmUgdGhlIGtleXMgdG8gZGVjcnlwdCBpdC4nXHJcbn07XHJcblxyXG4vLyBBZGQgdHlwZXMgYXMgcHJvcGVydGllcyBvbiBNZWRpYUVycm9yXHJcbi8vIGUuZy4gTWVkaWFFcnJvci5NRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURUQgPSA0O1xyXG5mb3IgKHZhciBlcnJOdW0gPSAwOyBlcnJOdW0gPCBNZWRpYUVycm9yLmVycm9yVHlwZXMubGVuZ3RoOyBlcnJOdW0rKykge1xyXG4gIE1lZGlhRXJyb3JbTWVkaWFFcnJvci5lcnJvclR5cGVzW2Vyck51bV1dID0gZXJyTnVtO1xyXG4gIC8vIHZhbHVlcyBzaG91bGQgYmUgYWNjZXNzaWJsZSBvbiBib3RoIHRoZSBjbGFzcyBhbmQgaW5zdGFuY2VcclxuICBNZWRpYUVycm9yLnByb3RvdHlwZVtNZWRpYUVycm9yLmVycm9yVHlwZXNbZXJyTnVtXV0gPSBlcnJOdW07XHJcbn1cclxuXHJcbnZhciB0dXBsZSA9IFNhZmVQYXJzZVR1cGxlO1xyXG5cclxuZnVuY3Rpb24gU2FmZVBhcnNlVHVwbGUob2JqLCByZXZpdmVyKSB7XHJcbiAgICB2YXIganNvbjtcclxuICAgIHZhciBlcnJvciA9IG51bGw7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShvYmosIHJldml2ZXIpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgZXJyb3IgPSBlcnI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFtlcnJvciwganNvbl1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBmaWxlIHRleHQtdHJhY2stbGlzdC1jb252ZXJ0ZXIuanMgVXRpbGl0aWVzIGZvciBjYXB0dXJpbmcgdGV4dCB0cmFjayBzdGF0ZSBhbmRcclxuICogcmUtY3JlYXRpbmcgdHJhY2tzIGJhc2VkIG9uIGEgY2FwdHVyZS5cclxuICpcclxuICogQG1vZHVsZSB0ZXh0LXRyYWNrLWxpc3QtY29udmVydGVyXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEV4YW1pbmUgYSBzaW5nbGUge0BsaW5rIFRleHRUcmFja30gYW5kIHJldHVybiBhIEpTT04tY29tcGF0aWJsZSBqYXZhc2NyaXB0IG9iamVjdCB0aGF0XHJcbiAqIHJlcHJlc2VudHMgdGhlIHtAbGluayBUZXh0VHJhY2t9J3Mgc3RhdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xyXG4gKiAgICAgICAgVGhlIHRleHQgdHJhY2sgdG8gcXVlcnkuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogICAgICAgICBBIHNlcmlhbGl6YWJsZSBqYXZhc2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBUZXh0VHJhY2suXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG52YXIgdHJhY2tUb0pzb25fID0gZnVuY3Rpb24gdHJhY2tUb0pzb25fKHRyYWNrKSB7XHJcbiAgdmFyIHJldCA9IFsna2luZCcsICdsYWJlbCcsICdsYW5ndWFnZScsICdpZCcsICdpbkJhbmRNZXRhZGF0YVRyYWNrRGlzcGF0Y2hUeXBlJywgJ21vZGUnLCAnc3JjJ10ucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHByb3AsIGkpIHtcclxuXHJcbiAgICBpZiAodHJhY2tbcHJvcF0pIHtcclxuICAgICAgYWNjW3Byb3BdID0gdHJhY2tbcHJvcF07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFjYztcclxuICB9LCB7XHJcbiAgICBjdWVzOiB0cmFjay5jdWVzICYmIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh0cmFjay5jdWVzLCBmdW5jdGlvbiAoY3VlKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhcnRUaW1lOiBjdWUuc3RhcnRUaW1lLFxyXG4gICAgICAgIGVuZFRpbWU6IGN1ZS5lbmRUaW1lLFxyXG4gICAgICAgIHRleHQ6IGN1ZS50ZXh0LFxyXG4gICAgICAgIGlkOiBjdWUuaWRcclxuICAgICAgfTtcclxuICAgIH0pXHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiByZXQ7XHJcbn07XHJcblxyXG4vKipcclxuICogRXhhbWluZSBhIHtAbGluayBUZWNofSBhbmQgcmV0dXJuIGEgSlNPTi1jb21wYXRpYmxlIGphdmFzY3JpcHQgYXJyYXkgdGhhdCByZXByZXNlbnRzIHRoZVxyXG4gKiBzdGF0ZSBvZiBhbGwge0BsaW5rIFRleHRUcmFja31zIGN1cnJlbnRseSBjb25maWd1cmVkLiBUaGUgcmV0dXJuIGFycmF5IGlzIGNvbXBhdGlibGUgd2l0aFxyXG4gKiB7QGxpbmsgdGV4dC10cmFjay1saXN0LWNvbnZlcnRlcjpqc29uVG9UZXh0VHJhY2tzfS5cclxuICpcclxuICogQHBhcmFtIHtUZWNofSB0ZWNoXHJcbiAqICAgICAgICBUaGUgdGVjaCBvYmplY3QgdG8gcXVlcnlcclxuICpcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqICAgICAgICAgQSBzZXJpYWxpemFibGUgamF2YXNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGUge0BsaW5rIFRlY2h9c1xyXG4gKiAgICAgICAgIHtAbGluayBUZXh0VHJhY2tMaXN0fS5cclxuICovXHJcbnZhciB0ZXh0VHJhY2tzVG9Kc29uID0gZnVuY3Rpb24gdGV4dFRyYWNrc1RvSnNvbih0ZWNoKSB7XHJcblxyXG4gIHZhciB0cmFja0VscyA9IHRlY2guJCQoJ3RyYWNrJyk7XHJcblxyXG4gIHZhciB0cmFja09ianMgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwodHJhY2tFbHMsIGZ1bmN0aW9uICh0KSB7XHJcbiAgICByZXR1cm4gdC50cmFjaztcclxuICB9KTtcclxuICB2YXIgdHJhY2tzID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKHRyYWNrRWxzLCBmdW5jdGlvbiAodHJhY2tFbCkge1xyXG4gICAgdmFyIGpzb24gPSB0cmFja1RvSnNvbl8odHJhY2tFbC50cmFjayk7XHJcblxyXG4gICAgaWYgKHRyYWNrRWwuc3JjKSB7XHJcbiAgICAgIGpzb24uc3JjID0gdHJhY2tFbC5zcmM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ganNvbjtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHRyYWNrcy5jb25jYXQoQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHRlY2gudGV4dFRyYWNrcygpLCBmdW5jdGlvbiAodHJhY2spIHtcclxuICAgIHJldHVybiB0cmFja09ianMuaW5kZXhPZih0cmFjaykgPT09IC0xO1xyXG4gIH0pLm1hcCh0cmFja1RvSnNvbl8pKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBzZXQgb2YgcmVtb3RlIHtAbGluayBUZXh0VHJhY2t9cyBvbiBhIHtAbGluayBUZWNofSBiYXNlZCBvbiBhbiBhcnJheSBvZiBqYXZhc2NyaXB0XHJcbiAqIG9iamVjdCB7QGxpbmsgVGV4dFRyYWNrfSByZXByZXNlbnRhdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGpzb25cclxuICogICAgICAgIEFuIGFycmF5IG9mIGBUZXh0VHJhY2tgIHJlcHJlc2VudGF0aW9uIG9iamVjdHMsIGxpa2UgdGhvc2UgdGhhdCB3b3VsZCBiZVxyXG4gKiAgICAgICAgcHJvZHVjZWQgYnkgYHRleHRUcmFja3NUb0pzb25gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1RlY2h9IHRlY2hcclxuICogICAgICAgIFRoZSBgVGVjaGAgdG8gY3JlYXRlIHRoZSBgVGV4dFRyYWNrYHMgb24uXHJcbiAqL1xyXG52YXIganNvblRvVGV4dFRyYWNrcyA9IGZ1bmN0aW9uIGpzb25Ub1RleHRUcmFja3MoanNvbiwgdGVjaCkge1xyXG4gIGpzb24uZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcclxuICAgIHZhciBhZGRlZFRyYWNrID0gdGVjaC5hZGRSZW1vdGVUZXh0VHJhY2sodHJhY2spLnRyYWNrO1xyXG5cclxuICAgIGlmICghdHJhY2suc3JjICYmIHRyYWNrLmN1ZXMpIHtcclxuICAgICAgdHJhY2suY3Vlcy5mb3JFYWNoKGZ1bmN0aW9uIChjdWUpIHtcclxuICAgICAgICByZXR1cm4gYWRkZWRUcmFjay5hZGRDdWUoY3VlKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiB0ZWNoLnRleHRUcmFja3MoKTtcclxufTtcclxuXHJcbnZhciB0ZXh0VHJhY2tDb252ZXJ0ZXIgPSB7IHRleHRUcmFja3NUb0pzb246IHRleHRUcmFja3NUb0pzb24sIGpzb25Ub1RleHRUcmFja3M6IGpzb25Ub1RleHRUcmFja3MsIHRyYWNrVG9Kc29uXzogdHJhY2tUb0pzb25fIH07XHJcblxyXG4vKipcclxuICogQGZpbGUgbW9kYWwtZGlhbG9nLmpzXHJcbiAqL1xyXG52YXIgTU9EQUxfQ0xBU1NfTkFNRSA9ICd2anMtbW9kYWwtZGlhbG9nJztcclxudmFyIEVTQyA9IDI3O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBgTW9kYWxEaWFsb2dgIGRpc3BsYXlzIG92ZXIgdGhlIHZpZGVvIGFuZCBpdHMgY29udHJvbHMsIHdoaWNoIGJsb2Nrc1xyXG4gKiBpbnRlcmFjdGlvbiB3aXRoIHRoZSBwbGF5ZXIgdW50aWwgaXQgaXMgY2xvc2VkLlxyXG4gKlxyXG4gKiBNb2RhbCBkaWFsb2dzIGluY2x1ZGUgYSBcIkNsb3NlXCIgYnV0dG9uIGFuZCB3aWxsIGNsb3NlIHdoZW4gdGhhdCBidXR0b25cclxuICogaXMgYWN0aXZhdGVkIC0gb3Igd2hlbiBFU0MgaXMgcHJlc3NlZCBhbnl3aGVyZS5cclxuICpcclxuICogQGV4dGVuZHMgQ29tcG9uZW50XHJcbiAqL1xyXG5cclxudmFyIE1vZGFsRGlhbG9nID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcclxuICBpbmhlcml0cyhNb2RhbERpYWxvZywgX0NvbXBvbmVudCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFtvcHRpb25zLmNvbnRlbnQ9dW5kZWZpbmVkXVxyXG4gICAqICAgICAgICBQcm92aWRlIGN1c3RvbWl6ZWQgY29udGVudCBmb3IgdGhpcyBtb2RhbC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kZXNjcmlwdGlvbl1cclxuICAgKiAgICAgICAgQSB0ZXh0IGRlc2NyaXB0aW9uIGZvciB0aGUgbW9kYWwsIHByaW1hcmlseSBmb3IgYWNjZXNzaWJpbGl0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZmlsbEFsd2F5cz1mYWxzZV1cclxuICAgKiAgICAgICAgTm9ybWFsbHksIG1vZGFscyBhcmUgYXV0b21hdGljYWxseSBmaWxsZWQgb25seSB0aGUgZmlyc3QgdGltZVxyXG4gICAqICAgICAgICB0aGV5IG9wZW4uIFRoaXMgdGVsbHMgdGhlIG1vZGFsIHRvIHJlZnJlc2ggaXRzIGNvbnRlbnRcclxuICAgKiAgICAgICAgZXZlcnkgdGltZSBpdCBvcGVucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbF1cclxuICAgKiAgICAgICAgQSB0ZXh0IGxhYmVsIGZvciB0aGUgbW9kYWwsIHByaW1hcmlseSBmb3IgYWNjZXNzaWJpbGl0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGVtcG9yYXJ5PXRydWVdXHJcbiAgICogICAgICAgIElmIGB0cnVlYCwgdGhlIG1vZGFsIGNhbiBvbmx5IGJlIG9wZW5lZCBvbmNlOyBpdCB3aWxsIGJlXHJcbiAgICogICAgICAgIGRpc3Bvc2VkIGFzIHNvb24gYXMgaXQncyBjbG9zZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnVuY2xvc2VhYmxlPWZhbHNlXVxyXG4gICAqICAgICAgICBJZiBgdHJ1ZWAsIHRoZSB1c2VyIHdpbGwgbm90IGJlIGFibGUgdG8gY2xvc2UgdGhlIG1vZGFsXHJcbiAgICogICAgICAgIHRocm91Z2ggdGhlIFVJIGluIHRoZSBub3JtYWwgd2F5cy4gUHJvZ3JhbW1hdGljIGNsb3NpbmcgaXNcclxuICAgKiAgICAgICAgc3RpbGwgcG9zc2libGUuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gTW9kYWxEaWFsb2cocGxheWVyLCBvcHRpb25zKSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RhbERpYWxvZyk7XHJcblxyXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XHJcblxyXG4gICAgX3RoaXMub3BlbmVkXyA9IF90aGlzLmhhc0JlZW5PcGVuZWRfID0gX3RoaXMuaGFzQmVlbkZpbGxlZF8gPSBmYWxzZTtcclxuXHJcbiAgICBfdGhpcy5jbG9zZWFibGUoIV90aGlzLm9wdGlvbnNfLnVuY2xvc2VhYmxlKTtcclxuICAgIF90aGlzLmNvbnRlbnQoX3RoaXMub3B0aW9uc18uY29udGVudCk7XHJcblxyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBjb250ZW50RWwgaXMgZGVmaW5lZCBBRlRFUiBhbnkgY2hpbGRyZW4gYXJlIGluaXRpYWxpemVkXHJcbiAgICAvLyBiZWNhdXNlIHdlIG9ubHkgd2FudCB0aGUgY29udGVudHMgb2YgdGhlIG1vZGFsIGluIHRoZSBjb250ZW50RWxcclxuICAgIC8vIChub3QgdGhlIFVJIGVsZW1lbnRzIGxpa2UgdGhlIGNsb3NlIGJ1dHRvbikuXHJcbiAgICBfdGhpcy5jb250ZW50RWxfID0gY3JlYXRlRWwoJ2RpdicsIHtcclxuICAgICAgY2xhc3NOYW1lOiBNT0RBTF9DTEFTU19OQU1FICsgJy1jb250ZW50J1xyXG4gICAgfSwge1xyXG4gICAgICByb2xlOiAnZG9jdW1lbnQnXHJcbiAgICB9KTtcclxuXHJcbiAgICBfdGhpcy5kZXNjRWxfID0gY3JlYXRlRWwoJ3AnLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogTU9EQUxfQ0xBU1NfTkFNRSArICctZGVzY3JpcHRpb24gdmpzLWNvbnRyb2wtdGV4dCcsXHJcbiAgICAgIGlkOiBfdGhpcy5lbCgpLmdldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpXHJcbiAgICB9KTtcclxuXHJcbiAgICB0ZXh0Q29udGVudChfdGhpcy5kZXNjRWxfLCBfdGhpcy5kZXNjcmlwdGlvbigpKTtcclxuICAgIF90aGlzLmVsXy5hcHBlbmRDaGlsZChfdGhpcy5kZXNjRWxfKTtcclxuICAgIF90aGlzLmVsXy5hcHBlbmRDaGlsZChfdGhpcy5jb250ZW50RWxfKTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgYE1vZGFsRGlhbG9nYCdzIERPTSBlbGVtZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gICAqICAgICAgICAgVGhlIERPTSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XHJcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xyXG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpLFxyXG4gICAgICB0YWJJbmRleDogLTFcclxuICAgIH0sIHtcclxuICAgICAgJ2FyaWEtZGVzY3JpYmVkYnknOiB0aGlzLmlkKCkgKyAnX2Rlc2NyaXB0aW9uJyxcclxuICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnLFxyXG4gICAgICAnYXJpYS1sYWJlbCc6IHRoaXMubGFiZWwoKSxcclxuICAgICAgJ3JvbGUnOiAnZGlhbG9nJ1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxyXG4gICAqL1xyXG5cclxuXHJcbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xyXG4gICAgcmV0dXJuIE1PREFMX0NMQVNTX05BTUUgKyAnIHZqcy1oaWRkZW4gJyArIF9Db21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGVzIGBrZXlkb3duYCBldmVudHMgb24gdGhlIGRvY3VtZW50LCBsb29raW5nIGZvciBFU0MsIHdoaWNoIGNsb3Nlc1xyXG4gICAqIHRoZSBtb2RhbC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGVcclxuICAgKiAgICAgICAgVGhlIGtleXByZXNzIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBrZXlkb3duXHJcbiAgICovXHJcblxyXG5cclxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhlKSB7XHJcbiAgICBpZiAoZS53aGljaCA9PT0gRVNDICYmIHRoaXMuY2xvc2VhYmxlKCkpIHtcclxuICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGxhYmVsIHN0cmluZyBmb3IgdGhpcyBtb2RhbC4gUHJpbWFyaWx5IHVzZWQgZm9yIGFjY2Vzc2liaWxpdHkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICogICAgICAgICB0aGUgbG9jYWxpemVkIG9yIHJhdyBsYWJlbCBvZiB0aGlzIG1vZGFsLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmxhYmVsID0gZnVuY3Rpb24gbGFiZWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb2NhbGl6ZSh0aGlzLm9wdGlvbnNfLmxhYmVsIHx8ICdNb2RhbCBXaW5kb3cnKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBkZXNjcmlwdGlvbiBzdHJpbmcgZm9yIHRoaXMgbW9kYWwuIFByaW1hcmlseSB1c2VkIGZvclxyXG4gICAqIGFjY2Vzc2liaWxpdHkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICogICAgICAgICBUaGUgbG9jYWxpemVkIG9yIHJhdyBkZXNjcmlwdGlvbiBvZiB0aGlzIG1vZGFsLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmRlc2NyaXB0aW9uID0gZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XHJcbiAgICB2YXIgZGVzYyA9IHRoaXMub3B0aW9uc18uZGVzY3JpcHRpb24gfHwgdGhpcy5sb2NhbGl6ZSgnVGhpcyBpcyBhIG1vZGFsIHdpbmRvdy4nKTtcclxuXHJcbiAgICAvLyBBcHBlbmQgYSB1bml2ZXJzYWwgY2xvc2VhYmlsaXR5IG1lc3NhZ2UgaWYgdGhlIG1vZGFsIGlzIGNsb3NlYWJsZS5cclxuICAgIGlmICh0aGlzLmNsb3NlYWJsZSgpKSB7XHJcbiAgICAgIGRlc2MgKz0gJyAnICsgdGhpcy5sb2NhbGl6ZSgnVGhpcyBtb2RhbCBjYW4gYmUgY2xvc2VkIGJ5IHByZXNzaW5nIHRoZSBFc2NhcGUga2V5IG9yIGFjdGl2YXRpbmcgdGhlIGNsb3NlIGJ1dHRvbi4nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGVzYztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBPcGVucyB0aGUgbW9kYWwuXHJcbiAgICpcclxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxvcGVuXHJcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI21vZGFsb3BlblxyXG4gICAqL1xyXG5cclxuXHJcbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiBvcGVuKCkge1xyXG4gICAgaWYgKCF0aGlzLm9wZW5lZF8pIHtcclxuICAgICAgdmFyIHBsYXllciA9IHRoaXMucGxheWVyKCk7XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICAqIEZpcmVkIGp1c3QgYmVmb3JlIGEgYE1vZGFsRGlhbG9nYCBpcyBvcGVuZWQuXHJcbiAgICAgICAgKlxyXG4gICAgICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsb3BlblxyXG4gICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICAgICovXHJcbiAgICAgIHRoaXMudHJpZ2dlcignYmVmb3JlbW9kYWxvcGVuJyk7XHJcbiAgICAgIHRoaXMub3BlbmVkXyA9IHRydWU7XHJcblxyXG4gICAgICAvLyBGaWxsIGNvbnRlbnQgaWYgdGhlIG1vZGFsIGhhcyBuZXZlciBvcGVuZWQgYmVmb3JlIGFuZFxyXG4gICAgICAvLyBuZXZlciBiZWVuIGZpbGxlZC5cclxuICAgICAgaWYgKHRoaXMub3B0aW9uc18uZmlsbEFsd2F5cyB8fCAhdGhpcy5oYXNCZWVuT3BlbmVkXyAmJiAhdGhpcy5oYXNCZWVuRmlsbGVkXykge1xyXG4gICAgICAgIHRoaXMuZmlsbCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB0aGUgcGxheWVyIHdhcyBwbGF5aW5nLCBwYXVzZSBpdCBhbmQgdGFrZSBub3RlIG9mIGl0cyBwcmV2aW91c2x5XHJcbiAgICAgIC8vIHBsYXlpbmcgc3RhdGUuXHJcbiAgICAgIHRoaXMud2FzUGxheWluZ18gPSAhcGxheWVyLnBhdXNlZCgpO1xyXG5cclxuICAgICAgaWYgKHRoaXMub3B0aW9uc18ucGF1c2VPbk9wZW4gJiYgdGhpcy53YXNQbGF5aW5nXykge1xyXG4gICAgICAgIHBsYXllci5wYXVzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5jbG9zZWFibGUoKSkge1xyXG4gICAgICAgIHRoaXMub24odGhpcy5lbF8ub3duZXJEb2N1bWVudCwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcGxheWVyLmNvbnRyb2xzKGZhbHNlKTtcclxuICAgICAgdGhpcy5zaG93KCk7XHJcbiAgICAgIHRoaXMuY29uZGl0aW9uYWxGb2N1c18oKTtcclxuICAgICAgdGhpcy5lbCgpLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgICogRmlyZWQganVzdCBhZnRlciBhIGBNb2RhbERpYWxvZ2AgaXMgb3BlbmVkLlxyXG4gICAgICAgICpcclxuICAgICAgICAqIEBldmVudCBNb2RhbERpYWxvZyNtb2RhbG9wZW5cclxuICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAgICAqL1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ21vZGFsb3BlbicpO1xyXG4gICAgICB0aGlzLmhhc0JlZW5PcGVuZWRfID0gdHJ1ZTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBJZiB0aGUgYE1vZGFsRGlhbG9nYCBpcyBjdXJyZW50bHkgb3BlbiBvciBjbG9zZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbdmFsdWVdXHJcbiAgICogICAgICAgICBJZiBnaXZlbiwgaXQgd2lsbCBvcGVuIChgdHJ1ZWApIG9yIGNsb3NlIChgZmFsc2VgKSB0aGUgbW9kYWwuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqICAgICAgICAgdGhlIGN1cnJlbnQgb3BlbiBzdGF0ZSBvZiB0aGUgbW9kYWxkaWFsb2dcclxuICAgKi9cclxuXHJcblxyXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5vcGVuZWQgPSBmdW5jdGlvbiBvcGVuZWQodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xyXG4gICAgICB0aGlzW3ZhbHVlID8gJ29wZW4nIDogJ2Nsb3NlJ10oKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLm9wZW5lZF87XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xvc2VzIHRoZSBtb2RhbCwgZG9lcyBub3RoaW5nIGlmIHRoZSBgTW9kYWxEaWFsb2dgIGlzXHJcbiAgICogbm90IG9wZW4uXHJcbiAgICpcclxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxjbG9zZVxyXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNtb2RhbGNsb3NlXHJcbiAgICovXHJcblxyXG5cclxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiBjbG9zZSgpIHtcclxuICAgIGlmICghdGhpcy5vcGVuZWRfKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBwbGF5ZXIgPSB0aGlzLnBsYXllcigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICAqIEZpcmVkIGp1c3QgYmVmb3JlIGEgYE1vZGFsRGlhbG9nYCBpcyBjbG9zZWQuXHJcbiAgICAgICpcclxuICAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxjbG9zZVxyXG4gICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAgKi9cclxuICAgIHRoaXMudHJpZ2dlcignYmVmb3JlbW9kYWxjbG9zZScpO1xyXG4gICAgdGhpcy5vcGVuZWRfID0gZmFsc2U7XHJcblxyXG4gICAgaWYgKHRoaXMud2FzUGxheWluZ18gJiYgdGhpcy5vcHRpb25zXy5wYXVzZU9uT3Blbikge1xyXG4gICAgICBwbGF5ZXIucGxheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmNsb3NlYWJsZSgpKSB7XHJcbiAgICAgIHRoaXMub2ZmKHRoaXMuZWxfLm93bmVyRG9jdW1lbnQsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcGxheWVyLmNvbnRyb2xzKHRydWUpO1xyXG4gICAgdGhpcy5oaWRlKCk7XHJcbiAgICB0aGlzLmVsKCkuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICogRmlyZWQganVzdCBhZnRlciBhIGBNb2RhbERpYWxvZ2AgaXMgY2xvc2VkLlxyXG4gICAgICAqXHJcbiAgICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI21vZGFsY2xvc2VcclxuICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAgICAgICovXHJcbiAgICB0aGlzLnRyaWdnZXIoJ21vZGFsY2xvc2UnKTtcclxuICAgIHRoaXMuY29uZGl0aW9uYWxCbHVyXygpO1xyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnNfLnRlbXBvcmFyeSkge1xyXG4gICAgICB0aGlzLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDaGVjayB0byBzZWUgaWYgdGhlIGBNb2RhbERpYWxvZ2AgaXMgY2xvc2VhYmxlIHZpYSB0aGUgVUkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbdmFsdWVdXHJcbiAgICogICAgICAgICBJZiBnaXZlbiBhcyBhIGJvb2xlYW4sIGl0IHdpbGwgc2V0IHRoZSBgY2xvc2VhYmxlYCBvcHRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqICAgICAgICAgUmV0dXJucyB0aGUgZmluYWwgdmFsdWUgb2YgdGhlIGNsb3NhYmxlIG9wdGlvbi5cclxuICAgKi9cclxuXHJcblxyXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jbG9zZWFibGUgPSBmdW5jdGlvbiBjbG9zZWFibGUodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xyXG4gICAgICB2YXIgY2xvc2VhYmxlID0gdGhpcy5jbG9zZWFibGVfID0gISF2YWx1ZTtcclxuICAgICAgdmFyIGNsb3NlID0gdGhpcy5nZXRDaGlsZCgnY2xvc2VCdXR0b24nKTtcclxuXHJcbiAgICAgIC8vIElmIHRoaXMgaXMgYmVpbmcgbWFkZSBjbG9zZWFibGUgYW5kIGhhcyBubyBjbG9zZSBidXR0b24sIGFkZCBvbmUuXHJcbiAgICAgIGlmIChjbG9zZWFibGUgJiYgIWNsb3NlKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSBjbG9zZSBidXR0b24gc2hvdWxkIGJlIGEgY2hpbGQgb2YgdGhlIG1vZGFsIC0gbm90IGl0c1xyXG4gICAgICAgIC8vIGNvbnRlbnQgZWxlbWVudCwgc28gdGVtcG9yYXJpbHkgY2hhbmdlIHRoZSBjb250ZW50IGVsZW1lbnQuXHJcbiAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmNvbnRlbnRFbF87XHJcblxyXG4gICAgICAgIHRoaXMuY29udGVudEVsXyA9IHRoaXMuZWxfO1xyXG4gICAgICAgIGNsb3NlID0gdGhpcy5hZGRDaGlsZCgnY2xvc2VCdXR0b24nLCB7IGNvbnRyb2xUZXh0OiAnQ2xvc2UgTW9kYWwgRGlhbG9nJyB9KTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbF8gPSB0ZW1wO1xyXG4gICAgICAgIHRoaXMub24oY2xvc2UsICdjbG9zZScsIHRoaXMuY2xvc2UpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB0aGlzIGlzIGJlaW5nIG1hZGUgdW5jbG9zZWFibGUgYW5kIGhhcyBhIGNsb3NlIGJ1dHRvbiwgcmVtb3ZlIGl0LlxyXG4gICAgICBpZiAoIWNsb3NlYWJsZSAmJiBjbG9zZSkge1xyXG4gICAgICAgIHRoaXMub2ZmKGNsb3NlLCAnY2xvc2UnLCB0aGlzLmNsb3NlKTtcclxuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGNsb3NlKTtcclxuICAgICAgICBjbG9zZS5kaXNwb3NlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmNsb3NlYWJsZV87XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRmlsbCB0aGUgbW9kYWwncyBjb250ZW50IGVsZW1lbnQgd2l0aCB0aGUgbW9kYWwncyBcImNvbnRlbnRcIiBvcHRpb24uXHJcbiAgICogVGhlIGNvbnRlbnQgZWxlbWVudCB3aWxsIGJlIGVtcHRpZWQgYmVmb3JlIHRoaXMgY2hhbmdlIHRha2VzIHBsYWNlLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsKCkge1xyXG4gICAgdGhpcy5maWxsV2l0aCh0aGlzLmNvbnRlbnQoKSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRmlsbCB0aGUgbW9kYWwncyBjb250ZW50IGVsZW1lbnQgd2l0aCBhcmJpdHJhcnkgY29udGVudC5cclxuICAgKiBUaGUgY29udGVudCBlbGVtZW50IHdpbGwgYmUgZW1wdGllZCBiZWZvcmUgdGhpcyBjaGFuZ2UgdGFrZXMgcGxhY2UuXHJcbiAgICpcclxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxmaWxsXHJcbiAgICogQGZpcmVzIE1vZGFsRGlhbG9nI21vZGFsZmlsbFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtNaXhlZH0gW2NvbnRlbnRdXHJcbiAgICogICAgICAgIFRoZSBzYW1lIHJ1bGVzIGFwcGx5IHRvIHRoaXMgYXMgYXBwbHkgdG8gdGhlIGBjb250ZW50YCBvcHRpb24uXHJcbiAgICovXHJcblxyXG5cclxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuZmlsbFdpdGggPSBmdW5jdGlvbiBmaWxsV2l0aChjb250ZW50KSB7XHJcbiAgICB2YXIgY29udGVudEVsID0gdGhpcy5jb250ZW50RWwoKTtcclxuICAgIHZhciBwYXJlbnRFbCA9IGNvbnRlbnRFbC5wYXJlbnROb2RlO1xyXG4gICAgdmFyIG5leHRTaWJsaW5nRWwgPSBjb250ZW50RWwubmV4dFNpYmxpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCBqdXN0IGJlZm9yZSBhIGBNb2RhbERpYWxvZ2AgaXMgZmlsbGVkIHdpdGggY29udGVudC5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxmaWxsXHJcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudHJpZ2dlcignYmVmb3JlbW9kYWxmaWxsJyk7XHJcbiAgICB0aGlzLmhhc0JlZW5GaWxsZWRfID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBEZXRhY2ggdGhlIGNvbnRlbnQgZWxlbWVudCBmcm9tIHRoZSBET00gYmVmb3JlIHBlcmZvcm1pbmdcclxuICAgIC8vIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBtb2RpZnlpbmcgdGhlIGxpdmUgRE9NIG11bHRpcGxlIHRpbWVzLlxyXG4gICAgcGFyZW50RWwucmVtb3ZlQ2hpbGQoY29udGVudEVsKTtcclxuICAgIHRoaXMuZW1wdHkoKTtcclxuICAgIGluc2VydENvbnRlbnQoY29udGVudEVsLCBjb250ZW50KTtcclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQganVzdCBhZnRlciBhIGBNb2RhbERpYWxvZ2AgaXMgZmlsbGVkIHdpdGggY29udGVudC5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjbW9kYWxmaWxsXHJcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudHJpZ2dlcignbW9kYWxmaWxsJyk7XHJcblxyXG4gICAgLy8gUmUtaW5qZWN0IHRoZSByZS1maWxsZWQgY29udGVudCBlbGVtZW50LlxyXG4gICAgaWYgKG5leHRTaWJsaW5nRWwpIHtcclxuICAgICAgcGFyZW50RWwuaW5zZXJ0QmVmb3JlKGNvbnRlbnRFbCwgbmV4dFNpYmxpbmdFbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChjb250ZW50RWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBjbG9zZSBidXR0b24gaXMgbGFzdCBpbiB0aGUgZGlhbG9nIERPTVxyXG4gICAgdmFyIGNsb3NlQnV0dG9uID0gdGhpcy5nZXRDaGlsZCgnY2xvc2VCdXR0b24nKTtcclxuXHJcbiAgICBpZiAoY2xvc2VCdXR0b24pIHtcclxuICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQoY2xvc2VCdXR0b24uZWxfKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBFbXB0aWVzIHRoZSBjb250ZW50IGVsZW1lbnQuIFRoaXMgaGFwcGVucyBhbnl0aW1lIHRoZSBtb2RhbCBpcyBmaWxsZWQuXHJcbiAgICpcclxuICAgKiBAZmlyZXMgTW9kYWxEaWFsb2cjYmVmb3JlbW9kYWxlbXB0eVxyXG4gICAqIEBmaXJlcyBNb2RhbERpYWxvZyNtb2RhbGVtcHR5XHJcbiAgICovXHJcblxyXG5cclxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiBlbXB0eSgpIHtcclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQganVzdCBiZWZvcmUgYSBgTW9kYWxEaWFsb2dgIGlzIGVtcHRpZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50IE1vZGFsRGlhbG9nI2JlZm9yZW1vZGFsZW1wdHlcclxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy50cmlnZ2VyKCdiZWZvcmVtb2RhbGVtcHR5Jyk7XHJcbiAgICBlbXB0eUVsKHRoaXMuY29udGVudEVsKCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQganVzdCBhZnRlciBhIGBNb2RhbERpYWxvZ2AgaXMgZW1wdGllZC5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnQgTW9kYWxEaWFsb2cjbW9kYWxlbXB0eVxyXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRyaWdnZXIoJ21vZGFsZW1wdHknKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXRzIG9yIHNldHMgdGhlIG1vZGFsIGNvbnRlbnQsIHdoaWNoIGdldHMgbm9ybWFsaXplZCBiZWZvcmUgYmVpbmdcclxuICAgKiByZW5kZXJlZCBpbnRvIHRoZSBET00uXHJcbiAgICpcclxuICAgKiBUaGlzIGRvZXMgbm90IHVwZGF0ZSB0aGUgRE9NIG9yIGZpbGwgdGhlIG1vZGFsLCBidXQgaXQgaXMgY2FsbGVkIGR1cmluZ1xyXG4gICAqIHRoYXQgcHJvY2Vzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge01peGVkfSBbdmFsdWVdXHJcbiAgICogICAgICAgICBJZiBkZWZpbmVkLCBzZXRzIHRoZSBpbnRlcm5hbCBjb250ZW50IHZhbHVlIHRvIGJlIHVzZWQgb24gdGhlXHJcbiAgICogICAgICAgICBuZXh0IGNhbGwocykgdG8gYGZpbGxgLiBUaGlzIHZhbHVlIGlzIG5vcm1hbGl6ZWQgYmVmb3JlIGJlaW5nXHJcbiAgICogICAgICAgICBpbnNlcnRlZC4gVG8gXCJjbGVhclwiIHRoZSBpbnRlcm5hbCBjb250ZW50IHZhbHVlLCBwYXNzIGBudWxsYC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge01peGVkfVxyXG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgY29udGVudCBvZiB0aGUgbW9kYWwgZGlhbG9nXHJcbiAgICovXHJcblxyXG5cclxuICBNb2RhbERpYWxvZy5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHRoaXMuY29udGVudF8gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRfO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIGNvbmRpdGlvbmFsbHkgZm9jdXMgdGhlIG1vZGFsIGRpYWxvZyBpZiBmb2N1cyB3YXMgcHJldmlvdXNseSBvbiB0aGUgcGxheWVyLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jb25kaXRpb25hbEZvY3VzXyA9IGZ1bmN0aW9uIGNvbmRpdGlvbmFsRm9jdXNfKCkge1xyXG4gICAgdmFyIGFjdGl2ZUVsID0gZG9jdW1lbnRfMS5hY3RpdmVFbGVtZW50O1xyXG4gICAgdmFyIHBsYXllckVsID0gdGhpcy5wbGF5ZXJfLmVsXztcclxuXHJcbiAgICB0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8gPSBudWxsO1xyXG5cclxuICAgIGlmIChwbGF5ZXJFbC5jb250YWlucyhhY3RpdmVFbCkgfHwgcGxheWVyRWwgPT09IGFjdGl2ZUVsKSB7XHJcbiAgICAgIHRoaXMucHJldmlvdXNseUFjdGl2ZUVsXyA9IGFjdGl2ZUVsO1xyXG5cclxuICAgICAgdGhpcy5mb2N1cygpO1xyXG5cclxuICAgICAgdGhpcy5vbihkb2N1bWVudF8xLCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogY29uZGl0aW9uYWxseSBibHVyIHRoZSBlbGVtZW50IGFuZCByZWZvY3VzIHRoZSBsYXN0IGZvY3VzZWQgZWxlbWVudFxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5jb25kaXRpb25hbEJsdXJfID0gZnVuY3Rpb24gY29uZGl0aW9uYWxCbHVyXygpIHtcclxuICAgIGlmICh0aGlzLnByZXZpb3VzbHlBY3RpdmVFbF8pIHtcclxuICAgICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfLmZvY3VzKCk7XHJcbiAgICAgIHRoaXMucHJldmlvdXNseUFjdGl2ZUVsXyA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5vZmYoZG9jdW1lbnRfMSwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEtleWRvd24gaGFuZGxlci4gQXR0YWNoZWQgd2hlbiBtb2RhbCBpcyBmb2N1c2VkLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMga2V5ZG93blxyXG4gICAqL1xyXG5cclxuXHJcbiAgTW9kYWxEaWFsb2cucHJvdG90eXBlLmhhbmRsZUtleURvd24gPSBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XHJcbiAgICAvLyBleGl0IGVhcmx5IGlmIGl0IGlzbid0IGEgdGFiIGtleVxyXG4gICAgaWYgKGV2ZW50LndoaWNoICE9PSA5KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZm9jdXNhYmxlRWxzID0gdGhpcy5mb2N1c2FibGVFbHNfKCk7XHJcbiAgICB2YXIgYWN0aXZlRWwgPSB0aGlzLmVsXy5xdWVyeVNlbGVjdG9yKCc6Zm9jdXMnKTtcclxuICAgIHZhciBmb2N1c0luZGV4ID0gdm9pZCAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9jdXNhYmxlRWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChhY3RpdmVFbCA9PT0gZm9jdXNhYmxlRWxzW2ldKSB7XHJcbiAgICAgICAgZm9jdXNJbmRleCA9IGk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoZG9jdW1lbnRfMS5hY3RpdmVFbGVtZW50ID09PSB0aGlzLmVsXykge1xyXG4gICAgICBmb2N1c0luZGV4ID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkgJiYgZm9jdXNJbmRleCA9PT0gMCkge1xyXG4gICAgICBmb2N1c2FibGVFbHNbZm9jdXNhYmxlRWxzLmxlbmd0aCAtIDFdLmZvY3VzKCk7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9IGVsc2UgaWYgKCFldmVudC5zaGlmdEtleSAmJiBmb2N1c0luZGV4ID09PSBmb2N1c2FibGVFbHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICBmb2N1c2FibGVFbHNbMF0uZm9jdXMoKTtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBnZXQgYWxsIGZvY3VzYWJsZSBlbGVtZW50c1xyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIE1vZGFsRGlhbG9nLnByb3RvdHlwZS5mb2N1c2FibGVFbHNfID0gZnVuY3Rpb24gZm9jdXNhYmxlRWxzXygpIHtcclxuICAgIHZhciBhbGxDaGlsZHJlbiA9IHRoaXMuZWxfLnF1ZXJ5U2VsZWN0b3JBbGwoJyonKTtcclxuXHJcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGFsbENoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgcmV0dXJuIChjaGlsZCBpbnN0YW5jZW9mIHdpbmRvd18xLkhUTUxBbmNob3JFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93XzEuSFRNTEFyZWFFbGVtZW50KSAmJiBjaGlsZC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKSB8fCAoY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3dfMS5IVE1MSW5wdXRFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93XzEuSFRNTFNlbGVjdEVsZW1lbnQgfHwgY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3dfMS5IVE1MVGV4dEFyZWFFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93XzEuSFRNTEJ1dHRvbkVsZW1lbnQpICYmICFjaGlsZC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgY2hpbGQgaW5zdGFuY2VvZiB3aW5kb3dfMS5IVE1MSUZyYW1lRWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIHdpbmRvd18xLkhUTUxPYmplY3RFbGVtZW50IHx8IGNoaWxkIGluc3RhbmNlb2Ygd2luZG93XzEuSFRNTEVtYmVkRWxlbWVudCB8fCBjaGlsZC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykgJiYgY2hpbGQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpICE9PSAtMSB8fCBjaGlsZC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIE1vZGFsRGlhbG9nO1xyXG59KENvbXBvbmVudCk7XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBvcHRpb25zIGZvciBgTW9kYWxEaWFsb2dgIGRlZmF1bHQgb3B0aW9ucy5cclxuICpcclxuICogQHR5cGUge09iamVjdH1cclxuICogQHByaXZhdGVcclxuICovXHJcblxyXG5cclxuTW9kYWxEaWFsb2cucHJvdG90eXBlLm9wdGlvbnNfID0ge1xyXG4gIHBhdXNlT25PcGVuOiB0cnVlLFxyXG4gIHRlbXBvcmFyeTogdHJ1ZVxyXG59O1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNb2RhbERpYWxvZycsIE1vZGFsRGlhbG9nKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSB0cmFjay1saXN0LmpzXHJcbiAqL1xyXG4vKipcclxuICogQ29tbW9uIGZ1bmN0aW9uYWxpeSBiZXR3ZWVuIHtAbGluayBUZXh0VHJhY2tMaXN0fSwge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fSwgYW5kXHJcbiAqIHtAbGluayBWaWRlb1RyYWNrTGlzdH1cclxuICpcclxuICogQGV4dGVuZHMgRXZlbnRUYXJnZXRcclxuICovXHJcblxyXG52YXIgVHJhY2tMaXN0ID0gZnVuY3Rpb24gKF9FdmVudFRhcmdldCkge1xyXG4gIGluaGVyaXRzKFRyYWNrTGlzdCwgX0V2ZW50VGFyZ2V0KTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3NcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VHJhY2tbXX0gdHJhY2tzXHJcbiAgICogICAgICAgIEEgbGlzdCBvZiB0cmFja3MgdG8gaW5pdGlhbGl6ZSB0aGUgbGlzdCB3aXRoLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtsaXN0XVxyXG4gICAqICAgICAgICBUaGUgY2hpbGQgb2JqZWN0IHdpdGggaW5oZXJpdGFuY2UgZG9uZSBtYW51YWxseSBmb3IgaWU4LlxyXG4gICAqXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gVHJhY2tMaXN0KCkge1xyXG4gICAgdmFyIHRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XHJcblxyXG4gICAgdmFyIF9yZXQ7XHJcblxyXG4gICAgdmFyIGxpc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFja0xpc3QpO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50VGFyZ2V0LmNhbGwodGhpcykpO1xyXG5cclxuICAgIGlmICghbGlzdCkge1xyXG4gICAgICBsaXN0ID0gX3RoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICAgICAgaWYgKElTX0lFOCkge1xyXG4gICAgICAgIGxpc3QgPSBkb2N1bWVudF8xLmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xyXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gVHJhY2tMaXN0LnByb3RvdHlwZSkge1xyXG4gICAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcclxuICAgICAgICAgICAgbGlzdFtwcm9wXSA9IFRyYWNrTGlzdC5wcm90b3R5cGVbcHJvcF07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGlzdC50cmFja3NfID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyb2YgVHJhY2tMaXN0XHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGxlbmd0aFxyXG4gICAgICogICAgICAgICBUaGUgY3VycmVudCBudW1iZXIgb2YgYFRyYWNrYHMgaW4gdGhlIHRoaXMgVHJhY2tpc3QuXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxpc3QsICdsZW5ndGgnLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrc18ubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBsaXN0LmFkZFRyYWNrKHRyYWNrc1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbXVzdCByZXR1cm4gdGhlIG9iamVjdCwgYXMgZm9yIGllOCBpdCB3aWxsIG5vdCBiZSB0aGlzXHJcbiAgICAvLyBidXQgYSByZWZlcmVuY2UgdG8gYSBkb2N1bWVudCBvYmplY3RcclxuICAgIHJldHVybiBfcmV0ID0gbGlzdCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSB7QGxpbmsgVHJhY2t9IHRvIHRoZSBgVHJhY2tMaXN0YFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUcmFja30gdHJhY2tcclxuICAgKiAgICAgICAgVGhlIGF1ZGlvLCB2aWRlbywgb3IgdGV4dCB0cmFjayB0byBhZGQgdG8gdGhlIGxpc3QuXHJcbiAgICpcclxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I2FkZHRyYWNrXHJcbiAgICovXHJcblxyXG5cclxuICBUcmFja0xpc3QucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2spIHtcclxuICAgIHZhciBpbmRleCA9IHRoaXMudHJhY2tzXy5sZW5ndGg7XHJcblxyXG4gICAgaWYgKCEoJycgKyBpbmRleCBpbiB0aGlzKSkge1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaW5kZXgsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLnRyYWNrc19baW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRG8gbm90IGFkZCBkdXBsaWNhdGUgdHJhY2tzXHJcbiAgICBpZiAodGhpcy50cmFja3NfLmluZGV4T2YodHJhY2spID09PSAtMSkge1xyXG4gICAgICB0aGlzLnRyYWNrc18ucHVzaCh0cmFjayk7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIHRyYWNrIGlzIGFkZGVkIHRvIGEgdHJhY2sgbGlzdC5cclxuICAgICAgICpcclxuICAgICAgICogQGV2ZW50IFRyYWNrTGlzdCNhZGR0cmFja1xyXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7VHJhY2t9IHRyYWNrXHJcbiAgICAgICAqICAgICAgICAgICBBIHJlZmVyZW5jZSB0byB0cmFjayB0aGF0IHdhcyBhZGRlZC5cclxuICAgICAgICovXHJcbiAgICAgIHRoaXMudHJpZ2dlcih7XHJcbiAgICAgICAgdHJhY2s6IHRyYWNrLFxyXG4gICAgICAgIHR5cGU6ICdhZGR0cmFjaydcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGEge0BsaW5rIFRyYWNrfSBmcm9tIHRoZSBgVHJhY2tMaXN0YFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUcmFja30gcnRyYWNrXHJcbiAgICogICAgICAgIFRoZSBhdWRpbywgdmlkZW8sIG9yIHRleHQgdHJhY2sgdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3QuXHJcbiAgICpcclxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I3JlbW92ZXRyYWNrXHJcbiAgICovXHJcblxyXG5cclxuICBUcmFja0xpc3QucHJvdG90eXBlLnJlbW92ZVRyYWNrID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2socnRyYWNrKSB7XHJcbiAgICB2YXIgdHJhY2sgPSB2b2lkIDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICBpZiAodGhpc1tpXSA9PT0gcnRyYWNrKSB7XHJcbiAgICAgICAgdHJhY2sgPSB0aGlzW2ldO1xyXG4gICAgICAgIGlmICh0cmFjay5vZmYpIHtcclxuICAgICAgICAgIHRyYWNrLm9mZigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50cmFja3NfLnNwbGljZShpLCAxKTtcclxuXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRyYWNrKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGEgdHJhY2sgaXMgcmVtb3ZlZCBmcm9tIHRyYWNrIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50IFRyYWNrTGlzdCNyZW1vdmV0cmFja1xyXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICogQHByb3BlcnR5IHtUcmFja30gdHJhY2tcclxuICAgICAqICAgICAgICAgICBBIHJlZmVyZW5jZSB0byB0cmFjayB0aGF0IHdhcyByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnRyaWdnZXIoe1xyXG4gICAgICB0cmFjazogdHJhY2ssXHJcbiAgICAgIHR5cGU6ICdyZW1vdmV0cmFjaydcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhIFRyYWNrIGZyb20gdGhlIFRyYWNrTGlzdCBieSBhIHRyYWNrcyBpZFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gdGhlIGlkIG9mIHRoZSB0cmFjayB0byBnZXRcclxuICAgKiBAbWV0aG9kIGdldFRyYWNrQnlJZFxyXG4gICAqIEByZXR1cm4ge1RyYWNrfVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBUcmFja0xpc3QucHJvdG90eXBlLmdldFRyYWNrQnlJZCA9IGZ1bmN0aW9uIGdldFRyYWNrQnlJZChpZCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICB2YXIgdHJhY2sgPSB0aGlzW2ldO1xyXG5cclxuICAgICAgaWYgKHRyYWNrLmlkID09PSBpZCkge1xyXG4gICAgICAgIHJlc3VsdCA9IHRyYWNrO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9O1xyXG5cclxuICByZXR1cm4gVHJhY2tMaXN0O1xyXG59KEV2ZW50VGFyZ2V0KTtcclxuXHJcbi8qKlxyXG4gKiBUcmlnZ2VyZWQgd2hlbiBhIGRpZmZlcmVudCB0cmFjayBpcyBzZWxlY3RlZC9lbmFibGVkLlxyXG4gKlxyXG4gKiBAZXZlbnQgVHJhY2tMaXN0I2NoYW5nZVxyXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEV2ZW50cyB0aGF0IGNhbiBiZSBjYWxsZWQgd2l0aCBvbiArIGV2ZW50TmFtZS4gU2VlIHtAbGluayBFdmVudEhhbmRsZXJ9LlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gVHJhY2tMaXN0I2FsbG93ZWRFdmVudHNfXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5cclxuXHJcblRyYWNrTGlzdC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7XHJcbiAgY2hhbmdlOiAnY2hhbmdlJyxcclxuICBhZGR0cmFjazogJ2FkZHRyYWNrJyxcclxuICByZW1vdmV0cmFjazogJ3JlbW92ZXRyYWNrJ1xyXG59O1xyXG5cclxuLy8gZW11bGF0ZSBhdHRyaWJ1dGUgRXZlbnRIYW5kbGVyIHN1cHBvcnQgdG8gYWxsb3cgZm9yIGZlYXR1cmUgZGV0ZWN0aW9uXHJcbmZvciAodmFyIGV2ZW50IGluIFRyYWNrTGlzdC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18pIHtcclxuICBUcmFja0xpc3QucHJvdG90eXBlWydvbicgKyBldmVudF0gPSBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogQGZpbGUgYXVkaW8tdHJhY2stbGlzdC5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIEFueXdoZXJlIHdlIGNhbGwgdGhpcyBmdW5jdGlvbiB3ZSBkaXZlcmdlIGZyb20gdGhlIHNwZWNcclxuICogYXMgd2Ugb25seSBzdXBwb3J0IG9uZSBlbmFibGVkIGF1ZGlvdHJhY2sgYXQgYSB0aW1lXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXVkaW9UcmFja0xpc3R9IGxpc3RcclxuICogICAgICAgIGxpc3QgdG8gd29yayBvblxyXG4gKlxyXG4gKiBAcGFyYW0ge0F1ZGlvVHJhY2t9IHRyYWNrXHJcbiAqICAgICAgICBUaGUgdHJhY2sgdG8gc2tpcFxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxudmFyIGRpc2FibGVPdGhlcnMgPSBmdW5jdGlvbiBkaXNhYmxlT3RoZXJzKGxpc3QsIHRyYWNrKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoIU9iamVjdC5rZXlzKGxpc3RbaV0pLmxlbmd0aCB8fCB0cmFjay5pZCA9PT0gbGlzdFtpXS5pZCkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIC8vIGFub3RoZXIgYXVkaW8gdHJhY2sgaXMgZW5hYmxlZCwgZGlzYWJsZSBpdFxyXG4gICAgbGlzdFtpXS5lbmFibGVkID0gZmFsc2U7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBjdXJyZW50IGxpc3Qgb2Yge0BsaW5rIEF1ZGlvVHJhY2t9IGZvciBhIG1lZGlhIGZpbGUuXHJcbiAqXHJcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNhdWRpb3RyYWNrbGlzdH1cclxuICogQGV4dGVuZHMgVHJhY2tMaXN0XHJcbiAqL1xyXG5cclxudmFyIEF1ZGlvVHJhY2tMaXN0ID0gZnVuY3Rpb24gKF9UcmFja0xpc3QpIHtcclxuICBpbmhlcml0cyhBdWRpb1RyYWNrTGlzdCwgX1RyYWNrTGlzdCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBdWRpb1RyYWNrW119IFt0cmFja3M9W11dXHJcbiAgICogICAgICAgIEEgbGlzdCBvZiBgQXVkaW9UcmFja2AgdG8gaW5zdGFudGlhdGUgdGhlIGxpc3Qgd2l0aC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBBdWRpb1RyYWNrTGlzdCgpIHtcclxuICAgIHZhciBfdGhpcywgX3JldDtcclxuXHJcbiAgICB2YXIgdHJhY2tzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEF1ZGlvVHJhY2tMaXN0KTtcclxuXHJcbiAgICB2YXIgbGlzdCA9IHZvaWQgMDtcclxuXHJcbiAgICAvLyBtYWtlIHN1cmUgb25seSAxIHRyYWNrIGlzIGVuYWJsZWRcclxuICAgIC8vIHNvcnRlZCBmcm9tIGxhc3QgaW5kZXggdG8gZmlyc3QgaW5kZXhcclxuICAgIGZvciAodmFyIGkgPSB0cmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgaWYgKHRyYWNrc1tpXS5lbmFibGVkKSB7XHJcbiAgICAgICAgZGlzYWJsZU90aGVycyh0cmFja3MsIHRyYWNrc1tpXSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJRTggZm9yY2VzIHVzIHRvIGltcGxlbWVudCBpbmhlcml0YW5jZSBvdXJzZWx2ZXNcclxuICAgIC8vIGFzIGl0IGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LmRlZmluZVByb3BlcnR5IHByb3Blcmx5XHJcbiAgICBpZiAoSVNfSUU4KSB7XHJcbiAgICAgIGxpc3QgPSBkb2N1bWVudF8xLmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xyXG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRyYWNrTGlzdC5wcm90b3R5cGUpIHtcclxuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICAgICAgbGlzdFtwcm9wXSA9IFRyYWNrTGlzdC5wcm90b3R5cGVbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGZvciAodmFyIF9wcm9wIGluIEF1ZGlvVHJhY2tMaXN0LnByb3RvdHlwZSkge1xyXG4gICAgICAgIGlmIChfcHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICAgICAgbGlzdFtfcHJvcF0gPSBBdWRpb1RyYWNrTGlzdC5wcm90b3R5cGVbX3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxpc3QgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0xpc3QuY2FsbCh0aGlzLCB0cmFja3MsIGxpc3QpKSwgX3RoaXMpO1xyXG4gICAgbGlzdC5jaGFuZ2luZ18gPSBmYWxzZTtcclxuXHJcbiAgICByZXR1cm4gX3JldCA9IGxpc3QsIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGFuIHtAbGluayBBdWRpb1RyYWNrfSB0byB0aGUgYEF1ZGlvVHJhY2tMaXN0YC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXVkaW9UcmFja30gdHJhY2tcclxuICAgKiAgICAgICAgVGhlIEF1ZGlvVHJhY2sgdG8gYWRkIHRvIHRoZSBsaXN0XHJcbiAgICpcclxuICAgKiBAZmlyZXMgVHJhY2tMaXN0I2FkZHRyYWNrXHJcbiAgICovXHJcblxyXG5cclxuICBBdWRpb1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaykge1xyXG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XHJcblxyXG4gICAgaWYgKHRyYWNrLmVuYWJsZWQpIHtcclxuICAgICAgZGlzYWJsZU90aGVycyh0aGlzLCB0cmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgX1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjayk7XHJcbiAgICAvLyBuYXRpdmUgdHJhY2tzIGRvbid0IGhhdmUgdGhpc1xyXG4gICAgaWYgKCF0cmFjay5hZGRFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBsaXN0ZW5zIEF1ZGlvVHJhY2sjZW5hYmxlZGNoYW5nZVxyXG4gICAgICogQGZpcmVzIFRyYWNrTGlzdCNjaGFuZ2VcclxuICAgICAqL1xyXG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5hYmxlZGNoYW5nZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgLy8gd2hlbiB3ZSBhcmUgZGlzYWJsaW5nIG90aGVyIHRyYWNrcyAoc2luY2Ugd2UgZG9uJ3Qgc3VwcG9ydFxyXG4gICAgICAvLyBtb3JlIHRoYW4gb25lIHRyYWNrIGF0IGEgdGltZSkgd2Ugd2lsbCBzZXQgY2hhbmdpbmdfXHJcbiAgICAgIC8vIHRvIHRydWUgc28gdGhhdCB3ZSBkb24ndCB0cmlnZ2VyIGFkZGl0aW9uYWwgY2hhbmdlIGV2ZW50c1xyXG4gICAgICBpZiAoX3RoaXMyLmNoYW5naW5nXykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBfdGhpczIuY2hhbmdpbmdfID0gdHJ1ZTtcclxuICAgICAgZGlzYWJsZU90aGVycyhfdGhpczIsIHRyYWNrKTtcclxuICAgICAgX3RoaXMyLmNoYW5naW5nXyA9IGZhbHNlO1xyXG4gICAgICBfdGhpczIudHJpZ2dlcignY2hhbmdlJyk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gQXVkaW9UcmFja0xpc3Q7XHJcbn0oVHJhY2tMaXN0KTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSB2aWRlby10cmFjay1saXN0LmpzXHJcbiAqL1xyXG4vKipcclxuICogVW4tc2VsZWN0IGFsbCBvdGhlciB7QGxpbmsgVmlkZW9UcmFja31zIHRoYXQgYXJlIHNlbGVjdGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1ZpZGVvVHJhY2tMaXN0fSBsaXN0XHJcbiAqICAgICAgICBsaXN0IHRvIHdvcmsgb25cclxuICpcclxuICogQHBhcmFtIHtWaWRlb1RyYWNrfSB0cmFja1xyXG4gKiAgICAgICAgVGhlIHRyYWNrIHRvIHNraXBcclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbnZhciBkaXNhYmxlT3RoZXJzJDEgPSBmdW5jdGlvbiBkaXNhYmxlT3RoZXJzKGxpc3QsIHRyYWNrKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoIU9iamVjdC5rZXlzKGxpc3RbaV0pLmxlbmd0aCB8fCB0cmFjay5pZCA9PT0gbGlzdFtpXS5pZCkge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIC8vIGFub3RoZXIgdmlkZW8gdHJhY2sgaXMgZW5hYmxlZCwgZGlzYWJsZSBpdFxyXG4gICAgbGlzdFtpXS5zZWxlY3RlZCA9IGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgY3VycmVudCBsaXN0IG9mIHtAbGluayBWaWRlb1RyYWNrfSBmb3IgYSB2aWRlby5cclxuICpcclxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3ZpZGVvdHJhY2tsaXN0fVxyXG4gKiBAZXh0ZW5kcyBUcmFja0xpc3RcclxuICovXHJcblxyXG52YXIgVmlkZW9UcmFja0xpc3QgPSBmdW5jdGlvbiAoX1RyYWNrTGlzdCkge1xyXG4gIGluaGVyaXRzKFZpZGVvVHJhY2tMaXN0LCBfVHJhY2tMaXN0KTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1ZpZGVvVHJhY2tbXX0gW3RyYWNrcz1bXV1cclxuICAgKiAgICAgICAgQSBsaXN0IG9mIGBWaWRlb1RyYWNrYCB0byBpbnN0YW50aWF0ZSB0aGUgbGlzdCB3aXRoLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFZpZGVvVHJhY2tMaXN0KCkge1xyXG4gICAgdmFyIF90aGlzLCBfcmV0O1xyXG5cclxuICAgIHZhciB0cmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlkZW9UcmFja0xpc3QpO1xyXG5cclxuICAgIHZhciBsaXN0ID0gdm9pZCAwO1xyXG5cclxuICAgIC8vIG1ha2Ugc3VyZSBvbmx5IDEgdHJhY2sgaXMgZW5hYmxlZFxyXG4gICAgLy8gc29ydGVkIGZyb20gbGFzdCBpbmRleCB0byBmaXJzdCBpbmRleFxyXG4gICAgZm9yICh2YXIgaSA9IHRyYWNrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICBpZiAodHJhY2tzW2ldLnNlbGVjdGVkKSB7XHJcbiAgICAgICAgZGlzYWJsZU90aGVycyQxKHRyYWNrcywgdHJhY2tzW2ldKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIElFOCBmb3JjZXMgdXMgdG8gaW1wbGVtZW50IGluaGVyaXRhbmNlIG91cnNlbHZlc1xyXG4gICAgLy8gYXMgaXQgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QuZGVmaW5lUHJvcGVydHkgcHJvcGVybHlcclxuICAgIGlmIChJU19JRTgpIHtcclxuICAgICAgbGlzdCA9IGRvY3VtZW50XzEuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XHJcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVHJhY2tMaXN0LnByb3RvdHlwZSkge1xyXG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XHJcbiAgICAgICAgICBsaXN0W3Byb3BdID0gVHJhY2tMaXN0LnByb3RvdHlwZVtwcm9wXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gVmlkZW9UcmFja0xpc3QucHJvdG90eXBlKSB7XHJcbiAgICAgICAgaWYgKF9wcm9wICE9PSAnY29uc3RydWN0b3InKSB7XHJcbiAgICAgICAgICBsaXN0W19wcm9wXSA9IFZpZGVvVHJhY2tMaXN0LnByb3RvdHlwZVtfcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGlzdCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrTGlzdC5jYWxsKHRoaXMsIHRyYWNrcywgbGlzdCkpLCBfdGhpcyk7XHJcbiAgICBsaXN0LmNoYW5naW5nXyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBWaWRlb1RyYWNrTGlzdCNzZWxlY3RlZEluZGV4XHJcbiAgICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBzZWxlY3RlZCB7QGxpbmsgVmlkZW9UcmFja2B9LlxyXG4gICAgICovXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGlzdCwgJ3NlbGVjdGVkSW5kZXgnLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgaWYgKHRoaXNbX2ldLnNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfaTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSgpIHt9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gX3JldCA9IGxpc3QsIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEge0BsaW5rIFZpZGVvVHJhY2t9IHRvIHRoZSBgVmlkZW9UcmFja0xpc3RgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtWaWRlb1RyYWNrfSB0cmFja1xyXG4gICAqICAgICAgICBUaGUgVmlkZW9UcmFjayB0byBhZGQgdG8gdGhlIGxpc3RcclxuICAgKlxyXG4gICAqIEBmaXJlcyBUcmFja0xpc3QjYWRkdHJhY2tcclxuICAgKi9cclxuXHJcblxyXG4gIFZpZGVvVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrKSB7XHJcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuXHJcbiAgICBpZiAodHJhY2suc2VsZWN0ZWQpIHtcclxuICAgICAgZGlzYWJsZU90aGVycyQxKHRoaXMsIHRyYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICBfVHJhY2tMaXN0LnByb3RvdHlwZS5hZGRUcmFjay5jYWxsKHRoaXMsIHRyYWNrKTtcclxuICAgIC8vIG5hdGl2ZSB0cmFja3MgZG9uJ3QgaGF2ZSB0aGlzXHJcbiAgICBpZiAoIXRyYWNrLmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGxpc3RlbnMgVmlkZW9UcmFjayNzZWxlY3RlZGNoYW5nZVxyXG4gICAgICogQGZpcmVzIFRyYWNrTGlzdCNjaGFuZ2VcclxuICAgICAqL1xyXG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0ZWRjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChfdGhpczIuY2hhbmdpbmdfKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIF90aGlzMi5jaGFuZ2luZ18gPSB0cnVlO1xyXG4gICAgICBkaXNhYmxlT3RoZXJzJDEoX3RoaXMyLCB0cmFjayk7XHJcbiAgICAgIF90aGlzMi5jaGFuZ2luZ18gPSBmYWxzZTtcclxuICAgICAgX3RoaXMyLnRyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFZpZGVvVHJhY2tMaXN0O1xyXG59KFRyYWNrTGlzdCk7XHJcblxyXG4vKipcclxuICogQGZpbGUgdGV4dC10cmFjay1saXN0LmpzXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGN1cnJlbnQgbGlzdCBvZiB7QGxpbmsgVGV4dFRyYWNrfSBmb3IgYSBtZWRpYSBmaWxlLlxyXG4gKlxyXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrbGlzdH1cclxuICogQGV4dGVuZHMgVHJhY2tMaXN0XHJcbiAqL1xyXG5cclxudmFyIFRleHRUcmFja0xpc3QgPSBmdW5jdGlvbiAoX1RyYWNrTGlzdCkge1xyXG4gIGluaGVyaXRzKFRleHRUcmFja0xpc3QsIF9UcmFja0xpc3QpO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrW119IFt0cmFja3M9W11dXHJcbiAgICogICAgICAgIEEgbGlzdCBvZiBgVGV4dFRyYWNrYCB0byBpbnN0YW50aWF0ZSB0aGUgbGlzdCB3aXRoLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFRleHRUcmFja0xpc3QoKSB7XHJcbiAgICB2YXIgX3RoaXMsIF9yZXQ7XHJcblxyXG4gICAgdmFyIHRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tMaXN0KTtcclxuXHJcbiAgICB2YXIgbGlzdCA9IHZvaWQgMDtcclxuXHJcbiAgICAvLyBJRTggZm9yY2VzIHVzIHRvIGltcGxlbWVudCBpbmhlcml0YW5jZSBvdXJzZWx2ZXNcclxuICAgIC8vIGFzIGl0IGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LmRlZmluZVByb3BlcnR5IHByb3Blcmx5XHJcbiAgICBpZiAoSVNfSUU4KSB7XHJcbiAgICAgIGxpc3QgPSBkb2N1bWVudF8xLmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xyXG4gICAgICBmb3IgKHZhciBwcm9wIGluIFRyYWNrTGlzdC5wcm90b3R5cGUpIHtcclxuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICAgICAgbGlzdFtwcm9wXSA9IFRyYWNrTGlzdC5wcm90b3R5cGVbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGZvciAodmFyIF9wcm9wIGluIFRleHRUcmFja0xpc3QucHJvdG90eXBlKSB7XHJcbiAgICAgICAgaWYgKF9wcm9wICE9PSAnY29uc3RydWN0b3InKSB7XHJcbiAgICAgICAgICBsaXN0W19wcm9wXSA9IFRleHRUcmFja0xpc3QucHJvdG90eXBlW19wcm9wXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsaXN0ID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhY2tMaXN0LmNhbGwodGhpcywgdHJhY2tzLCBsaXN0KSksIF90aGlzKTtcclxuICAgIHJldHVybiBfcmV0ID0gbGlzdCwgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSB7QGxpbmsgVGV4dFRyYWNrfSB0byB0aGUgYFRleHRUcmFja0xpc3RgXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcclxuICAgKiAgICAgICAgVGhlIHRleHQgdHJhY2sgdG8gYWRkIHRvIHRoZSBsaXN0LlxyXG4gICAqXHJcbiAgICogQGZpcmVzIFRyYWNrTGlzdCNhZGR0cmFja1xyXG4gICAqL1xyXG5cclxuXHJcbiAgVGV4dFRyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaykge1xyXG4gICAgX1RyYWNrTGlzdC5wcm90b3R5cGUuYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjayk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbGlzdGVucyBUZXh0VHJhY2sjbW9kZWNoYW5nZVxyXG4gICAgICogQGZpcmVzIFRyYWNrTGlzdCNjaGFuZ2VcclxuICAgICAqL1xyXG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIGJpbmQodGhpcywgZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgfSkpO1xyXG5cclxuICAgIHZhciBub25MYW5ndWFnZVRleHRUcmFja0tpbmQgPSBbJ21ldGFkYXRhJywgJ2NoYXB0ZXJzJ107XHJcblxyXG4gICAgaWYgKG5vbkxhbmd1YWdlVGV4dFRyYWNrS2luZC5pbmRleE9mKHRyYWNrLmtpbmQpID09PSAtMSkge1xyXG4gICAgICB0cmFjay5hZGRFdmVudExpc3RlbmVyKCdtb2RlY2hhbmdlJywgYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzZWxlY3RlZGxhbmd1YWdlY2hhbmdlJyk7XHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4gVGV4dFRyYWNrTGlzdDtcclxufShUcmFja0xpc3QpO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIGh0bWwtdHJhY2stZWxlbWVudC1saXN0LmpzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFRoZSBjdXJyZW50IGxpc3Qgb2Yge0BsaW5rIEh0bWxUcmFja0VsZW1lbnR9cy5cclxuICovXHJcblxyXG52YXIgSHRtbFRyYWNrRWxlbWVudExpc3QgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIdG1sVHJhY2tFbGVtZW50W119IFt0cmFja3M9W11dXHJcbiAgICogICAgICAgIEEgbGlzdCBvZiBgSHRtbFRyYWNrRWxlbWVudGAgdG8gaW5zdGFudGlhdGUgdGhlIGxpc3Qgd2l0aC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBIdG1sVHJhY2tFbGVtZW50TGlzdCgpIHtcclxuICAgIHZhciB0cmFja0VsZW1lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEh0bWxUcmFja0VsZW1lbnRMaXN0KTtcclxuXHJcbiAgICB2YXIgbGlzdCA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuXHJcbiAgICBpZiAoSVNfSUU4KSB7XHJcbiAgICAgIGxpc3QgPSBkb2N1bWVudF8xLmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xyXG5cclxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBIdG1sVHJhY2tFbGVtZW50TGlzdC5wcm90b3R5cGUpIHtcclxuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICAgICAgbGlzdFtwcm9wXSA9IEh0bWxUcmFja0VsZW1lbnRMaXN0LnByb3RvdHlwZVtwcm9wXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsaXN0LnRyYWNrRWxlbWVudHNfID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyb2YgSHRtbFRyYWNrRWxlbWVudExpc3RcclxuICAgICAqIEBtZW1iZXIge251bWJlcn0gbGVuZ3RoXHJcbiAgICAgKiAgICAgICAgIFRoZSBjdXJyZW50IG51bWJlciBvZiBgVHJhY2tgcyBpbiB0aGUgdGhpcyBUcmFja2lzdC5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGlzdCwgJ2xlbmd0aCcsIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tFbGVtZW50c18ubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdHJhY2tFbGVtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICBsaXN0LmFkZFRyYWNrRWxlbWVudF8odHJhY2tFbGVtZW50c1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKElTX0lFOCkge1xyXG4gICAgICByZXR1cm4gbGlzdDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhbiB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudH0gdG8gdGhlIGBIdG1sVHJhY2tFbGVtZW50TGlzdGBcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SHRtbFRyYWNrRWxlbWVudH0gdHJhY2tFbGVtZW50XHJcbiAgICogICAgICAgIFRoZSB0cmFjayBlbGVtZW50IHRvIGFkZCB0byB0aGUgbGlzdC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBIdG1sVHJhY2tFbGVtZW50TGlzdC5wcm90b3R5cGUuYWRkVHJhY2tFbGVtZW50XyA9IGZ1bmN0aW9uIGFkZFRyYWNrRWxlbWVudF8odHJhY2tFbGVtZW50KSB7XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLnRyYWNrRWxlbWVudHNfLmxlbmd0aDtcclxuXHJcbiAgICBpZiAoISgnJyArIGluZGV4IGluIHRoaXMpKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpbmRleCwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tFbGVtZW50c19baW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRG8gbm90IGFkZCBkdXBsaWNhdGUgZWxlbWVudHNcclxuICAgIGlmICh0aGlzLnRyYWNrRWxlbWVudHNfLmluZGV4T2YodHJhY2tFbGVtZW50KSA9PT0gLTEpIHtcclxuICAgICAgdGhpcy50cmFja0VsZW1lbnRzXy5wdXNoKHRyYWNrRWxlbWVudCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFuIHtAbGluayBIdG1sVHJhY2tFbGVtZW50fSBmcm9tIHRoZSBgSHRtbFRyYWNrRWxlbWVudExpc3RgIGdpdmVuIGFuXHJcbiAgICoge0BsaW5rIFRleHRUcmFja30uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcclxuICAgKiAgICAgICAgVGhlIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCBhIHRyYWNrIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtIdG1sVHJhY2tFbGVtZW50fHVuZGVmaW5lZH1cclxuICAgKiAgICAgICAgIFRoZSB0cmFjayBlbGVtZW50IHRoYXQgd2FzIGZvdW5kIG9yIHVuZGVmaW5lZC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBIdG1sVHJhY2tFbGVtZW50TGlzdC5wcm90b3R5cGUuZ2V0VHJhY2tFbGVtZW50QnlUcmFja18gPSBmdW5jdGlvbiBnZXRUcmFja0VsZW1lbnRCeVRyYWNrXyh0cmFjaykge1xyXG4gICAgdmFyIHRyYWNrRWxlbWVudF8gPSB2b2lkIDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHRoaXMudHJhY2tFbGVtZW50c18ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHRyYWNrID09PSB0aGlzLnRyYWNrRWxlbWVudHNfW2ldLnRyYWNrKSB7XHJcbiAgICAgICAgdHJhY2tFbGVtZW50XyA9IHRoaXMudHJhY2tFbGVtZW50c19baV07XHJcblxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRyYWNrRWxlbWVudF87XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGEge0BsaW5rIEh0bWxUcmFja0VsZW1lbnR9IGZyb20gdGhlIGBIdG1sVHJhY2tFbGVtZW50TGlzdGBcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SHRtbFRyYWNrRWxlbWVudH0gdHJhY2tFbGVtZW50XHJcbiAgICogICAgICAgIFRoZSB0cmFjayBlbGVtZW50IHRvIHJlbW92ZSBmcm9tIHRoZSBsaXN0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIEh0bWxUcmFja0VsZW1lbnRMaXN0LnByb3RvdHlwZS5yZW1vdmVUcmFja0VsZW1lbnRfID0gZnVuY3Rpb24gcmVtb3ZlVHJhY2tFbGVtZW50Xyh0cmFja0VsZW1lbnQpIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSB0aGlzLnRyYWNrRWxlbWVudHNfLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmICh0cmFja0VsZW1lbnQgPT09IHRoaXMudHJhY2tFbGVtZW50c19baV0pIHtcclxuICAgICAgICB0aGlzLnRyYWNrRWxlbWVudHNfLnNwbGljZShpLCAxKTtcclxuXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4gSHRtbFRyYWNrRWxlbWVudExpc3Q7XHJcbn0oKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWN1ZS1saXN0LmpzXHJcbiAqL1xyXG4vKipcclxuICogQHR5cGVkZWYge09iamVjdH0gVGV4dFRyYWNrQ3VlTGlzdH5UZXh0VHJhY2tDdWVcclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkXHJcbiAqICAgICAgICAgICBUaGUgdW5pcXVlIGlkIGZvciB0aGlzIHRleHQgdHJhY2sgY3VlXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGFydFRpbWVcclxuICogICAgICAgICAgIFRoZSBzdGFydCB0aW1lIGZvciB0aGlzIHRleHQgdHJhY2sgY3VlXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbmRUaW1lXHJcbiAqICAgICAgICAgICBUaGUgZW5kIHRpbWUgZm9yIHRoaXMgdGV4dCB0cmFjayBjdWVcclxuICpcclxuICogQHByb3BlcnR5IHtib29sZWFufSBwYXVzZU9uRXhpdFxyXG4gKiAgICAgICAgICAgUGF1c2Ugd2hlbiB0aGUgZW5kIHRpbWUgaXMgcmVhY2hlZCBpZiB0cnVlLlxyXG4gKlxyXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGV4dHRyYWNrY3VlfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIExpc3Qgb2YgVGV4dFRyYWNrQ3Vlcy5cclxuICpcclxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI3RleHR0cmFja2N1ZWxpc3R9XHJcbiAqL1xyXG5cclxudmFyIFRleHRUcmFja0N1ZUxpc3QgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGN1ZXNcclxuICAgKiAgICAgICAgQSBsaXN0IG9mIGN1ZXMgdG8gYmUgaW5pdGlhbGl6ZWQgd2l0aFxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFRleHRUcmFja0N1ZUxpc3QoY3Vlcykge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrQ3VlTGlzdCk7XHJcblxyXG4gICAgdmFyIGxpc3QgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcblxyXG4gICAgaWYgKElTX0lFOCkge1xyXG4gICAgICBsaXN0ID0gZG9jdW1lbnRfMS5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcclxuXHJcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVGV4dFRyYWNrQ3VlTGlzdC5wcm90b3R5cGUpIHtcclxuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICAgICAgbGlzdFtwcm9wXSA9IFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlLnNldEN1ZXNfLmNhbGwobGlzdCwgY3Vlcyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyb2YgVGV4dFRyYWNrQ3VlTGlzdFxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBsZW5ndGhcclxuICAgICAqICAgICAgICAgVGhlIGN1cnJlbnQgbnVtYmVyIG9mIGBUZXh0VHJhY2tDdWVgcyBpbiB0aGUgVGV4dFRyYWNrQ3VlTGlzdC5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGlzdCwgJ2xlbmd0aCcsIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoXztcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKElTX0lFOCkge1xyXG4gICAgICByZXR1cm4gbGlzdDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgc2V0dGVyIGZvciBjdWVzIGluIHRoaXMgbGlzdC4gQ3JlYXRlcyBnZXR0ZXJzXHJcbiAgICogYW4gYW4gaW5kZXggZm9yIHRoZSBjdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheX0gY3Vlc1xyXG4gICAqICAgICAgICBBbiBhcnJheSBvZiBjdWVzIHRvIHNldFxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlLnNldEN1ZXNfID0gZnVuY3Rpb24gc2V0Q3Vlc18oY3Vlcykge1xyXG4gICAgdmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB2YXIgbCA9IGN1ZXMubGVuZ3RoO1xyXG5cclxuICAgIHRoaXMuY3Vlc18gPSBjdWVzO1xyXG4gICAgdGhpcy5sZW5ndGhfID0gY3Vlcy5sZW5ndGg7XHJcblxyXG4gICAgdmFyIGRlZmluZVByb3AgPSBmdW5jdGlvbiBkZWZpbmVQcm9wKGluZGV4KSB7XHJcbiAgICAgIGlmICghKCcnICsgaW5kZXggaW4gdGhpcykpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJycgKyBpbmRleCwge1xyXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1ZXNfW2luZGV4XTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAob2xkTGVuZ3RoIDwgbCkge1xyXG4gICAgICBpID0gb2xkTGVuZ3RoO1xyXG5cclxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBkZWZpbmVQcm9wLmNhbGwodGhpcywgaSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgYSBgVGV4dFRyYWNrQ3VlYCB0aGF0IGlzIGN1cnJlbnRseSBpbiB0aGUgYFRleHRUcmFja0N1ZUxpc3RgIGJ5IGlkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkXHJcbiAgICogICAgICAgIFRoZSBpZCBvZiB0aGUgY3VlIHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkIGZvci5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1RleHRUcmFja0N1ZUxpc3R+VGV4dFRyYWNrQ3VlfG51bGx9XHJcbiAgICogICAgICAgICBBIHNpbmdsZSBjdWUgb3IgbnVsbCBpZiBub25lIHdhcyBmb3VuZC5cclxuICAgKi9cclxuXHJcblxyXG4gIFRleHRUcmFja0N1ZUxpc3QucHJvdG90eXBlLmdldEN1ZUJ5SWQgPSBmdW5jdGlvbiBnZXRDdWVCeUlkKGlkKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHZhciBjdWUgPSB0aGlzW2ldO1xyXG5cclxuICAgICAgaWYgKGN1ZS5pZCA9PT0gaWQpIHtcclxuICAgICAgICByZXN1bHQgPSBjdWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBUZXh0VHJhY2tDdWVMaXN0O1xyXG59KCk7XHJcblxyXG4vKipcclxuICogQGZpbGUgdHJhY2sta2luZHMuanNcclxuICovXHJcblxyXG4vKipcclxuICogQWxsIHBvc3NpYmxlIGBWaWRlb1RyYWNrS2luZGBzXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS12aWRlb3RyYWNrLWtpbmRcclxuICogQHR5cGVkZWYgVmlkZW9UcmFja35LaW5kXHJcbiAqIEBlbnVtXHJcbiAqL1xyXG52YXIgVmlkZW9UcmFja0tpbmQgPSB7XHJcbiAgYWx0ZXJuYXRpdmU6ICdhbHRlcm5hdGl2ZScsXHJcbiAgY2FwdGlvbnM6ICdjYXB0aW9ucycsXHJcbiAgbWFpbjogJ21haW4nLFxyXG4gIHNpZ246ICdzaWduJyxcclxuICBzdWJ0aXRsZXM6ICdzdWJ0aXRsZXMnLFxyXG4gIGNvbW1lbnRhcnk6ICdjb21tZW50YXJ5J1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFsbCBwb3NzaWJsZSBgQXVkaW9UcmFja0tpbmRgc1xyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tYXVkaW90cmFjay1raW5kXHJcbiAqIEB0eXBlZGVmIEF1ZGlvVHJhY2t+S2luZFxyXG4gKiBAZW51bVxyXG4gKi9cclxudmFyIEF1ZGlvVHJhY2tLaW5kID0ge1xyXG4gICdhbHRlcm5hdGl2ZSc6ICdhbHRlcm5hdGl2ZScsXHJcbiAgJ2Rlc2NyaXB0aW9ucyc6ICdkZXNjcmlwdGlvbnMnLFxyXG4gICdtYWluJzogJ21haW4nLFxyXG4gICdtYWluLWRlc2MnOiAnbWFpbi1kZXNjJyxcclxuICAndHJhbnNsYXRpb24nOiAndHJhbnNsYXRpb24nLFxyXG4gICdjb21tZW50YXJ5JzogJ2NvbW1lbnRhcnknXHJcbn07XHJcblxyXG4vKipcclxuICogQWxsIHBvc3NpYmxlIGBUZXh0VHJhY2tLaW5kYHNcclxuICpcclxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjZG9tLXRleHR0cmFjay1raW5kXHJcbiAqIEB0eXBlZGVmIFRleHRUcmFja35LaW5kXHJcbiAqIEBlbnVtXHJcbiAqL1xyXG52YXIgVGV4dFRyYWNrS2luZCA9IHtcclxuICBzdWJ0aXRsZXM6ICdzdWJ0aXRsZXMnLFxyXG4gIGNhcHRpb25zOiAnY2FwdGlvbnMnLFxyXG4gIGRlc2NyaXB0aW9uczogJ2Rlc2NyaXB0aW9ucycsXHJcbiAgY2hhcHRlcnM6ICdjaGFwdGVycycsXHJcbiAgbWV0YWRhdGE6ICdtZXRhZGF0YSdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBbGwgcG9zc2libGUgYFRleHRUcmFja01vZGVgc1xyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2ttb2RlXHJcbiAqIEB0eXBlZGVmIFRleHRUcmFja35Nb2RlXHJcbiAqIEBlbnVtXHJcbiAqL1xyXG52YXIgVGV4dFRyYWNrTW9kZSA9IHtcclxuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcclxuICBoaWRkZW46ICdoaWRkZW4nLFxyXG4gIHNob3dpbmc6ICdzaG93aW5nJ1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIHRyYWNrLmpzXHJcbiAqL1xyXG4vKipcclxuICogQSBUcmFjayBjbGFzcyB0aGF0IGNvbnRhaW5zIGFsbCBvZiB0aGUgY29tbW9uIGZ1bmN0aW9uYWxpdHkgZm9yIHtAbGluayBBdWRpb1RyYWNrfSxcclxuICoge0BsaW5rIFZpZGVvVHJhY2t9LCBhbmQge0BsaW5rIFRleHRUcmFja30uXHJcbiAqXHJcbiAqID4gTm90ZTogVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHlcclxuICpcclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sfVxyXG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxyXG4gKiBAYWJzdHJhY3RcclxuICovXHJcblxyXG52YXIgVHJhY2sgPSBmdW5jdGlvbiAoX0V2ZW50VGFyZ2V0KSB7XHJcbiAgaW5oZXJpdHMoVHJhY2ssIF9FdmVudFRhcmdldCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxyXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5raW5kPScnXVxyXG4gICAqICAgICAgICBBIHZhbGlkIGtpbmQgZm9yIHRoZSB0cmFjayB0eXBlIHlvdSBhcmUgY3JlYXRpbmcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWQ9J3Zqc190cmFja18nICsgR3VpZC5uZXdHVUlEKCldXHJcbiAgICogICAgICAgIEEgdW5pcXVlIGlkIGZvciB0aGlzIEF1ZGlvVHJhY2suXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWw9JyddXHJcbiAgICogICAgICAgIFRoZSBtZW51IGxhYmVsIGZvciB0aGlzIHRyYWNrLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlPScnXVxyXG4gICAqICAgICAgICBBIHZhbGlkIHR3byBjaGFyYWN0ZXIgbGFuZ3VhZ2UgY29kZS5cclxuICAgKlxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFRyYWNrKCkge1xyXG4gICAgdmFyIF9yZXQ7XHJcblxyXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhY2spO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50VGFyZ2V0LmNhbGwodGhpcykpO1xyXG5cclxuICAgIHZhciB0cmFjayA9IF90aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcblxyXG4gICAgaWYgKElTX0lFOCkge1xyXG4gICAgICB0cmFjayA9IGRvY3VtZW50XzEuY3JlYXRlRWxlbWVudCgnY3VzdG9tJyk7XHJcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVHJhY2sucHJvdG90eXBlKSB7XHJcbiAgICAgICAgaWYgKHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcclxuICAgICAgICAgIHRyYWNrW3Byb3BdID0gVHJhY2sucHJvdG90eXBlW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB0cmFja1Byb3BzID0ge1xyXG4gICAgICBpZDogb3B0aW9ucy5pZCB8fCAndmpzX3RyYWNrXycgKyBuZXdHVUlEKCksXHJcbiAgICAgIGtpbmQ6IG9wdGlvbnMua2luZCB8fCAnJyxcclxuICAgICAgbGFiZWw6IG9wdGlvbnMubGFiZWwgfHwgJycsXHJcbiAgICAgIGxhbmd1YWdlOiBvcHRpb25zLmxhbmd1YWdlIHx8ICcnXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlcm9mIFRyYWNrXHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGlkXHJcbiAgICAgKiAgICAgICAgIFRoZSBpZCBvZiB0aGlzIHRyYWNrLiBDYW5ub3QgYmUgY2hhbmdlZCBhZnRlciBjcmVhdGlvbi5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyb2YgVHJhY2tcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ30ga2luZFxyXG4gICAgICogICAgICAgICBUaGUga2luZCBvZiB0cmFjayB0aGF0IHRoaXMgaXMuIENhbm5vdCBiZSBjaGFuZ2VkIGFmdGVyIGNyZWF0aW9uLlxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXJvZiBUcmFja1xyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBsYWJlbFxyXG4gICAgICogICAgICAgICBUaGUgbGFiZWwgb2YgdGhpcyB0cmFjay4gQ2Fubm90IGJlIGNoYW5nZWQgYWZ0ZXIgY3JlYXRpb24uXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlcm9mIFRyYWNrXHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGxhbmd1YWdlXHJcbiAgICAgKiAgICAgICAgIFRoZSB0d28gbGV0dGVyIGxhbmd1YWdlIGNvZGUgZm9yIHRoaXMgdHJhY2suIENhbm5vdCBiZSBjaGFuZ2VkIGFmdGVyXHJcbiAgICAgKiAgICAgICAgIGNyZWF0aW9uLlxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuXHJcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChrZXkpIHtcclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRyYWNrLCBrZXksIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcclxuICAgICAgICAgIHJldHVybiB0cmFja1Byb3BzW2tleV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSgpIHt9XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdHJhY2tQcm9wcykge1xyXG4gICAgICBfbG9vcChrZXkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBfcmV0ID0gdHJhY2ssIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFRyYWNrO1xyXG59KEV2ZW50VGFyZ2V0KTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSB1cmwuanNcclxuICogQG1vZHVsZSB1cmxcclxuICovXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSB1cmw6VVJMT2JqZWN0XHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcm90b2NvbFxyXG4gKiAgICAgICAgICAgVGhlIHByb3RvY29sIG9mIHRoZSB1cmwgdGhhdCB3YXMgcGFyc2VkLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaG9zdG5hbWVcclxuICogICAgICAgICAgIFRoZSBob3N0bmFtZSBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBvcnRcclxuICogICAgICAgICAgIFRoZSBwb3J0IG9mIHRoZSB1cmwgdGhhdCB3YXMgcGFyc2VkLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGF0aG5hbWVcclxuICogICAgICAgICAgIFRoZSBwYXRobmFtZSBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNlYXJjaFxyXG4gKiAgICAgICAgICAgVGhlIHNlYXJjaCBxdWVyeSBvZiB0aGUgdXJsIHRoYXQgd2FzIHBhcnNlZC5cclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhhc2hcclxuICogICAgICAgICAgIFRoZSBoYXNoIG9mIHRoZSB1cmwgdGhhdCB3YXMgcGFyc2VkLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaG9zdFxyXG4gKiAgICAgICAgICAgVGhlIGhvc3Qgb2YgdGhlIHVybCB0aGF0IHdhcyBwYXJzZWQuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlc29sdmUgYW5kIHBhcnNlIHRoZSBlbGVtZW50cyBvZiBhIFVSTC5cclxuICpcclxuICogQHBhcmFtICB7U3RyaW5nfSB1cmxcclxuICogICAgICAgICBUaGUgdXJsIHRvIHBhcnNlXHJcbiAqXHJcbiAqIEByZXR1cm4ge3VybDpVUkxPYmplY3R9XHJcbiAqICAgICAgICAgQW4gb2JqZWN0IG9mIHVybCBkZXRhaWxzXHJcbiAqL1xyXG52YXIgcGFyc2VVcmwgPSBmdW5jdGlvbiBwYXJzZVVybCh1cmwpIHtcclxuICB2YXIgcHJvcHMgPSBbJ3Byb3RvY29sJywgJ2hvc3RuYW1lJywgJ3BvcnQnLCAncGF0aG5hbWUnLCAnc2VhcmNoJywgJ2hhc2gnLCAnaG9zdCddO1xyXG5cclxuICAvLyBhZGQgdGhlIHVybCB0byBhbiBhbmNob3IgYW5kIGxldCB0aGUgYnJvd3NlciBwYXJzZSB0aGUgVVJMXHJcbiAgdmFyIGEgPSBkb2N1bWVudF8xLmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuXHJcbiAgYS5ocmVmID0gdXJsO1xyXG5cclxuICAvLyBJRTggKGFuZCA5PykgRml4XHJcbiAgLy8gaWU4IGRvZXNuJ3QgcGFyc2UgdGhlIFVSTCBjb3JyZWN0bHkgdW50aWwgdGhlIGFuY2hvciBpcyBhY3R1YWxseVxyXG4gIC8vIGFkZGVkIHRvIHRoZSBib2R5LCBhbmQgYW4gaW5uZXJIVE1MIGlzIG5lZWRlZCB0byB0cmlnZ2VyIHRoZSBwYXJzaW5nXHJcbiAgdmFyIGFkZFRvQm9keSA9IGEuaG9zdCA9PT0gJycgJiYgYS5wcm90b2NvbCAhPT0gJ2ZpbGU6JztcclxuICB2YXIgZGl2ID0gdm9pZCAwO1xyXG5cclxuICBpZiAoYWRkVG9Cb2R5KSB7XHJcbiAgICBkaXYgPSBkb2N1bWVudF8xLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgZGl2LmlubmVySFRNTCA9ICc8YSBocmVmPVwiJyArIHVybCArICdcIj48L2E+JztcclxuICAgIGEgPSBkaXYuZmlyc3RDaGlsZDtcclxuICAgIC8vIHByZXZlbnQgdGhlIGRpdiBmcm9tIGFmZmVjdGluZyBsYXlvdXRcclxuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6bm9uZTsgcG9zaXRpb246YWJzb2x1dGU7Jyk7XHJcbiAgICBkb2N1bWVudF8xLmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcclxuICB9XHJcblxyXG4gIC8vIENvcHkgdGhlIHNwZWNpZmljIFVSTCBwcm9wZXJ0aWVzIHRvIGEgbmV3IG9iamVjdFxyXG4gIC8vIFRoaXMgaXMgYWxzbyBuZWVkZWQgZm9yIElFOCBiZWNhdXNlIHRoZSBhbmNob3IgbG9zZXMgaXRzXHJcbiAgLy8gcHJvcGVydGllcyB3aGVuIGl0J3MgcmVtb3ZlZCBmcm9tIHRoZSBkb21cclxuICB2YXIgZGV0YWlscyA9IHt9O1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBkZXRhaWxzW3Byb3BzW2ldXSA9IGFbcHJvcHNbaV1dO1xyXG4gIH1cclxuXHJcbiAgLy8gSUU5IGFkZHMgdGhlIHBvcnQgdG8gdGhlIGhvc3QgcHJvcGVydHkgdW5saWtlIGV2ZXJ5b25lIGVsc2UuIElmXHJcbiAgLy8gYSBwb3J0IGlkZW50aWZpZXIgaXMgYWRkZWQgZm9yIHN0YW5kYXJkIHBvcnRzLCBzdHJpcCBpdC5cclxuICBpZiAoZGV0YWlscy5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xyXG4gICAgZGV0YWlscy5ob3N0ID0gZGV0YWlscy5ob3N0LnJlcGxhY2UoLzo4MCQvLCAnJyk7XHJcbiAgfVxyXG5cclxuICBpZiAoZGV0YWlscy5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcclxuICAgIGRldGFpbHMuaG9zdCA9IGRldGFpbHMuaG9zdC5yZXBsYWNlKC86NDQzJC8sICcnKTtcclxuICB9XHJcblxyXG4gIGlmIChhZGRUb0JvZHkpIHtcclxuICAgIGRvY3VtZW50XzEuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRldGFpbHM7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IGFic29sdXRlIHZlcnNpb24gb2YgcmVsYXRpdmUgVVJMLiBVc2VkIHRvIHRlbGwgZmxhc2ggY29ycmVjdCBVUkwuXHJcbiAqXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gdXJsXHJcbiAqICAgICAgICAgVVJMIHRvIG1ha2UgYWJzb2x1dGVcclxuICpcclxuICogQHJldHVybiB7c3RyaW5nfVxyXG4gKiAgICAgICAgIEFic29sdXRlIFVSTFxyXG4gKlxyXG4gKiBAc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDcwODMyL2dldHRpbmctYW4tYWJzb2x1dGUtdXJsLWZyb20tYS1yZWxhdGl2ZS1vbmUtaWU2LWlzc3VlXHJcbiAqL1xyXG52YXIgZ2V0QWJzb2x1dGVVUkwgPSBmdW5jdGlvbiBnZXRBYnNvbHV0ZVVSTCh1cmwpIHtcclxuICAvLyBDaGVjayBpZiBhYnNvbHV0ZSBVUkxcclxuICBpZiAoIXVybC5tYXRjaCgvXmh0dHBzPzpcXC9cXC8vKSkge1xyXG4gICAgLy8gQ29udmVydCB0byBhYnNvbHV0ZSBVUkwuIEZsYXNoIGhvc3RlZCBvZmYtc2l0ZSBuZWVkcyBhbiBhYnNvbHV0ZSBVUkwuXHJcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnRfMS5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHJcbiAgICBkaXYuaW5uZXJIVE1MID0gJzxhIGhyZWY9XCInICsgdXJsICsgJ1wiPng8L2E+JztcclxuICAgIHVybCA9IGRpdi5maXJzdENoaWxkLmhyZWY7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdXJsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGV4dGVuc2lvbiBvZiB0aGUgcGFzc2VkIGZpbGUgbmFtZS4gSXQgd2lsbCByZXR1cm4gYW4gZW1wdHkgc3RyaW5nXHJcbiAqIGlmIHBhc3NlZCBhbiBpbnZhbGlkIHBhdGguXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXHJcbiAqICAgICAgICBUaGUgZmlsZU5hbWUgcGF0aCBsaWtlICcvcGF0aC90by9maWxlLm1wNCdcclxuICpcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICogICAgICAgICAgVGhlIGV4dGVuc2lvbiBpbiBsb3dlciBjYXNlIG9yIGFuIGVtcHR5IHN0cmluZyBpZiBub1xyXG4gKiAgICAgICAgICBleHRlbnNpb24gY291bGQgYmUgZm91bmQuXHJcbiAqL1xyXG52YXIgZ2V0RmlsZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIGdldEZpbGVFeHRlbnNpb24ocGF0aCkge1xyXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcclxuICAgIHZhciBzcGxpdFBhdGhSZSA9IC9eKFxcLz8pKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/KShcXC4oW15cXC5cXC9cXD9dKykpKSg/OltcXC9dKnxbXFw/XS4qKSQvaTtcclxuICAgIHZhciBwYXRoUGFydHMgPSBzcGxpdFBhdGhSZS5leGVjKHBhdGgpO1xyXG5cclxuICAgIGlmIChwYXRoUGFydHMpIHtcclxuICAgICAgcmV0dXJuIHBhdGhQYXJ0cy5wb3AoKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuICcnO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGUgdXJsIHBhc3NlZCBpcyBhIGNyb3NzIGRvbWFpbiByZXF1ZXN0IG9yIG5vdC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxyXG4gKiAgICAgICAgVGhlIHVybCB0byBjaGVjay5cclxuICpcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICogICAgICAgICBXaGV0aGVyIGl0IGlzIGEgY3Jvc3MgZG9tYWluIHJlcXVlc3Qgb3Igbm90LlxyXG4gKi9cclxudmFyIGlzQ3Jvc3NPcmlnaW4gPSBmdW5jdGlvbiBpc0Nyb3NzT3JpZ2luKHVybCkge1xyXG4gIHZhciB3aW5Mb2MgPSB3aW5kb3dfMS5sb2NhdGlvbjtcclxuICB2YXIgdXJsSW5mbyA9IHBhcnNlVXJsKHVybCk7XHJcblxyXG4gIC8vIElFOCBwcm90b2NvbCByZWxhdGl2ZSB1cmxzIHdpbGwgcmV0dXJuICc6JyBmb3IgcHJvdG9jb2xcclxuICB2YXIgc3JjUHJvdG9jb2wgPSB1cmxJbmZvLnByb3RvY29sID09PSAnOicgPyB3aW5Mb2MucHJvdG9jb2wgOiB1cmxJbmZvLnByb3RvY29sO1xyXG5cclxuICAvLyBDaGVjayBpZiB1cmwgaXMgZm9yIGFub3RoZXIgZG9tYWluL29yaWdpblxyXG4gIC8vIElFOCBkb2Vzbid0IGtub3cgbG9jYXRpb24ub3JpZ2luLCBzbyB3ZSB3b24ndCByZWx5IG9uIGl0IGhlcmVcclxuICB2YXIgY3Jvc3NPcmlnaW4gPSBzcmNQcm90b2NvbCArIHVybEluZm8uaG9zdCAhPT0gd2luTG9jLnByb3RvY29sICsgd2luTG9jLmhvc3Q7XHJcblxyXG4gIHJldHVybiBjcm9zc09yaWdpbjtcclxufTtcclxuXHJcbnZhciBVcmwgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHtcclxuXHRwYXJzZVVybDogcGFyc2VVcmwsXHJcblx0Z2V0QWJzb2x1dGVVUkw6IGdldEFic29sdXRlVVJMLFxyXG5cdGdldEZpbGVFeHRlbnNpb246IGdldEZpbGVFeHRlbnNpb24sXHJcblx0aXNDcm9zc09yaWdpbjogaXNDcm9zc09yaWdpblxyXG59KTtcclxuXHJcbnZhciBpc0Z1bmN0aW9uXzEgPSBpc0Z1bmN0aW9uO1xyXG5cclxudmFyIHRvU3RyaW5nJDEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG5cclxuZnVuY3Rpb24gaXNGdW5jdGlvbiAoZm4pIHtcclxuICB2YXIgc3RyaW5nID0gdG9TdHJpbmckMS5jYWxsKGZuKTtcclxuICByZXR1cm4gc3RyaW5nID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8XHJcbiAgICAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHN0cmluZyAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHx8XHJcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAvLyBJRTggYW5kIGJlbG93XHJcbiAgICAgKGZuID09PSB3aW5kb3cuc2V0VGltZW91dCB8fFxyXG4gICAgICBmbiA9PT0gd2luZG93LmFsZXJ0IHx8XHJcbiAgICAgIGZuID09PSB3aW5kb3cuY29uZmlybSB8fFxyXG4gICAgICBmbiA9PT0gd2luZG93LnByb21wdCkpXHJcbn1cclxuXHJcbnZhciB0cmltXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XHJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRyaW07XHJcblxyXG5mdW5jdGlvbiB0cmltKHN0cil7XHJcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7XHJcbn1cclxuXHJcbmV4cG9ydHMubGVmdCA9IGZ1bmN0aW9uKHN0cil7XHJcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKTtcclxufTtcclxuXHJcbmV4cG9ydHMucmlnaHQgPSBmdW5jdGlvbihzdHIpe1xyXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKiQvLCAnJyk7XHJcbn07XHJcbn0pO1xyXG5cclxudmFyIGZvckVhY2hfMSA9IGZvckVhY2g7XHJcblxyXG52YXIgdG9TdHJpbmckMiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcblxyXG5mdW5jdGlvbiBmb3JFYWNoKGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoIWlzRnVuY3Rpb25fMShpdGVyYXRvcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xyXG4gICAgICAgIGNvbnRleHQgPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAodG9TdHJpbmckMi5jYWxsKGxpc3QpID09PSAnW29iamVjdCBBcnJheV0nKVxyXG4gICAgICAgIGZvckVhY2hBcnJheSQxKGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KTtcclxuICAgIGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJylcclxuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KTtcclxuICAgIGVsc2VcclxuICAgICAgICBmb3JFYWNoT2JqZWN0KGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZm9yRWFjaEFycmF5JDEoYXJyYXksIGl0ZXJhdG9yLCBjb250ZXh0KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcclxuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVtpXSwgaSwgYXJyYXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXHJcbiAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBmb3JFYWNoT2JqZWN0KG9iamVjdCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcclxuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XHJcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrKSkge1xyXG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9iamVjdFtrXSwgaywgb2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBpc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XHJcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcclxuICAgIH07XHJcblxyXG52YXIgcGFyc2VIZWFkZXJzID0gZnVuY3Rpb24gKGhlYWRlcnMpIHtcclxuICBpZiAoIWhlYWRlcnMpXHJcbiAgICByZXR1cm4ge31cclxuXHJcbiAgdmFyIHJlc3VsdCA9IHt9O1xyXG5cclxuICBmb3JFYWNoXzEoXHJcbiAgICAgIHRyaW1fMShoZWFkZXJzKS5zcGxpdCgnXFxuJylcclxuICAgICwgZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHZhciBpbmRleCA9IHJvdy5pbmRleE9mKCc6JylcclxuICAgICAgICAgICwga2V5ID0gdHJpbV8xKHJvdy5zbGljZSgwLCBpbmRleCkpLnRvTG93ZXJDYXNlKClcclxuICAgICAgICAgICwgdmFsdWUgPSB0cmltXzEocm93LnNsaWNlKGluZGV4ICsgMSkpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mKHJlc3VsdFtrZXldKSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHJlc3VsdFtrZXldKSkge1xyXG4gICAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlc3VsdFtrZXldID0gWyByZXN1bHRba2V5XSwgdmFsdWUgXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICApO1xyXG5cclxuICByZXR1cm4gcmVzdWx0XHJcbn07XHJcblxyXG52YXIgaW1tdXRhYmxlID0gZXh0ZW5kO1xyXG5cclxudmFyIGhhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5cclxuZnVuY3Rpb24gZXh0ZW5kKCkge1xyXG4gICAgdmFyIHRhcmdldCA9IHt9O1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkkMS5jYWxsKHNvdXJjZSwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0XHJcbn1cclxuXHJcbnZhciB4aHIgPSBjcmVhdGVYSFI7XHJcbmNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCA9IHdpbmRvd18xLlhNTEh0dHBSZXF1ZXN0IHx8IG5vb3A7XHJcbmNyZWF0ZVhIUi5YRG9tYWluUmVxdWVzdCA9IFwid2l0aENyZWRlbnRpYWxzXCIgaW4gKG5ldyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QoKSkgPyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QgOiB3aW5kb3dfMS5YRG9tYWluUmVxdWVzdDtcclxuXHJcbmZvckVhY2hBcnJheShbXCJnZXRcIiwgXCJwdXRcIiwgXCJwb3N0XCIsIFwicGF0Y2hcIiwgXCJoZWFkXCIsIFwiZGVsZXRlXCJdLCBmdW5jdGlvbihtZXRob2QpIHtcclxuICAgIGNyZWF0ZVhIUlttZXRob2QgPT09IFwiZGVsZXRlXCIgPyBcImRlbFwiIDogbWV0aG9kXSA9IGZ1bmN0aW9uKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcclxuICAgICAgICBvcHRpb25zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKTtcclxuICAgICAgICBvcHRpb25zLm1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIHJldHVybiBfY3JlYXRlWEhSKG9wdGlvbnMpXHJcbiAgICB9O1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGZvckVhY2hBcnJheShhcnJheSwgaXRlcmF0b3IpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpdGVyYXRvcihhcnJheVtpXSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRW1wdHkob2JqKXtcclxuICAgIGZvcih2YXIgaSBpbiBvYmope1xyXG4gICAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZVxyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spIHtcclxuICAgIHZhciBwYXJhbXMgPSB1cmk7XHJcblxyXG4gICAgaWYgKGlzRnVuY3Rpb25fMShvcHRpb25zKSkge1xyXG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcclxuICAgICAgICBpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBwYXJhbXMgPSB7dXJpOnVyaX07XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBwYXJhbXMgPSBpbW11dGFibGUob3B0aW9ucywge3VyaTogdXJpfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcGFyYW1zLmNhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICByZXR1cm4gcGFyYW1zXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVhIUih1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcbiAgICBvcHRpb25zID0gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKTtcclxuICAgIHJldHVybiBfY3JlYXRlWEhSKG9wdGlvbnMpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9jcmVhdGVYSFIob3B0aW9ucykge1xyXG4gICAgaWYodHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgPT09IFwidW5kZWZpbmVkXCIpe1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIilcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2FsbGVkID0gZmFsc2U7XHJcbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYk9uY2UoZXJyLCByZXNwb25zZSwgYm9keSl7XHJcbiAgICAgICAgaWYoIWNhbGxlZCl7XHJcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soZXJyLCByZXNwb25zZSwgYm9keSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiByZWFkeXN0YXRlY2hhbmdlKCkge1xyXG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGxvYWRGdW5jLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Qm9keSgpIHtcclxuICAgICAgICAvLyBDaHJvbWUgd2l0aCByZXF1ZXN0VHlwZT1ibG9iIHRocm93cyBlcnJvcnMgYXJyb3VuZCB3aGVuIGV2ZW4gdGVzdGluZyBhY2Nlc3MgdG8gcmVzcG9uc2VUZXh0XHJcbiAgICAgICAgdmFyIGJvZHkgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIGlmICh4aHIucmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlVGV4dCB8fCBnZXRYbWwoeGhyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc0pzb24pIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGJvZHlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlcnJvckZ1bmMoZXZ0KSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcik7XHJcbiAgICAgICAgaWYoIShldnQgaW5zdGFuY2VvZiBFcnJvcikpe1xyXG4gICAgICAgICAgICBldnQgPSBuZXcgRXJyb3IoXCJcIiArIChldnQgfHwgXCJVbmtub3duIFhNTEh0dHBSZXF1ZXN0IEVycm9yXCIpICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2dC5zdGF0dXNDb2RlID0gMDtcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXZ0LCBmYWlsdXJlUmVzcG9uc2UpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2lsbCBsb2FkIHRoZSBkYXRhICYgcHJvY2VzcyB0aGUgcmVzcG9uc2UgaW4gYSBzcGVjaWFsIHJlc3BvbnNlIG9iamVjdFxyXG4gICAgZnVuY3Rpb24gbG9hZEZ1bmMoKSB7XHJcbiAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVyblxyXG4gICAgICAgIHZhciBzdGF0dXM7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcik7XHJcbiAgICAgICAgaWYob3B0aW9ucy51c2VYRFIgJiYgeGhyLnN0YXR1cz09PXVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvL0lFOCBDT1JTIEdFVCBzdWNjZXNzZnVsIHJlc3BvbnNlIGRvZXNuJ3QgaGF2ZSBhIHN0YXR1cyBmaWVsZCwgYnV0IGJvZHkgaXMgZmluZVxyXG4gICAgICAgICAgICBzdGF0dXMgPSAyMDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RhdHVzID0gKHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gZmFpbHVyZVJlc3BvbnNlO1xyXG4gICAgICAgIHZhciBlcnIgPSBudWxsO1xyXG5cclxuICAgICAgICBpZiAoc3RhdHVzICE9PSAwKXtcclxuICAgICAgICAgICAgcmVzcG9uc2UgPSB7XHJcbiAgICAgICAgICAgICAgICBib2R5OiBnZXRCb2R5KCksXHJcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcclxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxyXG4gICAgICAgICAgICAgICAgdXJsOiB1cmksXHJcbiAgICAgICAgICAgICAgICByYXdSZXF1ZXN0OiB4aHJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycyl7IC8vcmVtZW1iZXIgeGhyIGNhbiBpbiBmYWN0IGJlIFhEUiBmb3IgQ09SUyBpbiBJRVxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKFwiSW50ZXJuYWwgWE1MSHR0cFJlcXVlc3QgRXJyb3JcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIHJlc3BvbnNlLCByZXNwb25zZS5ib2R5KVxyXG4gICAgfVxyXG5cclxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociB8fCBudWxsO1xyXG5cclxuICAgIGlmICgheGhyKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY29ycyB8fCBvcHRpb25zLnVzZVhEUikge1xyXG4gICAgICAgICAgICB4aHIgPSBuZXcgY3JlYXRlWEhSLlhEb21haW5SZXF1ZXN0KCk7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHhociA9IG5ldyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGtleTtcclxuICAgIHZhciBhYm9ydGVkO1xyXG4gICAgdmFyIHVyaSA9IHhoci51cmwgPSBvcHRpb25zLnVyaSB8fCBvcHRpb25zLnVybDtcclxuICAgIHZhciBtZXRob2QgPSB4aHIubWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIjtcclxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG9wdGlvbnMuZGF0YTtcclxuICAgIHZhciBoZWFkZXJzID0geGhyLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XHJcbiAgICB2YXIgc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xyXG4gICAgdmFyIGlzSnNvbiA9IGZhbHNlO1xyXG4gICAgdmFyIHRpbWVvdXRUaW1lcjtcclxuICAgIHZhciBmYWlsdXJlUmVzcG9uc2UgPSB7XHJcbiAgICAgICAgYm9keTogdW5kZWZpbmVkLFxyXG4gICAgICAgIGhlYWRlcnM6IHt9LFxyXG4gICAgICAgIHN0YXR1c0NvZGU6IDAsXHJcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXHJcbiAgICAgICAgdXJsOiB1cmksXHJcbiAgICAgICAgcmF3UmVxdWVzdDogeGhyXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChcImpzb25cIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuanNvbiAhPT0gZmFsc2UpIHtcclxuICAgICAgICBpc0pzb24gPSB0cnVlO1xyXG4gICAgICAgIGhlYWRlcnNbXCJhY2NlcHRcIl0gfHwgaGVhZGVyc1tcIkFjY2VwdFwiXSB8fCAoaGVhZGVyc1tcIkFjY2VwdFwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiKTsgLy9Eb24ndCBvdmVycmlkZSBleGlzdGluZyBhY2NlcHQgaGVhZGVyIGRlY2xhcmVkIGJ5IHVzZXJcclxuICAgICAgICBpZiAobWV0aG9kICE9PSBcIkdFVFwiICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcclxuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdIHx8IChoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCIpOyAvL0Rvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFjY2VwdCBoZWFkZXIgZGVjbGFyZWQgYnkgdXNlclxyXG4gICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5qc29uID09PSB0cnVlID8gYm9keSA6IG9wdGlvbnMuanNvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSByZWFkeXN0YXRlY2hhbmdlO1xyXG4gICAgeGhyLm9ubG9hZCA9IGxvYWRGdW5jO1xyXG4gICAgeGhyLm9uZXJyb3IgPSBlcnJvckZ1bmM7XHJcbiAgICAvLyBJRTkgbXVzdCBoYXZlIG9ucHJvZ3Jlc3MgYmUgc2V0IHRvIGEgdW5pcXVlIGZ1bmN0aW9uLlxyXG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gSUUgbXVzdCBkaWVcclxuICAgIH07XHJcbiAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgYWJvcnRlZCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgeGhyLm9udGltZW91dCA9IGVycm9yRnVuYztcclxuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJpLCAhc3luYywgb3B0aW9ucy51c2VybmFtZSwgb3B0aW9ucy5wYXNzd29yZCk7XHJcbiAgICAvL2hhcyB0byBiZSBhZnRlciBvcGVuXHJcbiAgICBpZighc3luYykge1xyXG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdGlvbnMud2l0aENyZWRlbnRpYWxzO1xyXG4gICAgfVxyXG4gICAgLy8gQ2Fubm90IHNldCB0aW1lb3V0IHdpdGggc3luYyByZXF1ZXN0XHJcbiAgICAvLyBub3Qgc2V0dGluZyB0aW1lb3V0IG9uIHRoZSB4aHIgb2JqZWN0LCBiZWNhdXNlIG9mIG9sZCB3ZWJraXRzIGV0Yy4gbm90IGhhbmRsaW5nIHRoYXQgY29ycmVjdGx5XHJcbiAgICAvLyBib3RoIG5wbSdzIHJlcXVlc3QgYW5kIGpxdWVyeSAxLnggdXNlIHRoaXMga2luZCBvZiB0aW1lb3V0LCBzbyB0aGlzIGlzIGJlaW5nIGNvbnNpc3RlbnRcclxuICAgIGlmICghc3luYyAmJiBvcHRpb25zLnRpbWVvdXQgPiAwICkge1xyXG4gICAgICAgIHRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgaWYgKGFib3J0ZWQpIHJldHVyblxyXG4gICAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTsvL0lFOSBtYXkgc3RpbGwgY2FsbCByZWFkeXN0YXRlY2hhbmdlXHJcbiAgICAgICAgICAgIHhoci5hYm9ydChcInRpbWVvdXRcIik7XHJcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKFwiWE1MSHR0cFJlcXVlc3QgdGltZW91dFwiKTtcclxuICAgICAgICAgICAgZS5jb2RlID0gXCJFVElNRURPVVRcIjtcclxuICAgICAgICAgICAgZXJyb3JGdW5jKGUpO1xyXG4gICAgICAgIH0sIG9wdGlvbnMudGltZW91dCApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh4aHIuc2V0UmVxdWVzdEhlYWRlcikge1xyXG4gICAgICAgIGZvcihrZXkgaW4gaGVhZGVycyl7XHJcbiAgICAgICAgICAgIGlmKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSl7XHJcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaGVhZGVycyAmJiAhaXNFbXB0eShvcHRpb25zLmhlYWRlcnMpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIGFuIFhEb21haW5SZXF1ZXN0IG9iamVjdFwiKVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChcInJlc3BvbnNlVHlwZVwiIGluIG9wdGlvbnMpIHtcclxuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFwiYmVmb3JlU2VuZFwiIGluIG9wdGlvbnMgJiZcclxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTZW5kID09PSBcImZ1bmN0aW9uXCJcclxuICAgICkge1xyXG4gICAgICAgIG9wdGlvbnMuYmVmb3JlU2VuZCh4aHIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1pY3Jvc29mdCBFZGdlIGJyb3dzZXIgc2VuZHMgXCJ1bmRlZmluZWRcIiB3aGVuIHNlbmQgaXMgY2FsbGVkIHdpdGggdW5kZWZpbmVkIHZhbHVlLlxyXG4gICAgLy8gWE1MSHR0cFJlcXVlc3Qgc3BlYyBzYXlzIHRvIHBhc3MgbnVsbCBhcyBib2R5IHRvIGluZGljYXRlIG5vIGJvZHlcclxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbmF1Z3R1ci94aHIvaXNzdWVzLzEwMC5cclxuICAgIHhoci5zZW5kKGJvZHkgfHwgbnVsbCk7XHJcblxyXG4gICAgcmV0dXJuIHhoclxyXG5cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFhtbCh4aHIpIHtcclxuICAgIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSBcImRvY3VtZW50XCIpIHtcclxuICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlWE1MXHJcbiAgICB9XHJcbiAgICB2YXIgZmlyZWZveEJ1Z1Rha2VuRWZmZWN0ID0geGhyLnJlc3BvbnNlWE1MICYmIHhoci5yZXNwb25zZVhNTC5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgPT09IFwicGFyc2VyZXJyb3JcIjtcclxuICAgIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSBcIlwiICYmICFmaXJlZm94QnVnVGFrZW5FZmZlY3QpIHtcclxuICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlWE1MXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGxcclxufVxyXG5cclxuZnVuY3Rpb24gbm9vcCgpIHt9XHJcblxyXG4vKipcclxuICogQGZpbGUgdGV4dC10cmFjay5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIFRha2VzIGEgd2VidnR0IGZpbGUgY29udGVudHMgYW5kIHBhcnNlcyBpdCBpbnRvIGN1ZXNcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHNyY0NvbnRlbnRcclxuICogICAgICAgIHdlYlZUVCBmaWxlIGNvbnRlbnRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xyXG4gKiAgICAgICAgVGV4dFRyYWNrIHRvIGFkZCBjdWVzIHRvLiBDdWVzIGNvbWUgZnJvbSB0aGUgc3JjQ29udGVudC5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbnZhciBwYXJzZUN1ZXMgPSBmdW5jdGlvbiBwYXJzZUN1ZXMoc3JjQ29udGVudCwgdHJhY2spIHtcclxuICB2YXIgcGFyc2VyID0gbmV3IHdpbmRvd18xLldlYlZUVC5QYXJzZXIod2luZG93XzEsIHdpbmRvd18xLnZ0dGpzLCB3aW5kb3dfMS5XZWJWVFQuU3RyaW5nRGVjb2RlcigpKTtcclxuICB2YXIgZXJyb3JzID0gW107XHJcblxyXG4gIHBhcnNlci5vbmN1ZSA9IGZ1bmN0aW9uIChjdWUpIHtcclxuICAgIHRyYWNrLmFkZEN1ZShjdWUpO1xyXG4gIH07XHJcblxyXG4gIHBhcnNlci5vbnBhcnNpbmdlcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgZXJyb3JzLnB1c2goZXJyb3IpO1xyXG4gIH07XHJcblxyXG4gIHBhcnNlci5vbmZsdXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdHJhY2sudHJpZ2dlcih7XHJcbiAgICAgIHR5cGU6ICdsb2FkZWRkYXRhJyxcclxuICAgICAgdGFyZ2V0OiB0cmFja1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgcGFyc2VyLnBhcnNlKHNyY0NvbnRlbnQpO1xyXG4gIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xyXG4gICAgaWYgKHdpbmRvd18xLmNvbnNvbGUgJiYgd2luZG93XzEuY29uc29sZS5ncm91cENvbGxhcHNlZCkge1xyXG4gICAgICB3aW5kb3dfMS5jb25zb2xlLmdyb3VwQ29sbGFwc2VkKCdUZXh0IFRyYWNrIHBhcnNpbmcgZXJyb3JzIGZvciAnICsgdHJhY2suc3JjKTtcclxuICAgIH1cclxuICAgIGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICByZXR1cm4gbG9nJDEuZXJyb3IoZXJyb3IpO1xyXG4gICAgfSk7XHJcbiAgICBpZiAod2luZG93XzEuY29uc29sZSAmJiB3aW5kb3dfMS5jb25zb2xlLmdyb3VwRW5kKSB7XHJcbiAgICAgIHdpbmRvd18xLmNvbnNvbGUuZ3JvdXBFbmQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHBhcnNlci5mbHVzaCgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIExvYWQgYSBgVGV4dFRyYWNrYCBmcm9tIGEgc3BlY2lmZWQgdXJsLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjXHJcbiAqICAgICAgICBVcmwgdG8gbG9hZCB0cmFjayBmcm9tLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcclxuICogICAgICAgIFRyYWNrIHRvIGFkZCBjdWVzIHRvLiBDb21lcyBmcm9tIHRoZSBjb250ZW50IGF0IHRoZSBlbmQgb2YgYHVybGAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG52YXIgbG9hZFRyYWNrID0gZnVuY3Rpb24gbG9hZFRyYWNrKHNyYywgdHJhY2spIHtcclxuICB2YXIgb3B0cyA9IHtcclxuICAgIHVyaTogc3JjXHJcbiAgfTtcclxuICB2YXIgY3Jvc3NPcmlnaW4gPSBpc0Nyb3NzT3JpZ2luKHNyYyk7XHJcblxyXG4gIGlmIChjcm9zc09yaWdpbikge1xyXG4gICAgb3B0cy5jb3JzID0gY3Jvc3NPcmlnaW47XHJcbiAgfVxyXG5cclxuICB4aHIob3B0cywgYmluZCh0aGlzLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSwgcmVzcG9uc2VCb2R5KSB7XHJcbiAgICBpZiAoZXJyKSB7XHJcbiAgICAgIHJldHVybiBsb2ckMS5lcnJvcihlcnIsIHJlc3BvbnNlKTtcclxuICAgIH1cclxuXHJcbiAgICB0cmFjay5sb2FkZWRfID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB2dHRqcyBoYXMgbG9hZGVkLCBvdGhlcndpc2UsIHdhaXQgdGlsbCBpdCBmaW5pc2hlZCBsb2FkaW5nXHJcbiAgICAvLyBOT1RFOiB0aGlzIGlzIG9ubHkgdXNlZCBmb3IgdGhlIGFsdC92aWRlby5ub3Z0dC5qcyBidWlsZFxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3dfMS5XZWJWVFQgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgaWYgKHRyYWNrLnRlY2hfKSB7XHJcbiAgICAgICAgdmFyIGxvYWRIYW5kbGVyID0gZnVuY3Rpb24gbG9hZEhhbmRsZXIoKSB7XHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VDdWVzKHJlc3BvbnNlQm9keSwgdHJhY2spO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRyYWNrLnRlY2hfLm9uKCd2dHRqc2xvYWRlZCcsIGxvYWRIYW5kbGVyKTtcclxuICAgICAgICB0cmFjay50ZWNoXy5vbigndnR0anNlcnJvcicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGxvZyQxLmVycm9yKCd2dHRqcyBmYWlsZWQgdG8gbG9hZCwgc3RvcHBpbmcgdHJ5aW5nIHRvIHByb2Nlc3MgJyArIHRyYWNrLnNyYyk7XHJcbiAgICAgICAgICB0cmFjay50ZWNoXy5vZmYoJ3Z0dGpzbG9hZGVkJywgbG9hZEhhbmRsZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwYXJzZUN1ZXMocmVzcG9uc2VCb2R5LCB0cmFjayk7XHJcbiAgICB9XHJcbiAgfSkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgYFRleHRUcmFja2AuXHJcbiAqXHJcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0ZXh0dHJhY2t9XHJcbiAqIEBleHRlbmRzIFRyYWNrXHJcbiAqL1xyXG5cclxudmFyIFRleHRUcmFjayA9IGZ1bmN0aW9uIChfVHJhY2spIHtcclxuICBpbmhlcml0cyhUZXh0VHJhY2ssIF9UcmFjayk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnM9e31cclxuICAgKiAgICAgICAgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RlY2h9IG9wdGlvbnMudGVjaFxyXG4gICAqICAgICAgICBBIHJlZmVyZW5jZSB0byB0aGUgdGVjaCB0aGF0IG93bnMgdGhpcyBUZXh0VHJhY2suXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RleHRUcmFja35LaW5kfSBbb3B0aW9ucy5raW5kPSdzdWJ0aXRsZXMnXVxyXG4gICAqICAgICAgICBBIHZhbGlkIHRleHQgdHJhY2sga2luZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfk1vZGV9IFtvcHRpb25zLm1vZGU9J2Rpc2FibGVkJ11cclxuICAgKiAgICAgICAgQSB2YWxpZCB0ZXh0IHRyYWNrIG1vZGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWQ9J3Zqc190cmFja18nICsgR3VpZC5uZXdHVUlEKCldXHJcbiAgICogICAgICAgIEEgdW5pcXVlIGlkIGZvciB0aGlzIFRleHRUcmFjay5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbD0nJ11cclxuICAgKiAgICAgICAgVGhlIG1lbnUgbGFiZWwgZm9yIHRoaXMgdHJhY2suXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2U9JyddXHJcbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY2xhbmc9JyddXHJcbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLiBBbiBhbHRlcm5hdGl2ZSwgYnV0IGRlcHJpb3JpdGl6ZWRcclxuICAgKiAgICAgICAgdmVzaW9uIG9mIGBvcHRpb25zLmxhbmd1YWdlYFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY11cclxuICAgKiAgICAgICAgQSB1cmwgdG8gVGV4dFRyYWNrIGN1ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlZmF1bHRdXHJcbiAgICogICAgICAgIElmIHRoaXMgdHJhY2sgc2hvdWxkIGRlZmF1bHQgdG8gb24gb3Igb2ZmLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFRleHRUcmFjaygpIHtcclxuICAgIHZhciBfdGhpcywgX3JldDtcclxuXHJcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2spO1xyXG5cclxuICAgIGlmICghb3B0aW9ucy50ZWNoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSB0ZWNoIHdhcyBub3QgcHJvdmlkZWQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNldHRpbmdzID0gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIHtcclxuICAgICAga2luZDogVGV4dFRyYWNrS2luZFtvcHRpb25zLmtpbmRdIHx8ICdzdWJ0aXRsZXMnLFxyXG4gICAgICBsYW5ndWFnZTogb3B0aW9ucy5sYW5ndWFnZSB8fCBvcHRpb25zLnNyY2xhbmcgfHwgJydcclxuICAgIH0pO1xyXG4gICAgdmFyIG1vZGUgPSBUZXh0VHJhY2tNb2RlW3NldHRpbmdzLm1vZGVdIHx8ICdkaXNhYmxlZCc7XHJcbiAgICB2YXIgZGVmYXVsdF8gPSBzZXR0aW5nc1snZGVmYXVsdCddO1xyXG5cclxuICAgIGlmIChzZXR0aW5ncy5raW5kID09PSAnbWV0YWRhdGEnIHx8IHNldHRpbmdzLmtpbmQgPT09ICdjaGFwdGVycycpIHtcclxuICAgICAgbW9kZSA9ICdoaWRkZW4nO1xyXG4gICAgfVxyXG4gICAgLy8gb24gSUU4IHRoaXMgd2lsbCBiZSBhIGRvY3VtZW50IGVsZW1lbnRcclxuICAgIC8vIGZvciBldmVyeSBvdGhlciBicm93c2VyIHRoaXMgd2lsbCBiZSBhIG5vcm1hbCBvYmplY3RcclxuICAgIHZhciB0dCA9IChfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RyYWNrLmNhbGwodGhpcywgc2V0dGluZ3MpKSwgX3RoaXMpO1xyXG5cclxuICAgIHR0LnRlY2hfID0gc2V0dGluZ3MudGVjaDtcclxuXHJcbiAgICBpZiAoSVNfSUU4KSB7XHJcbiAgICAgIGZvciAodmFyIHByb3AgaW4gVGV4dFRyYWNrLnByb3RvdHlwZSkge1xyXG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XHJcbiAgICAgICAgICB0dFtwcm9wXSA9IFRleHRUcmFjay5wcm90b3R5cGVbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdHQuY3Vlc18gPSBbXTtcclxuICAgIHR0LmFjdGl2ZUN1ZXNfID0gW107XHJcblxyXG4gICAgdmFyIGN1ZXMgPSBuZXcgVGV4dFRyYWNrQ3VlTGlzdCh0dC5jdWVzXyk7XHJcbiAgICB2YXIgYWN0aXZlQ3VlcyA9IG5ldyBUZXh0VHJhY2tDdWVMaXN0KHR0LmFjdGl2ZUN1ZXNfKTtcclxuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XHJcbiAgICB2YXIgdGltZXVwZGF0ZUhhbmRsZXIgPSBiaW5kKHR0LCBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAvLyBBY2Nlc3NpbmcgdGhpcy5hY3RpdmVDdWVzIGZvciB0aGUgc2lkZS1lZmZlY3RzIG9mIHVwZGF0aW5nIGl0c2VsZlxyXG4gICAgICAvLyBkdWUgdG8gaXQncyBuYXR1cmUgYXMgYSBnZXR0ZXIgZnVuY3Rpb24uIERvIG5vdCByZW1vdmUgb3IgY3VlcyB3aWxsXHJcbiAgICAgIC8vIHN0b3AgdXBkYXRpbmchXHJcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xyXG4gICAgICB0aGlzLmFjdGl2ZUN1ZXM7XHJcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXHJcbiAgICAgIGlmIChjaGFuZ2VkKSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjdWVjaGFuZ2UnKTtcclxuICAgICAgICBjaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChtb2RlICE9PSAnZGlzYWJsZWQnKSB7XHJcbiAgICAgIHR0LnRlY2hfLnJlYWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0dC50ZWNoXy5vbigndGltZXVwZGF0ZScsIHRpbWV1cGRhdGVIYW5kbGVyKTtcclxuICAgICAgfSwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyb2YgVGV4dFRyYWNrXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSBkZWZhdWx0XHJcbiAgICAgKiAgICAgICAgIElmIHRoaXMgdHJhY2sgd2FzIHNldCB0byBiZSBvbiBvciBvZmYgYnkgZGVmYXVsdC4gQ2Fubm90IGJlIGNoYW5nZWQgYWZ0ZXJcclxuICAgICAqICAgICAgICAgY3JlYXRpb24uXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnZGVmYXVsdCcsIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRfO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSgpIHt9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXJvZiBUZXh0VHJhY2tcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gbW9kZVxyXG4gICAgICogICAgICAgICBTZXQgdGhlIG1vZGUgb2YgdGhpcyBUZXh0VHJhY2sgdG8gYSB2YWxpZCB7QGxpbmsgVGV4dFRyYWNrfk1vZGV9LiBXaWxsXHJcbiAgICAgKiAgICAgICAgIG5vdCBiZSBzZXQgaWYgc2V0dGluZyB0byBhbiBpbnZhbGlkIG1vZGUuXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqXHJcbiAgICAgKiBAZmlyZXMgVGV4dFRyYWNrI21vZGVjaGFuZ2VcclxuICAgICAqL1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR0LCAnbW9kZScsIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vZGU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKG5ld01vZGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuXHJcbiAgICAgICAgaWYgKCFUZXh0VHJhY2tNb2RlW25ld01vZGVdKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1vZGUgPSBuZXdNb2RlO1xyXG4gICAgICAgIGlmIChtb2RlID09PSAnc2hvd2luZycpIHtcclxuXHJcbiAgICAgICAgICB0aGlzLnRlY2hfLnJlYWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMyLnRlY2hfLm9uKCd0aW1ldXBkYXRlJywgdGltZXVwZGF0ZUhhbmRsZXIpO1xyXG4gICAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGV2ZW50IHRoYXQgZmlyZXMgd2hlbiBtb2RlIGNoYW5nZXMgb24gdGhpcyB0cmFjay4gVGhpcyBhbGxvd3NcclxuICAgICAgICAgKiB0aGUgVGV4dFRyYWNrTGlzdCB0aGF0IGhvbGRzIHRoaXMgdHJhY2sgdG8gYWN0IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogPiBOb3RlOiBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBzcGVjIVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV2ZW50IFRleHRUcmFjayNtb2RlY2hhbmdlXHJcbiAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignbW9kZWNoYW5nZScpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXJvZiBUZXh0VHJhY2tcclxuICAgICAqIEBtZW1iZXIge1RleHRUcmFja0N1ZUxpc3R9IGN1ZXNcclxuICAgICAqICAgICAgICAgVGhlIHRleHQgdHJhY2sgY3VlIGxpc3QgZm9yIHRoaXMgVGV4dFRyYWNrLlxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ2N1ZXMnLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5sb2FkZWRfKSB7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjdWVzO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMSgpIHt9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXJvZiBUZXh0VHJhY2tcclxuICAgICAqIEBtZW1iZXIge1RleHRUcmFja0N1ZUxpc3R9IGFjdGl2ZUN1ZXNcclxuICAgICAqICAgICAgICAgVGhlIGxpc3QgdGV4dCB0cmFjayBjdWVzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUgZm9yIHRoaXMgVGV4dFRyYWNrLlxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dCwgJ2FjdGl2ZUN1ZXMnLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0JCQxKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5sb2FkZWRfKSB7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cclxuICAgICAgICBpZiAodGhpcy5jdWVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZUN1ZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY3QgPSB0aGlzLnRlY2hfLmN1cnJlbnRUaW1lKCk7XHJcbiAgICAgICAgdmFyIGFjdGl2ZSA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuY3Vlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgIHZhciBjdWUgPSB0aGlzLmN1ZXNbaV07XHJcblxyXG4gICAgICAgICAgaWYgKGN1ZS5zdGFydFRpbWUgPD0gY3QgJiYgY3VlLmVuZFRpbWUgPj0gY3QpIHtcclxuICAgICAgICAgICAgYWN0aXZlLnB1c2goY3VlKTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VlLnN0YXJ0VGltZSA9PT0gY3VlLmVuZFRpbWUgJiYgY3VlLnN0YXJ0VGltZSA8PSBjdCAmJiBjdWUuc3RhcnRUaW1lICsgMC41ID49IGN0KSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZS5wdXNoKGN1ZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjaGFuZ2VkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoICE9PSB0aGlzLmFjdGl2ZUN1ZXNfLmxlbmd0aCkge1xyXG4gICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhY3RpdmUubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZUN1ZXNfLmluZGV4T2YoYWN0aXZlW19pXSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYWN0aXZlQ3Vlc18gPSBhY3RpdmU7XHJcbiAgICAgICAgYWN0aXZlQ3Vlcy5zZXRDdWVzXyh0aGlzLmFjdGl2ZUN1ZXNfKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGFjdGl2ZUN1ZXM7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKCkge31cclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChzZXR0aW5ncy5zcmMpIHtcclxuICAgICAgdHQuc3JjID0gc2V0dGluZ3Muc3JjO1xyXG4gICAgICBsb2FkVHJhY2soc2V0dGluZ3Muc3JjLCB0dCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0dC5sb2FkZWRfID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gX3JldCA9IHR0LCBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIGN1ZSB0byB0aGUgaW50ZXJuYWwgbGlzdCBvZiBjdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUZXh0VHJhY2t+Q3VlfSBjdWVcclxuICAgKiAgICAgICAgVGhlIGN1ZSB0byBhZGQgdG8gb3VyIGludGVybmFsIGxpc3RcclxuICAgKi9cclxuXHJcblxyXG4gIFRleHRUcmFjay5wcm90b3R5cGUuYWRkQ3VlID0gZnVuY3Rpb24gYWRkQ3VlKG9yaWdpbmFsQ3VlKSB7XHJcbiAgICB2YXIgY3VlID0gb3JpZ2luYWxDdWU7XHJcblxyXG4gICAgaWYgKHdpbmRvd18xLnZ0dGpzICYmICEob3JpZ2luYWxDdWUgaW5zdGFuY2VvZiB3aW5kb3dfMS52dHRqcy5WVFRDdWUpKSB7XHJcbiAgICAgIGN1ZSA9IG5ldyB3aW5kb3dfMS52dHRqcy5WVFRDdWUob3JpZ2luYWxDdWUuc3RhcnRUaW1lLCBvcmlnaW5hbEN1ZS5lbmRUaW1lLCBvcmlnaW5hbEN1ZS50ZXh0KTtcclxuXHJcbiAgICAgIGZvciAodmFyIHByb3AgaW4gb3JpZ2luYWxDdWUpIHtcclxuICAgICAgICBpZiAoIShwcm9wIGluIGN1ZSkpIHtcclxuICAgICAgICAgIGN1ZVtwcm9wXSA9IG9yaWdpbmFsQ3VlW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgYGlkYCBpcyBjb3BpZWQgb3ZlclxyXG4gICAgICBjdWUuaWQgPSBvcmlnaW5hbEN1ZS5pZDtcclxuICAgICAgY3VlLm9yaWdpbmFsQ3VlXyA9IG9yaWdpbmFsQ3VlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB0cmFja3MgPSB0aGlzLnRlY2hfLnRleHRUcmFja3MoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAodHJhY2tzW2ldICE9PSB0aGlzKSB7XHJcbiAgICAgICAgdHJhY2tzW2ldLnJlbW92ZUN1ZShjdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jdWVzXy5wdXNoKGN1ZSk7XHJcbiAgICB0aGlzLmN1ZXMuc2V0Q3Vlc18odGhpcy5jdWVzXyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGEgY3VlIGZyb20gb3VyIGludGVybmFsIGxpc3RcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfkN1ZX0gcmVtb3ZlQ3VlXHJcbiAgICogICAgICAgIFRoZSBjdWUgdG8gcmVtb3ZlIGZyb20gb3VyIGludGVybmFsIGxpc3RcclxuICAgKi9cclxuXHJcblxyXG4gIFRleHRUcmFjay5wcm90b3R5cGUucmVtb3ZlQ3VlID0gZnVuY3Rpb24gcmVtb3ZlQ3VlKF9yZW1vdmVDdWUpIHtcclxuICAgIHZhciBpID0gdGhpcy5jdWVzXy5sZW5ndGg7XHJcblxyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICB2YXIgY3VlID0gdGhpcy5jdWVzX1tpXTtcclxuXHJcbiAgICAgIGlmIChjdWUgPT09IF9yZW1vdmVDdWUgfHwgY3VlLm9yaWdpbmFsQ3VlXyAmJiBjdWUub3JpZ2luYWxDdWVfID09PSBfcmVtb3ZlQ3VlKSB7XHJcbiAgICAgICAgdGhpcy5jdWVzXy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgdGhpcy5jdWVzLnNldEN1ZXNfKHRoaXMuY3Vlc18pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFRleHRUcmFjaztcclxufShUcmFjayk7XHJcblxyXG4vKipcclxuICogY3VlY2hhbmdlIC0gT25lIG9yIG1vcmUgY3VlcyBpbiB0aGUgdHJhY2sgaGF2ZSBiZWNvbWUgYWN0aXZlIG9yIHN0b3BwZWQgYmVpbmcgYWN0aXZlLlxyXG4gKi9cclxuXHJcblxyXG5UZXh0VHJhY2sucHJvdG90eXBlLmFsbG93ZWRFdmVudHNfID0ge1xyXG4gIGN1ZWNoYW5nZTogJ2N1ZWNoYW5nZSdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGBBdWRpb1RyYWNrYC4gSWYgaXQgaXMgcGFydCBvZiBhbiB7QGxpbmsgQXVkaW9UcmFja0xpc3R9XHJcbiAqIG9ubHkgb25lIGBBdWRpb1RyYWNrYCBpbiB0aGUgbGlzdCB3aWxsIGJlIGVuYWJsZWQgYXQgYSB0aW1lLlxyXG4gKlxyXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjYXVkaW90cmFja31cclxuICogQGV4dGVuZHMgVHJhY2tcclxuICovXHJcblxyXG52YXIgQXVkaW9UcmFjayA9IGZ1bmN0aW9uIChfVHJhY2spIHtcclxuICBpbmhlcml0cyhBdWRpb1RyYWNrLCBfVHJhY2spO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cclxuICAgKiAgICAgICAgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0F1ZGlvVHJhY2t+S2luZH0gW29wdGlvbnMua2luZD0nJ11cclxuICAgKiAgICAgICAgQSB2YWxpZCBhdWRpbyB0cmFjayBraW5kXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWQ9J3Zqc190cmFja18nICsgR3VpZC5uZXdHVUlEKCldXHJcbiAgICogICAgICAgIEEgdW5pcXVlIGlkIGZvciB0aGlzIEF1ZGlvVHJhY2suXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWw9JyddXHJcbiAgICogICAgICAgIFRoZSBtZW51IGxhYmVsIGZvciB0aGlzIHRyYWNrLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlPScnXVxyXG4gICAqICAgICAgICBBIHZhbGlkIHR3byBjaGFyYWN0ZXIgbGFuZ3VhZ2UgY29kZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlZF1cclxuICAgKiAgICAgICAgSWYgdGhpcyB0cmFjayBpcyB0aGUgb25lIHRoYXQgaXMgY3VycmVudGx5IHBsYXlpbmcuIElmIHRoaXMgdHJhY2sgaXMgcGFydCBvZlxyXG4gICAqICAgICAgICBhbiB7QGxpbmsgQXVkaW9UcmFja0xpc3R9LCBvbmx5IG9uZSB7QGxpbmsgQXVkaW9UcmFja30gd2lsbCBiZSBlbmFibGVkLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2soKSB7XHJcbiAgICB2YXIgX3RoaXMsIF9yZXQ7XHJcblxyXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9UcmFjayk7XHJcblxyXG4gICAgdmFyIHNldHRpbmdzID0gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIHtcclxuICAgICAga2luZDogQXVkaW9UcmFja0tpbmRbb3B0aW9ucy5raW5kXSB8fCAnJ1xyXG4gICAgfSk7XHJcbiAgICAvLyBvbiBJRTggdGhpcyB3aWxsIGJlIGEgZG9jdW1lbnQgZWxlbWVudFxyXG4gICAgLy8gZm9yIGV2ZXJ5IG90aGVyIGJyb3dzZXIgdGhpcyB3aWxsIGJlIGEgbm9ybWFsIG9iamVjdFxyXG4gICAgdmFyIHRyYWNrID0gKF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVHJhY2suY2FsbCh0aGlzLCBzZXR0aW5ncykpLCBfdGhpcyk7XHJcbiAgICB2YXIgZW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChJU19JRTgpIHtcclxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBBdWRpb1RyYWNrLnByb3RvdHlwZSkge1xyXG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XHJcbiAgICAgICAgICB0cmFja1twcm9wXSA9IEF1ZGlvVHJhY2sucHJvdG90eXBlW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9UcmFja1xyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn0gZW5hYmxlZFxyXG4gICAgICogICAgICAgICBJZiB0aGlzIGBBdWRpb1RyYWNrYCBpcyBlbmFibGVkIG9yIG5vdC4gV2hlbiBzZXR0aW5nIHRoaXMgd2lsbFxyXG4gICAgICogICAgICAgICBmaXJlIHtAbGluayBBdWRpb1RyYWNrI2VuYWJsZWRjaGFuZ2V9IGlmIHRoZSBzdGF0ZSBvZiBlbmFibGVkIGlzIGNoYW5nZWQuXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqXHJcbiAgICAgKiBAZmlyZXMgVmlkZW9UcmFjayNzZWxlY3RlZGNoYW5nZVxyXG4gICAgICovXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2ssICdlbmFibGVkJywge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcclxuICAgICAgICByZXR1cm4gZW5hYmxlZDtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEobmV3RW5hYmxlZCkge1xyXG4gICAgICAgIC8vIGFuIGludmFsaWQgb3IgdW5jaGFuZ2VkIHZhbHVlXHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdFbmFibGVkICE9PSAnYm9vbGVhbicgfHwgbmV3RW5hYmxlZCA9PT0gZW5hYmxlZCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbmFibGVkID0gbmV3RW5hYmxlZDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gZXZlbnQgdGhhdCBmaXJlcyB3aGVuIGVuYWJsZWQgY2hhbmdlcyBvbiB0aGlzIHRyYWNrLiBUaGlzIGFsbG93c1xyXG4gICAgICAgICAqIHRoZSBBdWRpb1RyYWNrTGlzdCB0aGF0IGhvbGRzIHRoaXMgdHJhY2sgdG8gYWN0IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogPiBOb3RlOiBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBzcGVjISBOYXRpdmUgdHJhY2tzIHdpbGwgZG9cclxuICAgICAgICAgKiAgICAgICAgIHRoaXMgaW50ZXJuYWxseSB3aXRob3V0IGFuIGV2ZW50LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV2ZW50IEF1ZGlvVHJhY2sjZW5hYmxlZGNoYW5nZVxyXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2VuYWJsZWRjaGFuZ2UnKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gaWYgdGhlIHVzZXIgc2V0cyB0aGlzIHRyYWNrIHRvIHNlbGVjdGVkIHRoZW5cclxuICAgIC8vIHNldCBzZWxlY3RlZCB0byB0aGF0IHRydWUgdmFsdWUgb3RoZXJ3aXNlXHJcbiAgICAvLyB3ZSBrZWVwIGl0IGZhbHNlXHJcbiAgICBpZiAoc2V0dGluZ3MuZW5hYmxlZCkge1xyXG4gICAgICB0cmFjay5lbmFibGVkID0gc2V0dGluZ3MuZW5hYmxlZDtcclxuICAgIH1cclxuICAgIHRyYWNrLmxvYWRlZF8gPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiBfcmV0ID0gdHJhY2ssIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIEF1ZGlvVHJhY2s7XHJcbn0oVHJhY2spO1xyXG5cclxuLyoqXHJcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgYFZpZGVvVHJhY2tgLlxyXG4gKlxyXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdmlkZW90cmFja31cclxuICogQGV4dGVuZHMgVHJhY2tcclxuICovXHJcblxyXG52YXIgVmlkZW9UcmFjayA9IGZ1bmN0aW9uIChfVHJhY2spIHtcclxuICBpbmhlcml0cyhWaWRlb1RyYWNrLCBfVHJhY2spO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cclxuICAgKiAgICAgICAgT2JqZWN0IG9mIG9wdGlvbiBuYW1lcyBhbmQgdmFsdWVzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMua2luZD0nJ11cclxuICAgKiAgICAgICAgQSB2YWxpZCB7QGxpbmsgVmlkZW9UcmFja35LaW5kfVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkPSd2anNfdHJhY2tfJyArIEd1aWQubmV3R1VJRCgpXVxyXG4gICAqICAgICAgICBBIHVuaXF1ZSBpZCBmb3IgdGhpcyBBdWRpb1RyYWNrLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsPScnXVxyXG4gICAqICAgICAgICBUaGUgbWVudSBsYWJlbCBmb3IgdGhpcyB0cmFjay5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZT0nJ11cclxuICAgKiAgICAgICAgQSB2YWxpZCB0d28gY2hhcmFjdGVyIGxhbmd1YWdlIGNvZGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbGVjdGVkXVxyXG4gICAqICAgICAgICBJZiB0aGlzIHRyYWNrIGlzIHRoZSBvbmUgdGhhdCBpcyBjdXJyZW50bHkgcGxheWluZy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBWaWRlb1RyYWNrKCkge1xyXG4gICAgdmFyIF90aGlzLCBfcmV0O1xyXG5cclxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZpZGVvVHJhY2spO1xyXG5cclxuICAgIHZhciBzZXR0aW5ncyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCB7XHJcbiAgICAgIGtpbmQ6IFZpZGVvVHJhY2tLaW5kW29wdGlvbnMua2luZF0gfHwgJydcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIG9uIElFOCB0aGlzIHdpbGwgYmUgYSBkb2N1bWVudCBlbGVtZW50XHJcbiAgICAvLyBmb3IgZXZlcnkgb3RoZXIgYnJvd3NlciB0aGlzIHdpbGwgYmUgYSBub3JtYWwgb2JqZWN0XHJcbiAgICB2YXIgdHJhY2sgPSAoX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFjay5jYWxsKHRoaXMsIHNldHRpbmdzKSksIF90aGlzKTtcclxuICAgIHZhciBzZWxlY3RlZCA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChJU19JRTgpIHtcclxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBWaWRlb1RyYWNrLnByb3RvdHlwZSkge1xyXG4gICAgICAgIGlmIChwcm9wICE9PSAnY29uc3RydWN0b3InKSB7XHJcbiAgICAgICAgICB0cmFja1twcm9wXSA9IFZpZGVvVHJhY2sucHJvdG90eXBlW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlcm9mIFZpZGVvVHJhY2tcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IHNlbGVjdGVkXHJcbiAgICAgKiAgICAgICAgIElmIHRoaXMgYFZpZGVvVHJhY2tgIGlzIHNlbGVjdGVkIG9yIG5vdC4gV2hlbiBzZXR0aW5nIHRoaXMgd2lsbFxyXG4gICAgICogICAgICAgICBmaXJlIHtAbGluayBWaWRlb1RyYWNrI3NlbGVjdGVkY2hhbmdlfSBpZiB0aGUgc3RhdGUgb2Ygc2VsZWN0ZWQgY2hhbmdlZC5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICpcclxuICAgICAqIEBmaXJlcyBWaWRlb1RyYWNrI3NlbGVjdGVkY2hhbmdlXHJcbiAgICAgKi9cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cmFjaywgJ3NlbGVjdGVkJywge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcclxuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0JCQxKG5ld1NlbGVjdGVkKSB7XHJcbiAgICAgICAgLy8gYW4gaW52YWxpZCBvciB1bmNoYW5nZWQgdmFsdWVcclxuICAgICAgICBpZiAodHlwZW9mIG5ld1NlbGVjdGVkICE9PSAnYm9vbGVhbicgfHwgbmV3U2VsZWN0ZWQgPT09IHNlbGVjdGVkKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbGVjdGVkID0gbmV3U2VsZWN0ZWQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGV2ZW50IHRoYXQgZmlyZXMgd2hlbiBzZWxlY3RlZCBjaGFuZ2VzIG9uIHRoaXMgdHJhY2suIFRoaXMgYWxsb3dzXHJcbiAgICAgICAgICogdGhlIFZpZGVvVHJhY2tMaXN0IHRoYXQgaG9sZHMgdGhpcyB0cmFjayB0byBhY3QgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiA+IE5vdGU6IFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHNwZWMhIE5hdGl2ZSB0cmFja3Mgd2lsbCBkb1xyXG4gICAgICAgICAqICAgICAgICAgdGhpcyBpbnRlcm5hbGx5IHdpdGhvdXQgYW4gZXZlbnQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXZlbnQgVmlkZW9UcmFjayNzZWxlY3RlZGNoYW5nZVxyXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3NlbGVjdGVkY2hhbmdlJyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGlmIHRoZSB1c2VyIHNldHMgdGhpcyB0cmFjayB0byBzZWxlY3RlZCB0aGVuXHJcbiAgICAvLyBzZXQgc2VsZWN0ZWQgdG8gdGhhdCB0cnVlIHZhbHVlIG90aGVyd2lzZVxyXG4gICAgLy8gd2Uga2VlcCBpdCBmYWxzZVxyXG4gICAgaWYgKHNldHRpbmdzLnNlbGVjdGVkKSB7XHJcbiAgICAgIHRyYWNrLnNlbGVjdGVkID0gc2V0dGluZ3Muc2VsZWN0ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIF9yZXQgPSB0cmFjaywgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gVmlkZW9UcmFjaztcclxufShUcmFjayk7XHJcblxyXG4vKipcclxuICogQGZpbGUgaHRtbC10cmFjay1lbGVtZW50LmpzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBtZW1iZXJvZiBIVE1MVHJhY2tFbGVtZW50XHJcbiAqIEB0eXBlZGVmIHtIVE1MVHJhY2tFbGVtZW50flJlYWR5U3RhdGV9XHJcbiAqIEBlbnVtIHtudW1iZXJ9XHJcbiAqL1xyXG52YXIgTk9ORSA9IDA7XHJcbnZhciBMT0FESU5HID0gMTtcclxudmFyIExPQURFRCA9IDI7XHJcbnZhciBFUlJPUiA9IDM7XHJcblxyXG4vKipcclxuICogQSBzaW5nbGUgdHJhY2sgcmVwcmVzZW50ZWQgaW4gdGhlIERPTS5cclxuICpcclxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2h0bWx0cmFja2VsZW1lbnR9XHJcbiAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XHJcbiAqL1xyXG5cclxudmFyIEhUTUxUcmFja0VsZW1lbnQgPSBmdW5jdGlvbiAoX0V2ZW50VGFyZ2V0KSB7XHJcbiAgaW5oZXJpdHMoSFRNTFRyYWNrRWxlbWVudCwgX0V2ZW50VGFyZ2V0KTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucz17fVxyXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VGVjaH0gb3B0aW9ucy50ZWNoXHJcbiAgICogICAgICAgIEEgcmVmZXJlbmNlIHRvIHRoZSB0ZWNoIHRoYXQgb3ducyB0aGlzIEhUTUxUcmFja0VsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RleHRUcmFja35LaW5kfSBbb3B0aW9ucy5raW5kPSdzdWJ0aXRsZXMnXVxyXG4gICAqICAgICAgICBBIHZhbGlkIHRleHQgdHJhY2sga2luZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfk1vZGV9IFtvcHRpb25zLm1vZGU9J2Rpc2FibGVkJ11cclxuICAgKiAgICAgICAgQSB2YWxpZCB0ZXh0IHRyYWNrIG1vZGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWQ9J3Zqc190cmFja18nICsgR3VpZC5uZXdHVUlEKCldXHJcbiAgICogICAgICAgIEEgdW5pcXVlIGlkIGZvciB0aGlzIFRleHRUcmFjay5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbD0nJ11cclxuICAgKiAgICAgICAgVGhlIG1lbnUgbGFiZWwgZm9yIHRoaXMgdHJhY2suXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2U9JyddXHJcbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY2xhbmc9JyddXHJcbiAgICogICAgICAgIEEgdmFsaWQgdHdvIGNoYXJhY3RlciBsYW5ndWFnZSBjb2RlLiBBbiBhbHRlcm5hdGl2ZSwgYnV0IGRlcHJpb3JpdGl6ZWRcclxuICAgKiAgICAgICAgdmVzaW9uIG9mIGBvcHRpb25zLmxhbmd1YWdlYFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNyY11cclxuICAgKiAgICAgICAgQSB1cmwgdG8gVGV4dFRyYWNrIGN1ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlZmF1bHRdXHJcbiAgICogICAgICAgIElmIHRoaXMgdHJhY2sgc2hvdWxkIGRlZmF1bHQgdG8gb24gb3Igb2ZmLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIEhUTUxUcmFja0VsZW1lbnQoKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBIVE1MVHJhY2tFbGVtZW50KTtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudFRhcmdldC5jYWxsKHRoaXMpKTtcclxuXHJcbiAgICB2YXIgcmVhZHlTdGF0ZSA9IHZvaWQgMDtcclxuICAgIHZhciB0cmFja0VsZW1lbnQgPSBfdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG5cclxuICAgIGlmIChJU19JRTgpIHtcclxuICAgICAgdHJhY2tFbGVtZW50ID0gZG9jdW1lbnRfMS5jcmVhdGVFbGVtZW50KCdjdXN0b20nKTtcclxuXHJcbiAgICAgIGZvciAodmFyIHByb3AgaW4gSFRNTFRyYWNrRWxlbWVudC5wcm90b3R5cGUpIHtcclxuICAgICAgICBpZiAocHJvcCAhPT0gJ2NvbnN0cnVjdG9yJykge1xyXG4gICAgICAgICAgdHJhY2tFbGVtZW50W3Byb3BdID0gSFRNTFRyYWNrRWxlbWVudC5wcm90b3R5cGVbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRyYWNrID0gbmV3IFRleHRUcmFjayhvcHRpb25zKTtcclxuXHJcbiAgICB0cmFja0VsZW1lbnQua2luZCA9IHRyYWNrLmtpbmQ7XHJcbiAgICB0cmFja0VsZW1lbnQuc3JjID0gdHJhY2suc3JjO1xyXG4gICAgdHJhY2tFbGVtZW50LnNyY2xhbmcgPSB0cmFjay5sYW5ndWFnZTtcclxuICAgIHRyYWNrRWxlbWVudC5sYWJlbCA9IHRyYWNrLmxhYmVsO1xyXG4gICAgdHJhY2tFbGVtZW50WydkZWZhdWx0J10gPSB0cmFja1snZGVmYXVsdCddO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlcm9mIEhUTUxUcmFja0VsZW1lbnRcclxuICAgICAqIEBtZW1iZXIge0hUTUxUcmFja0VsZW1lbnR+UmVhZHlTdGF0ZX0gcmVhZHlTdGF0ZVxyXG4gICAgICogICAgICAgICBUaGUgY3VycmVudCByZWFkeSBzdGF0ZSBvZiB0aGUgdHJhY2sgZWxlbWVudC5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2tFbGVtZW50LCAncmVhZHlTdGF0ZScsIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlYWR5U3RhdGU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlcm9mIEhUTUxUcmFja0VsZW1lbnRcclxuICAgICAqIEBtZW1iZXIge1RleHRUcmFja30gdHJhY2tcclxuICAgICAqICAgICAgICAgVGhlIHVuZGVybHlpbmcgVGV4dFRyYWNrIG9iamVjdC5cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRyYWNrRWxlbWVudCwgJ3RyYWNrJywge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcclxuICAgICAgICByZXR1cm4gdHJhY2s7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJlYWR5U3RhdGUgPSBOT05FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGxpc3RlbnMgVGV4dFRyYWNrI2xvYWRlZGRhdGFcclxuICAgICAqIEBmaXJlcyBIVE1MVHJhY2tFbGVtZW50I2xvYWRcclxuICAgICAqL1xyXG4gICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkZGF0YScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmVhZHlTdGF0ZSA9IExPQURFRDtcclxuXHJcbiAgICAgIHRyYWNrRWxlbWVudC50cmlnZ2VyKHtcclxuICAgICAgICB0eXBlOiAnbG9hZCcsXHJcbiAgICAgICAgdGFyZ2V0OiB0cmFja0VsZW1lbnRcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoSVNfSUU4KSB7XHJcbiAgICAgIHZhciBfcmV0O1xyXG5cclxuICAgICAgcmV0dXJuIF9yZXQgPSB0cmFja0VsZW1lbnQsIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIEhUTUxUcmFja0VsZW1lbnQ7XHJcbn0oRXZlbnRUYXJnZXQpO1xyXG5cclxuSFRNTFRyYWNrRWxlbWVudC5wcm90b3R5cGUuYWxsb3dlZEV2ZW50c18gPSB7XHJcbiAgbG9hZDogJ2xvYWQnXHJcbn07XHJcblxyXG5IVE1MVHJhY2tFbGVtZW50Lk5PTkUgPSBOT05FO1xyXG5IVE1MVHJhY2tFbGVtZW50LkxPQURJTkcgPSBMT0FESU5HO1xyXG5IVE1MVHJhY2tFbGVtZW50LkxPQURFRCA9IExPQURFRDtcclxuSFRNTFRyYWNrRWxlbWVudC5FUlJPUiA9IEVSUk9SO1xyXG5cclxuLypcclxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGFsbCB0cmFjayBwcm9wZXJ0aWVzIHRoYXQgYXJlIHVzZWQgaW5cclxuICogcGxheWVyLmpzLCB0ZWNoLmpzLCBodG1sNS5qcyBhbmQgcG9zc2libHkgb3RoZXIgdGVjaHMgaW4gdGhlIGZ1dHVyZS5cclxuICovXHJcblxyXG52YXIgTk9STUFMID0ge1xyXG4gIGF1ZGlvOiB7XHJcbiAgICBMaXN0Q2xhc3M6IEF1ZGlvVHJhY2tMaXN0LFxyXG4gICAgVHJhY2tDbGFzczogQXVkaW9UcmFjayxcclxuICAgIGNhcGl0YWxOYW1lOiAnQXVkaW8nXHJcbiAgfSxcclxuICB2aWRlbzoge1xyXG4gICAgTGlzdENsYXNzOiBWaWRlb1RyYWNrTGlzdCxcclxuICAgIFRyYWNrQ2xhc3M6IFZpZGVvVHJhY2ssXHJcbiAgICBjYXBpdGFsTmFtZTogJ1ZpZGVvJ1xyXG4gIH0sXHJcbiAgdGV4dDoge1xyXG4gICAgTGlzdENsYXNzOiBUZXh0VHJhY2tMaXN0LFxyXG4gICAgVHJhY2tDbGFzczogVGV4dFRyYWNrLFxyXG4gICAgY2FwaXRhbE5hbWU6ICdUZXh0J1xyXG4gIH1cclxufTtcclxuXHJcbk9iamVjdC5rZXlzKE5PUk1BTCkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gIE5PUk1BTFt0eXBlXS5nZXR0ZXJOYW1lID0gdHlwZSArICdUcmFja3MnO1xyXG4gIE5PUk1BTFt0eXBlXS5wcml2YXRlTmFtZSA9IHR5cGUgKyAnVHJhY2tzXyc7XHJcbn0pO1xyXG5cclxudmFyIFJFTU9URSA9IHtcclxuICByZW1vdGVUZXh0OiB7XHJcbiAgICBMaXN0Q2xhc3M6IFRleHRUcmFja0xpc3QsXHJcbiAgICBUcmFja0NsYXNzOiBUZXh0VHJhY2ssXHJcbiAgICBjYXBpdGFsTmFtZTogJ1JlbW90ZVRleHQnLFxyXG4gICAgZ2V0dGVyTmFtZTogJ3JlbW90ZVRleHRUcmFja3MnLFxyXG4gICAgcHJpdmF0ZU5hbWU6ICdyZW1vdGVUZXh0VHJhY2tzXydcclxuICB9LFxyXG4gIHJlbW90ZVRleHRFbDoge1xyXG4gICAgTGlzdENsYXNzOiBIdG1sVHJhY2tFbGVtZW50TGlzdCxcclxuICAgIFRyYWNrQ2xhc3M6IEhUTUxUcmFja0VsZW1lbnQsXHJcbiAgICBjYXBpdGFsTmFtZTogJ1JlbW90ZVRleHRUcmFja0VscycsXHJcbiAgICBnZXR0ZXJOYW1lOiAncmVtb3RlVGV4dFRyYWNrRWxzJyxcclxuICAgIHByaXZhdGVOYW1lOiAncmVtb3RlVGV4dFRyYWNrRWxzXydcclxuICB9XHJcbn07XHJcblxyXG52YXIgQUxMID0gbWVyZ2VPcHRpb25zKE5PUk1BTCwgUkVNT1RFKTtcclxuXHJcblJFTU9URS5uYW1lcyA9IE9iamVjdC5rZXlzKFJFTU9URSk7XHJcbk5PUk1BTC5uYW1lcyA9IE9iamVjdC5rZXlzKE5PUk1BTCk7XHJcbkFMTC5uYW1lcyA9IFtdLmNvbmNhdChSRU1PVEUubmFtZXMpLmNvbmNhdChOT1JNQUwubmFtZXMpO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qIC0qLSBNb2RlOiBKYXZhOyB0YWItd2lkdGg6IDI7IGluZGVudC10YWJzLW1vZGU6IG5pbDsgYy1iYXNpYy1vZmZzZXQ6IDIgLSotICovXHJcbi8qIHZpbTogc2V0IHNoaWZ0d2lkdGg9MiB0YWJzdG9wPTIgYXV0b2luZGVudCBjaW5kZW50IGV4cGFuZHRhYjogKi9cclxudmFyIF9vYmpDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbigpIHtcclxuICBmdW5jdGlvbiBGKCkge31cclxuICByZXR1cm4gZnVuY3Rpb24obykge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDEpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPYmplY3QuY3JlYXRlIHNoaW0gb25seSBhY2NlcHRzIG9uZSBwYXJhbWV0ZXIuJyk7XHJcbiAgICB9XHJcbiAgICBGLnByb3RvdHlwZSA9IG87XHJcbiAgICByZXR1cm4gbmV3IEYoKTtcclxuICB9O1xyXG59KSgpO1xyXG5cclxuLy8gQ3JlYXRlcyBhIG5ldyBQYXJzZXJFcnJvciBvYmplY3QgZnJvbSBhbiBlcnJvckRhdGEgb2JqZWN0LiBUaGUgZXJyb3JEYXRhXHJcbi8vIG9iamVjdCBzaG91bGQgaGF2ZSBkZWZhdWx0IGNvZGUgYW5kIG1lc3NhZ2UgcHJvcGVydGllcy4gVGhlIGRlZmF1bHQgbWVzc2FnZVxyXG4vLyBwcm9wZXJ0eSBjYW4gYmUgb3ZlcnJpZGVuIGJ5IHBhc3NpbmcgaW4gYSBtZXNzYWdlIHBhcmFtZXRlci5cclxuLy8gU2VlIFBhcnNpbmdFcnJvci5FcnJvcnMgYmVsb3cgZm9yIGFjY2VwdGFibGUgZXJyb3JzLlxyXG5mdW5jdGlvbiBQYXJzaW5nRXJyb3IoZXJyb3JEYXRhLCBtZXNzYWdlKSB7XHJcbiAgdGhpcy5uYW1lID0gXCJQYXJzaW5nRXJyb3JcIjtcclxuICB0aGlzLmNvZGUgPSBlcnJvckRhdGEuY29kZTtcclxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IGVycm9yRGF0YS5tZXNzYWdlO1xyXG59XHJcblBhcnNpbmdFcnJvci5wcm90b3R5cGUgPSBfb2JqQ3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XHJcblBhcnNpbmdFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJzaW5nRXJyb3I7XHJcblxyXG4vLyBQYXJzaW5nRXJyb3IgbWV0YWRhdGEgZm9yIGFjY2VwdGFibGUgUGFyc2luZ0Vycm9ycy5cclxuUGFyc2luZ0Vycm9yLkVycm9ycyA9IHtcclxuICBCYWRTaWduYXR1cmU6IHtcclxuICAgIGNvZGU6IDAsXHJcbiAgICBtZXNzYWdlOiBcIk1hbGZvcm1lZCBXZWJWVFQgc2lnbmF0dXJlLlwiXHJcbiAgfSxcclxuICBCYWRUaW1lU3RhbXA6IHtcclxuICAgIGNvZGU6IDEsXHJcbiAgICBtZXNzYWdlOiBcIk1hbGZvcm1lZCB0aW1lIHN0YW1wLlwiXHJcbiAgfVxyXG59O1xyXG5cclxuLy8gVHJ5IHRvIHBhcnNlIGlucHV0IGFzIGEgdGltZSBzdGFtcC5cclxuZnVuY3Rpb24gcGFyc2VUaW1lU3RhbXAoaW5wdXQpIHtcclxuXHJcbiAgZnVuY3Rpb24gY29tcHV0ZVNlY29uZHMoaCwgbSwgcywgZikge1xyXG4gICAgcmV0dXJuIChoIHwgMCkgKiAzNjAwICsgKG0gfCAwKSAqIDYwICsgKHMgfCAwKSArIChmIHwgMCkgLyAxMDAwO1xyXG4gIH1cclxuXHJcbiAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihcXGQrKTooXFxkezJ9KSg6XFxkezJ9KT9cXC4oXFxkezN9KS8pO1xyXG4gIGlmICghbSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBpZiAobVszXSkge1xyXG4gICAgLy8gVGltZXN0YW1wIHRha2VzIHRoZSBmb3JtIG9mIFtob3Vyc106W21pbnV0ZXNdOltzZWNvbmRzXS5bbWlsbGlzZWNvbmRzXVxyXG4gICAgcmV0dXJuIGNvbXB1dGVTZWNvbmRzKG1bMV0sIG1bMl0sIG1bM10ucmVwbGFjZShcIjpcIiwgXCJcIiksIG1bNF0pO1xyXG4gIH0gZWxzZSBpZiAobVsxXSA+IDU5KSB7XHJcbiAgICAvLyBUaW1lc3RhbXAgdGFrZXMgdGhlIGZvcm0gb2YgW2hvdXJzXTpbbWludXRlc10uW21pbGxpc2Vjb25kc11cclxuICAgIC8vIEZpcnN0IHBvc2l0aW9uIGlzIGhvdXJzIGFzIGl0J3Mgb3ZlciA1OS5cclxuICAgIHJldHVybiBjb21wdXRlU2Vjb25kcyhtWzFdLCBtWzJdLCAwLCAgbVs0XSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIFRpbWVzdGFtcCB0YWtlcyB0aGUgZm9ybSBvZiBbbWludXRlc106W3NlY29uZHNdLlttaWxsaXNlY29uZHNdXHJcbiAgICByZXR1cm4gY29tcHV0ZVNlY29uZHMoMCwgbVsxXSwgbVsyXSwgbVs0XSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBBIHNldHRpbmdzIG9iamVjdCBob2xkcyBrZXkvdmFsdWUgcGFpcnMgYW5kIHdpbGwgaWdub3JlIGFueXRoaW5nIGJ1dCB0aGUgZmlyc3RcclxuLy8gYXNzaWdubWVudCB0byBhIHNwZWNpZmljIGtleS5cclxuZnVuY3Rpb24gU2V0dGluZ3MoKSB7XHJcbiAgdGhpcy52YWx1ZXMgPSBfb2JqQ3JlYXRlKG51bGwpO1xyXG59XHJcblxyXG5TZXR0aW5ncy5wcm90b3R5cGUgPSB7XHJcbiAgLy8gT25seSBhY2NlcHQgdGhlIGZpcnN0IGFzc2lnbm1lbnQgdG8gYW55IGtleS5cclxuICBzZXQ6IGZ1bmN0aW9uKGssIHYpIHtcclxuICAgIGlmICghdGhpcy5nZXQoaykgJiYgdiAhPT0gXCJcIikge1xyXG4gICAgICB0aGlzLnZhbHVlc1trXSA9IHY7XHJcbiAgICB9XHJcbiAgfSxcclxuICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciBhIGtleSwgb3IgYSBkZWZhdWx0IHZhbHVlLlxyXG4gIC8vIElmICdkZWZhdWx0S2V5JyBpcyBwYXNzZWQgdGhlbiAnZGZsdCcgaXMgYXNzdW1lZCB0byBiZSBhbiBvYmplY3Qgd2l0aFxyXG4gIC8vIGEgbnVtYmVyIG9mIHBvc3NpYmxlIGRlZmF1bHQgdmFsdWVzIGFzIHByb3BlcnRpZXMgd2hlcmUgJ2RlZmF1bHRLZXknIGlzXHJcbiAgLy8gdGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIGNob3Nlbjsgb3RoZXJ3aXNlIGl0J3MgYXNzdW1lZCB0byBiZVxyXG4gIC8vIGEgc2luZ2xlIHZhbHVlLlxyXG4gIGdldDogZnVuY3Rpb24oaywgZGZsdCwgZGVmYXVsdEtleSkge1xyXG4gICAgaWYgKGRlZmF1bHRLZXkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0W2RlZmF1bHRLZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuaGFzKGspID8gdGhpcy52YWx1ZXNba10gOiBkZmx0O1xyXG4gIH0sXHJcbiAgLy8gQ2hlY2sgd2hldGhlciB3ZSBoYXZlIGEgdmFsdWUgZm9yIGEga2V5LlxyXG4gIGhhczogZnVuY3Rpb24oaykge1xyXG4gICAgcmV0dXJuIGsgaW4gdGhpcy52YWx1ZXM7XHJcbiAgfSxcclxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBvbmUgb2YgdGhlIGdpdmVuIGFsdGVybmF0aXZlcy5cclxuICBhbHQ6IGZ1bmN0aW9uKGssIHYsIGEpIHtcclxuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgYS5sZW5ndGg7ICsrbikge1xyXG4gICAgICBpZiAodiA9PT0gYVtuXSkge1xyXG4gICAgICAgIHRoaXMuc2V0KGssIHYpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIChzaWduZWQpIGludGVnZXIuXHJcbiAgaW50ZWdlcjogZnVuY3Rpb24oaywgdikge1xyXG4gICAgaWYgKC9eLT9cXGQrJC8udGVzdCh2KSkgeyAvLyBpbnRlZ2VyXHJcbiAgICAgIHRoaXMuc2V0KGssIHBhcnNlSW50KHYsIDEwKSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIHBlcmNlbnRhZ2UuXHJcbiAgcGVyY2VudDogZnVuY3Rpb24oaywgdikge1xyXG4gICAgdmFyIG07XHJcbiAgICBpZiAoKG0gPSB2Lm1hdGNoKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvKSkpIHtcclxuICAgICAgdiA9IHBhcnNlRmxvYXQodik7XHJcbiAgICAgIGlmICh2ID49IDAgJiYgdiA8PSAxMDApIHtcclxuICAgICAgICB0aGlzLnNldChrLCB2KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEhlbHBlciBmdW5jdGlvbiB0byBwYXJzZSBpbnB1dCBpbnRvIGdyb3VwcyBzZXBhcmF0ZWQgYnkgJ2dyb3VwRGVsaW0nLCBhbmRcclxuLy8gaW50ZXJwcmV0ZSBlYWNoIGdyb3VwIGFzIGEga2V5L3ZhbHVlIHBhaXIgc2VwYXJhdGVkIGJ5ICdrZXlWYWx1ZURlbGltJy5cclxuZnVuY3Rpb24gcGFyc2VPcHRpb25zKGlucHV0LCBjYWxsYmFjaywga2V5VmFsdWVEZWxpbSwgZ3JvdXBEZWxpbSkge1xyXG4gIHZhciBncm91cHMgPSBncm91cERlbGltID8gaW5wdXQuc3BsaXQoZ3JvdXBEZWxpbSkgOiBbaW5wdXRdO1xyXG4gIGZvciAodmFyIGkgaW4gZ3JvdXBzKSB7XHJcbiAgICBpZiAodHlwZW9mIGdyb3Vwc1tpXSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIHZhciBrdiA9IGdyb3Vwc1tpXS5zcGxpdChrZXlWYWx1ZURlbGltKTtcclxuICAgIGlmIChrdi5sZW5ndGggIT09IDIpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICB2YXIgayA9IGt2WzBdO1xyXG4gICAgdmFyIHYgPSBrdlsxXTtcclxuICAgIGNhbGxiYWNrKGssIHYpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VDdWUoaW5wdXQsIGN1ZSwgcmVnaW9uTGlzdCkge1xyXG4gIC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCBpbnB1dCBpZiB3ZSBuZWVkIHRvIHRocm93IGFuIGVycm9yLlxyXG4gIHZhciBvSW5wdXQgPSBpbnB1dDtcclxuICAvLyA0LjEgV2ViVlRUIHRpbWVzdGFtcFxyXG4gIGZ1bmN0aW9uIGNvbnN1bWVUaW1lU3RhbXAoKSB7XHJcbiAgICB2YXIgdHMgPSBwYXJzZVRpbWVTdGFtcChpbnB1dCk7XHJcbiAgICBpZiAodHMgPT09IG51bGwpIHtcclxuICAgICAgdGhyb3cgbmV3IFBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3IuRXJyb3JzLkJhZFRpbWVTdGFtcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTWFsZm9ybWVkIHRpbWVzdGFtcDogXCIgKyBvSW5wdXQpO1xyXG4gICAgfVxyXG4gICAgLy8gUmVtb3ZlIHRpbWUgc3RhbXAgZnJvbSBpbnB1dC5cclxuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXlteXFxzYS16QS1aLV0rLywgXCJcIik7XHJcbiAgICByZXR1cm4gdHM7XHJcbiAgfVxyXG5cclxuICAvLyA0LjQuMiBXZWJWVFQgY3VlIHNldHRpbmdzXHJcbiAgZnVuY3Rpb24gY29uc3VtZUN1ZVNldHRpbmdzKGlucHV0LCBjdWUpIHtcclxuICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xyXG5cclxuICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgICAgc3dpdGNoIChrKSB7XHJcbiAgICAgIGNhc2UgXCJyZWdpb25cIjpcclxuICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IHJlZ2lvbiB3ZSBwYXJzZWQgd2l0aCB0aGUgc2FtZSByZWdpb24gaWQuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHJlZ2lvbkxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgIGlmIChyZWdpb25MaXN0W2ldLmlkID09PSB2KSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnNldChrLCByZWdpb25MaXN0W2ldLnJlZ2lvbik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XHJcbiAgICAgICAgc2V0dGluZ3MuYWx0KGssIHYsIFtcInJsXCIsIFwibHJcIl0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwibGluZVwiOlxyXG4gICAgICAgIHZhciB2YWxzID0gdi5zcGxpdChcIixcIiksXHJcbiAgICAgICAgICAgIHZhbHMwID0gdmFsc1swXTtcclxuICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHZhbHMwKTtcclxuICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHZhbHMwKSA/IHNldHRpbmdzLnNldChcInNuYXBUb0xpbmVzXCIsIGZhbHNlKSA6IG51bGw7XHJcbiAgICAgICAgc2V0dGluZ3MuYWx0KGssIHZhbHMwLCBbXCJhdXRvXCJdKTtcclxuICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgIHNldHRpbmdzLmFsdChcImxpbmVBbGlnblwiLCB2YWxzWzFdLCBbXCJzdGFydFwiLCBcIm1pZGRsZVwiLCBcImVuZFwiXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwicG9zaXRpb25cIjpcclxuICAgICAgICB2YWxzID0gdi5zcGxpdChcIixcIik7XHJcbiAgICAgICAgc2V0dGluZ3MucGVyY2VudChrLCB2YWxzWzBdKTtcclxuICAgICAgICBpZiAodmFscy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgIHNldHRpbmdzLmFsdChcInBvc2l0aW9uQWxpZ25cIiwgdmFsc1sxXSwgW1wic3RhcnRcIiwgXCJtaWRkbGVcIiwgXCJlbmRcIl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBcInNpemVcIjpcclxuICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHYpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIFwiYWxpZ25cIjpcclxuICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgW1wic3RhcnRcIiwgXCJtaWRkbGVcIiwgXCJlbmRcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9LCAvOi8sIC9cXHMvKTtcclxuXHJcbiAgICAvLyBBcHBseSBkZWZhdWx0IHZhbHVlcyBmb3IgYW55IG1pc3NpbmcgZmllbGRzLlxyXG4gICAgY3VlLnJlZ2lvbiA9IHNldHRpbmdzLmdldChcInJlZ2lvblwiLCBudWxsKTtcclxuICAgIGN1ZS52ZXJ0aWNhbCA9IHNldHRpbmdzLmdldChcInZlcnRpY2FsXCIsIFwiXCIpO1xyXG4gICAgY3VlLmxpbmUgPSBzZXR0aW5ncy5nZXQoXCJsaW5lXCIsIFwiYXV0b1wiKTtcclxuICAgIGN1ZS5saW5lQWxpZ24gPSBzZXR0aW5ncy5nZXQoXCJsaW5lQWxpZ25cIiwgXCJzdGFydFwiKTtcclxuICAgIGN1ZS5zbmFwVG9MaW5lcyA9IHNldHRpbmdzLmdldChcInNuYXBUb0xpbmVzXCIsIHRydWUpO1xyXG4gICAgY3VlLnNpemUgPSBzZXR0aW5ncy5nZXQoXCJzaXplXCIsIDEwMCk7XHJcbiAgICBjdWUuYWxpZ24gPSBzZXR0aW5ncy5nZXQoXCJhbGlnblwiLCBcIm1pZGRsZVwiKTtcclxuICAgIGN1ZS5wb3NpdGlvbiA9IHNldHRpbmdzLmdldChcInBvc2l0aW9uXCIsIHtcclxuICAgICAgc3RhcnQ6IDAsXHJcbiAgICAgIGxlZnQ6IDAsXHJcbiAgICAgIG1pZGRsZTogNTAsXHJcbiAgICAgIGVuZDogMTAwLFxyXG4gICAgICByaWdodDogMTAwXHJcbiAgICB9LCBjdWUuYWxpZ24pO1xyXG4gICAgY3VlLnBvc2l0aW9uQWxpZ24gPSBzZXR0aW5ncy5nZXQoXCJwb3NpdGlvbkFsaWduXCIsIHtcclxuICAgICAgc3RhcnQ6IFwic3RhcnRcIixcclxuICAgICAgbGVmdDogXCJzdGFydFwiLFxyXG4gICAgICBtaWRkbGU6IFwibWlkZGxlXCIsXHJcbiAgICAgIGVuZDogXCJlbmRcIixcclxuICAgICAgcmlnaHQ6IFwiZW5kXCJcclxuICAgIH0sIGN1ZS5hbGlnbik7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBza2lwV2hpdGVzcGFjZSgpIHtcclxuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXlxccysvLCBcIlwiKTtcclxuICB9XHJcblxyXG4gIC8vIDQuMSBXZWJWVFQgY3VlIHRpbWluZ3MuXHJcbiAgc2tpcFdoaXRlc3BhY2UoKTtcclxuICBjdWUuc3RhcnRUaW1lID0gY29uc3VtZVRpbWVTdGFtcCgpOyAgIC8vICgxKSBjb2xsZWN0IGN1ZSBzdGFydCB0aW1lXHJcbiAgc2tpcFdoaXRlc3BhY2UoKTtcclxuICBpZiAoaW5wdXQuc3Vic3RyKDAsIDMpICE9PSBcIi0tPlwiKSB7ICAgICAvLyAoMykgbmV4dCBjaGFyYWN0ZXJzIG11c3QgbWF0Y2ggXCItLT5cIlxyXG4gICAgdGhyb3cgbmV3IFBhcnNpbmdFcnJvcihQYXJzaW5nRXJyb3IuRXJyb3JzLkJhZFRpbWVTdGFtcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNYWxmb3JtZWQgdGltZSBzdGFtcCAodGltZSBzdGFtcHMgbXVzdCBiZSBzZXBhcmF0ZWQgYnkgJy0tPicpOiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9JbnB1dCk7XHJcbiAgfVxyXG4gIGlucHV0ID0gaW5wdXQuc3Vic3RyKDMpO1xyXG4gIHNraXBXaGl0ZXNwYWNlKCk7XHJcbiAgY3VlLmVuZFRpbWUgPSBjb25zdW1lVGltZVN0YW1wKCk7ICAgICAvLyAoNSkgY29sbGVjdCBjdWUgZW5kIHRpbWVcclxuXHJcbiAgLy8gNC4xIFdlYlZUVCBjdWUgc2V0dGluZ3MgbGlzdC5cclxuICBza2lwV2hpdGVzcGFjZSgpO1xyXG4gIGNvbnN1bWVDdWVTZXR0aW5ncyhpbnB1dCwgY3VlKTtcclxufVxyXG5cclxudmFyIEVTQ0FQRSA9IHtcclxuICBcIiZhbXA7XCI6IFwiJlwiLFxyXG4gIFwiJmx0O1wiOiBcIjxcIixcclxuICBcIiZndDtcIjogXCI+XCIsXHJcbiAgXCImbHJtO1wiOiBcIlxcdTIwMGVcIixcclxuICBcIiZybG07XCI6IFwiXFx1MjAwZlwiLFxyXG4gIFwiJm5ic3A7XCI6IFwiXFx1MDBhMFwiXHJcbn07XHJcblxyXG52YXIgVEFHX05BTUUgPSB7XHJcbiAgYzogXCJzcGFuXCIsXHJcbiAgaTogXCJpXCIsXHJcbiAgYjogXCJiXCIsXHJcbiAgdTogXCJ1XCIsXHJcbiAgcnVieTogXCJydWJ5XCIsXHJcbiAgcnQ6IFwicnRcIixcclxuICB2OiBcInNwYW5cIixcclxuICBsYW5nOiBcInNwYW5cIlxyXG59O1xyXG5cclxudmFyIFRBR19BTk5PVEFUSU9OID0ge1xyXG4gIHY6IFwidGl0bGVcIixcclxuICBsYW5nOiBcImxhbmdcIlxyXG59O1xyXG5cclxudmFyIE5FRURTX1BBUkVOVCA9IHtcclxuICBydDogXCJydWJ5XCJcclxufTtcclxuXHJcbi8vIFBhcnNlIGNvbnRlbnQgaW50byBhIGRvY3VtZW50IGZyYWdtZW50LlxyXG5mdW5jdGlvbiBwYXJzZUNvbnRlbnQod2luZG93LCBpbnB1dCkge1xyXG4gIGZ1bmN0aW9uIG5leHRUb2tlbigpIHtcclxuICAgIC8vIENoZWNrIGZvciBlbmQtb2Ytc3RyaW5nLlxyXG4gICAgaWYgKCFpbnB1dCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb25zdW1lICduJyBjaGFyYWN0ZXJzIGZyb20gdGhlIGlucHV0LlxyXG4gICAgZnVuY3Rpb24gY29uc3VtZShyZXN1bHQpIHtcclxuICAgICAgaW5wdXQgPSBpbnB1dC5zdWJzdHIocmVzdWx0Lmxlbmd0aCk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihbXjxdKikoPFtePl0rPj8pPy8pO1xyXG4gICAgLy8gSWYgdGhlcmUgaXMgc29tZSB0ZXh0IGJlZm9yZSB0aGUgbmV4dCB0YWcsIHJldHVybiBpdCwgb3RoZXJ3aXNlIHJldHVyblxyXG4gICAgLy8gdGhlIHRhZy5cclxuICAgIHJldHVybiBjb25zdW1lKG1bMV0gPyBtWzFdIDogbVsyXSk7XHJcbiAgfVxyXG5cclxuICAvLyBVbmVzY2FwZSBhIHN0cmluZyAncycuXHJcbiAgZnVuY3Rpb24gdW5lc2NhcGUxKGUpIHtcclxuICAgIHJldHVybiBFU0NBUEVbZV07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHVuZXNjYXBlKHMpIHtcclxuICAgIHdoaWxlICgobSA9IHMubWF0Y2goLyYoYW1wfGx0fGd0fGxybXxybG18bmJzcCk7LykpKSB7XHJcbiAgICAgIHMgPSBzLnJlcGxhY2UobVswXSwgdW5lc2NhcGUxKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2hvdWxkQWRkKGN1cnJlbnQsIGVsZW1lbnQpIHtcclxuICAgIHJldHVybiAhTkVFRFNfUEFSRU5UW2VsZW1lbnQubG9jYWxOYW1lXSB8fFxyXG4gICAgICAgICAgIE5FRURTX1BBUkVOVFtlbGVtZW50LmxvY2FsTmFtZV0gPT09IGN1cnJlbnQubG9jYWxOYW1lO1xyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlIGFuIGVsZW1lbnQgZm9yIHRoaXMgdGFnLlxyXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgYW5ub3RhdGlvbikge1xyXG4gICAgdmFyIHRhZ05hbWUgPSBUQUdfTkFNRVt0eXBlXTtcclxuICAgIGlmICghdGFnTmFtZSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHZhciBlbGVtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XHJcbiAgICBlbGVtZW50LmxvY2FsTmFtZSA9IHRhZ05hbWU7XHJcbiAgICB2YXIgbmFtZSA9IFRBR19BTk5PVEFUSU9OW3R5cGVdO1xyXG4gICAgaWYgKG5hbWUgJiYgYW5ub3RhdGlvbikge1xyXG4gICAgICBlbGVtZW50W25hbWVdID0gYW5ub3RhdGlvbi50cmltKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxuICB9XHJcblxyXG4gIHZhciByb290RGl2ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXHJcbiAgICAgIGN1cnJlbnQgPSByb290RGl2LFxyXG4gICAgICB0LFxyXG4gICAgICB0YWdTdGFjayA9IFtdO1xyXG5cclxuICB3aGlsZSAoKHQgPSBuZXh0VG9rZW4oKSkgIT09IG51bGwpIHtcclxuICAgIGlmICh0WzBdID09PSAnPCcpIHtcclxuICAgICAgaWYgKHRbMV0gPT09IFwiL1wiKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIGNsb3NpbmcgdGFnIG1hdGNoZXMsIG1vdmUgYmFjayB1cCB0byB0aGUgcGFyZW50IG5vZGUuXHJcbiAgICAgICAgaWYgKHRhZ1N0YWNrLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICB0YWdTdGFja1t0YWdTdGFjay5sZW5ndGggLSAxXSA9PT0gdC5zdWJzdHIoMikucmVwbGFjZShcIj5cIiwgXCJcIikpIHtcclxuICAgICAgICAgIHRhZ1N0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGp1c3QgaWdub3JlIHRoZSBlbmQgdGFnLlxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB0cyA9IHBhcnNlVGltZVN0YW1wKHQuc3Vic3RyKDEsIHQubGVuZ3RoIC0gMikpO1xyXG4gICAgICB2YXIgbm9kZTtcclxuICAgICAgaWYgKHRzKSB7XHJcbiAgICAgICAgLy8gVGltZXN0YW1wcyBhcmUgbGVhZCBub2RlcyBhcyB3ZWxsLlxyXG4gICAgICAgIG5vZGUgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlUHJvY2Vzc2luZ0luc3RydWN0aW9uKFwidGltZXN0YW1wXCIsIHRzKTtcclxuICAgICAgICBjdXJyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBtID0gdC5tYXRjaCgvXjwoW14uXFxzLzAtOT5dKykoXFwuW15cXHNcXFxcPl0rKT8oW14+XFxcXF0rKT8oXFxcXD8pPj8kLyk7XHJcbiAgICAgIC8vIElmIHdlIGNhbid0IHBhcnNlIHRoZSB0YWcsIHNraXAgdG8gdGhlIG5leHQgdGFnLlxyXG4gICAgICBpZiAoIW0pIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICAvLyBUcnkgdG8gY29uc3RydWN0IGFuIGVsZW1lbnQsIGFuZCBpZ25vcmUgdGhlIHRhZyBpZiB3ZSBjb3VsZG4ndC5cclxuICAgICAgbm9kZSA9IGNyZWF0ZUVsZW1lbnQobVsxXSwgbVszXSk7XHJcbiAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIERldGVybWluZSBpZiB0aGUgdGFnIHNob3VsZCBiZSBhZGRlZCBiYXNlZCBvbiB0aGUgY29udGV4dCBvZiB3aGVyZSBpdFxyXG4gICAgICAvLyBpcyBwbGFjZWQgaW4gdGhlIGN1ZXRleHQuXHJcbiAgICAgIGlmICghc2hvdWxkQWRkKGN1cnJlbnQsIG5vZGUpKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgLy8gU2V0IHRoZSBjbGFzcyBsaXN0IChhcyBhIGxpc3Qgb2YgY2xhc3Nlcywgc2VwYXJhdGVkIGJ5IHNwYWNlKS5cclxuICAgICAgaWYgKG1bMl0pIHtcclxuICAgICAgICBub2RlLmNsYXNzTmFtZSA9IG1bMl0uc3Vic3RyKDEpLnJlcGxhY2UoJy4nLCAnICcpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIEFwcGVuZCB0aGUgbm9kZSB0byB0aGUgY3VycmVudCBub2RlLCBhbmQgZW50ZXIgdGhlIHNjb3BlIG9mIHRoZSBuZXdcclxuICAgICAgLy8gbm9kZS5cclxuICAgICAgdGFnU3RhY2sucHVzaChtWzFdKTtcclxuICAgICAgY3VycmVudC5hcHBlbmRDaGlsZChub2RlKTtcclxuICAgICAgY3VycmVudCA9IG5vZGU7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRleHQgbm9kZXMgYXJlIGxlYWYgbm9kZXMuXHJcbiAgICBjdXJyZW50LmFwcGVuZENoaWxkKHdpbmRvdy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh1bmVzY2FwZSh0KSkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJvb3REaXY7XHJcbn1cclxuXHJcbi8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCB0aGUgVW5pY29kZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhIHN0cm9uZ1xyXG4vLyByaWdodC10by1sZWZ0IGNhdGVnb3J5LiBXaGF0IHRoaXMgbWVhbnMgaXMgdGhhdCB0aGVzZSBjaGFyYWN0ZXJzIGFyZVxyXG4vLyB3cml0dGVuIHJpZ2h0LXRvLWxlZnQgZm9yIHN1cmUuIEl0IHdhcyBnZW5lcmF0ZWQgYnkgcHVsbGluZyBhbGwgdGhlIHN0cm9uZ1xyXG4vLyByaWdodC10by1sZWZ0IGNoYXJhY3RlcnMgb3V0IG9mIHRoZSBVbmljb2RlIGRhdGEgdGFibGUuIFRoYXQgdGFibGUgY2FuXHJcbi8vIGZvdW5kIGF0OiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VTklEQVRBL1VuaWNvZGVEYXRhLnR4dFxyXG52YXIgc3Ryb25nUlRMUmFuZ2VzID0gW1sweDViZSwgMHg1YmVdLCBbMHg1YzAsIDB4NWMwXSwgWzB4NWMzLCAweDVjM10sIFsweDVjNiwgMHg1YzZdLFxyXG4gWzB4NWQwLCAweDVlYV0sIFsweDVmMCwgMHg1ZjRdLCBbMHg2MDgsIDB4NjA4XSwgWzB4NjBiLCAweDYwYl0sIFsweDYwZCwgMHg2MGRdLFxyXG4gWzB4NjFiLCAweDYxYl0sIFsweDYxZSwgMHg2NGFdLCBbMHg2NmQsIDB4NjZmXSwgWzB4NjcxLCAweDZkNV0sIFsweDZlNSwgMHg2ZTZdLFxyXG4gWzB4NmVlLCAweDZlZl0sIFsweDZmYSwgMHg3MGRdLCBbMHg3MGYsIDB4NzEwXSwgWzB4NzEyLCAweDcyZl0sIFsweDc0ZCwgMHg3YTVdLFxyXG4gWzB4N2IxLCAweDdiMV0sIFsweDdjMCwgMHg3ZWFdLCBbMHg3ZjQsIDB4N2Y1XSwgWzB4N2ZhLCAweDdmYV0sIFsweDgwMCwgMHg4MTVdLFxyXG4gWzB4ODFhLCAweDgxYV0sIFsweDgyNCwgMHg4MjRdLCBbMHg4MjgsIDB4ODI4XSwgWzB4ODMwLCAweDgzZV0sIFsweDg0MCwgMHg4NThdLFxyXG4gWzB4ODVlLCAweDg1ZV0sIFsweDhhMCwgMHg4YTBdLCBbMHg4YTIsIDB4OGFjXSwgWzB4MjAwZiwgMHgyMDBmXSxcclxuIFsweGZiMWQsIDB4ZmIxZF0sIFsweGZiMWYsIDB4ZmIyOF0sIFsweGZiMmEsIDB4ZmIzNl0sIFsweGZiMzgsIDB4ZmIzY10sXHJcbiBbMHhmYjNlLCAweGZiM2VdLCBbMHhmYjQwLCAweGZiNDFdLCBbMHhmYjQzLCAweGZiNDRdLCBbMHhmYjQ2LCAweGZiYzFdLFxyXG4gWzB4ZmJkMywgMHhmZDNkXSwgWzB4ZmQ1MCwgMHhmZDhmXSwgWzB4ZmQ5MiwgMHhmZGM3XSwgWzB4ZmRmMCwgMHhmZGZjXSxcclxuIFsweGZlNzAsIDB4ZmU3NF0sIFsweGZlNzYsIDB4ZmVmY10sIFsweDEwODAwLCAweDEwODA1XSwgWzB4MTA4MDgsIDB4MTA4MDhdLFxyXG4gWzB4MTA4MGEsIDB4MTA4MzVdLCBbMHgxMDgzNywgMHgxMDgzOF0sIFsweDEwODNjLCAweDEwODNjXSwgWzB4MTA4M2YsIDB4MTA4NTVdLFxyXG4gWzB4MTA4NTcsIDB4MTA4NWZdLCBbMHgxMDkwMCwgMHgxMDkxYl0sIFsweDEwOTIwLCAweDEwOTM5XSwgWzB4MTA5M2YsIDB4MTA5M2ZdLFxyXG4gWzB4MTA5ODAsIDB4MTA5YjddLCBbMHgxMDliZSwgMHgxMDliZl0sIFsweDEwYTAwLCAweDEwYTAwXSwgWzB4MTBhMTAsIDB4MTBhMTNdLFxyXG4gWzB4MTBhMTUsIDB4MTBhMTddLCBbMHgxMGExOSwgMHgxMGEzM10sIFsweDEwYTQwLCAweDEwYTQ3XSwgWzB4MTBhNTAsIDB4MTBhNThdLFxyXG4gWzB4MTBhNjAsIDB4MTBhN2ZdLCBbMHgxMGIwMCwgMHgxMGIzNV0sIFsweDEwYjQwLCAweDEwYjU1XSwgWzB4MTBiNTgsIDB4MTBiNzJdLFxyXG4gWzB4MTBiNzgsIDB4MTBiN2ZdLCBbMHgxMGMwMCwgMHgxMGM0OF0sIFsweDFlZTAwLCAweDFlZTAzXSwgWzB4MWVlMDUsIDB4MWVlMWZdLFxyXG4gWzB4MWVlMjEsIDB4MWVlMjJdLCBbMHgxZWUyNCwgMHgxZWUyNF0sIFsweDFlZTI3LCAweDFlZTI3XSwgWzB4MWVlMjksIDB4MWVlMzJdLFxyXG4gWzB4MWVlMzQsIDB4MWVlMzddLCBbMHgxZWUzOSwgMHgxZWUzOV0sIFsweDFlZTNiLCAweDFlZTNiXSwgWzB4MWVlNDIsIDB4MWVlNDJdLFxyXG4gWzB4MWVlNDcsIDB4MWVlNDddLCBbMHgxZWU0OSwgMHgxZWU0OV0sIFsweDFlZTRiLCAweDFlZTRiXSwgWzB4MWVlNGQsIDB4MWVlNGZdLFxyXG4gWzB4MWVlNTEsIDB4MWVlNTJdLCBbMHgxZWU1NCwgMHgxZWU1NF0sIFsweDFlZTU3LCAweDFlZTU3XSwgWzB4MWVlNTksIDB4MWVlNTldLFxyXG4gWzB4MWVlNWIsIDB4MWVlNWJdLCBbMHgxZWU1ZCwgMHgxZWU1ZF0sIFsweDFlZTVmLCAweDFlZTVmXSwgWzB4MWVlNjEsIDB4MWVlNjJdLFxyXG4gWzB4MWVlNjQsIDB4MWVlNjRdLCBbMHgxZWU2NywgMHgxZWU2YV0sIFsweDFlZTZjLCAweDFlZTcyXSwgWzB4MWVlNzQsIDB4MWVlNzddLFxyXG4gWzB4MWVlNzksIDB4MWVlN2NdLCBbMHgxZWU3ZSwgMHgxZWU3ZV0sIFsweDFlZTgwLCAweDFlZTg5XSwgWzB4MWVlOGIsIDB4MWVlOWJdLFxyXG4gWzB4MWVlYTEsIDB4MWVlYTNdLCBbMHgxZWVhNSwgMHgxZWVhOV0sIFsweDFlZWFiLCAweDFlZWJiXSwgWzB4MTBmZmZkLCAweDEwZmZmZF1dO1xyXG5cclxuZnVuY3Rpb24gaXNTdHJvbmdSVExDaGFyKGNoYXJDb2RlKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJvbmdSVExSYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBjdXJyZW50UmFuZ2UgPSBzdHJvbmdSVExSYW5nZXNbaV07XHJcbiAgICBpZiAoY2hhckNvZGUgPj0gY3VycmVudFJhbmdlWzBdICYmIGNoYXJDb2RlIDw9IGN1cnJlbnRSYW5nZVsxXSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZGV0ZXJtaW5lQmlkaShjdWVEaXYpIHtcclxuICB2YXIgbm9kZVN0YWNrID0gW10sXHJcbiAgICAgIHRleHQgPSBcIlwiLFxyXG4gICAgICBjaGFyQ29kZTtcclxuXHJcbiAgaWYgKCFjdWVEaXYgfHwgIWN1ZURpdi5jaGlsZE5vZGVzKSB7XHJcbiAgICByZXR1cm4gXCJsdHJcIjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHB1c2hOb2Rlcyhub2RlU3RhY2ssIG5vZGUpIHtcclxuICAgIGZvciAodmFyIGkgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgbm9kZVN0YWNrLnB1c2gobm9kZS5jaGlsZE5vZGVzW2ldKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG5leHRUZXh0Tm9kZShub2RlU3RhY2spIHtcclxuICAgIGlmICghbm9kZVN0YWNrIHx8ICFub2RlU3RhY2subGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBub2RlID0gbm9kZVN0YWNrLnBvcCgpLFxyXG4gICAgICAgIHRleHQgPSBub2RlLnRleHRDb250ZW50IHx8IG5vZGUuaW5uZXJUZXh0O1xyXG4gICAgaWYgKHRleHQpIHtcclxuICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbWF0Y2ggYWxsIHVuaWNvZGUgdHlwZSBCIGNoYXJhY3RlcnMgKHBhcmFncmFwaFxyXG4gICAgICAvLyBzZXBhcmF0b3IgY2hhcmFjdGVycykuIFNlZSBpc3N1ZSAjMTE1LlxyXG4gICAgICB2YXIgbSA9IHRleHQubWF0Y2goL14uKihcXG58XFxyKS8pO1xyXG4gICAgICBpZiAobSkge1xyXG4gICAgICAgIG5vZGVTdGFjay5sZW5ndGggPSAwO1xyXG4gICAgICAgIHJldHVybiBtWzBdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gXCJydWJ5XCIpIHtcclxuICAgICAgcmV0dXJuIG5leHRUZXh0Tm9kZShub2RlU3RhY2spO1xyXG4gICAgfVxyXG4gICAgaWYgKG5vZGUuY2hpbGROb2Rlcykge1xyXG4gICAgICBwdXNoTm9kZXMobm9kZVN0YWNrLCBub2RlKTtcclxuICAgICAgcmV0dXJuIG5leHRUZXh0Tm9kZShub2RlU3RhY2spO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVzaE5vZGVzKG5vZGVTdGFjaywgY3VlRGl2KTtcclxuICB3aGlsZSAoKHRleHQgPSBuZXh0VGV4dE5vZGUobm9kZVN0YWNrKSkpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpKTtcclxuICAgICAgaWYgKGlzU3Ryb25nUlRMQ2hhcihjaGFyQ29kZSkpIHtcclxuICAgICAgICByZXR1cm4gXCJydGxcIjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gXCJsdHJcIjtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcHV0ZUxpbmVQb3MoY3VlKSB7XHJcbiAgaWYgKHR5cGVvZiBjdWUubGluZSA9PT0gXCJudW1iZXJcIiAmJlxyXG4gICAgICAoY3VlLnNuYXBUb0xpbmVzIHx8IChjdWUubGluZSA+PSAwICYmIGN1ZS5saW5lIDw9IDEwMCkpKSB7XHJcbiAgICByZXR1cm4gY3VlLmxpbmU7XHJcbiAgfVxyXG4gIGlmICghY3VlLnRyYWNrIHx8ICFjdWUudHJhY2sudGV4dFRyYWNrTGlzdCB8fFxyXG4gICAgICAhY3VlLnRyYWNrLnRleHRUcmFja0xpc3QubWVkaWFFbGVtZW50KSB7XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfVxyXG4gIHZhciB0cmFjayA9IGN1ZS50cmFjayxcclxuICAgICAgdHJhY2tMaXN0ID0gdHJhY2sudGV4dFRyYWNrTGlzdCxcclxuICAgICAgY291bnQgPSAwO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMaXN0Lmxlbmd0aCAmJiB0cmFja0xpc3RbaV0gIT09IHRyYWNrOyBpKyspIHtcclxuICAgIGlmICh0cmFja0xpc3RbaV0ubW9kZSA9PT0gXCJzaG93aW5nXCIpIHtcclxuICAgICAgY291bnQrKztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuICsrY291bnQgKiAtMTtcclxufVxyXG5cclxuZnVuY3Rpb24gU3R5bGVCb3goKSB7XHJcbn1cclxuXHJcbi8vIEFwcGx5IHN0eWxlcyB0byBhIGRpdi4gSWYgdGhlcmUgaXMgbm8gZGl2IHBhc3NlZCB0aGVuIGl0IGRlZmF1bHRzIHRvIHRoZVxyXG4vLyBkaXYgb24gJ3RoaXMnLlxyXG5TdHlsZUJveC5wcm90b3R5cGUuYXBwbHlTdHlsZXMgPSBmdW5jdGlvbihzdHlsZXMsIGRpdikge1xyXG4gIGRpdiA9IGRpdiB8fCB0aGlzLmRpdjtcclxuICBmb3IgKHZhciBwcm9wIGluIHN0eWxlcykge1xyXG4gICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICBkaXYuc3R5bGVbcHJvcF0gPSBzdHlsZXNbcHJvcF07XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuU3R5bGVCb3gucHJvdG90eXBlLmZvcm1hdFN0eWxlID0gZnVuY3Rpb24odmFsLCB1bml0KSB7XHJcbiAgcmV0dXJuIHZhbCA9PT0gMCA/IDAgOiB2YWwgKyB1bml0O1xyXG59O1xyXG5cclxuLy8gQ29uc3RydWN0cyB0aGUgY29tcHV0ZWQgZGlzcGxheSBzdGF0ZSBvZiB0aGUgY3VlIChhIGRpdikuIFBsYWNlcyB0aGUgZGl2XHJcbi8vIGludG8gdGhlIG92ZXJsYXkgd2hpY2ggc2hvdWxkIGJlIGEgYmxvY2sgbGV2ZWwgZWxlbWVudCAodXN1YWxseSBhIGRpdikuXHJcbmZ1bmN0aW9uIEN1ZVN0eWxlQm94KHdpbmRvdywgY3VlLCBzdHlsZU9wdGlvbnMpIHtcclxuICB2YXIgaXNJRTggPSAoL01TSUVcXHM4XFwuMC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbiAgdmFyIGNvbG9yID0gXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpXCI7XHJcbiAgdmFyIGJhY2tncm91bmRDb2xvciA9IFwicmdiYSgwLCAwLCAwLCAwLjgpXCI7XHJcblxyXG4gIGlmIChpc0lFOCkge1xyXG4gICAgY29sb3IgPSBcInJnYigyNTUsIDI1NSwgMjU1KVwiO1xyXG4gICAgYmFja2dyb3VuZENvbG9yID0gXCJyZ2IoMCwgMCwgMClcIjtcclxuICB9XHJcblxyXG4gIFN0eWxlQm94LmNhbGwodGhpcyk7XHJcbiAgdGhpcy5jdWUgPSBjdWU7XHJcblxyXG4gIC8vIFBhcnNlIG91ciBjdWUncyB0ZXh0IGludG8gYSBET00gdHJlZSByb290ZWQgYXQgJ2N1ZURpdicuIFRoaXMgZGl2IHdpbGxcclxuICAvLyBoYXZlIGlubGluZSBwb3NpdGlvbmluZyBhbmQgd2lsbCBmdW5jdGlvbiBhcyB0aGUgY3VlIGJhY2tncm91bmQgYm94LlxyXG4gIHRoaXMuY3VlRGl2ID0gcGFyc2VDb250ZW50KHdpbmRvdywgY3VlLnRleHQpO1xyXG4gIHZhciBzdHlsZXMgPSB7XHJcbiAgICBjb2xvcjogY29sb3IsXHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGJhY2tncm91bmRDb2xvcixcclxuICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXHJcbiAgICBsZWZ0OiAwLFxyXG4gICAgcmlnaHQ6IDAsXHJcbiAgICB0b3A6IDAsXHJcbiAgICBib3R0b206IDAsXHJcbiAgICBkaXNwbGF5OiBcImlubGluZVwiXHJcbiAgfTtcclxuXHJcbiAgaWYgKCFpc0lFOCkge1xyXG4gICAgc3R5bGVzLndyaXRpbmdNb2RlID0gY3VlLnZlcnRpY2FsID09PSBcIlwiID8gXCJob3Jpem9udGFsLXRiXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdWUudmVydGljYWwgPT09IFwibHJcIiA/IFwidmVydGljYWwtbHJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwidmVydGljYWwtcmxcIjtcclxuICAgIHN0eWxlcy51bmljb2RlQmlkaSA9IFwicGxhaW50ZXh0XCI7XHJcbiAgfVxyXG4gIHRoaXMuYXBwbHlTdHlsZXMoc3R5bGVzLCB0aGlzLmN1ZURpdik7XHJcblxyXG4gIC8vIENyZWF0ZSBhbiBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgZGl2IHRoYXQgd2lsbCBiZSB1c2VkIHRvIHBvc2l0aW9uIHRoZSBjdWVcclxuICAvLyBkaXYuIE5vdGUsIGFsbCBXZWJWVFQgY3VlLXNldHRpbmcgYWxpZ25tZW50cyBhcmUgZXF1aXZhbGVudCB0byB0aGUgQ1NTXHJcbiAgLy8gbWlycm9ycyBvZiB0aGVtIGV4Y2VwdCBcIm1pZGRsZVwiIHdoaWNoIGlzIFwiY2VudGVyXCIgaW4gQ1NTLlxyXG4gIHRoaXMuZGl2ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgc3R5bGVzID0ge1xyXG4gICAgdGV4dEFsaWduOiBjdWUuYWxpZ24gPT09IFwibWlkZGxlXCIgPyBcImNlbnRlclwiIDogY3VlLmFsaWduLFxyXG4gICAgZm9udDogc3R5bGVPcHRpb25zLmZvbnQsXHJcbiAgICB3aGl0ZVNwYWNlOiBcInByZS1saW5lXCIsXHJcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXHJcbiAgfTtcclxuXHJcbiAgaWYgKCFpc0lFOCkge1xyXG4gICAgc3R5bGVzLmRpcmVjdGlvbiA9IGRldGVybWluZUJpZGkodGhpcy5jdWVEaXYpO1xyXG4gICAgc3R5bGVzLndyaXRpbmdNb2RlID0gY3VlLnZlcnRpY2FsID09PSBcIlwiID8gXCJob3Jpem9udGFsLXRiXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdWUudmVydGljYWwgPT09IFwibHJcIiA/IFwidmVydGljYWwtbHJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwidmVydGljYWwtcmxcIi5cclxuICAgIHN0eWxlc3VuaWNvZGVCaWRpID0gIFwicGxhaW50ZXh0XCI7XHJcbiAgfVxyXG5cclxuICB0aGlzLmFwcGx5U3R5bGVzKHN0eWxlcyk7XHJcblxyXG4gIHRoaXMuZGl2LmFwcGVuZENoaWxkKHRoaXMuY3VlRGl2KTtcclxuXHJcbiAgLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSByZWZlcmVuY2UgZWRnZSBvZiB0aGUgdmlld3BvcnQgdG8gdGhlIHRleHRcclxuICAvLyBwb3NpdGlvbiBvZiB0aGUgY3VlIGJveC4gVGhlIHJlZmVyZW5jZSBlZGdlIHdpbGwgYmUgcmVzb2x2ZWQgbGF0ZXIgd2hlblxyXG4gIC8vIHRoZSBib3ggb3JpZW50YXRpb24gc3R5bGVzIGFyZSBhcHBsaWVkLlxyXG4gIHZhciB0ZXh0UG9zID0gMDtcclxuICBzd2l0Y2ggKGN1ZS5wb3NpdGlvbkFsaWduKSB7XHJcbiAgY2FzZSBcInN0YXJ0XCI6XHJcbiAgICB0ZXh0UG9zID0gY3VlLnBvc2l0aW9uO1xyXG4gICAgYnJlYWs7XHJcbiAgY2FzZSBcIm1pZGRsZVwiOlxyXG4gICAgdGV4dFBvcyA9IGN1ZS5wb3NpdGlvbiAtIChjdWUuc2l6ZSAvIDIpO1xyXG4gICAgYnJlYWs7XHJcbiAgY2FzZSBcImVuZFwiOlxyXG4gICAgdGV4dFBvcyA9IGN1ZS5wb3NpdGlvbiAtIGN1ZS5zaXplO1xyXG4gICAgYnJlYWs7XHJcbiAgfVxyXG5cclxuICAvLyBIb3Jpem9udGFsIGJveCBvcmllbnRhdGlvbjsgdGV4dFBvcyBpcyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZVxyXG4gIC8vIGFyZWEgdG8gdGhlIGxlZnQgZWRnZSBvZiB0aGUgYm94IGFuZCBjdWUuc2l6ZSBpcyB0aGUgZGlzdGFuY2UgZXh0ZW5kaW5nIHRvXHJcbiAgLy8gdGhlIHJpZ2h0IGZyb20gdGhlcmUuXHJcbiAgaWYgKGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIikge1xyXG4gICAgdGhpcy5hcHBseVN0eWxlcyh7XHJcbiAgICAgIGxlZnQ6ICB0aGlzLmZvcm1hdFN0eWxlKHRleHRQb3MsIFwiJVwiKSxcclxuICAgICAgd2lkdGg6IHRoaXMuZm9ybWF0U3R5bGUoY3VlLnNpemUsIFwiJVwiKVxyXG4gICAgfSk7XHJcbiAgLy8gVmVydGljYWwgYm94IG9yaWVudGF0aW9uOyB0ZXh0UG9zIGlzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSB0b3AgZWRnZSBvZiB0aGVcclxuICAvLyBhcmVhIHRvIHRoZSB0b3AgZWRnZSBvZiB0aGUgYm94IGFuZCBjdWUuc2l6ZSBpcyB0aGUgaGVpZ2h0IGV4dGVuZGluZ1xyXG4gIC8vIGRvd253YXJkcyBmcm9tIHRoZXJlLlxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLmFwcGx5U3R5bGVzKHtcclxuICAgICAgdG9wOiB0aGlzLmZvcm1hdFN0eWxlKHRleHRQb3MsIFwiJVwiKSxcclxuICAgICAgaGVpZ2h0OiB0aGlzLmZvcm1hdFN0eWxlKGN1ZS5zaXplLCBcIiVcIilcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgdGhpcy5tb3ZlID0gZnVuY3Rpb24oYm94KSB7XHJcbiAgICB0aGlzLmFwcGx5U3R5bGVzKHtcclxuICAgICAgdG9wOiB0aGlzLmZvcm1hdFN0eWxlKGJveC50b3AsIFwicHhcIiksXHJcbiAgICAgIGJvdHRvbTogdGhpcy5mb3JtYXRTdHlsZShib3guYm90dG9tLCBcInB4XCIpLFxyXG4gICAgICBsZWZ0OiB0aGlzLmZvcm1hdFN0eWxlKGJveC5sZWZ0LCBcInB4XCIpLFxyXG4gICAgICByaWdodDogdGhpcy5mb3JtYXRTdHlsZShib3gucmlnaHQsIFwicHhcIiksXHJcbiAgICAgIGhlaWdodDogdGhpcy5mb3JtYXRTdHlsZShib3guaGVpZ2h0LCBcInB4XCIpLFxyXG4gICAgICB3aWR0aDogdGhpcy5mb3JtYXRTdHlsZShib3gud2lkdGgsIFwicHhcIilcclxuICAgIH0pO1xyXG4gIH07XHJcbn1cclxuQ3VlU3R5bGVCb3gucHJvdG90eXBlID0gX29iakNyZWF0ZShTdHlsZUJveC5wcm90b3R5cGUpO1xyXG5DdWVTdHlsZUJveC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdWVTdHlsZUJveDtcclxuXHJcbi8vIFJlcHJlc2VudHMgdGhlIGNvLW9yZGluYXRlcyBvZiBhbiBFbGVtZW50IGluIGEgd2F5IHRoYXQgd2UgY2FuIGVhc2lseVxyXG4vLyBjb21wdXRlIHRoaW5ncyB3aXRoIHN1Y2ggYXMgaWYgaXQgb3ZlcmxhcHMgb3IgaW50ZXJzZWN0cyB3aXRoIGFub3RoZXIgRWxlbWVudC5cclxuLy8gQ2FuIGluaXRpYWxpemUgaXQgd2l0aCBlaXRoZXIgYSBTdHlsZUJveCBvciBhbm90aGVyIEJveFBvc2l0aW9uLlxyXG5mdW5jdGlvbiBCb3hQb3NpdGlvbihvYmopIHtcclxuICB2YXIgaXNJRTggPSAoL01TSUVcXHM4XFwuMC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcblxyXG4gIC8vIEVpdGhlciBhIEJveFBvc2l0aW9uIHdhcyBwYXNzZWQgaW4gYW5kIHdlIG5lZWQgdG8gY29weSBpdCwgb3IgYSBTdHlsZUJveFxyXG4gIC8vIHdhcyBwYXNzZWQgaW4gYW5kIHdlIG5lZWQgdG8gY29weSB0aGUgcmVzdWx0cyBvZiAnZ2V0Qm91bmRpbmdDbGllbnRSZWN0J1xyXG4gIC8vIGFzIHRoZSBvYmplY3QgcmV0dXJuZWQgaXMgcmVhZG9ubHkuIEFsbCBjby1vcmRpbmF0ZSB2YWx1ZXMgYXJlIGluIHJlZmVyZW5jZVxyXG4gIC8vIHRvIHRoZSB2aWV3cG9ydCBvcmlnaW4gKHRvcCBsZWZ0KS5cclxuICB2YXIgbGgsIGhlaWdodCwgd2lkdGgsIHRvcDtcclxuICBpZiAob2JqLmRpdikge1xyXG4gICAgaGVpZ2h0ID0gb2JqLmRpdi5vZmZzZXRIZWlnaHQ7XHJcbiAgICB3aWR0aCA9IG9iai5kaXYub2Zmc2V0V2lkdGg7XHJcbiAgICB0b3AgPSBvYmouZGl2Lm9mZnNldFRvcDtcclxuXHJcbiAgICB2YXIgcmVjdHMgPSAocmVjdHMgPSBvYmouZGl2LmNoaWxkTm9kZXMpICYmIChyZWN0cyA9IHJlY3RzWzBdKSAmJlxyXG4gICAgICAgICAgICAgICAgcmVjdHMuZ2V0Q2xpZW50UmVjdHMgJiYgcmVjdHMuZ2V0Q2xpZW50UmVjdHMoKTtcclxuICAgIG9iaiA9IG9iai5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAvLyBJbiBjZXJ0YWluIGNhc2VzIHRoZSBvdXR0ZXIgZGl2IHdpbGwgYmUgc2xpZ2h0bHkgbGFyZ2VyIHRoZW4gdGhlIHN1bSBvZlxyXG4gICAgLy8gdGhlIGlubmVyIGRpdidzIGxpbmVzLiBUaGlzIGNvdWxkIGJlIGR1ZSB0byBib2xkIHRleHQsIGV0Yywgb24gc29tZSBwbGF0Zm9ybXMuXHJcbiAgICAvLyBJbiB0aGlzIGNhc2Ugd2Ugc2hvdWxkIGdldCB0aGUgYXZlcmFnZSBsaW5lIGhlaWdodCBhbmQgdXNlIHRoYXQuIFRoaXMgd2lsbFxyXG4gICAgLy8gcmVzdWx0IGluIHRoZSBkZXNpcmVkIGJlaGF2aW91ci5cclxuICAgIGxoID0gcmVjdHMgPyBNYXRoLm1heCgocmVjdHNbMF0gJiYgcmVjdHNbMF0uaGVpZ2h0KSB8fCAwLCBvYmouaGVpZ2h0IC8gcmVjdHMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICA6IDA7XHJcblxyXG4gIH1cclxuICB0aGlzLmxlZnQgPSBvYmoubGVmdDtcclxuICB0aGlzLnJpZ2h0ID0gb2JqLnJpZ2h0O1xyXG4gIHRoaXMudG9wID0gb2JqLnRvcCB8fCB0b3A7XHJcbiAgdGhpcy5oZWlnaHQgPSBvYmouaGVpZ2h0IHx8IGhlaWdodDtcclxuICB0aGlzLmJvdHRvbSA9IG9iai5ib3R0b20gfHwgKHRvcCArIChvYmouaGVpZ2h0IHx8IGhlaWdodCkpO1xyXG4gIHRoaXMud2lkdGggPSBvYmoud2lkdGggfHwgd2lkdGg7XHJcbiAgdGhpcy5saW5lSGVpZ2h0ID0gbGggIT09IHVuZGVmaW5lZCA/IGxoIDogb2JqLmxpbmVIZWlnaHQ7XHJcblxyXG4gIGlmIChpc0lFOCAmJiAhdGhpcy5saW5lSGVpZ2h0KSB7XHJcbiAgICB0aGlzLmxpbmVIZWlnaHQgPSAxMztcclxuICB9XHJcbn1cclxuXHJcbi8vIE1vdmUgdGhlIGJveCBhbG9uZyBhIHBhcnRpY3VsYXIgYXhpcy4gT3B0aW9uYWxseSBwYXNzIGluIGFuIGFtb3VudCB0byBtb3ZlXHJcbi8vIHRoZSBib3guIElmIG5vIGFtb3VudCBpcyBwYXNzZWQgdGhlbiB0aGUgZGVmYXVsdCBpcyB0aGUgbGluZSBoZWlnaHQgb2YgdGhlXHJcbi8vIGJveC5cclxuQm94UG9zaXRpb24ucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihheGlzLCB0b01vdmUpIHtcclxuICB0b01vdmUgPSB0b01vdmUgIT09IHVuZGVmaW5lZCA/IHRvTW92ZSA6IHRoaXMubGluZUhlaWdodDtcclxuICBzd2l0Y2ggKGF4aXMpIHtcclxuICBjYXNlIFwiK3hcIjpcclxuICAgIHRoaXMubGVmdCArPSB0b01vdmU7XHJcbiAgICB0aGlzLnJpZ2h0ICs9IHRvTW92ZTtcclxuICAgIGJyZWFrO1xyXG4gIGNhc2UgXCIteFwiOlxyXG4gICAgdGhpcy5sZWZ0IC09IHRvTW92ZTtcclxuICAgIHRoaXMucmlnaHQgLT0gdG9Nb3ZlO1xyXG4gICAgYnJlYWs7XHJcbiAgY2FzZSBcIit5XCI6XHJcbiAgICB0aGlzLnRvcCArPSB0b01vdmU7XHJcbiAgICB0aGlzLmJvdHRvbSArPSB0b01vdmU7XHJcbiAgICBicmVhaztcclxuICBjYXNlIFwiLXlcIjpcclxuICAgIHRoaXMudG9wIC09IHRvTW92ZTtcclxuICAgIHRoaXMuYm90dG9tIC09IHRvTW92ZTtcclxuICAgIGJyZWFrO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIENoZWNrIGlmIHRoaXMgYm94IG92ZXJsYXBzIGFub3RoZXIgYm94LCBiMi5cclxuQm94UG9zaXRpb24ucHJvdG90eXBlLm92ZXJsYXBzID0gZnVuY3Rpb24oYjIpIHtcclxuICByZXR1cm4gdGhpcy5sZWZ0IDwgYjIucmlnaHQgJiZcclxuICAgICAgICAgdGhpcy5yaWdodCA+IGIyLmxlZnQgJiZcclxuICAgICAgICAgdGhpcy50b3AgPCBiMi5ib3R0b20gJiZcclxuICAgICAgICAgdGhpcy5ib3R0b20gPiBiMi50b3A7XHJcbn07XHJcblxyXG4vLyBDaGVjayBpZiB0aGlzIGJveCBvdmVybGFwcyBhbnkgb3RoZXIgYm94ZXMgaW4gYm94ZXMuXHJcbkJveFBvc2l0aW9uLnByb3RvdHlwZS5vdmVybGFwc0FueSA9IGZ1bmN0aW9uKGJveGVzKSB7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKHRoaXMub3ZlcmxhcHMoYm94ZXNbaV0pKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG4vLyBDaGVjayBpZiB0aGlzIGJveCBpcyB3aXRoaW4gYW5vdGhlciBib3guXHJcbkJveFBvc2l0aW9uLnByb3RvdHlwZS53aXRoaW4gPSBmdW5jdGlvbihjb250YWluZXIpIHtcclxuICByZXR1cm4gdGhpcy50b3AgPj0gY29udGFpbmVyLnRvcCAmJlxyXG4gICAgICAgICB0aGlzLmJvdHRvbSA8PSBjb250YWluZXIuYm90dG9tICYmXHJcbiAgICAgICAgIHRoaXMubGVmdCA+PSBjb250YWluZXIubGVmdCAmJlxyXG4gICAgICAgICB0aGlzLnJpZ2h0IDw9IGNvbnRhaW5lci5yaWdodDtcclxufTtcclxuXHJcbi8vIENoZWNrIGlmIHRoaXMgYm94IGlzIGVudGlyZWx5IHdpdGhpbiB0aGUgY29udGFpbmVyIG9yIGl0IGlzIG92ZXJsYXBwaW5nXHJcbi8vIG9uIHRoZSBlZGdlIG9wcG9zaXRlIG9mIHRoZSBheGlzIGRpcmVjdGlvbiBwYXNzZWQuIEZvciBleGFtcGxlLCBpZiBcIit4XCIgaXNcclxuLy8gcGFzc2VkIGFuZCB0aGUgYm94IGlzIG92ZXJsYXBwaW5nIG9uIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGNvbnRhaW5lciwgdGhlblxyXG4vLyByZXR1cm4gdHJ1ZS5cclxuQm94UG9zaXRpb24ucHJvdG90eXBlLm92ZXJsYXBzT3Bwb3NpdGVBeGlzID0gZnVuY3Rpb24oY29udGFpbmVyLCBheGlzKSB7XHJcbiAgc3dpdGNoIChheGlzKSB7XHJcbiAgY2FzZSBcIit4XCI6XHJcbiAgICByZXR1cm4gdGhpcy5sZWZ0IDwgY29udGFpbmVyLmxlZnQ7XHJcbiAgY2FzZSBcIi14XCI6XHJcbiAgICByZXR1cm4gdGhpcy5yaWdodCA+IGNvbnRhaW5lci5yaWdodDtcclxuICBjYXNlIFwiK3lcIjpcclxuICAgIHJldHVybiB0aGlzLnRvcCA8IGNvbnRhaW5lci50b3A7XHJcbiAgY2FzZSBcIi15XCI6XHJcbiAgICByZXR1cm4gdGhpcy5ib3R0b20gPiBjb250YWluZXIuYm90dG9tO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIEZpbmQgdGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGFyZWEgdGhhdCB0aGlzIGJveCBpcyBvdmVybGFwcGluZyB3aXRoIGFub3RoZXJcclxuLy8gYm94LlxyXG5Cb3hQb3NpdGlvbi5wcm90b3R5cGUuaW50ZXJzZWN0UGVyY2VudGFnZSA9IGZ1bmN0aW9uKGIyKSB7XHJcbiAgdmFyIHggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLnJpZ2h0LCBiMi5yaWdodCkgLSBNYXRoLm1heCh0aGlzLmxlZnQsIGIyLmxlZnQpKSxcclxuICAgICAgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuYm90dG9tLCBiMi5ib3R0b20pIC0gTWF0aC5tYXgodGhpcy50b3AsIGIyLnRvcCkpLFxyXG4gICAgICBpbnRlcnNlY3RBcmVhID0geCAqIHk7XHJcbiAgcmV0dXJuIGludGVyc2VjdEFyZWEgLyAodGhpcy5oZWlnaHQgKiB0aGlzLndpZHRoKTtcclxufTtcclxuXHJcbi8vIENvbnZlcnQgdGhlIHBvc2l0aW9ucyBmcm9tIHRoaXMgYm94IHRvIENTUyBjb21wYXRpYmxlIHBvc2l0aW9ucyB1c2luZ1xyXG4vLyB0aGUgcmVmZXJlbmNlIGNvbnRhaW5lcidzIHBvc2l0aW9ucy4gVGhpcyBoYXMgdG8gYmUgZG9uZSBiZWNhdXNlIHRoaXNcclxuLy8gYm94J3MgcG9zaXRpb25zIGFyZSBpbiByZWZlcmVuY2UgdG8gdGhlIHZpZXdwb3J0IG9yaWdpbiwgd2hlcmVhcywgQ1NTXHJcbi8vIHZhbHVlcyBhcmUgaW4gcmVmZXJlY25lIHRvIHRoZWlyIHJlc3BlY3RpdmUgZWRnZXMuXHJcbkJveFBvc2l0aW9uLnByb3RvdHlwZS50b0NTU0NvbXBhdFZhbHVlcyA9IGZ1bmN0aW9uKHJlZmVyZW5jZSkge1xyXG4gIHJldHVybiB7XHJcbiAgICB0b3A6IHRoaXMudG9wIC0gcmVmZXJlbmNlLnRvcCxcclxuICAgIGJvdHRvbTogcmVmZXJlbmNlLmJvdHRvbSAtIHRoaXMuYm90dG9tLFxyXG4gICAgbGVmdDogdGhpcy5sZWZ0IC0gcmVmZXJlbmNlLmxlZnQsXHJcbiAgICByaWdodDogcmVmZXJlbmNlLnJpZ2h0IC0gdGhpcy5yaWdodCxcclxuICAgIGhlaWdodDogdGhpcy5oZWlnaHQsXHJcbiAgICB3aWR0aDogdGhpcy53aWR0aFxyXG4gIH07XHJcbn07XHJcblxyXG4vLyBHZXQgYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgYm94J3MgcG9zaXRpb24gd2l0aG91dCBhbnl0aGluZyBleHRyYS5cclxuLy8gQ2FuIHBhc3MgYSBTdHlsZUJveCwgSFRNTEVsZW1lbnQsIG9yIGFub3RoZXIgQm94UG9zaXRvbi5cclxuQm94UG9zaXRpb24uZ2V0U2ltcGxlQm94UG9zaXRpb24gPSBmdW5jdGlvbihvYmopIHtcclxuICB2YXIgaGVpZ2h0ID0gb2JqLmRpdiA/IG9iai5kaXYub2Zmc2V0SGVpZ2h0IDogb2JqLnRhZ05hbWUgPyBvYmoub2Zmc2V0SGVpZ2h0IDogMDtcclxuICB2YXIgd2lkdGggPSBvYmouZGl2ID8gb2JqLmRpdi5vZmZzZXRXaWR0aCA6IG9iai50YWdOYW1lID8gb2JqLm9mZnNldFdpZHRoIDogMDtcclxuICB2YXIgdG9wID0gb2JqLmRpdiA/IG9iai5kaXYub2Zmc2V0VG9wIDogb2JqLnRhZ05hbWUgPyBvYmoub2Zmc2V0VG9wIDogMDtcclxuXHJcbiAgb2JqID0gb2JqLmRpdiA/IG9iai5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOlxyXG4gICAgICAgICAgICAgICAgb2JqLnRhZ05hbWUgPyBvYmouZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBvYmo7XHJcbiAgdmFyIHJldCA9IHtcclxuICAgIGxlZnQ6IG9iai5sZWZ0LFxyXG4gICAgcmlnaHQ6IG9iai5yaWdodCxcclxuICAgIHRvcDogb2JqLnRvcCB8fCB0b3AsXHJcbiAgICBoZWlnaHQ6IG9iai5oZWlnaHQgfHwgaGVpZ2h0LFxyXG4gICAgYm90dG9tOiBvYmouYm90dG9tIHx8ICh0b3AgKyAob2JqLmhlaWdodCB8fCBoZWlnaHQpKSxcclxuICAgIHdpZHRoOiBvYmoud2lkdGggfHwgd2lkdGhcclxuICB9O1xyXG4gIHJldHVybiByZXQ7XHJcbn07XHJcblxyXG4vLyBNb3ZlIGEgU3R5bGVCb3ggdG8gaXRzIHNwZWNpZmllZCwgb3IgbmV4dCBiZXN0LCBwb3NpdGlvbi4gVGhlIGNvbnRhaW5lckJveFxyXG4vLyBpcyB0aGUgYm94IHRoYXQgY29udGFpbnMgdGhlIFN0eWxlQm94LCBzdWNoIGFzIGEgZGl2LiBib3hQb3NpdGlvbnMgYXJlXHJcbi8vIGEgbGlzdCBvZiBvdGhlciBib3hlcyB0aGF0IHRoZSBzdHlsZUJveCBjYW4ndCBvdmVybGFwIHdpdGguXHJcbmZ1bmN0aW9uIG1vdmVCb3hUb0xpbmVQb3NpdGlvbih3aW5kb3csIHN0eWxlQm94LCBjb250YWluZXJCb3gsIGJveFBvc2l0aW9ucykge1xyXG5cclxuICAvLyBGaW5kIHRoZSBiZXN0IHBvc2l0aW9uIGZvciBhIGN1ZSBib3gsIGIsIG9uIHRoZSB2aWRlby4gVGhlIGF4aXMgcGFyYW1ldGVyXHJcbiAgLy8gaXMgYSBsaXN0IG9mIGF4aXMsIHRoZSBvcmRlciBvZiB3aGljaCwgaXQgd2lsbCBtb3ZlIHRoZSBib3ggYWxvbmcuIEZvciBleGFtcGxlOlxyXG4gIC8vIFBhc3NpbmcgW1wiK3hcIiwgXCIteFwiXSB3aWxsIG1vdmUgdGhlIGJveCBmaXJzdCBhbG9uZyB0aGUgeCBheGlzIGluIHRoZSBwb3NpdGl2ZVxyXG4gIC8vIGRpcmVjdGlvbi4gSWYgaXQgZG9lc24ndCBmaW5kIGEgZ29vZCBwb3NpdGlvbiBmb3IgaXQgdGhlcmUgaXQgd2lsbCB0aGVuIG1vdmVcclxuICAvLyBpdCBhbG9uZyB0aGUgeCBheGlzIGluIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24uXHJcbiAgZnVuY3Rpb24gZmluZEJlc3RQb3NpdGlvbihiLCBheGlzKSB7XHJcbiAgICB2YXIgYmVzdFBvc2l0aW9uLFxyXG4gICAgICAgIHNwZWNpZmllZFBvc2l0aW9uID0gbmV3IEJveFBvc2l0aW9uKGIpLFxyXG4gICAgICAgIHBlcmNlbnRhZ2UgPSAxOyAvLyBIaWdoZXN0IHBvc3NpYmxlIHNvIHRoZSBmaXJzdCB0aGluZyB3ZSBnZXQgaXMgYmV0dGVyLlxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhpcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB3aGlsZSAoYi5vdmVybGFwc09wcG9zaXRlQXhpcyhjb250YWluZXJCb3gsIGF4aXNbaV0pIHx8XHJcbiAgICAgICAgICAgICAoYi53aXRoaW4oY29udGFpbmVyQm94KSAmJiBiLm92ZXJsYXBzQW55KGJveFBvc2l0aW9ucykpKSB7XHJcbiAgICAgICAgYi5tb3ZlKGF4aXNbaV0pO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFdlIGZvdW5kIGEgc3BvdCB3aGVyZSB3ZSBhcmVuJ3Qgb3ZlcmxhcHBpbmcgYW55dGhpbmcuIFRoaXMgaXMgb3VyXHJcbiAgICAgIC8vIGJlc3QgcG9zaXRpb24uXHJcbiAgICAgIGlmIChiLndpdGhpbihjb250YWluZXJCb3gpKSB7XHJcbiAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHAgPSBiLmludGVyc2VjdFBlcmNlbnRhZ2UoY29udGFpbmVyQm94KTtcclxuICAgICAgLy8gSWYgd2UncmUgb3V0c2lkZSB0aGUgY29udGFpbmVyIGJveCBsZXNzIHRoZW4gd2Ugd2VyZSBvbiBvdXIgbGFzdCB0cnlcclxuICAgICAgLy8gdGhlbiByZW1lbWJlciB0aGlzIHBvc2l0aW9uIGFzIHRoZSBiZXN0IHBvc2l0aW9uLlxyXG4gICAgICBpZiAocGVyY2VudGFnZSA+IHApIHtcclxuICAgICAgICBiZXN0UG9zaXRpb24gPSBuZXcgQm94UG9zaXRpb24oYik7XHJcbiAgICAgICAgcGVyY2VudGFnZSA9IHA7XHJcbiAgICAgIH1cclxuICAgICAgLy8gUmVzZXQgdGhlIGJveCBwb3NpdGlvbiB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxyXG4gICAgICBiID0gbmV3IEJveFBvc2l0aW9uKHNwZWNpZmllZFBvc2l0aW9uKTtcclxuICAgIH1cclxuICAgIHJldHVybiBiZXN0UG9zaXRpb24gfHwgc3BlY2lmaWVkUG9zaXRpb247XHJcbiAgfVxyXG5cclxuICB2YXIgYm94UG9zaXRpb24gPSBuZXcgQm94UG9zaXRpb24oc3R5bGVCb3gpLFxyXG4gICAgICBjdWUgPSBzdHlsZUJveC5jdWUsXHJcbiAgICAgIGxpbmVQb3MgPSBjb21wdXRlTGluZVBvcyhjdWUpLFxyXG4gICAgICBheGlzID0gW107XHJcblxyXG4gIC8vIElmIHdlIGhhdmUgYSBsaW5lIG51bWJlciB0byBhbGlnbiB0aGUgY3VlIHRvLlxyXG4gIGlmIChjdWUuc25hcFRvTGluZXMpIHtcclxuICAgIHZhciBzaXplO1xyXG4gICAgc3dpdGNoIChjdWUudmVydGljYWwpIHtcclxuICAgIGNhc2UgXCJcIjpcclxuICAgICAgYXhpcyA9IFsgXCIreVwiLCBcIi15XCIgXTtcclxuICAgICAgc2l6ZSA9IFwiaGVpZ2h0XCI7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBcInJsXCI6XHJcbiAgICAgIGF4aXMgPSBbIFwiK3hcIiwgXCIteFwiIF07XHJcbiAgICAgIHNpemUgPSBcIndpZHRoXCI7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBcImxyXCI6XHJcbiAgICAgIGF4aXMgPSBbIFwiLXhcIiwgXCIreFwiIF07XHJcbiAgICAgIHNpemUgPSBcIndpZHRoXCI7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzdGVwID0gYm94UG9zaXRpb24ubGluZUhlaWdodCxcclxuICAgICAgICBwb3NpdGlvbiA9IHN0ZXAgKiBNYXRoLnJvdW5kKGxpbmVQb3MpLFxyXG4gICAgICAgIG1heFBvc2l0aW9uID0gY29udGFpbmVyQm94W3NpemVdICsgc3RlcCxcclxuICAgICAgICBpbml0aWFsQXhpcyA9IGF4aXNbMF07XHJcblxyXG4gICAgLy8gSWYgdGhlIHNwZWNpZmllZCBpbnRpYWwgcG9zaXRpb24gaXMgZ3JlYXRlciB0aGVuIHRoZSBtYXggcG9zaXRpb24gdGhlblxyXG4gICAgLy8gY2xhbXAgdGhlIGJveCB0byB0aGUgYW1vdW50IG9mIHN0ZXBzIGl0IHdvdWxkIHRha2UgZm9yIHRoZSBib3ggdG9cclxuICAgIC8vIHJlYWNoIHRoZSBtYXggcG9zaXRpb24uXHJcbiAgICBpZiAoTWF0aC5hYnMocG9zaXRpb24pID4gbWF4UG9zaXRpb24pIHtcclxuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA8IDAgPyAtMSA6IDE7XHJcbiAgICAgIHBvc2l0aW9uICo9IE1hdGguY2VpbChtYXhQb3NpdGlvbiAvIHN0ZXApICogc3RlcDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBjb21wdXRlZCBsaW5lIHBvc2l0aW9uIHJldHVybnMgbmVnYXRpdmUgdGhlbiBsaW5lIG51bWJlcnMgYXJlXHJcbiAgICAvLyByZWxhdGl2ZSB0byB0aGUgYm90dG9tIG9mIHRoZSB2aWRlbyBpbnN0ZWFkIG9mIHRoZSB0b3AuIFRoZXJlZm9yZSwgd2VcclxuICAgIC8vIG5lZWQgdG8gaW5jcmVhc2Ugb3VyIGluaXRpYWwgcG9zaXRpb24gYnkgdGhlIGxlbmd0aCBvciB3aWR0aCBvZiB0aGVcclxuICAgIC8vIHZpZGVvLCBkZXBlbmRpbmcgb24gdGhlIHdyaXRpbmcgZGlyZWN0aW9uLCBhbmQgcmV2ZXJzZSBvdXIgYXhpcyBkaXJlY3Rpb25zLlxyXG4gICAgaWYgKGxpbmVQb3MgPCAwKSB7XHJcbiAgICAgIHBvc2l0aW9uICs9IGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIiA/IGNvbnRhaW5lckJveC5oZWlnaHQgOiBjb250YWluZXJCb3gud2lkdGg7XHJcbiAgICAgIGF4aXMgPSBheGlzLnJldmVyc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNb3ZlIHRoZSBib3ggdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbi4gVGhpcyBtYXkgbm90IGJlIGl0cyBiZXN0XHJcbiAgICAvLyBwb3NpdGlvbi5cclxuICAgIGJveFBvc2l0aW9uLm1vdmUoaW5pdGlhbEF4aXMsIHBvc2l0aW9uKTtcclxuXHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIElmIHdlIGhhdmUgYSBwZXJjZW50YWdlIGxpbmUgdmFsdWUgZm9yIHRoZSBjdWUuXHJcbiAgICB2YXIgY2FsY3VsYXRlZFBlcmNlbnRhZ2UgPSAoYm94UG9zaXRpb24ubGluZUhlaWdodCAvIGNvbnRhaW5lckJveC5oZWlnaHQpICogMTAwO1xyXG5cclxuICAgIHN3aXRjaCAoY3VlLmxpbmVBbGlnbikge1xyXG4gICAgY2FzZSBcIm1pZGRsZVwiOlxyXG4gICAgICBsaW5lUG9zIC09IChjYWxjdWxhdGVkUGVyY2VudGFnZSAvIDIpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgXCJlbmRcIjpcclxuICAgICAgbGluZVBvcyAtPSBjYWxjdWxhdGVkUGVyY2VudGFnZTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQXBwbHkgaW5pdGlhbCBsaW5lIHBvc2l0aW9uIHRvIHRoZSBjdWUgYm94LlxyXG4gICAgc3dpdGNoIChjdWUudmVydGljYWwpIHtcclxuICAgIGNhc2UgXCJcIjpcclxuICAgICAgc3R5bGVCb3guYXBwbHlTdHlsZXMoe1xyXG4gICAgICAgIHRvcDogc3R5bGVCb3guZm9ybWF0U3R5bGUobGluZVBvcywgXCIlXCIpXHJcbiAgICAgIH0pO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgXCJybFwiOlxyXG4gICAgICBzdHlsZUJveC5hcHBseVN0eWxlcyh7XHJcbiAgICAgICAgbGVmdDogc3R5bGVCb3guZm9ybWF0U3R5bGUobGluZVBvcywgXCIlXCIpXHJcbiAgICAgIH0pO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgXCJsclwiOlxyXG4gICAgICBzdHlsZUJveC5hcHBseVN0eWxlcyh7XHJcbiAgICAgICAgcmlnaHQ6IHN0eWxlQm94LmZvcm1hdFN0eWxlKGxpbmVQb3MsIFwiJVwiKVxyXG4gICAgICB9KTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgYXhpcyA9IFsgXCIreVwiLCBcIi14XCIsIFwiK3hcIiwgXCIteVwiIF07XHJcblxyXG4gICAgLy8gR2V0IHRoZSBib3ggcG9zaXRpb24gYWdhaW4gYWZ0ZXIgd2UndmUgYXBwbGllZCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uaW5nXHJcbiAgICAvLyB0byBpdC5cclxuICAgIGJveFBvc2l0aW9uID0gbmV3IEJveFBvc2l0aW9uKHN0eWxlQm94KTtcclxuICB9XHJcblxyXG4gIHZhciBiZXN0UG9zaXRpb24gPSBmaW5kQmVzdFBvc2l0aW9uKGJveFBvc2l0aW9uLCBheGlzKTtcclxuICBzdHlsZUJveC5tb3ZlKGJlc3RQb3NpdGlvbi50b0NTU0NvbXBhdFZhbHVlcyhjb250YWluZXJCb3gpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gV2ViVlRUJDEoKSB7XHJcbiAgLy8gTm90aGluZ1xyXG59XHJcblxyXG4vLyBIZWxwZXIgdG8gYWxsb3cgc3RyaW5ncyB0byBiZSBkZWNvZGVkIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYmluYXJ5IHV0ZjggZGF0YS5cclxuV2ViVlRUJDEuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBkZWNvZGU6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgLSBleHBlY3RlZCBzdHJpbmcgZGF0YS5cIik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZGF0YSkpO1xyXG4gICAgfVxyXG4gIH07XHJcbn07XHJcblxyXG5XZWJWVFQkMS5jb252ZXJ0Q3VlVG9ET01UcmVlID0gZnVuY3Rpb24od2luZG93LCBjdWV0ZXh0KSB7XHJcbiAgaWYgKCF3aW5kb3cgfHwgIWN1ZXRleHQpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gcGFyc2VDb250ZW50KHdpbmRvdywgY3VldGV4dCk7XHJcbn07XHJcblxyXG52YXIgRk9OVF9TSVpFX1BFUkNFTlQgPSAwLjA1O1xyXG52YXIgRk9OVF9TVFlMRSA9IFwic2Fucy1zZXJpZlwiO1xyXG52YXIgQ1VFX0JBQ0tHUk9VTkRfUEFERElORyA9IFwiMS41JVwiO1xyXG5cclxuLy8gUnVucyB0aGUgcHJvY2Vzc2luZyBtb2RlbCBvdmVyIHRoZSBjdWVzIGFuZCByZWdpb25zIHBhc3NlZCB0byBpdC5cclxuLy8gQHBhcmFtIG92ZXJsYXkgQSBibG9jayBsZXZlbCBlbGVtZW50ICh1c3VhbGx5IGEgZGl2KSB0aGF0IHRoZSBjb21wdXRlZCBjdWVzXHJcbi8vICAgICAgICAgICAgICAgIGFuZCByZWdpb25zIHdpbGwgYmUgcGxhY2VkIGludG8uXHJcbldlYlZUVCQxLnByb2Nlc3NDdWVzID0gZnVuY3Rpb24od2luZG93LCBjdWVzLCBvdmVybGF5KSB7XHJcbiAgaWYgKCF3aW5kb3cgfHwgIWN1ZXMgfHwgIW92ZXJsYXkpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIGFsbCBwcmV2aW91cyBjaGlsZHJlbi5cclxuICB3aGlsZSAob3ZlcmxheS5maXJzdENoaWxkKSB7XHJcbiAgICBvdmVybGF5LnJlbW92ZUNoaWxkKG92ZXJsYXkuZmlyc3RDaGlsZCk7XHJcbiAgfVxyXG5cclxuICB2YXIgcGFkZGVkT3ZlcmxheSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gIHBhZGRlZE92ZXJsYXkuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XHJcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5sZWZ0ID0gXCIwXCI7XHJcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5yaWdodCA9IFwiMFwiO1xyXG4gIHBhZGRlZE92ZXJsYXkuc3R5bGUudG9wID0gXCIwXCI7XHJcbiAgcGFkZGVkT3ZlcmxheS5zdHlsZS5ib3R0b20gPSBcIjBcIjtcclxuICBwYWRkZWRPdmVybGF5LnN0eWxlLm1hcmdpbiA9IENVRV9CQUNLR1JPVU5EX1BBRERJTkc7XHJcbiAgb3ZlcmxheS5hcHBlbmRDaGlsZChwYWRkZWRPdmVybGF5KTtcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgZGlzcGxheSBzdGF0ZXMgb2YgdGhlIGN1ZXMuIFRoaXMgY291bGRcclxuICAvLyBiZSB0aGUgY2FzZSBpZiBhIGN1ZSdzIHN0YXRlIGhhcyBiZWVuIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgY29tcHV0YXRpb24gb3JcclxuICAvLyBpZiBpdCBoYXMgbm90IGJlZW4gY29tcHV0ZWQgeWV0LlxyXG4gIGZ1bmN0aW9uIHNob3VsZENvbXB1dGUoY3Vlcykge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChjdWVzW2ldLmhhc0JlZW5SZXNldCB8fCAhY3Vlc1tpXS5kaXNwbGF5U3RhdGUpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZWNvbXB1dGUgdGhlIGN1ZXMnIGRpc3BsYXkgc3RhdGVzLiBKdXN0IHJldXNlIHRoZW0uXHJcbiAgaWYgKCFzaG91bGRDb21wdXRlKGN1ZXMpKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgcGFkZGVkT3ZlcmxheS5hcHBlbmRDaGlsZChjdWVzW2ldLmRpc3BsYXlTdGF0ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgYm94UG9zaXRpb25zID0gW10sXHJcbiAgICAgIGNvbnRhaW5lckJveCA9IEJveFBvc2l0aW9uLmdldFNpbXBsZUJveFBvc2l0aW9uKHBhZGRlZE92ZXJsYXkpLFxyXG4gICAgICBmb250U2l6ZSA9IE1hdGgucm91bmQoY29udGFpbmVyQm94LmhlaWdodCAqIEZPTlRfU0laRV9QRVJDRU5UICogMTAwKSAvIDEwMDtcclxuICB2YXIgc3R5bGVPcHRpb25zID0ge1xyXG4gICAgZm9udDogZm9udFNpemUgKyBcInB4IFwiICsgRk9OVF9TVFlMRVxyXG4gIH07XHJcblxyXG4gIChmdW5jdGlvbigpIHtcclxuICAgIHZhciBzdHlsZUJveCwgY3VlO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3Vlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjdWUgPSBjdWVzW2ldO1xyXG5cclxuICAgICAgLy8gQ29tcHV0ZSB0aGUgaW50aWFsIHBvc2l0aW9uIGFuZCBzdHlsZXMgb2YgdGhlIGN1ZSBkaXYuXHJcbiAgICAgIHN0eWxlQm94ID0gbmV3IEN1ZVN0eWxlQm94KHdpbmRvdywgY3VlLCBzdHlsZU9wdGlvbnMpO1xyXG4gICAgICBwYWRkZWRPdmVybGF5LmFwcGVuZENoaWxkKHN0eWxlQm94LmRpdik7XHJcblxyXG4gICAgICAvLyBNb3ZlIHRoZSBjdWUgZGl2IHRvIGl0J3MgY29ycmVjdCBsaW5lIHBvc2l0aW9uLlxyXG4gICAgICBtb3ZlQm94VG9MaW5lUG9zaXRpb24od2luZG93LCBzdHlsZUJveCwgY29udGFpbmVyQm94LCBib3hQb3NpdGlvbnMpO1xyXG5cclxuICAgICAgLy8gUmVtZW1iZXIgdGhlIGNvbXB1dGVkIGRpdiBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gcmVjb21wdXRlIGl0IGxhdGVyXHJcbiAgICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgdG9vLlxyXG4gICAgICBjdWUuZGlzcGxheVN0YXRlID0gc3R5bGVCb3guZGl2O1xyXG5cclxuICAgICAgYm94UG9zaXRpb25zLnB1c2goQm94UG9zaXRpb24uZ2V0U2ltcGxlQm94UG9zaXRpb24oc3R5bGVCb3gpKTtcclxuICAgIH1cclxuICB9KSgpO1xyXG59O1xyXG5cclxuV2ViVlRUJDEuUGFyc2VyID0gZnVuY3Rpb24od2luZG93LCB2dHRqcywgZGVjb2Rlcikge1xyXG4gIGlmICghZGVjb2Rlcikge1xyXG4gICAgZGVjb2RlciA9IHZ0dGpzO1xyXG4gICAgdnR0anMgPSB7fTtcclxuICB9XHJcbiAgaWYgKCF2dHRqcykge1xyXG4gICAgdnR0anMgPSB7fTtcclxuICB9XHJcblxyXG4gIHRoaXMud2luZG93ID0gd2luZG93O1xyXG4gIHRoaXMudnR0anMgPSB2dHRqcztcclxuICB0aGlzLnN0YXRlID0gXCJJTklUSUFMXCI7XHJcbiAgdGhpcy5idWZmZXIgPSBcIlwiO1xyXG4gIHRoaXMuZGVjb2RlciA9IGRlY29kZXIgfHwgbmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTtcclxuICB0aGlzLnJlZ2lvbkxpc3QgPSBbXTtcclxufTtcclxuXHJcbldlYlZUVCQxLlBhcnNlci5wcm90b3R5cGUgPSB7XHJcbiAgLy8gSWYgdGhlIGVycm9yIGlzIGEgUGFyc2luZ0Vycm9yIHRoZW4gcmVwb3J0IGl0IHRvIHRoZSBjb25zdW1lciBpZlxyXG4gIC8vIHBvc3NpYmxlLiBJZiBpdCdzIG5vdCBhIFBhcnNpbmdFcnJvciB0aGVuIHRocm93IGl0IGxpa2Ugbm9ybWFsLlxyXG4gIHJlcG9ydE9yVGhyb3dFcnJvcjogZnVuY3Rpb24oZSkge1xyXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBQYXJzaW5nRXJyb3IpIHtcclxuICAgICAgdGhpcy5vbnBhcnNpbmdlcnJvciAmJiB0aGlzLm9ucGFyc2luZ2Vycm9yKGUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgZTtcclxuICAgIH1cclxuICB9LFxyXG4gIHBhcnNlOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIC8vIElmIHRoZXJlIGlzIG5vIGRhdGEgdGhlbiB3ZSB3b24ndCBkZWNvZGUgaXQsIGJ1dCB3aWxsIGp1c3QgdHJ5IHRvIHBhcnNlXHJcbiAgICAvLyB3aGF0ZXZlciBpcyBpbiBidWZmZXIgYWxyZWFkeS4gVGhpcyBtYXkgb2NjdXIgaW4gY2lyY3Vtc3RhbmNlcywgZm9yXHJcbiAgICAvLyBleGFtcGxlIHdoZW4gZmx1c2goKSBpcyBjYWxsZWQuXHJcbiAgICBpZiAoZGF0YSkge1xyXG4gICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSBkYXRhIHRoYXQgd2UgcmVjZWl2ZWQuXHJcbiAgICAgIHNlbGYuYnVmZmVyICs9IHNlbGYuZGVjb2Rlci5kZWNvZGUoZGF0YSwge3N0cmVhbTogdHJ1ZX0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbGxlY3ROZXh0TGluZSgpIHtcclxuICAgICAgdmFyIGJ1ZmZlciA9IHNlbGYuYnVmZmVyO1xyXG4gICAgICB2YXIgcG9zID0gMDtcclxuICAgICAgd2hpbGUgKHBvcyA8IGJ1ZmZlci5sZW5ndGggJiYgYnVmZmVyW3Bvc10gIT09ICdcXHInICYmIGJ1ZmZlcltwb3NdICE9PSAnXFxuJykge1xyXG4gICAgICAgICsrcG9zO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBsaW5lID0gYnVmZmVyLnN1YnN0cigwLCBwb3MpO1xyXG4gICAgICAvLyBBZHZhbmNlIHRoZSBidWZmZXIgZWFybHkgaW4gY2FzZSB3ZSBmYWlsIGJlbG93LlxyXG4gICAgICBpZiAoYnVmZmVyW3Bvc10gPT09ICdcXHInKSB7XHJcbiAgICAgICAgKytwb3M7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGJ1ZmZlcltwb3NdID09PSAnXFxuJykge1xyXG4gICAgICAgICsrcG9zO1xyXG4gICAgICB9XHJcbiAgICAgIHNlbGYuYnVmZmVyID0gYnVmZmVyLnN1YnN0cihwb3MpO1xyXG4gICAgICByZXR1cm4gbGluZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAzLjQgV2ViVlRUIHJlZ2lvbiBhbmQgV2ViVlRUIHJlZ2lvbiBzZXR0aW5ncyBzeW50YXhcclxuICAgIGZ1bmN0aW9uIHBhcnNlUmVnaW9uKGlucHV0KSB7XHJcbiAgICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xyXG5cclxuICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgICAgIHN3aXRjaCAoaykge1xyXG4gICAgICAgIGNhc2UgXCJpZFwiOlxyXG4gICAgICAgICAgc2V0dGluZ3Muc2V0KGssIHYpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIndpZHRoXCI6XHJcbiAgICAgICAgICBzZXR0aW5ncy5wZXJjZW50KGssIHYpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImxpbmVzXCI6XHJcbiAgICAgICAgICBzZXR0aW5ncy5pbnRlZ2VyKGssIHYpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcInJlZ2lvbmFuY2hvclwiOlxyXG4gICAgICAgIGNhc2UgXCJ2aWV3cG9ydGFuY2hvclwiOlxyXG4gICAgICAgICAgdmFyIHh5ID0gdi5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgaWYgKHh5Lmxlbmd0aCAhPT0gMikge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbWFrZSBzdXJlIGJvdGggeCBhbmQgeSBwYXJzZSwgc28gdXNlIGEgdGVtcG9yYXJ5XHJcbiAgICAgICAgICAvLyBzZXR0aW5ncyBvYmplY3QgaGVyZS5cclxuICAgICAgICAgIHZhciBhbmNob3IgPSBuZXcgU2V0dGluZ3MoKTtcclxuICAgICAgICAgIGFuY2hvci5wZXJjZW50KFwieFwiLCB4eVswXSk7XHJcbiAgICAgICAgICBhbmNob3IucGVyY2VudChcInlcIiwgeHlbMV0pO1xyXG4gICAgICAgICAgaWYgKCFhbmNob3IuaGFzKFwieFwiKSB8fCAhYW5jaG9yLmhhcyhcInlcIikpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzZXR0aW5ncy5zZXQoayArIFwiWFwiLCBhbmNob3IuZ2V0KFwieFwiKSk7XHJcbiAgICAgICAgICBzZXR0aW5ncy5zZXQoayArIFwiWVwiLCBhbmNob3IuZ2V0KFwieVwiKSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwic2Nyb2xsXCI6XHJcbiAgICAgICAgICBzZXR0aW5ncy5hbHQoaywgdiwgW1widXBcIl0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCAvPS8sIC9cXHMvKTtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgcmVnaW9uLCB1c2luZyBkZWZhdWx0IHZhbHVlcyBmb3IgYW55IHZhbHVlcyB0aGF0IHdlcmUgbm90XHJcbiAgICAgIC8vIHNwZWNpZmllZC5cclxuICAgICAgaWYgKHNldHRpbmdzLmhhcyhcImlkXCIpKSB7XHJcbiAgICAgICAgdmFyIHJlZ2lvbiA9IG5ldyAoc2VsZi52dHRqcy5WVFRSZWdpb24gfHwgc2VsZi53aW5kb3cuVlRUUmVnaW9uKSgpO1xyXG4gICAgICAgIHJlZ2lvbi53aWR0aCA9IHNldHRpbmdzLmdldChcIndpZHRoXCIsIDEwMCk7XHJcbiAgICAgICAgcmVnaW9uLmxpbmVzID0gc2V0dGluZ3MuZ2V0KFwibGluZXNcIiwgMyk7XHJcbiAgICAgICAgcmVnaW9uLnJlZ2lvbkFuY2hvclggPSBzZXR0aW5ncy5nZXQoXCJyZWdpb25hbmNob3JYXCIsIDApO1xyXG4gICAgICAgIHJlZ2lvbi5yZWdpb25BbmNob3JZID0gc2V0dGluZ3MuZ2V0KFwicmVnaW9uYW5jaG9yWVwiLCAxMDApO1xyXG4gICAgICAgIHJlZ2lvbi52aWV3cG9ydEFuY2hvclggPSBzZXR0aW5ncy5nZXQoXCJ2aWV3cG9ydGFuY2hvclhcIiwgMCk7XHJcbiAgICAgICAgcmVnaW9uLnZpZXdwb3J0QW5jaG9yWSA9IHNldHRpbmdzLmdldChcInZpZXdwb3J0YW5jaG9yWVwiLCAxMDApO1xyXG4gICAgICAgIHJlZ2lvbi5zY3JvbGwgPSBzZXR0aW5ncy5nZXQoXCJzY3JvbGxcIiwgXCJcIik7XHJcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIHJlZ2lvbi5cclxuICAgICAgICBzZWxmLm9ucmVnaW9uICYmIHNlbGYub25yZWdpb24ocmVnaW9uKTtcclxuICAgICAgICAvLyBSZW1lbWJlciB0aGUgVlRUUmVnaW9uIGZvciBsYXRlciBpbiBjYXNlIHdlIHBhcnNlIGFueSBWVFRDdWVzIHRoYXRcclxuICAgICAgICAvLyByZWZlcmVuY2UgaXQuXHJcbiAgICAgICAgc2VsZi5yZWdpb25MaXN0LnB1c2goe1xyXG4gICAgICAgICAgaWQ6IHNldHRpbmdzLmdldChcImlkXCIpLFxyXG4gICAgICAgICAgcmVnaW9uOiByZWdpb25cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGRyYWZ0LXBhbnRvcy1odHRwLWxpdmUtc3RyZWFtaW5nLTIwXHJcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGFudG9zLWh0dHAtbGl2ZS1zdHJlYW1pbmctMjAjc2VjdGlvbi0zLjVcclxuICAgIC8vIDMuNSBXZWJWVFRcclxuICAgIGZ1bmN0aW9uIHBhcnNlVGltZXN0YW1wTWFwKGlucHV0KSB7XHJcbiAgICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncygpO1xyXG5cclxuICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbihrLCB2KSB7XHJcbiAgICAgICAgc3dpdGNoKGspIHtcclxuICAgICAgICBjYXNlIFwiTVBFR1RcIjpcclxuICAgICAgICAgIHNldHRpbmdzLmludGVnZXIoayArICdTJywgdik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiTE9DQVwiOlxyXG4gICAgICAgICAgc2V0dGluZ3Muc2V0KGsgKyAnTCcsIHBhcnNlVGltZVN0YW1wKHYpKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgL1teXFxkXTovLCAvLC8pO1xyXG5cclxuICAgICAgc2VsZi5vbnRpbWVzdGFtcG1hcCAmJiBzZWxmLm9udGltZXN0YW1wbWFwKHtcclxuICAgICAgICBcIk1QRUdUU1wiOiBzZXR0aW5ncy5nZXQoXCJNUEVHVFNcIiksXHJcbiAgICAgICAgXCJMT0NBTFwiOiBzZXR0aW5ncy5nZXQoXCJMT0NBTFwiKVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAzLjIgV2ViVlRUIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcclxuICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGlucHV0KSB7XHJcbiAgICAgIGlmIChpbnB1dC5tYXRjaCgvWC1USU1FU1RBTVAtTUFQLykpIHtcclxuICAgICAgICAvLyBUaGlzIGxpbmUgY29udGFpbnMgSExTIFgtVElNRVNUQU1QLU1BUCBtZXRhZGF0YVxyXG4gICAgICAgIHBhcnNlT3B0aW9ucyhpbnB1dCwgZnVuY3Rpb24oaywgdikge1xyXG4gICAgICAgICAgc3dpdGNoKGspIHtcclxuICAgICAgICAgIGNhc2UgXCJYLVRJTUVTVEFNUC1NQVBcIjpcclxuICAgICAgICAgICAgcGFyc2VUaW1lc3RhbXBNYXAodik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIC89Lyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGFyc2VPcHRpb25zKGlucHV0LCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgICAgICAgc3dpdGNoIChrKSB7XHJcbiAgICAgICAgICBjYXNlIFwiUmVnaW9uXCI6XHJcbiAgICAgICAgICAgIC8vIDMuMyBXZWJWVFQgcmVnaW9uIG1ldGFkYXRhIGhlYWRlciBzeW50YXhcclxuICAgICAgICAgICAgcGFyc2VSZWdpb24odik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIC86Lyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gNS4xIFdlYlZUVCBmaWxlIHBhcnNpbmcuXHJcbiAgICB0cnkge1xyXG4gICAgICB2YXIgbGluZTtcclxuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFwiSU5JVElBTFwiKSB7XHJcbiAgICAgICAgLy8gV2UgY2FuJ3Qgc3RhcnQgcGFyc2luZyB1bnRpbCB3ZSBoYXZlIHRoZSBmaXJzdCBsaW5lLlxyXG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3Qoc2VsZi5idWZmZXIpKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxpbmUgPSBjb2xsZWN0TmV4dExpbmUoKTtcclxuXHJcbiAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKC9eV0VCVlRUKFsgXFx0XS4qKT8kLyk7XHJcbiAgICAgICAgaWYgKCFtIHx8ICFtWzBdKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvci5FcnJvcnMuQmFkU2lnbmF0dXJlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGYuc3RhdGUgPSBcIkhFQURFUlwiO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgYWxyZWFkeUNvbGxlY3RlZExpbmUgPSBmYWxzZTtcclxuICAgICAgd2hpbGUgKHNlbGYuYnVmZmVyKSB7XHJcbiAgICAgICAgLy8gV2UgY2FuJ3QgcGFyc2UgYSBsaW5lIHVudGlsIHdlIGhhdmUgdGhlIGZ1bGwgbGluZS5cclxuICAgICAgICBpZiAoIS9cXHJcXG58XFxuLy50ZXN0KHNlbGYuYnVmZmVyKSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWFscmVhZHlDb2xsZWN0ZWRMaW5lKSB7XHJcbiAgICAgICAgICBsaW5lID0gY29sbGVjdE5leHRMaW5lKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFscmVhZHlDb2xsZWN0ZWRMaW5lID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzd2l0Y2ggKHNlbGYuc3RhdGUpIHtcclxuICAgICAgICBjYXNlIFwiSEVBREVSXCI6XHJcbiAgICAgICAgICAvLyAxMy0xOCAtIEFsbG93IGEgaGVhZGVyIChtZXRhZGF0YSkgdW5kZXIgdGhlIFdFQlZUVCBsaW5lLlxyXG4gICAgICAgICAgaWYgKC86Ly50ZXN0KGxpbmUpKSB7XHJcbiAgICAgICAgICAgIHBhcnNlSGVhZGVyKGxpbmUpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICghbGluZSkge1xyXG4gICAgICAgICAgICAvLyBBbiBlbXB0eSBsaW5lIHRlcm1pbmF0ZXMgdGhlIGhlYWRlciBhbmQgc3RhcnRzIHRoZSBib2R5IChjdWVzKS5cclxuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiSURcIjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGNhc2UgXCJOT1RFXCI6XHJcbiAgICAgICAgICAvLyBJZ25vcmUgTk9URSBibG9ja3MuXHJcbiAgICAgICAgICBpZiAoIWxpbmUpIHtcclxuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiSURcIjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGNhc2UgXCJJRFwiOlxyXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBzdGFydCBvZiBOT1RFIGJsb2Nrcy5cclxuICAgICAgICAgIGlmICgvXk5PVEUoJHxbIFxcdF0pLy50ZXN0KGxpbmUpKSB7XHJcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIk5PVEVcIjtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyAxOS0yOSAtIEFsbG93IGFueSBudW1iZXIgb2YgbGluZSB0ZXJtaW5hdG9ycywgdGhlbiBpbml0aWFsaXplIG5ldyBjdWUgdmFsdWVzLlxyXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc2VsZi5jdWUgPSBuZXcgKHNlbGYudnR0anMuVlRUQ3VlIHx8IHNlbGYud2luZG93LlZUVEN1ZSkoMCwgMCwgXCJcIik7XHJcbiAgICAgICAgICBzZWxmLnN0YXRlID0gXCJDVUVcIjtcclxuICAgICAgICAgIC8vIDMwLTM5IC0gQ2hlY2sgaWYgc2VsZiBsaW5lIGNvbnRhaW5zIGFuIG9wdGlvbmFsIGlkZW50aWZpZXIgb3IgdGltaW5nIGRhdGEuXHJcbiAgICAgICAgICBpZiAobGluZS5pbmRleE9mKFwiLS0+XCIpID09PSAtMSkge1xyXG4gICAgICAgICAgICBzZWxmLmN1ZS5pZCA9IGxpbmU7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gUHJvY2VzcyBsaW5lIGFzIHN0YXJ0IG9mIGEgY3VlLlxyXG4gICAgICAgICAgLypmYWxscyB0aHJvdWdoKi9cclxuICAgICAgICBjYXNlIFwiQ1VFXCI6XHJcbiAgICAgICAgICAvLyA0MCAtIENvbGxlY3QgY3VlIHRpbWluZ3MgYW5kIHNldHRpbmdzLlxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcGFyc2VDdWUobGluZSwgc2VsZi5jdWUsIHNlbGYucmVnaW9uTGlzdCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHNlbGYucmVwb3J0T3JUaHJvd0Vycm9yKGUpO1xyXG4gICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yIGlnbm9yZSByZXN0IG9mIHRoZSBjdWUuXHJcbiAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcclxuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiQkFEQ1VFXCI7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiQ1VFVEVYVFwiO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgY2FzZSBcIkNVRVRFWFRcIjpcclxuICAgICAgICAgIHZhciBoYXNTdWJzdHJpbmcgPSBsaW5lLmluZGV4T2YoXCItLT5cIikgIT09IC0xO1xyXG4gICAgICAgICAgLy8gMzQgLSBJZiB3ZSBoYXZlIGFuIGVtcHR5IGxpbmUgdGhlbiByZXBvcnQgdGhlIGN1ZS5cclxuICAgICAgICAgIC8vIDM1IC0gSWYgd2UgaGF2ZSB0aGUgc3BlY2lhbCBzdWJzdHJpbmcgJy0tPicgdGhlbiByZXBvcnQgdGhlIGN1ZSxcclxuICAgICAgICAgIC8vIGJ1dCBkbyBub3QgY29sbGVjdCB0aGUgbGluZSBhcyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIGN1cnJlbnRcclxuICAgICAgICAgIC8vIG9uZSBhcyBhIG5ldyBjdWUuXHJcbiAgICAgICAgICBpZiAoIWxpbmUgfHwgaGFzU3Vic3RyaW5nICYmIChhbHJlYWR5Q29sbGVjdGVkTGluZSA9IHRydWUpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGFyZSBkb25lIHBhcnNpbmcgc2VsZiBjdWUuXHJcbiAgICAgICAgICAgIHNlbGYub25jdWUgJiYgc2VsZi5vbmN1ZShzZWxmLmN1ZSk7XHJcbiAgICAgICAgICAgIHNlbGYuY3VlID0gbnVsbDtcclxuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IFwiSURcIjtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoc2VsZi5jdWUudGV4dCkge1xyXG4gICAgICAgICAgICBzZWxmLmN1ZS50ZXh0ICs9IFwiXFxuXCI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzZWxmLmN1ZS50ZXh0ICs9IGxpbmU7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICBjYXNlIFwiQkFEQ1VFXCI6IC8vIEJBRENVRVxyXG4gICAgICAgICAgLy8gNTQtNjIgLSBDb2xsZWN0IGFuZCBkaXNjYXJkIHRoZSByZW1haW5pbmcgY3VlLlxyXG4gICAgICAgICAgaWYgKCFsaW5lKSB7XHJcbiAgICAgICAgICAgIHNlbGYuc3RhdGUgPSBcIklEXCI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgc2VsZi5yZXBvcnRPclRocm93RXJyb3IoZSk7XHJcblxyXG4gICAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IHBhcnNpbmcgYSBjdWUsIHJlcG9ydCB3aGF0IHdlIGhhdmUuXHJcbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSBcIkNVRVRFWFRcIiAmJiBzZWxmLmN1ZSAmJiBzZWxmLm9uY3VlKSB7XHJcbiAgICAgICAgc2VsZi5vbmN1ZShzZWxmLmN1ZSk7XHJcbiAgICAgIH1cclxuICAgICAgc2VsZi5jdWUgPSBudWxsO1xyXG4gICAgICAvLyBFbnRlciBCQURXRUJWVFQgc3RhdGUgaWYgaGVhZGVyIHdhcyBub3QgcGFyc2VkIGNvcnJlY3RseSBvdGhlcndpc2VcclxuICAgICAgLy8gYW5vdGhlciBleGNlcHRpb24gb2NjdXJyZWQgc28gZW50ZXIgQkFEQ1VFIHN0YXRlLlxyXG4gICAgICBzZWxmLnN0YXRlID0gc2VsZi5zdGF0ZSA9PT0gXCJJTklUSUFMXCIgPyBcIkJBRFdFQlZUVFwiIDogXCJCQURDVUVcIjtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcbiAgZmx1c2g6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEZpbmlzaCBkZWNvZGluZyB0aGUgc3RyZWFtLlxyXG4gICAgICBzZWxmLmJ1ZmZlciArPSBzZWxmLmRlY29kZXIuZGVjb2RlKCk7XHJcbiAgICAgIC8vIFN5bnRoZXNpemUgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjdWUgb3IgcmVnaW9uLlxyXG4gICAgICBpZiAoc2VsZi5jdWUgfHwgc2VsZi5zdGF0ZSA9PT0gXCJIRUFERVJcIikge1xyXG4gICAgICAgIHNlbGYuYnVmZmVyICs9IFwiXFxuXFxuXCI7XHJcbiAgICAgICAgc2VsZi5wYXJzZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIElmIHdlJ3ZlIGZsdXNoZWQsIHBhcnNlZCwgYW5kIHdlJ3JlIHN0aWxsIG9uIHRoZSBJTklUSUFMIHN0YXRlIHRoZW5cclxuICAgICAgLy8gdGhhdCBtZWFucyB3ZSBkb24ndCBoYXZlIGVub3VnaCBvZiB0aGUgc3RyZWFtIHRvIHBhcnNlIHRoZSBmaXJzdFxyXG4gICAgICAvLyBsaW5lLlxyXG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gXCJJTklUSUFMXCIpIHtcclxuICAgICAgICB0aHJvdyBuZXcgUGFyc2luZ0Vycm9yKFBhcnNpbmdFcnJvci5FcnJvcnMuQmFkU2lnbmF0dXJlKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaChlKSB7XHJcbiAgICAgIHNlbGYucmVwb3J0T3JUaHJvd0Vycm9yKGUpO1xyXG4gICAgfVxyXG4gICAgc2VsZi5vbmZsdXNoICYmIHNlbGYub25mbHVzaCgpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG59O1xyXG5cclxudmFyIHZ0dCQxID0gV2ViVlRUJDE7XHJcblxyXG4vKipcclxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxudmFyIGF1dG9LZXl3b3JkID0gXCJhdXRvXCI7XHJcbnZhciBkaXJlY3Rpb25TZXR0aW5nID0ge1xyXG4gIFwiXCI6IHRydWUsXHJcbiAgXCJsclwiOiB0cnVlLFxyXG4gIFwicmxcIjogdHJ1ZVxyXG59O1xyXG52YXIgYWxpZ25TZXR0aW5nID0ge1xyXG4gIFwic3RhcnRcIjogdHJ1ZSxcclxuICBcIm1pZGRsZVwiOiB0cnVlLFxyXG4gIFwiZW5kXCI6IHRydWUsXHJcbiAgXCJsZWZ0XCI6IHRydWUsXHJcbiAgXCJyaWdodFwiOiB0cnVlXHJcbn07XHJcblxyXG5mdW5jdGlvbiBmaW5kRGlyZWN0aW9uU2V0dGluZyh2YWx1ZSkge1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgdmFyIGRpciA9IGRpcmVjdGlvblNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XHJcbiAgcmV0dXJuIGRpciA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZmluZEFsaWduU2V0dGluZyh2YWx1ZSkge1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgdmFyIGFsaWduID0gYWxpZ25TZXR0aW5nW3ZhbHVlLnRvTG93ZXJDYXNlKCldO1xyXG4gIHJldHVybiBhbGlnbiA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXh0ZW5kJDEob2JqKSB7XHJcbiAgdmFyIGkgPSAxO1xyXG4gIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgY29iaiA9IGFyZ3VtZW50c1tpXTtcclxuICAgIGZvciAodmFyIHAgaW4gY29iaikge1xyXG4gICAgICBvYmpbcF0gPSBjb2JqW3BdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuZnVuY3Rpb24gVlRUQ3VlKHN0YXJ0VGltZSwgZW5kVGltZSwgdGV4dCkge1xyXG4gIHZhciBjdWUgPSB0aGlzO1xyXG4gIHZhciBpc0lFOCA9ICgvTVNJRVxcczhcXC4wLykudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcclxuICB2YXIgYmFzZU9iaiA9IHt9O1xyXG5cclxuICBpZiAoaXNJRTgpIHtcclxuICAgIGN1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2N1c3RvbScpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBiYXNlT2JqLmVudW1lcmFibGUgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2hpbSBpbXBsZW1lbnRhdGlvbiBzcGVjaWZpYyBwcm9wZXJ0aWVzLiBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBub3QgaW5cclxuICAgKiB0aGUgc3BlYy5cclxuICAgKi9cclxuXHJcbiAgLy8gTGV0cyB1cyBrbm93IHdoZW4gdGhlIFZUVEN1ZSdzIGRhdGEgaGFzIGNoYW5nZWQgaW4gc3VjaCBhIHdheSB0aGF0IHdlIG5lZWRcclxuICAvLyB0byByZWNvbXB1dGUgaXRzIGRpc3BsYXkgc3RhdGUuIFRoaXMgbGV0cyB1cyBjb21wdXRlIGl0cyBkaXNwbGF5IHN0YXRlXHJcbiAgLy8gbGF6aWx5LlxyXG4gIGN1ZS5oYXNCZWVuUmVzZXQgPSBmYWxzZTtcclxuXHJcbiAgLyoqXHJcbiAgICogVlRUQ3VlIGFuZCBUZXh0VHJhY2tDdWUgcHJvcGVydGllc1xyXG4gICAqIGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnZ0dC8jdnR0Y3VlLWludGVyZmFjZVxyXG4gICAqL1xyXG5cclxuICB2YXIgX2lkID0gXCJcIjtcclxuICB2YXIgX3BhdXNlT25FeGl0ID0gZmFsc2U7XHJcbiAgdmFyIF9zdGFydFRpbWUgPSBzdGFydFRpbWU7XHJcbiAgdmFyIF9lbmRUaW1lID0gZW5kVGltZTtcclxuICB2YXIgX3RleHQgPSB0ZXh0O1xyXG4gIHZhciBfcmVnaW9uID0gbnVsbDtcclxuICB2YXIgX3ZlcnRpY2FsID0gXCJcIjtcclxuICB2YXIgX3NuYXBUb0xpbmVzID0gdHJ1ZTtcclxuICB2YXIgX2xpbmUgPSBcImF1dG9cIjtcclxuICB2YXIgX2xpbmVBbGlnbiA9IFwic3RhcnRcIjtcclxuICB2YXIgX3Bvc2l0aW9uID0gNTA7XHJcbiAgdmFyIF9wb3NpdGlvbkFsaWduID0gXCJtaWRkbGVcIjtcclxuICB2YXIgX3NpemUgPSA1MDtcclxuICB2YXIgX2FsaWduID0gXCJtaWRkbGVcIjtcclxuXHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcclxuICAgIFwiaWRcIiwgZXh0ZW5kJDEoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX2lkO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgX2lkID0gXCJcIiArIHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXHJcbiAgICBcInBhdXNlT25FeGl0XCIsIGV4dGVuZCQxKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9wYXVzZU9uRXhpdDtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIF9wYXVzZU9uRXhpdCA9ICEhdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcclxuICAgIFwic3RhcnRUaW1lXCIsIGV4dGVuZCQxKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdGFydFRpbWU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3RhcnQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zdGFydFRpbWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcclxuICAgIFwiZW5kVGltZVwiLCBleHRlbmQkMSh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBfZW5kVGltZTtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFbmQgdGltZSBtdXN0IGJlIHNldCB0byBhIG51bWJlci5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9lbmRUaW1lID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXHJcbiAgICBcInRleHRcIiwgZXh0ZW5kJDEoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX3RleHQ7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBfdGV4dCA9IFwiXCIgKyB2YWx1ZTtcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcclxuICAgIFwicmVnaW9uXCIsIGV4dGVuZCQxKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9yZWdpb247XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBfcmVnaW9uID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXHJcbiAgICBcInZlcnRpY2FsXCIsIGV4dGVuZCQxKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF92ZXJ0aWNhbDtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZERpcmVjdGlvblNldHRpbmcodmFsdWUpO1xyXG4gICAgICAgIC8vIEhhdmUgdG8gY2hlY2sgZm9yIGZhbHNlIGJlY2F1c2UgdGhlIHNldHRpbmcgYW4gYmUgYW4gZW1wdHkgc3RyaW5nLlxyXG4gICAgICAgIGlmIChzZXR0aW5nID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3ZlcnRpY2FsID0gc2V0dGluZztcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcclxuICAgIFwic25hcFRvTGluZXNcIiwgZXh0ZW5kJDEoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX3NuYXBUb0xpbmVzO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgX3NuYXBUb0xpbmVzID0gISF2YWx1ZTtcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcclxuICAgIFwibGluZVwiLCBleHRlbmQkMSh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBfbGluZTtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIgJiYgdmFsdWUgIT09IGF1dG9LZXl3b3JkKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG51bWJlciBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2xpbmUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcclxuICAgIFwibGluZUFsaWduXCIsIGV4dGVuZCQxKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9saW5lQWxpZ247XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xyXG4gICAgICAgIGlmICghc2V0dGluZykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2xpbmVBbGlnbiA9IHNldHRpbmc7XHJcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXHJcbiAgICBcInBvc2l0aW9uXCIsIGV4dGVuZCQxKHt9LCBiYXNlT2JqLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9wb3NpdGlvbjtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc2l0aW9uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfcG9zaXRpb24gPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1ZSxcclxuICAgIFwicG9zaXRpb25BbGlnblwiLCBleHRlbmQkMSh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBfcG9zaXRpb25BbGlnbjtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzZXR0aW5nID0gZmluZEFsaWduU2V0dGluZyh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKCFzZXR0aW5nKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfcG9zaXRpb25BbGlnbiA9IHNldHRpbmc7XHJcbiAgICAgICAgdGhpcy5oYXNCZWVuUmVzZXQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KSk7XHJcblxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdWUsXHJcbiAgICBcInNpemVcIiwgZXh0ZW5kJDEoe30sIGJhc2VPYmosIHtcclxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX3NpemU7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaXplIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc2l6ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaGFzQmVlblJlc2V0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG5cclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VlLFxyXG4gICAgXCJhbGlnblwiLCBleHRlbmQkMSh7fSwgYmFzZU9iaiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBfYWxpZ247XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRBbGlnblNldHRpbmcodmFsdWUpO1xyXG4gICAgICAgIGlmICghc2V0dGluZykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2FsaWduID0gc2V0dGluZztcclxuICAgICAgICB0aGlzLmhhc0JlZW5SZXNldCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgLyoqXHJcbiAgICogT3RoZXIgPHRyYWNrPiBzcGVjIGRlZmluZWQgcHJvcGVydGllc1xyXG4gICAqL1xyXG5cclxuICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtdmlkZW8tZWxlbWVudC5odG1sI3RleHQtdHJhY2stY3VlLWRpc3BsYXktc3RhdGVcclxuICBjdWUuZGlzcGxheVN0YXRlID0gdW5kZWZpbmVkO1xyXG5cclxuICBpZiAoaXNJRTgpIHtcclxuICAgIHJldHVybiBjdWU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVlRUQ3VlIG1ldGhvZHNcclxuICovXHJcblxyXG5WVFRDdWUucHJvdG90eXBlLmdldEN1ZUFzSFRNTCA9IGZ1bmN0aW9uKCkge1xyXG4gIC8vIEFzc3VtZSBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSBpcyBvbiB0aGUgZ2xvYmFsLlxyXG4gIHJldHVybiBXZWJWVFQuY29udmVydEN1ZVRvRE9NVHJlZSh3aW5kb3csIHRoaXMudGV4dCk7XHJcbn07XHJcblxyXG52YXIgdnR0Y3VlID0gVlRUQ3VlO1xyXG5cclxuLyoqXHJcbiAqIENvcHlyaWdodCAyMDEzIHZ0dC5qcyBDb250cmlidXRvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBzY3JvbGxTZXR0aW5nID0ge1xyXG4gIFwiXCI6IHRydWUsXHJcbiAgXCJ1cFwiOiB0cnVlXHJcbn07XHJcblxyXG5mdW5jdGlvbiBmaW5kU2Nyb2xsU2V0dGluZyh2YWx1ZSkge1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgdmFyIHNjcm9sbCA9IHNjcm9sbFNldHRpbmdbdmFsdWUudG9Mb3dlckNhc2UoKV07XHJcbiAgcmV0dXJuIHNjcm9sbCA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkge1xyXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgKHZhbHVlID49IDAgJiYgdmFsdWUgPD0gMTAwKTtcclxufVxyXG5cclxuLy8gVlRUUmVnaW9uIHNoaW0gaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2VidnR0LyN2dHRyZWdpb24taW50ZXJmYWNlXHJcbmZ1bmN0aW9uIFZUVFJlZ2lvbigpIHtcclxuICB2YXIgX3dpZHRoID0gMTAwO1xyXG4gIHZhciBfbGluZXMgPSAzO1xyXG4gIHZhciBfcmVnaW9uQW5jaG9yWCA9IDA7XHJcbiAgdmFyIF9yZWdpb25BbmNob3JZID0gMTAwO1xyXG4gIHZhciBfdmlld3BvcnRBbmNob3JYID0gMDtcclxuICB2YXIgX3ZpZXdwb3J0QW5jaG9yWSA9IDEwMDtcclxuICB2YXIgX3Njcm9sbCA9IFwiXCI7XHJcblxyXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcclxuICAgIFwid2lkdGhcIjoge1xyXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBfd2lkdGg7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICBpZiAoIWlzVmFsaWRQZXJjZW50VmFsdWUodmFsdWUpKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaWR0aCBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3dpZHRoID0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcImxpbmVzXCI6IHtcclxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX2xpbmVzO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkxpbmVzIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX2xpbmVzID0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcInJlZ2lvbkFuY2hvcllcIjoge1xyXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBfcmVnaW9uQW5jaG9yWTtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIGlmICghaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZ2lvbkFuY2hvclggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9yZWdpb25BbmNob3JZID0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcInJlZ2lvbkFuY2hvclhcIjoge1xyXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBfcmVnaW9uQW5jaG9yWDtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIGlmKCFpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVnaW9uQW5jaG9yWSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3JlZ2lvbkFuY2hvclggPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIFwidmlld3BvcnRBbmNob3JZXCI6IHtcclxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX3ZpZXdwb3J0QW5jaG9yWTtcclxuICAgICAgfSxcclxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIGlmICghaXNWYWxpZFBlcmNlbnRWYWx1ZSh2YWx1ZSkpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZpZXdwb3J0QW5jaG9yWSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMTAwLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3ZpZXdwb3J0QW5jaG9yWSA9IHZhbHVlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgXCJ2aWV3cG9ydEFuY2hvclhcIjoge1xyXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBfdmlld3BvcnRBbmNob3JYO1xyXG4gICAgICB9LFxyXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkUGVyY2VudFZhbHVlKHZhbHVlKSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmlld3BvcnRBbmNob3JYIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdmlld3BvcnRBbmNob3JYID0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcInNjcm9sbFwiOiB7XHJcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zY3JvbGw7XHJcbiAgICAgIH0sXHJcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICB2YXIgc2V0dGluZyA9IGZpbmRTY3JvbGxTZXR0aW5nKHZhbHVlKTtcclxuICAgICAgICAvLyBIYXZlIHRvIGNoZWNrIGZvciBmYWxzZSBhcyBhbiBlbXB0eSBzdHJpbmcgaXMgYSBsZWdhbCB2YWx1ZS5cclxuICAgICAgICBpZiAoc2V0dGluZyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9zY3JvbGwgPSBzZXR0aW5nO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbn1cclxuXHJcbnZhciB2dHRyZWdpb24gPSBWVFRSZWdpb247XHJcblxyXG52YXIgYnJvd3NlckluZGV4ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xyXG4vKipcclxuICogQ29weXJpZ2h0IDIwMTMgdnR0LmpzIENvbnRyaWJ1dG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuLy8gRGVmYXVsdCBleHBvcnRzIGZvciBOb2RlLiBFeHBvcnQgdGhlIGV4dGVuZGVkIHZlcnNpb25zIG9mIFZUVEN1ZSBhbmRcclxuLy8gVlRUUmVnaW9uIGluIE5vZGUgc2luY2Ugd2UgbGlrZWx5IHdhbnQgdGhlIGNhcGFiaWxpdHkgdG8gY29udmVydCBiYWNrIGFuZFxyXG4vLyBmb3J0aCBiZXR3ZWVuIEpTT04uIElmIHdlIGRvbid0IHRoZW4gaXQncyBub3QgdGhhdCBiaWcgb2YgYSBkZWFsIHNpbmNlIHdlJ3JlXHJcbi8vIG9mZiBicm93c2VyLlxyXG5cclxuXHJcblxyXG52YXIgdnR0anMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICBXZWJWVFQ6IHZ0dCQxLFxyXG4gIFZUVEN1ZTogdnR0Y3VlLFxyXG4gIFZUVFJlZ2lvbjogdnR0cmVnaW9uXHJcbn07XHJcblxyXG53aW5kb3dfMS52dHRqcyA9IHZ0dGpzO1xyXG53aW5kb3dfMS5XZWJWVFQgPSB2dHRqcy5XZWJWVFQ7XHJcblxyXG52YXIgY3VlU2hpbSA9IHZ0dGpzLlZUVEN1ZTtcclxudmFyIHJlZ2lvblNoaW0gPSB2dHRqcy5WVFRSZWdpb247XHJcbnZhciBuYXRpdmVWVFRDdWUgPSB3aW5kb3dfMS5WVFRDdWU7XHJcbnZhciBuYXRpdmVWVFRSZWdpb24gPSB3aW5kb3dfMS5WVFRSZWdpb247XHJcblxyXG52dHRqcy5zaGltID0gZnVuY3Rpb24oKSB7XHJcbiAgd2luZG93XzEuVlRUQ3VlID0gY3VlU2hpbTtcclxuICB3aW5kb3dfMS5WVFRSZWdpb24gPSByZWdpb25TaGltO1xyXG59O1xyXG5cclxudnR0anMucmVzdG9yZSA9IGZ1bmN0aW9uKCkge1xyXG4gIHdpbmRvd18xLlZUVEN1ZSA9IG5hdGl2ZVZUVEN1ZTtcclxuICB3aW5kb3dfMS5WVFRSZWdpb24gPSBuYXRpdmVWVFRSZWdpb247XHJcbn07XHJcblxyXG5pZiAoIXdpbmRvd18xLlZUVEN1ZSkge1xyXG4gIHZ0dGpzLnNoaW0oKTtcclxufVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSB0ZWNoLmpzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEFuIE9iamVjdCBjb250YWluaW5nIGEgc3RydWN0dXJlIGxpa2U6IGB7c3JjOiAndXJsJywgdHlwZTogJ21pbWV0eXBlJ31gIG9yIHN0cmluZ1xyXG4gKiB0aGF0IGp1c3QgY29udGFpbnMgdGhlIHNyYyB1cmwgYWxvbmUuXHJcbiAqICogYHZhciBTb3VyY2VPYmplY3QgPSB7c3JjOiAnaHR0cDovL2V4LmNvbS92aWRlby5tcDQnLCB0eXBlOiAndmlkZW8vbXA0J307YFxyXG4gICAqIGB2YXIgU291cmNlU3RyaW5nID0gJ2h0dHA6Ly9leGFtcGxlLmNvbS9zb21lLXZpZGVvLm1wNCc7YFxyXG4gKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fHN0cmluZ30gVGVjaH5Tb3VyY2VPYmplY3RcclxuICpcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNyY1xyXG4gKiAgICAgICAgICAgVGhlIHVybCB0byB0aGUgc291cmNlXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlXHJcbiAqICAgICAgICAgICBUaGUgbWltZSB0eXBlIG9mIHRoZSBzb3VyY2VcclxuICovXHJcblxyXG4vKipcclxuICogQSBmdW5jdGlvbiB1c2VkIGJ5IHtAbGluayBUZWNofSB0byBjcmVhdGUgYSBuZXcge0BsaW5rIFRleHRUcmFja30uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqXHJcbiAqIEBwYXJhbSB7VGVjaH0gc2VsZlxyXG4gKiAgICAgICAgQW4gaW5zdGFuY2Ugb2YgdGhlIFRlY2ggY2xhc3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBraW5kXHJcbiAqICAgICAgICBgVGV4dFRyYWNrYCBraW5kIChzdWJ0aXRsZXMsIGNhcHRpb25zLCBkZXNjcmlwdGlvbnMsIGNoYXB0ZXJzLCBvciBtZXRhZGF0YSlcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IFtsYWJlbF1cclxuICogICAgICAgIExhYmVsIHRvIGlkZW50aWZ5IHRoZSB0ZXh0IHRyYWNrXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2VdXHJcbiAqICAgICAgICBUd28gbGV0dGVyIGxhbmd1YWdlIGFiYnJldmlhdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXHJcbiAqICAgICAgICBBbiBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsIHRleHQgdHJhY2sgb3B0aW9uc1xyXG4gKlxyXG4gKiBAcmV0dXJuIHtUZXh0VHJhY2t9XHJcbiAqICAgICAgICAgIFRoZSB0ZXh0IHRyYWNrIHRoYXQgd2FzIGNyZWF0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVUcmFja0hlbHBlcihzZWxmLCBraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcclxuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XHJcblxyXG4gIHZhciB0cmFja3MgPSBzZWxmLnRleHRUcmFja3MoKTtcclxuXHJcbiAgb3B0aW9ucy5raW5kID0ga2luZDtcclxuXHJcbiAgaWYgKGxhYmVsKSB7XHJcbiAgICBvcHRpb25zLmxhYmVsID0gbGFiZWw7XHJcbiAgfVxyXG4gIGlmIChsYW5ndWFnZSkge1xyXG4gICAgb3B0aW9ucy5sYW5ndWFnZSA9IGxhbmd1YWdlO1xyXG4gIH1cclxuICBvcHRpb25zLnRlY2ggPSBzZWxmO1xyXG5cclxuICB2YXIgdHJhY2sgPSBuZXcgQUxMLnRleHQuVHJhY2tDbGFzcyhvcHRpb25zKTtcclxuXHJcbiAgdHJhY2tzLmFkZFRyYWNrKHRyYWNrKTtcclxuXHJcbiAgcmV0dXJuIHRyYWNrO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgbWVkaWEgcGxheWJhY2sgdGVjaG5vbG9neSBjb250cm9sbGVycywgc3VjaCBhc1xyXG4gKiB7QGxpbmsgRmxhc2h9IGFuZCB7QGxpbmsgSFRNTDV9XHJcbiAqXHJcbiAqIEBleHRlbmRzIENvbXBvbmVudFxyXG4gKi9cclxuXHJcbnZhciBUZWNoID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcclxuICBpbmhlcml0cyhUZWNoLCBfQ29tcG9uZW50KTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgVGVjaC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IHJlYWR5XHJcbiAgICogICAgICAgIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgYEhUTUw1YCBUZWNoIGlzIHJlYWR5LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFRlY2goKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XHJcbiAgICB2YXIgcmVhZHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZ1bmN0aW9uICgpIHt9O1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGVjaCk7XHJcblxyXG4gICAgLy8gd2UgZG9uJ3Qgd2FudCB0aGUgdGVjaCB0byByZXBvcnQgdXNlciBhY3Rpdml0eSBhdXRvbWF0aWNhbGx5LlxyXG4gICAgLy8gVGhpcyBpcyBkb25lIG1hbnVhbGx5IGluIGFkZENvbnRyb2xzTGlzdGVuZXJzXHJcbiAgICBvcHRpb25zLnJlcG9ydFRvdWNoQWN0aXZpdHkgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgdGhlIGN1cnJlbnQgc291cmNlIGhhcyBwbGF5ZWQgYXQgYWxsIHRvXHJcbiAgICAvLyBpbXBsZW1lbnQgYSB2ZXJ5IGxpbWl0ZWQgcGxheWVkKClcclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIG51bGwsIG9wdGlvbnMsIHJlYWR5KSk7XHJcblxyXG4gICAgX3RoaXMuaGFzU3RhcnRlZF8gPSBmYWxzZTtcclxuICAgIF90aGlzLm9uKCdwbGF5aW5nJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLmhhc1N0YXJ0ZWRfID0gdHJ1ZTtcclxuICAgIH0pO1xyXG4gICAgX3RoaXMub24oJ2xvYWRzdGFydCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGhpcy5oYXNTdGFydGVkXyA9IGZhbHNlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgQUxMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgdmFyIHByb3BzID0gQUxMW25hbWVdO1xyXG5cclxuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9uc1twcm9wcy5nZXR0ZXJOYW1lXSkge1xyXG4gICAgICAgIF90aGlzW3Byb3BzLnByaXZhdGVOYW1lXSA9IG9wdGlvbnNbcHJvcHMuZ2V0dGVyTmFtZV07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIE1hbnVhbGx5IHRyYWNrIHByb2dyZXNzIGluIGNhc2VzIHdoZXJlIHRoZSBicm93c2VyL2ZsYXNoIHBsYXllciBkb2Vzbid0IHJlcG9ydCBpdC5cclxuICAgIGlmICghX3RoaXMuZmVhdHVyZXNQcm9ncmVzc0V2ZW50cykge1xyXG4gICAgICBfdGhpcy5tYW51YWxQcm9ncmVzc09uKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFudWFsbHkgdHJhY2sgdGltZXVwZGF0ZXMgaW4gY2FzZXMgd2hlcmUgdGhlIGJyb3dzZXIvZmxhc2ggcGxheWVyIGRvZXNuJ3QgcmVwb3J0IGl0LlxyXG4gICAgaWYgKCFfdGhpcy5mZWF0dXJlc1RpbWV1cGRhdGVFdmVudHMpIHtcclxuICAgICAgX3RoaXMubWFudWFsVGltZVVwZGF0ZXNPbigpO1xyXG4gICAgfVxyXG5cclxuICAgIFsnVGV4dCcsICdBdWRpbycsICdWaWRlbyddLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XHJcbiAgICAgIGlmIChvcHRpb25zWyduYXRpdmUnICsgdHJhY2sgKyAnVHJhY2tzJ10gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgX3RoaXNbJ2ZlYXR1cmVzTmF0aXZlJyArIHRyYWNrICsgJ1RyYWNrcyddID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChvcHRpb25zLm5hdGl2ZUNhcHRpb25zID09PSBmYWxzZSB8fCBvcHRpb25zLm5hdGl2ZVRleHRUcmFja3MgPT09IGZhbHNlKSB7XHJcbiAgICAgIF90aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm5hdGl2ZUNhcHRpb25zID09PSB0cnVlIHx8IG9wdGlvbnMubmF0aXZlVGV4dFRyYWNrcyA9PT0gdHJ1ZSkge1xyXG4gICAgICBfdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghX3RoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XHJcbiAgICAgIF90aGlzLmVtdWxhdGVUZXh0VHJhY2tzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgX3RoaXMuYXV0b1JlbW90ZVRleHRUcmFja3NfID0gbmV3IEFMTC50ZXh0Lkxpc3RDbGFzcygpO1xyXG5cclxuICAgIF90aGlzLmluaXRUcmFja0xpc3RlbmVycygpO1xyXG5cclxuICAgIC8vIFR1cm4gb24gY29tcG9uZW50IHRhcCBldmVudHMgb25seSBpZiBub3QgdXNpbmcgbmF0aXZlIGNvbnRyb2xzXHJcbiAgICBpZiAoIW9wdGlvbnMubmF0aXZlQ29udHJvbHNGb3JUb3VjaCkge1xyXG4gICAgICBfdGhpcy5lbWl0VGFwRXZlbnRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKF90aGlzLmNvbnN0cnVjdG9yKSB7XHJcbiAgICAgIF90aGlzLm5hbWVfID0gX3RoaXMuY29uc3RydWN0b3IubmFtZSB8fCAnVW5rbm93biBUZWNoJztcclxuICAgIH1cclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIC8qIEZhbGxiYWNrcyBmb3IgdW5zdXBwb3J0ZWQgZXZlbnQgdHlwZXNcclxuICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xyXG5cclxuICAvKipcclxuICAgKiBQb2x5ZmlsbCB0aGUgYHByb2dyZXNzYCBldmVudCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGl0IG5hdGl2ZWx5LlxyXG4gICAqXHJcbiAgICogQHNlZSB7QGxpbmsgVGVjaCN0cmFja1Byb2dyZXNzfVxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGVjaC5wcm90b3R5cGUubWFudWFsUHJvZ3Jlc3NPbiA9IGZ1bmN0aW9uIG1hbnVhbFByb2dyZXNzT24oKSB7XHJcbiAgICB0aGlzLm9uKCdkdXJhdGlvbmNoYW5nZScsIHRoaXMub25EdXJhdGlvbkNoYW5nZSk7XHJcblxyXG4gICAgdGhpcy5tYW51YWxQcm9ncmVzcyA9IHRydWU7XHJcblxyXG4gICAgLy8gVHJpZ2dlciBwcm9ncmVzcyB3YXRjaGluZyB3aGVuIGEgc291cmNlIGJlZ2lucyBsb2FkaW5nXHJcbiAgICB0aGlzLm9uZSgncmVhZHknLCB0aGlzLnRyYWNrUHJvZ3Jlc3MpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFR1cm4gb2ZmIHRoZSBwb2x5ZmlsbCBmb3IgYHByb2dyZXNzYCBldmVudHMgdGhhdCB3YXMgY3JlYXRlZCBpblxyXG4gICAqIHtAbGluayBUZWNoI21hbnVhbFByb2dyZXNzT259XHJcbiAgICovXHJcblxyXG5cclxuICBUZWNoLnByb3RvdHlwZS5tYW51YWxQcm9ncmVzc09mZiA9IGZ1bmN0aW9uIG1hbnVhbFByb2dyZXNzT2ZmKCkge1xyXG4gICAgdGhpcy5tYW51YWxQcm9ncmVzcyA9IGZhbHNlO1xyXG4gICAgdGhpcy5zdG9wVHJhY2tpbmdQcm9ncmVzcygpO1xyXG5cclxuICAgIHRoaXMub2ZmKCdkdXJhdGlvbmNoYW5nZScsIHRoaXMub25EdXJhdGlvbkNoYW5nZSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBpcyB1c2VkIHRvIHRyaWdnZXIgYSBgcHJvZ3Jlc3NgIGV2ZW50IHdoZW4gdGhlIGJ1ZmZlcmVkIHBlcmNlbnQgY2hhbmdlcy4gSXRcclxuICAgKiBzZXRzIGFuIGludGVydmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgZXZlcnkgNTAwIG1pbGxpc2Vjb25kcyB0byBjaGVjayBpZiB0aGVcclxuICAgKiBidWZmZXIgZW5kIHBlcmNlbnQgaGFzIGNoYW5nZWQuXHJcbiAgICpcclxuICAgKiA+IFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IHtAbGluayBUZWNoI21hbnVhbFByb2dyZXNzT259XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICBUaGUgYHJlYWR5YCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIFRlY2gjcmVhZHlcclxuICAgKiBAZmlyZXMgVGVjaCNwcm9ncmVzc1xyXG4gICAqL1xyXG5cclxuXHJcbiAgVGVjaC5wcm90b3R5cGUudHJhY2tQcm9ncmVzcyA9IGZ1bmN0aW9uIHRyYWNrUHJvZ3Jlc3MoZXZlbnQpIHtcclxuICAgIHRoaXMuc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKTtcclxuICAgIHRoaXMucHJvZ3Jlc3NJbnRlcnZhbCA9IHRoaXMuc2V0SW50ZXJ2YWwoYmluZCh0aGlzLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIC8vIERvbid0IHRyaWdnZXIgdW5sZXNzIGJ1ZmZlcmVkIGFtb3VudCBpcyBncmVhdGVyIHRoYW4gbGFzdCB0aW1lXHJcblxyXG4gICAgICB2YXIgbnVtQnVmZmVyZWRQZXJjZW50ID0gdGhpcy5idWZmZXJlZFBlcmNlbnQoKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmJ1ZmZlcmVkUGVyY2VudF8gIT09IG51bUJ1ZmZlcmVkUGVyY2VudCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNlZSB7QGxpbmsgUGxheWVyI3Byb2dyZXNzfVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV2ZW50IFRlY2gjcHJvZ3Jlc3NcclxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdwcm9ncmVzcycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmJ1ZmZlcmVkUGVyY2VudF8gPSBudW1CdWZmZXJlZFBlcmNlbnQ7XHJcblxyXG4gICAgICBpZiAobnVtQnVmZmVyZWRQZXJjZW50ID09PSAxKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wVHJhY2tpbmdQcm9ncmVzcygpO1xyXG4gICAgICB9XHJcbiAgICB9KSwgNTAwKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgb3VyIGludGVybmFsIGR1cmF0aW9uIG9uIGEgYGR1cmF0aW9uY2hhbmdlYCBldmVudCBieSBjYWxsaW5nXHJcbiAgICoge0BsaW5rIFRlY2gjZHVyYXRpb259LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcclxuICAgKiAgICAgICAgVGhlIGBkdXJhdGlvbmNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBUZWNoI2R1cmF0aW9uY2hhbmdlXHJcbiAgICovXHJcblxyXG5cclxuICBUZWNoLnByb3RvdHlwZS5vbkR1cmF0aW9uQ2hhbmdlID0gZnVuY3Rpb24gb25EdXJhdGlvbkNoYW5nZShldmVudCkge1xyXG4gICAgdGhpcy5kdXJhdGlvbl8gPSB0aGlzLmR1cmF0aW9uKCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGFuZCBjcmVhdGUgYSBgVGltZVJhbmdlYCBvYmplY3QgZm9yIGJ1ZmZlcmluZy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1RpbWVSYW5nZX1cclxuICAgKiAgICAgICAgIFRoZSB0aW1lIHJhbmdlIG9iamVjdCB0aGF0IHdhcyBjcmVhdGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGVjaC5wcm90b3R5cGUuYnVmZmVyZWQgPSBmdW5jdGlvbiBidWZmZXJlZCgpIHtcclxuICAgIHJldHVybiBjcmVhdGVUaW1lUmFuZ2VzKDAsIDApO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcGVyY2VudGFnZSBvZiB0aGUgY3VycmVudCB2aWRlbyB0aGF0IGlzIGN1cnJlbnRseSBidWZmZXJlZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKiAgICAgICAgIEEgbnVtYmVyIGZyb20gMCB0byAxIHRoYXQgcmVwcmVzZW50cyB0aGUgZGVjaW1hbCBwZXJjZW50YWdlIG9mIHRoZVxyXG4gICAqICAgICAgICAgdmlkZW8gdGhhdCBpcyBidWZmZXJlZC5cclxuICAgKlxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGVjaC5wcm90b3R5cGUuYnVmZmVyZWRQZXJjZW50ID0gZnVuY3Rpb24gYnVmZmVyZWRQZXJjZW50JCQxKCkge1xyXG4gICAgcmV0dXJuIGJ1ZmZlcmVkUGVyY2VudCh0aGlzLmJ1ZmZlcmVkKCksIHRoaXMuZHVyYXRpb25fKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUdXJuIG9mZiB0aGUgcG9seWZpbGwgZm9yIGBwcm9ncmVzc2AgZXZlbnRzIHRoYXQgd2FzIGNyZWF0ZWQgaW5cclxuICAgKiB7QGxpbmsgVGVjaCNtYW51YWxQcm9ncmVzc09ufVxyXG4gICAqIFN0b3AgbWFudWFsbHkgdHJhY2tpbmcgcHJvZ3Jlc3MgZXZlbnRzIGJ5IGNsZWFyaW5nIHRoZSBpbnRlcnZhbCB0aGF0IHdhcyBzZXQgaW5cclxuICAgKiB7QGxpbmsgVGVjaCN0cmFja1Byb2dyZXNzfS5cclxuICAgKi9cclxuXHJcblxyXG4gIFRlY2gucHJvdG90eXBlLnN0b3BUcmFja2luZ1Byb2dyZXNzID0gZnVuY3Rpb24gc3RvcFRyYWNraW5nUHJvZ3Jlc3MoKSB7XHJcbiAgICB0aGlzLmNsZWFySW50ZXJ2YWwodGhpcy5wcm9ncmVzc0ludGVydmFsKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBQb2x5ZmlsbCB0aGUgYHRpbWV1cGRhdGVgIGV2ZW50IGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgaXQuXHJcbiAgICpcclxuICAgKiBAc2VlIHtAbGluayBUZWNoI3RyYWNrQ3VycmVudFRpbWV9XHJcbiAgICovXHJcblxyXG5cclxuICBUZWNoLnByb3RvdHlwZS5tYW51YWxUaW1lVXBkYXRlc09uID0gZnVuY3Rpb24gbWFudWFsVGltZVVwZGF0ZXNPbigpIHtcclxuICAgIHRoaXMubWFudWFsVGltZVVwZGF0ZXMgPSB0cnVlO1xyXG5cclxuICAgIHRoaXMub24oJ3BsYXknLCB0aGlzLnRyYWNrQ3VycmVudFRpbWUpO1xyXG4gICAgdGhpcy5vbigncGF1c2UnLCB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUdXJuIG9mZiB0aGUgcG9seWZpbGwgZm9yIGB0aW1ldXBkYXRlYCBldmVudHMgdGhhdCB3YXMgY3JlYXRlZCBpblxyXG4gICAqIHtAbGluayBUZWNoI21hbnVhbFRpbWVVcGRhdGVzT259XHJcbiAgICovXHJcblxyXG5cclxuICBUZWNoLnByb3RvdHlwZS5tYW51YWxUaW1lVXBkYXRlc09mZiA9IGZ1bmN0aW9uIG1hbnVhbFRpbWVVcGRhdGVzT2ZmKCkge1xyXG4gICAgdGhpcy5tYW51YWxUaW1lVXBkYXRlcyA9IGZhbHNlO1xyXG4gICAgdGhpcy5zdG9wVHJhY2tpbmdDdXJyZW50VGltZSgpO1xyXG4gICAgdGhpcy5vZmYoJ3BsYXknLCB0aGlzLnRyYWNrQ3VycmVudFRpbWUpO1xyXG4gICAgdGhpcy5vZmYoJ3BhdXNlJywgdGhpcy5zdG9wVHJhY2tpbmdDdXJyZW50VGltZSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB1cCBhbiBpbnRlcnZhbCBmdW5jdGlvbiB0byB0cmFjayBjdXJyZW50IHRpbWUgYW5kIHRyaWdnZXIgYHRpbWV1cGRhdGVgIGV2ZXJ5XHJcbiAgICogMjUwIG1pbGxpc2Vjb25kcy5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIFRlY2gjcGxheVxyXG4gICAqIEB0cmlnZ2VycyBUZWNoI3RpbWV1cGRhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIFRlY2gucHJvdG90eXBlLnRyYWNrQ3VycmVudFRpbWUgPSBmdW5jdGlvbiB0cmFja0N1cnJlbnRUaW1lKCkge1xyXG4gICAgaWYgKHRoaXMuY3VycmVudFRpbWVJbnRlcnZhbCkge1xyXG4gICAgICB0aGlzLnN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmN1cnJlbnRUaW1lSW50ZXJ2YWwgPSB0aGlzLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRyaWdnZXJlZCBhdCBhbiBpbnRlcnZhbCBvZiAyNTBtcyB0byBpbmRpY2F0ZWQgdGhhdCB0aW1lIGlzIHBhc3NpbmcgaW4gdGhlIHZpZGVvLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZXZlbnQgVGVjaCN0aW1ldXBkYXRlXHJcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAgICovXHJcbiAgICAgIHRoaXMudHJpZ2dlcih7IHR5cGU6ICd0aW1ldXBkYXRlJywgdGFyZ2V0OiB0aGlzLCBtYW51YWxseVRyaWdnZXJlZDogdHJ1ZSB9KTtcclxuXHJcbiAgICAgIC8vIDQyID0gMjQgZnBzIC8vIDI1MCBpcyB3aGF0IFdlYmtpdCB1c2VzIC8vIEZGIHVzZXMgMTVcclxuICAgIH0sIDI1MCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcCB0aGUgaW50ZXJ2YWwgZnVuY3Rpb24gY3JlYXRlZCBpbiB7QGxpbmsgVGVjaCN0cmFja0N1cnJlbnRUaW1lfSBzbyB0aGF0IHRoZVxyXG4gICAqIGB0aW1ldXBkYXRlYCBldmVudCBpcyBubyBsb25nZXIgdHJpZ2dlcmVkLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMge1RlY2gjcGF1c2V9XHJcbiAgICovXHJcblxyXG5cclxuICBUZWNoLnByb3RvdHlwZS5zdG9wVHJhY2tpbmdDdXJyZW50VGltZSA9IGZ1bmN0aW9uIHN0b3BUcmFja2luZ0N1cnJlbnRUaW1lKCkge1xyXG4gICAgdGhpcy5jbGVhckludGVydmFsKHRoaXMuY3VycmVudFRpbWVJbnRlcnZhbCk7XHJcblxyXG4gICAgLy8gIzEwMDIgLSBpZiB0aGUgdmlkZW8gZW5kcyByaWdodCBiZWZvcmUgdGhlIG5leHQgdGltZXVwZGF0ZSB3b3VsZCBoYXBwZW4sXHJcbiAgICAvLyB0aGUgcHJvZ3Jlc3MgYmFyIHdvbid0IG1ha2UgaXQgYWxsIHRoZSB3YXkgdG8gdGhlIGVuZFxyXG4gICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFR1cm4gb2ZmIGFsbCBldmVudCBwb2x5ZmlsbHMsIGNsZWFyIHRoZSBgVGVjaGBzIHtAbGluayBBdWRpb1RyYWNrTGlzdH0sXHJcbiAgICoge0BsaW5rIFZpZGVvVHJhY2tMaXN0fSwgYW5kIHtAbGluayBUZXh0VHJhY2tMaXN0fSwgYW5kIGRpc3Bvc2Ugb2YgdGhpcyBUZWNoLlxyXG4gICAqXHJcbiAgICogQGZpcmVzIENvbXBvbmVudCNkaXNwb3NlXHJcbiAgICovXHJcblxyXG5cclxuICBUZWNoLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcclxuXHJcbiAgICAvLyBjbGVhciBvdXQgYWxsIHRyYWNrcyBiZWNhdXNlIHdlIGNhbid0IHJldXNlIHRoZW0gYmV0d2VlbiB0ZWNoc1xyXG4gICAgdGhpcy5jbGVhclRyYWNrcyhOT1JNQUwubmFtZXMpO1xyXG5cclxuICAgIC8vIFR1cm4gb2ZmIGFueSBtYW51YWwgcHJvZ3Jlc3Mgb3IgdGltZXVwZGF0ZSB0cmFja2luZ1xyXG4gICAgaWYgKHRoaXMubWFudWFsUHJvZ3Jlc3MpIHtcclxuICAgICAgdGhpcy5tYW51YWxQcm9ncmVzc09mZigpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLm1hbnVhbFRpbWVVcGRhdGVzKSB7XHJcbiAgICAgIHRoaXMubWFudWFsVGltZVVwZGF0ZXNPZmYoKTtcclxuICAgIH1cclxuXHJcbiAgICBfQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYXIgb3V0IGEgc2luZ2xlIGBUcmFja0xpc3RgIG9yIGFuIGFycmF5IG9mIGBUcmFja0xpc3RzYCBnaXZlbiB0aGVpciBuYW1lcy5cclxuICAgKlxyXG4gICAqID4gTm90ZTogVGVjaHMgd2l0aG91dCBzb3VyY2UgaGFuZGxlcnMgc2hvdWxkIGNhbGwgdGhpcyBiZXR3ZWVuIHNvdXJjZXMgZm9yIGB2aWRlb2BcclxuICAgKiAgICAgICAgICYgYGF1ZGlvYCB0cmFja3MuIFlvdSBkb24ndCB3YW50IHRvIHVzZSB0aGVtIGJldHdlZW4gdHJhY2tzIVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmdbXXxzdHJpbmd9IHR5cGVzXHJcbiAgICogICAgICAgIFRyYWNrTGlzdCBuYW1lcyB0byBjbGVhciwgdmFsaWQgbmFtZXMgYXJlIGB2aWRlb2AsIGBhdWRpb2AsIGFuZFxyXG4gICAqICAgICAgICBgdGV4dGAuXHJcbiAgICovXHJcblxyXG5cclxuICBUZWNoLnByb3RvdHlwZS5jbGVhclRyYWNrcyA9IGZ1bmN0aW9uIGNsZWFyVHJhY2tzKHR5cGVzKSB7XHJcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuXHJcbiAgICB0eXBlcyA9IFtdLmNvbmNhdCh0eXBlcyk7XHJcbiAgICAvLyBjbGVhciBvdXQgYWxsIHRyYWNrcyBiZWNhdXNlIHdlIGNhbid0IHJldXNlIHRoZW0gYmV0d2VlbiB0ZWNoc1xyXG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICB2YXIgbGlzdCA9IF90aGlzMlt0eXBlICsgJ1RyYWNrcyddKCkgfHwgW107XHJcbiAgICAgIHZhciBpID0gbGlzdC5sZW5ndGg7XHJcblxyXG4gICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgdmFyIHRyYWNrID0gbGlzdFtpXTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xyXG4gICAgICAgICAgX3RoaXMyLnJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxpc3QucmVtb3ZlVHJhY2sodHJhY2spO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgYW55IFRleHRUcmFja3MgYWRkZWQgdmlhIGFkZFJlbW90ZVRleHRUcmFjayB0aGF0IGFyZVxyXG4gICAqIGZsYWdnZWQgZm9yIGF1dG9tYXRpYyBnYXJiYWdlIGNvbGxlY3Rpb25cclxuICAgKi9cclxuXHJcblxyXG4gIFRlY2gucHJvdG90eXBlLmNsZWFudXBBdXRvVGV4dFRyYWNrcyA9IGZ1bmN0aW9uIGNsZWFudXBBdXRvVGV4dFRyYWNrcygpIHtcclxuICAgIHZhciBsaXN0ID0gdGhpcy5hdXRvUmVtb3RlVGV4dFRyYWNrc18gfHwgW107XHJcbiAgICB2YXIgaSA9IGxpc3QubGVuZ3RoO1xyXG5cclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgdmFyIHRyYWNrID0gbGlzdFtpXTtcclxuXHJcbiAgICAgIHRoaXMucmVtb3ZlUmVtb3RlVGV4dFRyYWNrKHRyYWNrKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXNldCB0aGUgdGVjaCwgd2hpY2ggd2lsbCByZW1vdmVzIGFsbCBzb3VyY2VzIGFuZCByZXNldCB0aGUgaW50ZXJuYWwgcmVhZHlTdGF0ZS5cclxuICAgKlxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGVjaC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHt9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgb3Igc2V0IGFuIGVycm9yIG9uIHRoZSBUZWNoLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtNZWRpYUVycm9yfSBbZXJyXVxyXG4gICAqICAgICAgICBFcnJvciB0byBzZXQgb24gdGhlIFRlY2hcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge01lZGlhRXJyb3J8bnVsbH1cclxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGVycm9yIG9iamVjdCBvbiB0aGUgdGVjaCwgb3IgbnVsbCBpZiB0aGVyZSBpc24ndCBvbmUuXHJcbiAgICovXHJcblxyXG5cclxuICBUZWNoLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKGVycikge1xyXG4gICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMuZXJyb3JfID0gbmV3IE1lZGlhRXJyb3IoZXJyKTtcclxuICAgICAgdGhpcy50cmlnZ2VyKCdlcnJvcicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuZXJyb3JfO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGBUaW1lUmFuZ2VgcyB0aGF0IGhhdmUgYmVlbiBwbGF5ZWQgdGhyb3VnaCBmb3IgdGhlIGN1cnJlbnQgc291cmNlLlxyXG4gICAqXHJcbiAgICogPiBOT1RFOiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGluY29tcGxldGUuIEl0IGRvZXMgbm90IHRyYWNrIHRoZSBwbGF5ZWQgYFRpbWVSYW5nZWAuXHJcbiAgICogICAgICAgICBJdCBvbmx5IGNoZWNrcyB3ZXRoZXIgdGhlIHNvdXJjZSBoYXMgcGxheWVkIGF0IGFsbCBvciBub3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XHJcbiAgICogICAgICAgICAtIEEgc2luZ2xlIHRpbWUgcmFuZ2UgaWYgdGhpcyB2aWRlbyBoYXMgcGxheWVkXHJcbiAgICogICAgICAgICAtIEFuIGVtcHR5IHNldCBvZiByYW5nZXMgaWYgbm90LlxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGVjaC5wcm90b3R5cGUucGxheWVkID0gZnVuY3Rpb24gcGxheWVkKCkge1xyXG4gICAgaWYgKHRoaXMuaGFzU3RhcnRlZF8pIHtcclxuICAgICAgcmV0dXJuIGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlVGltZVJhbmdlcygpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENhdXNlcyBhIG1hbnVhbCB0aW1lIHVwZGF0ZSB0byBvY2N1ciBpZiB7QGxpbmsgVGVjaCNtYW51YWxUaW1lVXBkYXRlc09ufSB3YXNcclxuICAgKiBwcmV2aW91c2x5IGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEBmaXJlcyBUZWNoI3RpbWV1cGRhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIFRlY2gucHJvdG90eXBlLnNldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24gc2V0Q3VycmVudFRpbWUoKSB7XHJcbiAgICAvLyBpbXByb3ZlIHRoZSBhY2N1cmFjeSBvZiBtYW51YWwgdGltZXVwZGF0ZXNcclxuICAgIGlmICh0aGlzLm1hbnVhbFRpbWVVcGRhdGVzKSB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBBIG1hbnVhbCBgdGltZXVwZGF0ZWAgZXZlbnQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBldmVudCBUZWNoI3RpbWV1cGRhdGVcclxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICAgKi9cclxuICAgICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ3RpbWV1cGRhdGUnLCB0YXJnZXQ6IHRoaXMsIG1hbnVhbGx5VHJpZ2dlcmVkOiB0cnVlIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFR1cm4gb24gbGlzdGVuZXJzIGZvciB7QGxpbmsgVmlkZW9UcmFja0xpc3R9LCB7QGxpbmsge0F1ZGlvVHJhY2tMaXN0fSwgYW5kXHJcbiAgICoge0BsaW5rIFRleHRUcmFja0xpc3R9IGV2ZW50cy5cclxuICAgKlxyXG4gICAqIFRoaXMgYWRkcyB7QGxpbmsgRXZlbnRUYXJnZXR+RXZlbnRMaXN0ZW5lcnN9IGZvciBgYWRkdHJhY2tgLCBhbmQgIGByZW1vdmV0cmFja2AuXHJcbiAgICpcclxuICAgKiBAZmlyZXMgVGVjaCNhdWRpb3RyYWNrY2hhbmdlXHJcbiAgICogQGZpcmVzIFRlY2gjdmlkZW90cmFja2NoYW5nZVxyXG4gICAqIEBmaXJlcyBUZWNoI3RleHR0cmFja2NoYW5nZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGVjaC5wcm90b3R5cGUuaW5pdFRyYWNrTGlzdGVuZXJzID0gZnVuY3Rpb24gaW5pdFRyYWNrTGlzdGVuZXJzKCkge1xyXG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0cmFja3MgYXJlIGFkZGVkIG9yIHJlbW92ZWQgb24gdGhlIFRlY2gge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fVxyXG4gICAgICpcclxuICAgICAqIEBldmVudCBUZWNoI2F1ZGlvdHJhY2tjaGFuZ2VcclxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdHJhY2tzIGFyZSBhZGRlZCBvciByZW1vdmVkIG9uIHRoZSBUZWNoIHtAbGluayBWaWRlb1RyYWNrTGlzdH1cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnQgVGVjaCN2aWRlb3RyYWNrY2hhbmdlXHJcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRyYWNrcyBhcmUgYWRkZWQgb3IgcmVtb3ZlZCBvbiB0aGUgVGVjaCB7QGxpbmsgVGV4dFRyYWNrTGlzdH1cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnQgVGVjaCN0ZXh0dHJhY2tjaGFuZ2VcclxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAqL1xyXG4gICAgTk9STUFMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgdmFyIHByb3BzID0gTk9STUFMW25hbWVdO1xyXG4gICAgICB2YXIgdHJhY2tMaXN0Q2hhbmdlcyA9IGZ1bmN0aW9uIHRyYWNrTGlzdENoYW5nZXMoKSB7XHJcbiAgICAgICAgX3RoaXMzLnRyaWdnZXIobmFtZSArICd0cmFja2NoYW5nZScpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdmFyIHRyYWNrcyA9IF90aGlzM1twcm9wcy5nZXR0ZXJOYW1lXSgpO1xyXG5cclxuICAgICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdHJhY2tMaXN0Q2hhbmdlcyk7XHJcbiAgICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRyYWNrTGlzdENoYW5nZXMpO1xyXG5cclxuICAgICAgX3RoaXMzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW1vdmV0cmFjaycsIHRyYWNrTGlzdENoYW5nZXMpO1xyXG4gICAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRyYWNrTGlzdENoYW5nZXMpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEVtdWxhdGUgVGV4dFRyYWNrcyB1c2luZyB2dHQuanMgaWYgbmVjZXNzYXJ5XHJcbiAgICpcclxuICAgKiBAZmlyZXMgVGVjaCN2dHRqc2xvYWRlZFxyXG4gICAqIEBmaXJlcyBUZWNoI3Z0dGpzZXJyb3JcclxuICAgKi9cclxuXHJcblxyXG4gIFRlY2gucHJvdG90eXBlLmFkZFdlYlZ0dFNjcmlwdF8gPSBmdW5jdGlvbiBhZGRXZWJWdHRTY3JpcHRfKCkge1xyXG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XHJcblxyXG4gICAgaWYgKHdpbmRvd18xLldlYlZUVCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbGx5LCBUZWNoLmVsXyBpcyBhIGNoaWxkIG9mIGEgZHVtbXktZGl2IHdhaXQgdW50aWwgdGhlIENvbXBvbmVudCBzeXN0ZW1cclxuICAgIC8vIHNpZ25hbHMgdGhhdCB0aGUgVGVjaCBpcyByZWFkeSBhdCB3aGljaCBwb2ludCBUZWNoLmVsXyBpcyBwYXJ0IG9mIHRoZSBET01cclxuICAgIC8vIGJlZm9yZSBpbnNlcnRpbmcgdGhlIFdlYlZUVCBzY3JpcHRcclxuICAgIGlmIChkb2N1bWVudF8xLmJvZHkuY29udGFpbnModGhpcy5lbCgpKSkge1xyXG5cclxuICAgICAgLy8gbG9hZCB2aWEgcmVxdWlyZSBpZiBhdmFpbGFibGUgYW5kIHZ0dC5qcyBzY3JpcHQgbG9jYXRpb24gd2FzIG5vdCBwYXNzZWQgaW5cclxuICAgICAgLy8gYXMgYW4gb3B0aW9uLiBub3Z0dCBidWlsZHMgd2lsbCB0dXJuIHRoZSBhYm92ZSByZXF1aXJlIGNhbGwgaW50byBhbiBlbXB0eSBvYmplY3RcclxuICAgICAgLy8gd2hpY2ggd2lsbCBjYXVzZSB0aGlzIGlmIGNoZWNrIHRvIGFsd2F5cyBmYWlsLlxyXG4gICAgICBpZiAoIXRoaXMub3B0aW9uc19bJ3Z0dC5qcyddICYmIGlzUGxhaW4oYnJvd3NlckluZGV4KSAmJiBPYmplY3Qua2V5cyhicm93c2VySW5kZXgpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Z0dGpzbG9hZGVkJyk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBsb2FkIHZ0dC5qcyB2aWEgdGhlIHNjcmlwdCBsb2NhdGlvbiBvcHRpb24gb3IgdGhlIGNkbiBvZiBubyBsb2NhdGlvbiB3YXNcclxuICAgICAgLy8gcGFzc2VkIGluXHJcbiAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudF8xLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xyXG5cclxuICAgICAgc2NyaXB0LnNyYyA9IHRoaXMub3B0aW9uc19bJ3Z0dC5qcyddIHx8ICdodHRwczovL3Zqcy56ZW5jZG4ubmV0L3Z0dGpzLzAuMTIuNC92dHQubWluLmpzJztcclxuICAgICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaXJlZCB3aGVuIHZ0dC5qcyBpcyBsb2FkZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXZlbnQgVGVjaCN2dHRqc2xvYWRlZFxyXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpczQudHJpZ2dlcigndnR0anNsb2FkZWQnKTtcclxuICAgICAgfTtcclxuICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlyZWQgd2hlbiB2dHQuanMgd2FzIG5vdCBsb2FkZWQgZHVlIHRvIGFuIGVycm9yXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXZlbnQgVGVjaCN2dHRqc2xvYWRlZFxyXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpczQudHJpZ2dlcigndnR0anNlcnJvcicpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBudWxsO1xyXG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gbnVsbDtcclxuICAgICAgfSk7XHJcbiAgICAgIC8vIGJ1dCBoYXZlIG5vdCBsb2FkZWQgeWV0IGFuZCB3ZSBzZXQgaXQgdG8gdHJ1ZSBiZWZvcmUgdGhlIGluamVjdCBzbyB0aGF0XHJcbiAgICAgIC8vIHdlIGRvbid0IG92ZXJ3cml0ZSB0aGUgaW5qZWN0ZWQgd2luZG93LldlYlZUVCBpZiBpdCBsb2FkcyByaWdodCBhd2F5XHJcbiAgICAgIHdpbmRvd18xLldlYlZUVCA9IHRydWU7XHJcbiAgICAgIHRoaXMuZWwoKS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHNjcmlwdCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnJlYWR5KHRoaXMuYWRkV2ViVnR0U2NyaXB0Xyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRW11bGF0ZSB0ZXh0dHJhY2tzXHJcbiAgICpcclxuICAgKi9cclxuXHJcblxyXG4gIFRlY2gucHJvdG90eXBlLmVtdWxhdGVUZXh0VHJhY2tzID0gZnVuY3Rpb24gZW11bGF0ZVRleHRUcmFja3MoKSB7XHJcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcclxuXHJcbiAgICB2YXIgdHJhY2tzID0gdGhpcy50ZXh0VHJhY2tzKCk7XHJcbiAgICB2YXIgcmVtb3RlVHJhY2tzID0gdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCk7XHJcbiAgICB2YXIgaGFuZGxlQWRkVHJhY2sgPSBmdW5jdGlvbiBoYW5kbGVBZGRUcmFjayhlKSB7XHJcbiAgICAgIHJldHVybiB0cmFja3MuYWRkVHJhY2soZS50cmFjayk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGhhbmRsZVJlbW92ZVRyYWNrID0gZnVuY3Rpb24gaGFuZGxlUmVtb3ZlVHJhY2soZSkge1xyXG4gICAgICByZXR1cm4gdHJhY2tzLnJlbW92ZVRyYWNrKGUudHJhY2spO1xyXG4gICAgfTtcclxuXHJcbiAgICByZW1vdGVUcmFja3Mub24oJ2FkZHRyYWNrJywgaGFuZGxlQWRkVHJhY2spO1xyXG4gICAgcmVtb3RlVHJhY2tzLm9uKCdyZW1vdmV0cmFjaycsIGhhbmRsZVJlbW92ZVRyYWNrKTtcclxuXHJcbiAgICB0aGlzLmFkZFdlYlZ0dFNjcmlwdF8oKTtcclxuXHJcbiAgICB2YXIgdXBkYXRlRGlzcGxheSA9IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XHJcbiAgICAgIHJldHVybiBfdGhpczUudHJpZ2dlcigndGV4dHRyYWNrY2hhbmdlJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciB0ZXh0VHJhY2tzQ2hhbmdlcyA9IGZ1bmN0aW9uIHRleHRUcmFja3NDaGFuZ2VzKCkge1xyXG4gICAgICB1cGRhdGVEaXNwbGF5KCk7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcclxuXHJcbiAgICAgICAgdHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgdXBkYXRlRGlzcGxheSk7XHJcbiAgICAgICAgaWYgKHRyYWNrLm1vZGUgPT09ICdzaG93aW5nJykge1xyXG4gICAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgdXBkYXRlRGlzcGxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRleHRUcmFja3NDaGFuZ2VzKCk7XHJcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xyXG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xyXG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ3JlbW92ZXRyYWNrJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xyXG5cclxuICAgIHRoaXMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJlbW90ZVRyYWNrcy5vZmYoJ2FkZHRyYWNrJywgaGFuZGxlQWRkVHJhY2spO1xyXG4gICAgICByZW1vdGVUcmFja3Mub2ZmKCdyZW1vdmV0cmFjaycsIGhhbmRsZVJlbW92ZVRyYWNrKTtcclxuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRleHRUcmFja3NDaGFuZ2VzKTtcclxuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdGV4dFRyYWNrc0NoYW5nZXMpO1xyXG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB0ZXh0VHJhY2tzQ2hhbmdlcyk7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcclxuXHJcbiAgICAgICAgdHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcignY3VlY2hhbmdlJywgdXBkYXRlRGlzcGxheSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbmQgcmV0dXJucyBhIHJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrfSBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2luZFxyXG4gICAqICAgICAgICBgVGV4dFRyYWNrYCBraW5kIChzdWJ0aXRsZXMsIGNhcHRpb25zLCBkZXNjcmlwdGlvbnMsIGNoYXB0ZXJzLCBvciBtZXRhZGF0YSlcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdXHJcbiAgICogICAgICAgIExhYmVsIHRvIGlkZW50aWZ5IHRoZSB0ZXh0IHRyYWNrXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlXVxyXG4gICAqICAgICAgICBUd28gbGV0dGVyIGxhbmd1YWdlIGFiYnJldmlhdGlvblxyXG4gICAqXHJcbiAgICogQHJldHVybiB7VGV4dFRyYWNrfVxyXG4gICAqICAgICAgICAgVGhlIFRleHRUcmFjayB0aGF0IGdldHMgY3JlYXRlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIFRlY2gucHJvdG90eXBlLmFkZFRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcclxuICAgIGlmICgha2luZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHRUcmFjayBraW5kIGlzIHJlcXVpcmVkIGJ1dCB3YXMgbm90IHByb3ZpZGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNyZWF0ZVRyYWNrSGVscGVyKHRoaXMsIGtpbmQsIGxhYmVsLCBsYW5ndWFnZSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuIGVtdWxhdGVkIFRleHRUcmFjayBmb3IgdXNlIGJ5IGFkZFJlbW90ZVRleHRUcmFja1xyXG4gICAqXHJcbiAgICogVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGJ5IGNsYXNzZXMgdGhhdCBpbmhlcml0IGZyb21cclxuICAgKiBUZWNoIGluIG9yZGVyIHRvIGNyZWF0ZSBuYXRpdmUgb3IgY3VzdG9tIFRleHRUcmFja3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAqICAgICAgICBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIHRoZSBvcHRpb25zIHRvIGluaXRpYWxpemUgdGhlIFRleHRUcmFjayB3aXRoLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmtpbmRdXHJcbiAgICogICAgICAgIGBUZXh0VHJhY2tgIGtpbmQgKHN1YnRpdGxlcywgY2FwdGlvbnMsIGRlc2NyaXB0aW9ucywgY2hhcHRlcnMsIG9yIG1ldGFkYXRhKS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYWJlbF0uXHJcbiAgICogICAgICAgIExhYmVsIHRvIGlkZW50aWZ5IHRoZSB0ZXh0IHRyYWNrXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2VdXHJcbiAgICogICAgICAgIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7SFRNTFRyYWNrRWxlbWVudH1cclxuICAgKiAgICAgICAgIFRoZSB0cmFjayBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGVjaC5wcm90b3R5cGUuY3JlYXRlUmVtb3RlVGV4dFRyYWNrID0gZnVuY3Rpb24gY3JlYXRlUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMpIHtcclxuICAgIHZhciB0cmFjayA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCB7XHJcbiAgICAgIHRlY2g6IHRoaXNcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBuZXcgUkVNT1RFLnJlbW90ZVRleHRFbC5UcmFja0NsYXNzKHRyYWNrKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgcmVtb3RlIHRleHQgdHJhY2sgb2JqZWN0IGFuZCByZXR1cm5zIGFuIGh0bWwgdHJhY2sgZWxlbWVudC5cclxuICAgKlxyXG4gICAqID4gTm90ZTogVGhpcyBjYW4gYmUgYW4gZW11bGF0ZWQge0BsaW5rIEhUTUxUcmFja0VsZW1lbnR9IG9yIGEgbmF0aXZlIG9uZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICogICAgICAgIFNlZSB7QGxpbmsgVGVjaCNjcmVhdGVSZW1vdGVUZXh0VHJhY2t9IGZvciBtb3JlIGRldGFpbGVkIHByb3BlcnRpZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttYW51YWxDbGVhbnVwPXRydWVdXHJcbiAgICogICAgICAgIC0gV2hlbiBmYWxzZTogdGhlIFRleHRUcmFjayB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHRoZSB2aWRlb1xyXG4gICAqICAgICAgICAgIGVsZW1lbnQgd2hlbmV2ZXIgdGhlIHNvdXJjZSBjaGFuZ2VzXHJcbiAgICogICAgICAgIC0gV2hlbiBUcnVlOiBUaGUgVGV4dFRyYWNrIHdpbGwgaGF2ZSB0byBiZSBjbGVhbmVkIHVwIG1hbnVhbGx5XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50fVxyXG4gICAqICAgICAgICAgQW4gSHRtbCBUcmFjayBFbGVtZW50LlxyXG4gICAqXHJcbiAgICogQGRlcHJlY2F0ZWQgVGhlIGRlZmF1bHQgZnVuY3Rpb25hbGl0eSBmb3IgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGVxdWl2YWxlbnRcclxuICAgKiAgICAgICAgICAgICB0byBcIm1hbnVhbENsZWFudXA9ZmFsc2VcIiBpbiB0aGUgZnV0dXJlLiBUaGUgbWFudWFsQ2xlYW51cCBwYXJhbWV0ZXIgd2lsbFxyXG4gICAqICAgICAgICAgICAgIGFsc28gYmUgcmVtb3ZlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIFRlY2gucHJvdG90eXBlLmFkZFJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFJlbW90ZVRleHRUcmFjaygpIHtcclxuICAgIHZhciBfdGhpczYgPSB0aGlzO1xyXG5cclxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcclxuICAgIHZhciBtYW51YWxDbGVhbnVwID0gYXJndW1lbnRzWzFdO1xyXG5cclxuICAgIHZhciBodG1sVHJhY2tFbGVtZW50ID0gdGhpcy5jcmVhdGVSZW1vdGVUZXh0VHJhY2sob3B0aW9ucyk7XHJcblxyXG4gICAgaWYgKG1hbnVhbENsZWFudXAgIT09IHRydWUgJiYgbWFudWFsQ2xlYW51cCAhPT0gZmFsc2UpIHtcclxuICAgICAgLy8gZGVwcmVjYXRpb24gd2FybmluZ1xyXG4gICAgICBsb2ckMS53YXJuKCdDYWxsaW5nIGFkZFJlbW90ZVRleHRUcmFjayB3aXRob3V0IGV4cGxpY2l0bHkgc2V0dGluZyB0aGUgXCJtYW51YWxDbGVhbnVwXCIgcGFyYW1ldGVyIHRvIGB0cnVlYCBpcyBkZXByZWNhdGVkIGFuZCBkZWZhdWx0IHRvIGBmYWxzZWAgaW4gZnV0dXJlIHZlcnNpb24gb2YgdmlkZW8uanMnKTtcclxuICAgICAgbWFudWFsQ2xlYW51cCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc3RvcmUgSFRNTFRyYWNrRWxlbWVudCBhbmQgVGV4dFRyYWNrIHRvIHJlbW90ZSBsaXN0XHJcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja0VscygpLmFkZFRyYWNrRWxlbWVudF8oaHRtbFRyYWNrRWxlbWVudCk7XHJcbiAgICB0aGlzLnJlbW90ZVRleHRUcmFja3MoKS5hZGRUcmFjayhodG1sVHJhY2tFbGVtZW50LnRyYWNrKTtcclxuXHJcbiAgICBpZiAobWFudWFsQ2xlYW51cCAhPT0gdHJ1ZSkge1xyXG4gICAgICAvLyBjcmVhdGUgdGhlIFRleHRUcmFja0xpc3QgaWYgaXQgZG9lc24ndCBleGlzdFxyXG4gICAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3RoaXM2LmF1dG9SZW1vdGVUZXh0VHJhY2tzXy5hZGRUcmFjayhodG1sVHJhY2tFbGVtZW50LnRyYWNrKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGh0bWxUcmFja0VsZW1lbnQ7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGEgcmVtb3RlIHRleHQgdHJhY2sgZnJvbSB0aGUgcmVtb3RlIGBUZXh0VHJhY2tMaXN0YC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xyXG4gICAqICAgICAgICBgVGV4dFRyYWNrYCB0byByZW1vdmUgZnJvbSB0aGUgYFRleHRUcmFja0xpc3RgXHJcbiAgICovXHJcblxyXG5cclxuICBUZWNoLnByb3RvdHlwZS5yZW1vdmVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiByZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spIHtcclxuICAgIHZhciB0cmFja0VsZW1lbnQgPSB0aGlzLnJlbW90ZVRleHRUcmFja0VscygpLmdldFRyYWNrRWxlbWVudEJ5VHJhY2tfKHRyYWNrKTtcclxuXHJcbiAgICAvLyByZW1vdmUgSFRNTFRyYWNrRWxlbWVudCBhbmQgVGV4dFRyYWNrIGZyb20gcmVtb3RlIGxpc3RcclxuICAgIHRoaXMucmVtb3RlVGV4dFRyYWNrRWxzKCkucmVtb3ZlVHJhY2tFbGVtZW50Xyh0cmFja0VsZW1lbnQpO1xyXG4gICAgdGhpcy5yZW1vdGVUZXh0VHJhY2tzKCkucmVtb3ZlVHJhY2sodHJhY2spO1xyXG4gICAgdGhpcy5hdXRvUmVtb3RlVGV4dFRyYWNrc18ucmVtb3ZlVHJhY2sodHJhY2spO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYXZhaWxhYmxlIG1lZGlhIHBsYXliYWNrIHF1YWxpdHkgbWV0cmljcyBhcyBzcGVjaWZpZWQgYnkgdGhlIFczQydzIE1lZGlhXHJcbiAgICogUGxheWJhY2sgUXVhbGl0eSBBUEkuXHJcbiAgICpcclxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3dpY2cuZ2l0aHViLmlvL21lZGlhLXBsYXliYWNrLXF1YWxpdHl9XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICogICAgICAgICBBbiBvYmplY3Qgd2l0aCBzdXBwb3J0ZWQgbWVkaWEgcGxheWJhY2sgcXVhbGl0eSBtZXRyaWNzXHJcbiAgICpcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuXHJcblxyXG4gIFRlY2gucHJvdG90eXBlLmdldFZpZGVvUGxheWJhY2tRdWFsaXR5ID0gZnVuY3Rpb24gZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkoKSB7XHJcbiAgICByZXR1cm4ge307XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBtZXRob2QgdG8gc2V0IGEgcG9zdGVyIGZyb20gYSBgVGVjaGAuXHJcbiAgICpcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuXHJcblxyXG4gIFRlY2gucHJvdG90eXBlLnNldFBvc3RlciA9IGZ1bmN0aW9uIHNldFBvc3RlcigpIHt9O1xyXG5cclxuICAvKipcclxuICAgKiBBIG1ldGhvZCB0byBjaGVjayBmb3IgdGhlIHByZXNlbmNlIG9mIHRoZSAncGxheXNpbmluZScgPHZpZGVvPiBhdHRyaWJ1dGUuXHJcbiAgICpcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuXHJcblxyXG4gIFRlY2gucHJvdG90eXBlLnBsYXlzaW5saW5lID0gZnVuY3Rpb24gcGxheXNpbmxpbmUoKSB7fTtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBtZXRob2QgdG8gc2V0IG9yIHVuc2V0IHRoZSAncGxheXNpbmluZScgPHZpZGVvPiBhdHRyaWJ1dGUuXHJcbiAgICpcclxuICAgKiBAYWJzdHJhY3RcclxuICAgKi9cclxuXHJcblxyXG4gIFRlY2gucHJvdG90eXBlLnNldFBsYXlzaW5saW5lID0gZnVuY3Rpb24gc2V0UGxheXNpbmxpbmUoKSB7fTtcclxuXHJcbiAgLypcclxuICAgKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gbWltZS10eXBlLlxyXG4gICAqXHJcbiAgICogVGhlIGJhc2UgdGVjaCBkb2VzIG5vdCBzdXBwb3J0IGFueSB0eXBlLCBidXQgc291cmNlIGhhbmRsZXJzIG1pZ2h0XHJcbiAgICogb3ZlcndyaXRlIHRoaXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGVcclxuICAgKiAgICAgICAgIFRoZSBtaW1ldHlwZSB0byBjaGVjayBmb3Igc3VwcG9ydFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgZW1wdHkgc3RyaW5nXHJcbiAgICpcclxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9jYW5QbGF5VHlwZX1cclxuICAgKlxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGVjaC5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiBjYW5QbGF5VHlwZSgpIHtcclxuICAgIHJldHVybiAnJztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgdGhpcyB0ZWNoLlxyXG4gICAqXHJcbiAgICogVGhlIGJhc2UgdGVjaCBkb2VzIG5vdCBzdXBwb3J0IGFueSB0eXBlLCBidXQgc291cmNlIGhhbmRsZXJzIG1pZ2h0XHJcbiAgICogb3ZlcndyaXRlIHRoaXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxyXG4gICAqICAgICAgICBUaGUgbWVkaWEgdHlwZSB0byBjaGVja1xyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyB0aGUgbmF0aXZlIHZpZGVvIGVsZW1lbnQncyByZXNwb25zZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGVjaC5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uIGNhblBsYXlUeXBlKCkge1xyXG4gICAgcmV0dXJuICcnO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiBzb3VyY2VcclxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjT2JqXHJcbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgKiAgICAgICAgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSB0ZWNoXHJcbiAgICogQHJldHVybiB7c3RyaW5nfSAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGVjaC5jYW5QbGF5U291cmNlID0gZnVuY3Rpb24gY2FuUGxheVNvdXJjZShzcmNPYmosIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBUZWNoLmNhblBsYXlUeXBlKHNyY09iai50eXBlKTtcclxuICB9O1xyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB3aGV0aGVyIHRoZSBhcmd1bWVudCBpcyBhIFRlY2ggb3Igbm90LlxyXG4gICAqIENhbiBiZSBwYXNzZWQgZWl0aGVyIGEgQ2xhc3MgbGlrZSBgSHRtbDVgIG9yIGEgaW5zdGFuY2UgbGlrZSBgcGxheWVyLnRlY2hfYFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbXBvbmVudFxyXG4gICAqICAgICAgICBUaGUgaXRlbSB0byBjaGVja1xyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKiAgICAgICAgIFdoZXRoZXIgaXQgaXMgYSB0ZWNoIG9yIG5vdFxyXG4gICAqICAgICAgICAgLSBUcnVlIGlmIGl0IGlzIGEgdGVjaFxyXG4gICAqICAgICAgICAgLSBGYWxzZSBpZiBpdCBpcyBub3RcclxuICAgKi9cclxuXHJcblxyXG4gIFRlY2guaXNUZWNoID0gZnVuY3Rpb24gaXNUZWNoKGNvbXBvbmVudCkge1xyXG4gICAgcmV0dXJuIGNvbXBvbmVudC5wcm90b3R5cGUgaW5zdGFuY2VvZiBUZWNoIHx8IGNvbXBvbmVudCBpbnN0YW5jZW9mIFRlY2ggfHwgY29tcG9uZW50ID09PSBUZWNoO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVycyBhIGBUZWNoYCBpbnRvIGEgc2hhcmVkIGxpc3QgZm9yIHZpZGVvanMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAqICAgICAgICBOYW1lIG9mIHRoZSBgVGVjaGAgdG8gcmVnaXN0ZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gdGVjaFxyXG4gICAqICAgICAgICBUaGUgYFRlY2hgIGNsYXNzIHRvIHJlZ2lzdGVyLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGVjaC5yZWdpc3RlclRlY2ggPSBmdW5jdGlvbiByZWdpc3RlclRlY2gobmFtZSwgdGVjaCkge1xyXG4gICAgaWYgKCFUZWNoLnRlY2hzXykge1xyXG4gICAgICBUZWNoLnRlY2hzXyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghVGVjaC5pc1RlY2godGVjaCkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZWNoICcgKyBuYW1lICsgJyBtdXN0IGJlIGEgVGVjaCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghVGVjaC5jYW5QbGF5VHlwZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlY2hzIG11c3QgaGF2ZSBhIHN0YXRpYyBjYW5QbGF5VHlwZSBtZXRob2Qgb24gdGhlbScpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFUZWNoLmNhblBsYXlTb3VyY2UpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZWNocyBtdXN0IGhhdmUgYSBzdGF0aWMgY2FuUGxheVNvdXJjZSBtZXRob2Qgb24gdGhlbScpO1xyXG4gICAgfVxyXG5cclxuICAgIG5hbWUgPSB0b1RpdGxlQ2FzZShuYW1lKTtcclxuXHJcbiAgICBUZWNoLnRlY2hzX1tuYW1lXSA9IHRlY2g7XHJcbiAgICBpZiAobmFtZSAhPT0gJ1RlY2gnKSB7XHJcbiAgICAgIC8vIGNhbWVsIGNhc2UgdGhlIHRlY2hOYW1lIGZvciB1c2UgaW4gdGVjaE9yZGVyXHJcbiAgICAgIFRlY2guZGVmYXVsdFRlY2hPcmRlcl8ucHVzaChuYW1lKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0ZWNoO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhIGBUZWNoYCBmcm9tIHRoZSBzaGFyZWQgbGlzdCBieSBuYW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgKiAgICAgICAgYGNhbWVsQ2FzZWAgb3IgYFRpdGxlQ2FzZWAgbmFtZSBvZiB0aGUgVGVjaCB0byBnZXRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1RlY2h8dW5kZWZpbmVkfVxyXG4gICAqICAgICAgICAgVGhlIGBUZWNoYCBvciB1bmRlZmluZWQgaWYgdGhlcmUgd2FzIG5vIHRlY2ggd2l0aCB0aGUgbmFtZSByZXF1c3RlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIFRlY2guZ2V0VGVjaCA9IGZ1bmN0aW9uIGdldFRlY2gobmFtZSkge1xyXG4gICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBuYW1lID0gdG9UaXRsZUNhc2UobmFtZSk7XHJcblxyXG4gICAgaWYgKFRlY2gudGVjaHNfICYmIFRlY2gudGVjaHNfW25hbWVdKSB7XHJcbiAgICAgIHJldHVybiBUZWNoLnRlY2hzX1tuYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAod2luZG93XzEgJiYgd2luZG93XzEudmlkZW9qcyAmJiB3aW5kb3dfMS52aWRlb2pzW25hbWVdKSB7XHJcbiAgICAgIGxvZyQxLndhcm4oJ1RoZSAnICsgbmFtZSArICcgdGVjaCB3YXMgYWRkZWQgdG8gdGhlIHZpZGVvanMgb2JqZWN0IHdoZW4gaXQgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgdXNpbmcgdmlkZW9qcy5yZWdpc3RlclRlY2gobmFtZSwgdGVjaCknKTtcclxuICAgICAgcmV0dXJuIHdpbmRvd18xLnZpZGVvanNbbmFtZV07XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFRlY2g7XHJcbn0oQ29tcG9uZW50KTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHtAbGluayBWaWRlb1RyYWNrTGlzdH1cclxuICpcclxuICogQHJldHVybnMge1ZpZGVvVHJhY2tMaXN0fVxyXG4gKiBAbWV0aG9kIFRlY2gucHJvdG90eXBlLnZpZGVvVHJhY2tzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUge0BsaW5rIEF1ZGlvVHJhY2tMaXN0fVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7QXVkaW9UcmFja0xpc3R9XHJcbiAqIEBtZXRob2QgVGVjaC5wcm90b3R5cGUuYXVkaW9UcmFja3NcclxuICovXHJcblxyXG4vKipcclxuICogR2V0IHRoZSB7QGxpbmsgVGV4dFRyYWNrTGlzdH1cclxuICpcclxuICogQHJldHVybnMge1RleHRUcmFja0xpc3R9XHJcbiAqIEBtZXRob2QgVGVjaC5wcm90b3R5cGUudGV4dFRyYWNrc1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHJlbW90ZSBlbGVtZW50IHtAbGluayBUZXh0VHJhY2tMaXN0fVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7VGV4dFRyYWNrTGlzdH1cclxuICogQG1ldGhvZCBUZWNoLnByb3RvdHlwZS5yZW1vdGVUZXh0VHJhY2tzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgcmVtb3RlIGVsZW1lbnQge0BsaW5rIEh0bWxUcmFja0VsZW1lbnRMaXN0fVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7SHRtbFRyYWNrRWxlbWVudExpc3R9XHJcbiAqIEBtZXRob2QgVGVjaC5wcm90b3R5cGUucmVtb3RlVGV4dFRyYWNrRWxzXHJcbiAqL1xyXG5cclxuQUxMLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICB2YXIgcHJvcHMgPSBBTExbbmFtZV07XHJcblxyXG4gIFRlY2gucHJvdG90eXBlW3Byb3BzLmdldHRlck5hbWVdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpc1twcm9wcy5wcml2YXRlTmFtZV0gPSB0aGlzW3Byb3BzLnByaXZhdGVOYW1lXSB8fCBuZXcgcHJvcHMuTGlzdENsYXNzKCk7XHJcbiAgICByZXR1cm4gdGhpc1twcm9wcy5wcml2YXRlTmFtZV07XHJcbiAgfTtcclxufSk7XHJcblxyXG4vKipcclxuICogTGlzdCBvZiBhc3NvY2lhdGVkIHRleHQgdHJhY2tzXHJcbiAqXHJcbiAqIEB0eXBlIHtUZXh0VHJhY2tMaXN0fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcHJvcGVydHkgVGVjaCN0ZXh0VHJhY2tzX1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBMaXN0IG9mIGFzc29jaWF0ZWQgYXVkaW8gdHJhY2tzLlxyXG4gKlxyXG4gKiBAdHlwZSB7QXVkaW9UcmFja0xpc3R9XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwcm9wZXJ0eSBUZWNoI2F1ZGlvVHJhY2tzX1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBMaXN0IG9mIGFzc29jaWF0ZWQgdmlkZW8gdHJhY2tzLlxyXG4gKlxyXG4gKiBAdHlwZSB7VmlkZW9UcmFja0xpc3R9XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwcm9wZXJ0eSBUZWNoI3ZpZGVvVHJhY2tzX1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2V0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgdm9sdW1lIGNvbnRyb2wuXHJcbiAqXHJcbiAqIEB0eXBlIHtib29sZWFufVxyXG4gKiBAZGVmYXVsdFxyXG4gKi9cclxuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNWb2x1bWVDb250cm9sID0gdHJ1ZTtcclxuXHJcbi8qKlxyXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2V0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydCBmdWxsc2NyZWVuIHJlc2l6ZSBjb250cm9sLlxyXG4gKiBSZXNpemluZyBwbHVnaW5zIHVzaW5nIHJlcXVlc3QgZnVsbHNjcmVlbiByZWxvYWRzIHRoZSBwbHVnaW5cclxuICpcclxuICogQHR5cGUge2Jvb2xlYW59XHJcbiAqIEBkZWZhdWx0XHJcbiAqL1xyXG5UZWNoLnByb3RvdHlwZS5mZWF0dXJlc0Z1bGxzY3JlZW5SZXNpemUgPSBmYWxzZTtcclxuXHJcbi8qKlxyXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2V0aGVyIHRoZSBgVGVjaGAgc3VwcG9ydHMgY2hhbmdpbmcgdGhlIHNwZWVkIGF0IHdoaWNoIHRoZSB2aWRlb1xyXG4gKiBwbGF5cy4gRXhhbXBsZXM6XHJcbiAqICAgLSBTZXQgcGxheWVyIHRvIHBsYXkgMnggKHR3aWNlKSBhcyBmYXN0XHJcbiAqICAgLSBTZXQgcGxheWVyIHRvIHBsYXkgMC41eCAoaGFsZikgYXMgZmFzdFxyXG4gKlxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICogQGRlZmF1bHRcclxuICovXHJcblRlY2gucHJvdG90eXBlLmZlYXR1cmVzUGxheWJhY2tSYXRlID0gZmFsc2U7XHJcblxyXG4vKipcclxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIHRoZSBgcHJvZ3Jlc3NgIGV2ZW50LiBUaGlzIGlzIGN1cnJlbnRseVxyXG4gKiBub3QgdHJpZ2dlcmVkIGJ5IHZpZGVvLWpzLXN3Zi4gVGhpcyB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmXHJcbiAqIHtAbGluayBUZWNoI21hbnVhbFByb2dyZXNzT259IHNob3VsZCBiZSBjYWxsZWQuXHJcbiAqXHJcbiAqIEB0eXBlIHtib29sZWFufVxyXG4gKiBAZGVmYXVsdFxyXG4gKi9cclxuVGVjaC5wcm90b3R5cGUuZmVhdHVyZXNQcm9ncmVzc0V2ZW50cyA9IGZhbHNlO1xyXG5cclxuLyoqXHJcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB0aGUgYHRpbWV1cGRhdGVgIGV2ZW50LiBUaGlzIGlzIGN1cnJlbnRseVxyXG4gKiBub3QgdHJpZ2dlcmVkIGJ5IHZpZGVvLWpzLXN3Zi4gVGhpcyB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmXHJcbiAqIHtAbGluayBUZWNoI21hbnVhbFRpbWVVcGRhdGVzfSBzaG91bGQgYmUgY2FsbGVkLlxyXG4gKlxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICogQGRlZmF1bHRcclxuICovXHJcblRlY2gucHJvdG90eXBlLmZlYXR1cmVzVGltZXVwZGF0ZUV2ZW50cyA9IGZhbHNlO1xyXG5cclxuLyoqXHJcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3ZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB0aGUgbmF0aXZlIGBUZXh0VHJhY2tgcy5cclxuICogVGhpcyB3aWxsIGhlbHAgdXMgaW50ZWdyYXRlIHdpdGggbmF0aXZlIGBUZXh0VHJhY2tgcyBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGVtLlxyXG4gKlxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICogQGRlZmF1bHRcclxuICovXHJcblRlY2gucHJvdG90eXBlLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyA9IGZhbHNlO1xyXG5cclxuLyoqXHJcbiAqIEEgZnVuY3Rpb25hbCBtaXhpbiBmb3IgdGVjaHMgdGhhdCB3YW50IHRvIHVzZSB0aGUgU291cmNlIEhhbmRsZXIgcGF0dGVybi5cclxuICogU291cmNlIGhhbmRsZXJzIGFyZSBzY3JpcHRzIGZvciBoYW5kbGluZyBzcGVjaWZpYyBmb3JtYXRzLlxyXG4gKiBUaGUgc291cmNlIGhhbmRsZXIgcGF0dGVybiBpcyB1c2VkIGZvciBhZGFwdGl2ZSBmb3JtYXRzIChITFMsIERBU0gpIHRoYXRcclxuICogbWFudWFsbHkgbG9hZCB2aWRlbyBkYXRhIGFuZCBmZWVkIGl0IGludG8gYSBTb3VyY2UgQnVmZmVyIChNZWRpYSBTb3VyY2UgRXh0ZW5zaW9ucylcclxuICogRXhhbXBsZTogYFRlY2gud2l0aFNvdXJjZUhhbmRsZXJzLmNhbGwoTXlUZWNoKTtgXHJcbiAqXHJcbiAqIEBwYXJhbSB7VGVjaH0gX1RlY2hcclxuICogICAgICAgIFRoZSB0ZWNoIHRvIGFkZCBzb3VyY2UgaGFuZGxlciBmdW5jdGlvbnMgdG8uXHJcbiAqXHJcbiAqIEBtaXhlcyBUZWNoflNvdXJjZUhhbmRsZXJBZGRpdGlvbnNcclxuICovXHJcblRlY2gud2l0aFNvdXJjZUhhbmRsZXJzID0gZnVuY3Rpb24gKF9UZWNoKSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVyIGEgc291cmNlIGhhbmRsZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcclxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBoYW5kbGVyIGNsYXNzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxyXG4gICAqICAgICAgICBSZWdpc3RlciBpdCBhdCB0aGUgZm9sbG93aW5nIGluZGV4XHJcbiAgICovXHJcbiAgX1RlY2gucmVnaXN0ZXJTb3VyY2VIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIsIGluZGV4KSB7XHJcbiAgICB2YXIgaGFuZGxlcnMgPSBfVGVjaC5zb3VyY2VIYW5kbGVycztcclxuXHJcbiAgICBpZiAoIWhhbmRsZXJzKSB7XHJcbiAgICAgIGhhbmRsZXJzID0gX1RlY2guc291cmNlSGFuZGxlcnMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxyXG4gICAgICBpbmRleCA9IGhhbmRsZXJzLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDAsIGhhbmRsZXIpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiB0eXBlLiBBbHNvIGNoZWNrcyB0aGVcclxuICAgKiBUZWNocyBzb3VyY2VIYW5kbGVycy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXHJcbiAgICogICAgICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2suXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICogICAgICAgICAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxyXG4gICAqL1xyXG4gIF9UZWNoLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgIHZhciBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzIHx8IFtdO1xyXG4gICAgdmFyIGNhbiA9IHZvaWQgMDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNhbiA9IGhhbmRsZXJzW2ldLmNhblBsYXlUeXBlKHR5cGUpO1xyXG5cclxuICAgICAgaWYgKGNhbikge1xyXG4gICAgICAgIHJldHVybiBjYW47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgZmlyc3Qgc291cmNlIGhhbmRsZXIgdGhhdCBzdXBwb3J0cyB0aGUgc291cmNlLlxyXG4gICAqXHJcbiAgICogVE9ETzogQW5zd2VyIHF1ZXN0aW9uOiBzaG91bGQgJ3Byb2JhYmx5JyBiZSBwcmlvcml0aXplZCBvdmVyICdtYXliZSdcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNvdXJjZVxyXG4gICAqICAgICAgICBUaGUgc291cmNlIG9iamVjdFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgKiAgICAgICAgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSB0ZWNoXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtTb3VyY2VIYW5kbGVyfG51bGx9XHJcbiAgICogICAgICAgICAgVGhlIGZpcnN0IHNvdXJjZSBoYW5kbGVyIHRoYXQgc3VwcG9ydHMgdGhlIHNvdXJjZSBvciBudWxsIGlmXHJcbiAgICogICAgICAgICAgbm8gU291cmNlSGFuZGxlciBzdXBwb3J0cyB0aGUgc291cmNlXHJcbiAgICovXHJcbiAgX1RlY2guc2VsZWN0U291cmNlSGFuZGxlciA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgIHZhciBoYW5kbGVycyA9IF9UZWNoLnNvdXJjZUhhbmRsZXJzIHx8IFtdO1xyXG4gICAgdmFyIGNhbiA9IHZvaWQgMDtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNhbiA9IGhhbmRsZXJzW2ldLmNhbkhhbmRsZVNvdXJjZShzb3VyY2UsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgaWYgKGNhbikge1xyXG4gICAgICAgIHJldHVybiBoYW5kbGVyc1tpXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiBzb3VyY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fSBzcmNPYmpcclxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICogICAgICAgIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgdGVjaFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqICAgICAgICAgJ3Byb2JhYmx5JywgJ21heWJlJywgb3IgJycgKGVtcHR5IHN0cmluZylcclxuICAgKi9cclxuICBfVGVjaC5jYW5QbGF5U291cmNlID0gZnVuY3Rpb24gKHNyY09iaiwgb3B0aW9ucykge1xyXG4gICAgdmFyIHNoID0gX1RlY2guc2VsZWN0U291cmNlSGFuZGxlcihzcmNPYmosIG9wdGlvbnMpO1xyXG5cclxuICAgIGlmIChzaCkge1xyXG4gICAgICByZXR1cm4gc2guY2FuSGFuZGxlU291cmNlKHNyY09iaiwgb3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICcnO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZW4gdXNpbmcgYSBzb3VyY2UgaGFuZGxlciwgcHJlZmVyIGl0cyBpbXBsZW1lbnRhdGlvbiBvZlxyXG4gICAqIGFueSBmdW5jdGlvbiBub3JtYWxseSBwcm92aWRlZCBieSB0aGUgdGVjaC5cclxuICAgKi9cclxuICB2YXIgZGVmZXJyYWJsZSA9IFsnc2Vla2FibGUnLCAnZHVyYXRpb24nXTtcclxuXHJcbiAgLyoqXHJcbiAgICogQSB3cmFwcGVyIGFyb3VuZCB7QGxpbmsgVGVjaCNzZWVrYWJsZX0gdGhhdCB3aWxsIGNhbGwgYSBgU291cmNlSGFuZGxlcmBzIHNlZWthYmxlXHJcbiAgICogZnVuY3Rpb24gaWYgaXQgZXhpc3RzLCB3aXRoIGEgZmFsbGJhY2sgdG8gdGhlIFRlY2hzIHNlZWthYmxlIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQG1ldGhvZCBfVGVjaC5zZWVrYWJsZVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBBIHdyYXBwZXIgYXJvdW5kIHtAbGluayBUZWNoI2R1cmF0aW9ufSB0aGF0IHdpbGwgY2FsbCBhIGBTb3VyY2VIYW5kbGVyYHMgZHVyYXRpb25cclxuICAgKiBmdW5jdGlvbiBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSBpdCB3aWxsIGZhbGxiYWNrIHRvIHRoZSB0ZWNocyBkdXJhdGlvbiBmdW5jdGlvbi5cclxuICAgKlxyXG4gICAqIEBtZXRob2QgX1RlY2guZHVyYXRpb25cclxuICAgKi9cclxuXHJcbiAgZGVmZXJyYWJsZS5mb3JFYWNoKGZ1bmN0aW9uIChmbk5hbWUpIHtcclxuICAgIHZhciBvcmlnaW5hbEZuID0gdGhpc1tmbk5hbWVdO1xyXG5cclxuICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxGbiAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpc1tmbk5hbWVdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAodGhpcy5zb3VyY2VIYW5kbGVyXyAmJiB0aGlzLnNvdXJjZUhhbmRsZXJfW2ZuTmFtZV0pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VIYW5kbGVyX1tmbk5hbWVdLmFwcGx5KHRoaXMuc291cmNlSGFuZGxlcl8sIGFyZ3VtZW50cyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG9yaWdpbmFsRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgfSwgX1RlY2gucHJvdG90eXBlKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgZnVuY3Rpb24gZm9yIHNldHRpbmcgdGhlIHNvdXJjZSB1c2luZyBhIHNvdXJjZSBvYmplY3RcclxuICAgKiBhbmQgc291cmNlIGhhbmRsZXJzLlxyXG4gICAqIFNob3VsZCBuZXZlciBiZSBjYWxsZWQgdW5sZXNzIGEgc291cmNlIGhhbmRsZXIgd2FzIGZvdW5kLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXHJcbiAgICogICAgICAgIEEgc291cmNlIG9iamVjdCB3aXRoIHNyYyBhbmQgdHlwZSBrZXlzXHJcbiAgICovXHJcbiAgX1RlY2gucHJvdG90eXBlLnNldFNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgIHZhciBzaCA9IF9UZWNoLnNlbGVjdFNvdXJjZUhhbmRsZXIoc291cmNlLCB0aGlzLm9wdGlvbnNfKTtcclxuXHJcbiAgICBpZiAoIXNoKSB7XHJcbiAgICAgIC8vIEZhbGwgYmFjayB0byBhIG5hdGl2ZSBzb3VyY2UgaGFuZGVyIHdoZW4gdW5zdXBwb3J0ZWQgc291cmNlcyBhcmVcclxuICAgICAgLy8gZGVsaWJlcmF0ZWx5IHNldFxyXG4gICAgICBpZiAoX1RlY2gubmF0aXZlU291cmNlSGFuZGxlcikge1xyXG4gICAgICAgIHNoID0gX1RlY2gubmF0aXZlU291cmNlSGFuZGxlcjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBsb2ckMS5lcnJvcignTm8gc291cmNlIGhhbmRlciBmb3VuZCBmb3IgdGhlIGN1cnJlbnQgc291cmNlLicpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlzcG9zZSBhbnkgZXhpc3Rpbmcgc291cmNlIGhhbmRsZXJcclxuICAgIHRoaXMuZGlzcG9zZVNvdXJjZUhhbmRsZXIoKTtcclxuICAgIHRoaXMub2ZmKCdkaXNwb3NlJywgdGhpcy5kaXNwb3NlU291cmNlSGFuZGxlcik7XHJcblxyXG4gICAgaWYgKHNoICE9PSBfVGVjaC5uYXRpdmVTb3VyY2VIYW5kbGVyKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudFNvdXJjZV8gPSBzb3VyY2U7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zb3VyY2VIYW5kbGVyXyA9IHNoLmhhbmRsZVNvdXJjZShzb3VyY2UsIHRoaXMsIHRoaXMub3B0aW9uc18pO1xyXG4gICAgdGhpcy5vbignZGlzcG9zZScsIHRoaXMuZGlzcG9zZVNvdXJjZUhhbmRsZXIpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFuIHVwIGFueSBleGlzdGluZyBTb3VyY2VIYW5kbGVycyBhbmQgbGlzdGVuZXJzIHdoZW4gdGhlIFRlY2ggaXMgZGlzcG9zZWQuXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBUZWNoI2Rpc3Bvc2VcclxuICAgKi9cclxuICBfVGVjaC5wcm90b3R5cGUuZGlzcG9zZVNvdXJjZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBpZiB3ZSBoYXZlIGEgc291cmNlIGFuZCBnZXQgYW5vdGhlciBvbmVcclxuICAgIC8vIHRoZW4gd2UgYXJlIGxvYWRpbmcgc29tZXRoaW5nIG5ld1xyXG4gICAgLy8gdGhhbiBjbGVhciBhbGwgb2Ygb3VyIGN1cnJlbnQgdHJhY2tzXHJcbiAgICBpZiAodGhpcy5jdXJyZW50U291cmNlXykge1xyXG4gICAgICB0aGlzLmNsZWFyVHJhY2tzKFsnYXVkaW8nLCAndmlkZW8nXSk7XHJcbiAgICAgIHRoaXMuY3VycmVudFNvdXJjZV8gPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGFsd2F5cyBjbGVhbiB1cCBhdXRvLXRleHQgdHJhY2tzXHJcbiAgICB0aGlzLmNsZWFudXBBdXRvVGV4dFRyYWNrcygpO1xyXG5cclxuICAgIGlmICh0aGlzLnNvdXJjZUhhbmRsZXJfKSB7XHJcblxyXG4gICAgICBpZiAodGhpcy5zb3VyY2VIYW5kbGVyXy5kaXNwb3NlKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VIYW5kbGVyXy5kaXNwb3NlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuc291cmNlSGFuZGxlcl8gPSBudWxsO1xyXG4gICAgfVxyXG4gIH07XHJcbn07XHJcblxyXG4vLyBUaGUgYmFzZSBUZWNoIGNsYXNzIG5lZWRzIHRvIGJlIHJlZ2lzdGVyZWQgYXMgYSBDb21wb25lbnQuIEl0IGlzIHRoZSBvbmx5XHJcbi8vIFRlY2ggdGhhdCBjYW4gYmUgcmVnaXN0ZXJlZCBhcyBhIENvbXBvbmVudC5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZWNoJywgVGVjaCk7XHJcblRlY2gucmVnaXN0ZXJUZWNoKCdUZWNoJywgVGVjaCk7XHJcblxyXG4vKipcclxuICogQSBsaXN0IG9mIHRlY2hzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRlY2hPcmRlciBvbiBQbGF5ZXJzXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5UZWNoLmRlZmF1bHRUZWNoT3JkZXJfID0gW107XHJcblxyXG52YXIgbWlkZGxld2FyZXMgPSB7fTtcclxuXHJcbmZ1bmN0aW9uIHVzZSh0eXBlLCBtaWRkbGV3YXJlKSB7XHJcbiAgbWlkZGxld2FyZXNbdHlwZV0gPSBtaWRkbGV3YXJlc1t0eXBlXSB8fCBbXTtcclxuICBtaWRkbGV3YXJlc1t0eXBlXS5wdXNoKG1pZGRsZXdhcmUpO1xyXG59XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIHNldFNvdXJjZShwbGF5ZXIsIHNyYywgbmV4dCkge1xyXG4gIHBsYXllci5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtaWRkbGV3YXJlc1tzcmMudHlwZV0sIG5leHQsIHBsYXllcik7XHJcbiAgfSwgMSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFRlY2gobWlkZGxld2FyZSwgdGVjaCkge1xyXG4gIG1pZGRsZXdhcmUuZm9yRWFjaChmdW5jdGlvbiAobXcpIHtcclxuICAgIHJldHVybiBtdy5zZXRUZWNoICYmIG13LnNldFRlY2godGVjaCk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldCQxKG1pZGRsZXdhcmUsIHRlY2gsIG1ldGhvZCkge1xyXG4gIHJldHVybiBtaWRkbGV3YXJlLnJlZHVjZVJpZ2h0KG1pZGRsZXdhcmVJdGVyYXRvcihtZXRob2QpLCB0ZWNoW21ldGhvZF0oKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldCQxKG1pZGRsZXdhcmUsIHRlY2gsIG1ldGhvZCwgYXJnKSB7XHJcbiAgcmV0dXJuIHRlY2hbbWV0aG9kXShtaWRkbGV3YXJlLnJlZHVjZShtaWRkbGV3YXJlSXRlcmF0b3IobWV0aG9kKSwgYXJnKSk7XHJcbn1cclxuXHJcbnZhciBhbGxvd2VkR2V0dGVycyA9IHtcclxuICBidWZmZXJlZDogMSxcclxuICBjdXJyZW50VGltZTogMSxcclxuICBkdXJhdGlvbjogMSxcclxuICBzZWVrYWJsZTogMSxcclxuICBwbGF5ZWQ6IDFcclxufTtcclxuXHJcbnZhciBhbGxvd2VkU2V0dGVycyA9IHtcclxuICBzZXRDdXJyZW50VGltZTogMVxyXG59O1xyXG5cclxuZnVuY3Rpb24gbWlkZGxld2FyZUl0ZXJhdG9yKG1ldGhvZCkge1xyXG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIG13KSB7XHJcbiAgICBpZiAobXdbbWV0aG9kXSkge1xyXG4gICAgICByZXR1cm4gbXdbbWV0aG9kXSh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFNvdXJjZUhlbHBlcigpIHtcclxuICB2YXIgc3JjID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcclxuICB2YXIgbWlkZGxld2FyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XHJcbiAgdmFyIG5leHQgPSBhcmd1bWVudHNbMl07XHJcbiAgdmFyIHBsYXllciA9IGFyZ3VtZW50c1szXTtcclxuICB2YXIgYWNjID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBbXTtcclxuICB2YXIgbGFzdFJ1biA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogZmFsc2U7XHJcbiAgdmFyIG13RmFjdG9yeSA9IG1pZGRsZXdhcmVbMF0sXHJcbiAgICAgIG13cmVzdCA9IG1pZGRsZXdhcmUuc2xpY2UoMSk7XHJcblxyXG4gIC8vIGlmIG13RmFjdG9yeSBpcyBhIHN0cmluZywgdGhlbiB3ZSdyZSBhdCBhIGZvcmsgaW4gdGhlIHJvYWRcclxuXHJcbiAgaWYgKHR5cGVvZiBtd0ZhY3RvcnkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtaWRkbGV3YXJlc1ttd0ZhY3RvcnldLCBuZXh0LCBwbGF5ZXIsIGFjYywgbGFzdFJ1bik7XHJcblxyXG4gICAgLy8gaWYgd2UgaGF2ZSBhbiBtd0ZhY3RvcnksIGNhbGwgaXQgd2l0aCB0aGUgcGxheWVyIHRvIGdldCB0aGUgbXcsXHJcbiAgICAvLyB0aGVuIGNhbGwgdGhlIG13J3Mgc2V0U291cmNlIG1ldGhvZFxyXG4gIH0gZWxzZSBpZiAobXdGYWN0b3J5KSB7XHJcbiAgICB2YXIgbXcgPSBtd0ZhY3RvcnkocGxheWVyKTtcclxuXHJcbiAgICBtdy5zZXRTb3VyY2UoYXNzaWduKHt9LCBzcmMpLCBmdW5jdGlvbiAoZXJyLCBfc3JjKSB7XHJcblxyXG4gICAgICAvLyBzb21ldGhpbmcgaGFwcGVuZWQsIHRyeSB0aGUgbmV4dCBtaWRkbGV3YXJlIG9uIHRoZSBjdXJyZW50IGxldmVsXHJcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byB1c2UgdGhlIG9sZCBzcmNcclxuICAgICAgaWYgKGVycikge1xyXG4gICAgICAgIHJldHVybiBzZXRTb3VyY2VIZWxwZXIoc3JjLCBtd3Jlc3QsIG5leHQsIHBsYXllciwgYWNjLCBsYXN0UnVuKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gd2UndmUgc3VjY2VlZGVkLCBub3cgd2UgbmVlZCB0byBnbyBkZWVwZXJcclxuICAgICAgYWNjLnB1c2gobXcpO1xyXG5cclxuICAgICAgLy8gaWYgaXQncyB0aGUgc2FtZSB0aW1lLCBjb250aW51ZSBkb2VzIHRoZSBjdXJyZW50IGNoYWluXHJcbiAgICAgIC8vIG90aGVyd2lzZSwgd2Ugd2FudCB0byBnbyBkb3duIHRoZSBuZXcgY2hhaW5cclxuICAgICAgc2V0U291cmNlSGVscGVyKF9zcmMsIHNyYy50eXBlID09PSBfc3JjLnR5cGUgPyBtd3Jlc3QgOiBtaWRkbGV3YXJlc1tfc3JjLnR5cGVdLCBuZXh0LCBwbGF5ZXIsIGFjYywgbGFzdFJ1bik7XHJcbiAgICB9KTtcclxuICB9IGVsc2UgaWYgKG13cmVzdC5sZW5ndGgpIHtcclxuICAgIHNldFNvdXJjZUhlbHBlcihzcmMsIG13cmVzdCwgbmV4dCwgcGxheWVyLCBhY2MsIGxhc3RSdW4pO1xyXG4gIH0gZWxzZSBpZiAobGFzdFJ1bikge1xyXG4gICAgbmV4dChzcmMsIGFjYyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNldFNvdXJjZUhlbHBlcihzcmMsIG1pZGRsZXdhcmVzWycqJ10sIG5leHQsIHBsYXllciwgYWNjLCB0cnVlKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIGZpbHRlci1zb3VyY2VcclxuICovXHJcbi8qKlxyXG4gKiBGaWx0ZXIgb3V0IHNpbmdsZSBiYWQgc291cmNlIG9iamVjdHMgb3IgbXVsdGlwbGUgc291cmNlIG9iamVjdHMgaW4gYW5cclxuICogYXJyYXkuIEFsc28gZmxhdHRlbnMgbmVzdGVkIHNvdXJjZSBvYmplY3QgYXJyYXlzIGludG8gYSAxIGRpbWVuc2lvbmFsXHJcbiAqIGFycmF5IG9mIHNvdXJjZSBvYmplY3RzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fFRlY2h+U291cmNlT2JqZWN0W119IHNyY1xyXG4gKiAgICAgICAgVGhlIHNyYyBvYmplY3QgdG8gZmlsdGVyXHJcbiAqXHJcbiAqIEByZXR1cm4ge1RlY2h+U291cmNlT2JqZWN0W119XHJcbiAqICAgICAgICAgQW4gYXJyYXkgb2Ygc291cmNlb2JqZWN0cyBjb250YWluaW5nIG9ubHkgdmFsaWQgc291cmNlc1xyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxudmFyIGZpbHRlclNvdXJjZSA9IGZ1bmN0aW9uIGZpbHRlclNvdXJjZShzcmMpIHtcclxuICAvLyB0cmF2ZXJzZSBhcnJheVxyXG4gIGlmIChBcnJheS5pc0FycmF5KHNyYykpIHtcclxuICAgIHZhciBuZXdzcmMgPSBbXTtcclxuXHJcbiAgICBzcmMuZm9yRWFjaChmdW5jdGlvbiAoc3Jjb2JqKSB7XHJcbiAgICAgIHNyY29iaiA9IGZpbHRlclNvdXJjZShzcmNvYmopO1xyXG5cclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3Jjb2JqKSkge1xyXG4gICAgICAgIG5ld3NyYyA9IG5ld3NyYy5jb25jYXQoc3Jjb2JqKTtcclxuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChzcmNvYmopKSB7XHJcbiAgICAgICAgbmV3c3JjLnB1c2goc3Jjb2JqKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgc3JjID0gbmV3c3JjO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgJiYgc3JjLnRyaW0oKSkge1xyXG4gICAgLy8gY29udmVydCBzdHJpbmcgaW50byBvYmplY3RcclxuICAgIHNyYyA9IFt7IHNyYzogc3JjIH1dO1xyXG4gIH0gZWxzZSBpZiAoaXNPYmplY3Qoc3JjKSAmJiB0eXBlb2Ygc3JjLnNyYyA9PT0gJ3N0cmluZycgJiYgc3JjLnNyYyAmJiBzcmMuc3JjLnRyaW0oKSkge1xyXG4gICAgLy8gc3JjIGlzIGFscmVhZHkgdmFsaWRcclxuICAgIHNyYyA9IFtzcmNdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBpbnZhbGlkIHNvdXJjZSwgdHVybiBpdCBpbnRvIGFuIGVtcHR5IGFycmF5XHJcbiAgICBzcmMgPSBbXTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzcmM7XHJcbn07XHJcblxyXG4vKipcclxuICogQGZpbGUgbG9hZGVyLmpzXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGBNZWRpYUxvYWRlcmAgaXMgdGhlIGBDb21wb25lbnRgIHRoYXQgZGVjaWRlcyB3aGljaCBwbGF5YmFjayB0ZWNobm9sb2d5IHRvIGxvYWRcclxuICogd2hlbiBhIHBsYXllciBpcyBpbml0aWFsaXplZC5cclxuICpcclxuICogQGV4dGVuZHMgQ29tcG9uZW50XHJcbiAqL1xyXG5cclxudmFyIE1lZGlhTG9hZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcclxuICBpbmhlcml0cyhNZWRpYUxvYWRlciwgX0NvbXBvbmVudCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBhdHRhY2ggdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3Ryb2Ugb2YgcGxheWVyIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXHJcbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIHJ1biB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHJlYWR5LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIE1lZGlhTG9hZGVyKHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1lZGlhTG9hZGVyKTtcclxuXHJcbiAgICAvLyBNZWRpYUxvYWRlciBoYXMgbm8gZWxlbWVudFxyXG4gICAgdmFyIG9wdGlvbnNfID0gbWVyZ2VPcHRpb25zKHsgY3JlYXRlRWw6IGZhbHNlIH0sIG9wdGlvbnMpO1xyXG5cclxuICAgIC8vIElmIHRoZXJlIGFyZSBubyBzb3VyY2VzIHdoZW4gdGhlIHBsYXllciBpcyBpbml0aWFsaXplZCxcclxuICAgIC8vIGxvYWQgdGhlIGZpcnN0IHN1cHBvcnRlZCBwbGF5YmFjayB0ZWNobm9sb2d5LlxyXG5cclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9uc18sIHJlYWR5KSk7XHJcblxyXG4gICAgaWYgKCFvcHRpb25zLnBsYXllck9wdGlvbnMuc291cmNlcyB8fCBvcHRpb25zLnBsYXllck9wdGlvbnMuc291cmNlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBvcHRpb25zLnBsYXllck9wdGlvbnMudGVjaE9yZGVyOyBpIDwgai5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciB0ZWNoTmFtZSA9IHRvVGl0bGVDYXNlKGpbaV0pO1xyXG4gICAgICAgIHZhciB0ZWNoID0gVGVjaC5nZXRUZWNoKHRlY2hOYW1lKTtcclxuXHJcbiAgICAgICAgLy8gU3VwcG9ydCBvbGQgYmVoYXZpb3Igb2YgdGVjaHMgYmVpbmcgcmVnaXN0ZXJlZCBhcyBjb21wb25lbnRzLlxyXG4gICAgICAgIC8vIFJlbW92ZSBvbmNlIHRoYXQgZGVwcmVjYXRlZCBiZWhhdmlvciBpcyByZW1vdmVkLlxyXG4gICAgICAgIGlmICghdGVjaE5hbWUpIHtcclxuICAgICAgICAgIHRlY2ggPSBDb21wb25lbnQuZ2V0Q29tcG9uZW50KHRlY2hOYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoaXMgdGVjaG5vbG9neVxyXG4gICAgICAgIGlmICh0ZWNoICYmIHRlY2guaXNTdXBwb3J0ZWQoKSkge1xyXG4gICAgICAgICAgcGxheWVyLmxvYWRUZWNoXyh0ZWNoTmFtZSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIExvb3AgdGhyb3VnaCBwbGF5YmFjayB0ZWNobm9sb2dpZXMgKEhUTUw1LCBGbGFzaCkgYW5kIGNoZWNrIGZvciBzdXBwb3J0LlxyXG4gICAgICAvLyBUaGVuIGxvYWQgdGhlIGJlc3Qgc291cmNlLlxyXG4gICAgICAvLyBBIGZldyBhc3N1bXB0aW9ucyBoZXJlOlxyXG4gICAgICAvLyAgIEFsbCBwbGF5YmFjayB0ZWNobm9sb2dpZXMgcmVzcGVjdCBwcmVsb2FkIGZhbHNlLlxyXG4gICAgICBwbGF5ZXIuc3JjKG9wdGlvbnMucGxheWVyT3B0aW9ucy5zb3VyY2VzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIHJldHVybiBNZWRpYUxvYWRlcjtcclxufShDb21wb25lbnQpO1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNZWRpYUxvYWRlcicsIE1lZGlhTG9hZGVyKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBidXR0b24uanNcclxuICovXHJcbi8qKlxyXG4gKiBDbGlja2FibGUgQ29tcG9uZW50IHdoaWNoIGlzIGNsaWNrYWJsZSBvciBrZXlib2FyZCBhY3Rpb25hYmxlLFxyXG4gKiBidXQgaXMgbm90IGEgbmF0aXZlIEhUTUwgYnV0dG9uLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcclxuICovXHJcblxyXG52YXIgQ2xpY2thYmxlQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcclxuICBpbmhlcml0cyhDbGlja2FibGVDb21wb25lbnQsIF9Db21wb25lbnQpO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBDbGlja2FibGVDb21wb25lbnQocGxheWVyLCBvcHRpb25zKSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDbGlja2FibGVDb21wb25lbnQpO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xyXG5cclxuICAgIF90aGlzLmVtaXRUYXBFdmVudHMoKTtcclxuXHJcbiAgICBfdGhpcy5lbmFibGUoKTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGBzIERPTSBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0YWc9ZGl2XVxyXG4gICAqICAgICAgICBUaGUgZWxlbWVudCdzIG5vZGUgdHlwZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHM9e31dXHJcbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlcz17fV1cclxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RWxlbWVudH1cclxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xyXG4gICAgdmFyIHRhZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ2Rpdic7XHJcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xyXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xyXG5cclxuICAgIHByb3BzID0gYXNzaWduKHtcclxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3M9XCJ2anMtaWNvbi1wbGFjZWhvbGRlclwiPjwvc3Bhbj4nLFxyXG4gICAgICBjbGFzc05hbWU6IHRoaXMuYnVpbGRDU1NDbGFzcygpLFxyXG4gICAgICB0YWJJbmRleDogMFxyXG4gICAgfSwgcHJvcHMpO1xyXG5cclxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XHJcbiAgICAgIGxvZyQxLmVycm9yKCdDcmVhdGluZyBhIENsaWNrYWJsZUNvbXBvbmVudCB3aXRoIGFuIEhUTUwgZWxlbWVudCBvZiAnICsgdGFnICsgJyBpcyBub3Qgc3VwcG9ydGVkOyB1c2UgYSBCdXR0b24gaW5zdGVhZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgQVJJQSBhdHRyaWJ1dGVzIGZvciBjbGlja2FibGUgZWxlbWVudCB3aGljaCBpcyBub3QgYSBuYXRpdmUgSFRNTCBidXR0b25cclxuICAgIGF0dHJpYnV0ZXMgPSBhc3NpZ24oe1xyXG4gICAgICAncm9sZSc6ICdidXR0b24nLFxyXG5cclxuICAgICAgLy8gbGV0IHRoZSBzY3JlZW4gcmVhZGVyIHVzZXIga25vdyB0aGF0IHRoZSB0ZXh0IG9mIHRoZSBlbGVtZW50IG1heSBjaGFuZ2VcclxuICAgICAgJ2FyaWEtbGl2ZSc6ICdwb2xpdGUnXHJcbiAgICB9LCBhdHRyaWJ1dGVzKTtcclxuXHJcbiAgICB0aGlzLnRhYkluZGV4XyA9IHByb3BzLnRhYkluZGV4O1xyXG5cclxuICAgIHZhciBlbCA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgdGFnLCBwcm9wcywgYXR0cmlidXRlcyk7XHJcblxyXG4gICAgdGhpcy5jcmVhdGVDb250cm9sVGV4dEVsKGVsKTtcclxuXHJcbiAgICByZXR1cm4gZWw7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgY29udHJvbCB0ZXh0IGVsZW1lbnQgb24gdGhpcyBgQ29tcG9uZW50YFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBbZWxdXHJcbiAgICogICAgICAgIFBhcmVudCBlbGVtZW50IGZvciB0aGUgY29udHJvbCB0ZXh0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RWxlbWVudH1cclxuICAgKiAgICAgICAgIFRoZSBjb250cm9sIHRleHQgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlQ29udHJvbFRleHRFbCA9IGZ1bmN0aW9uIGNyZWF0ZUNvbnRyb2xUZXh0RWwoZWwpIHtcclxuICAgIHRoaXMuY29udHJvbFRleHRFbF8gPSBjcmVhdGVFbCgnc3BhbicsIHtcclxuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtdGV4dCdcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChlbCkge1xyXG4gICAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRyb2xUZXh0RWxfKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmNvbnRyb2xUZXh0KHRoaXMuY29udHJvbFRleHRfLCBlbCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuY29udHJvbFRleHRFbF87XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IG9yIHNldCB0aGUgbG9jYWxpemUgdGV4dCB0byB1c2UgZm9yIHRoZSBjb250cm9scyBvbiB0aGUgYENvbXBvbmVudGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RleHRdXHJcbiAgICogICAgICAgIENvbnRyb2wgdGV4dCBmb3IgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gW2VsPXRoaXMuZWwoKV1cclxuICAgKiAgICAgICAgRWxlbWVudCB0byBzZXQgdGhlIHRpdGxlIG9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqICAgICAgICAgLSBUaGUgY29udHJvbCB0ZXh0IHdoZW4gZ2V0dGluZ1xyXG4gICAqL1xyXG5cclxuXHJcbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5jb250cm9sVGV4dCA9IGZ1bmN0aW9uIGNvbnRyb2xUZXh0KHRleHQpIHtcclxuICAgIHZhciBlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5lbCgpO1xyXG5cclxuICAgIGlmICghdGV4dCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5jb250cm9sVGV4dF8gfHwgJ05lZWQgVGV4dCc7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxvY2FsaXplZFRleHQgPSB0aGlzLmxvY2FsaXplKHRleHQpO1xyXG5cclxuICAgIHRoaXMuY29udHJvbFRleHRfID0gdGV4dDtcclxuICAgIHRleHRDb250ZW50KHRoaXMuY29udHJvbFRleHRFbF8sIGxvY2FsaXplZFRleHQpO1xyXG4gICAgaWYgKCF0aGlzLm5vbkljb25Db250cm9sKSB7XHJcbiAgICAgIC8vIFNldCB0aXRsZSBhdHRyaWJ1dGUgaWYgb25seSBhbiBpY29uIGlzIHNob3duXHJcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBsb2NhbGl6ZWRUZXh0KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXHJcbiAgICovXHJcblxyXG5cclxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xyXG4gICAgcmV0dXJuICd2anMtY29udHJvbCB2anMtYnV0dG9uICcgKyBfQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRW5hYmxlIHRoaXMgYENvbXBvbmVudGBzIGVsZW1lbnQuXHJcbiAgICovXHJcblxyXG5cclxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcclxuICAgIGlmICghdGhpcy5lbmFibGVkXykge1xyXG4gICAgICB0aGlzLmVuYWJsZWRfID0gdHJ1ZTtcclxuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWRpc2FibGVkJyk7XHJcbiAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xyXG4gICAgICBpZiAodHlwZW9mIHRoaXMudGFiSW5kZXhfICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCB0aGlzLnRhYkluZGV4Xyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5vbihbJ3RhcCcsICdjbGljayddLCB0aGlzLmhhbmRsZUNsaWNrKTtcclxuICAgICAgdGhpcy5vbignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzKTtcclxuICAgICAgdGhpcy5vbignYmx1cicsIHRoaXMuaGFuZGxlQmx1cik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRGlzYWJsZSB0aGlzIGBDb21wb25lbnRgcyBlbGVtZW50LlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcclxuICAgIHRoaXMuZW5hYmxlZF8gPSBmYWxzZTtcclxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1kaXNhYmxlZCcpO1xyXG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcclxuICAgIGlmICh0eXBlb2YgdGhpcy50YWJJbmRleF8gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHRoaXMuZWxfLnJlbW92ZUF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcclxuICAgIH1cclxuICAgIHRoaXMub2ZmKFsndGFwJywgJ2NsaWNrJ10sIHRoaXMuaGFuZGxlQ2xpY2spO1xyXG4gICAgdGhpcy5vZmYoJ2ZvY3VzJywgdGhpcy5oYW5kbGVGb2N1cyk7XHJcbiAgICB0aGlzLm9mZignYmx1cicsIHRoaXMuaGFuZGxlQmx1cik7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGEgYENsaWNrYWJsZUNvbXBvbmVudGAgZ2V0czpcclxuICAgKiAtIENsaWNrZWQgKHZpYSB0aGUgYGNsaWNrYCBldmVudCwgbGlzdGVuaW5nIHN0YXJ0cyBpbiB0aGUgY29uc3RydWN0b3IpXHJcbiAgICogLSBUYXBwZWQgKHZpYSB0aGUgYHRhcGAgZXZlbnQsIGxpc3RlbmluZyBzdGFydHMgaW4gdGhlIGNvbnN0cnVjdG9yKVxyXG4gICAqIC0gVGhlIGZvbGxvd2luZyB0aGluZ3MgaGFwcGVuIGluIG9yZGVyOlxyXG4gICAqICAgMS4ge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVGb2N1c30gaXMgY2FsbGVkIHZpYSBhIGBmb2N1c2AgZXZlbnQgb24gdGhlXHJcbiAgICogICAgICBgQ2xpY2thYmxlQ29tcG9uZW50YC5cclxuICAgKiAgIDIuIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlRm9jdXN9IGFkZHMgYSBsaXN0ZW5lciBmb3IgYGtleWRvd25gIG9uIHVzaW5nXHJcbiAgICogICAgICB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUtleVByZXNzfS5cclxuICAgKiAgIDMuIGBDbGlja2FibGVDb21wb25lbnRgIGhhcyBub3QgaGFkIGEgYGJsdXJgIGV2ZW50IChgYmx1cmAgbWVhbnMgdGhhdCBmb2N1cyB3YXMgbG9zdCkuIFRoZSB1c2VyIHByZXNzZXNcclxuICAgKiAgICAgIHRoZSBzcGFjZSBvciBlbnRlciBrZXkuXHJcbiAgICogICA0LiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUtleVByZXNzfSBjYWxscyB0aGlzIGZ1bmN0aW9uIHdpdGggdGhlIGBrZXlkb3duYFxyXG4gICAqICAgICAgZXZlbnQgYXMgYSBwYXJhbWV0ZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXHJcbiAgICogICAgICAgIGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIHRhcFxyXG4gICAqIEBsaXN0ZW5zIGNsaWNrXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICovXHJcblxyXG5cclxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHt9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQ2xpY2thYmxlQ29tcG9uZW50YCBnYWlucyBmb2N1cyB2aWEgYSBgZm9jdXNgIGV2ZW50LlxyXG4gICAqIFR1cm5zIG9uIGxpc3RlbmluZyBmb3IgYGtleWRvd25gIGV2ZW50cy4gV2hlbiB0aGV5IGhhcHBlbiBpdFxyXG4gICAqIGNhbGxzIGB0aGlzLmhhbmRsZUtleVByZXNzYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIFRoZSBgZm9jdXNgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgZm9jdXNcclxuICAgKi9cclxuXHJcblxyXG4gIENsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlRm9jdXMgPSBmdW5jdGlvbiBoYW5kbGVGb2N1cyhldmVudCkge1xyXG4gICAgb24oZG9jdW1lbnRfMSwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgd2hlbiB0aGlzIENsaWNrYWJsZUNvbXBvbmVudCBoYXMgZm9jdXMgYW5kIGEga2V5IGdldHMgcHJlc3NlZCBkb3duLiBCeVxyXG4gICAqIGRlZmF1bHQgaXQgd2lsbCBjYWxsIGB0aGlzLmhhbmRsZUNsaWNrYCB3aGVuIHRoZSBrZXkgaXMgc3BhY2Ugb3IgZW50ZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMga2V5ZG93blxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XHJcblxyXG4gICAgLy8gU3VwcG9ydCBTcGFjZSAoMzIpIG9yIEVudGVyICgxMykga2V5IG9wZXJhdGlvbiB0byBmaXJlIGEgY2xpY2sgZXZlbnRcclxuICAgIGlmIChldmVudC53aGljaCA9PT0gMzIgfHwgZXZlbnQud2hpY2ggPT09IDEzKSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIHRoaXMudHJpZ2dlcignY2xpY2snKTtcclxuICAgIH0gZWxzZSBpZiAoX0NvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MpIHtcclxuXHJcbiAgICAgIC8vIFBhc3Mga2V5cHJlc3MgaGFuZGxpbmcgdXAgZm9yIHVuc3VwcG9ydGVkIGtleXNcclxuICAgICAgX0NvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MuY2FsbCh0aGlzLCBldmVudCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW4gYSBgQ2xpY2thYmxlQ29tcG9uZW50YCBsb3NlcyBmb2N1cy4gVHVybnMgb2ZmIHRoZSBsaXN0ZW5lciBmb3JcclxuICAgKiBga2V5ZG93bmAgZXZlbnRzLiBXaGljaCBTdG9wcyBgdGhpcy5oYW5kbGVLZXlQcmVzc2AgZnJvbSBnZXR0aW5nIGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIFRoZSBgYmx1cmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBibHVyXHJcbiAgICovXHJcblxyXG5cclxuICBDbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiBoYW5kbGVCbHVyKGV2ZW50KSB7XHJcbiAgICBvZmYoZG9jdW1lbnRfMSwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gQ2xpY2thYmxlQ29tcG9uZW50O1xyXG59KENvbXBvbmVudCk7XHJcblxyXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0NsaWNrYWJsZUNvbXBvbmVudCcsIENsaWNrYWJsZUNvbXBvbmVudCk7XHJcblxyXG4vKipcclxuICogQGZpbGUgcG9zdGVyLWltYWdlLmpzXHJcbiAqL1xyXG4vKipcclxuICogQSBgQ2xpY2thYmxlQ29tcG9uZW50YCB0aGF0IGhhbmRsZXMgc2hvd2luZyB0aGUgcG9zdGVyIGltYWdlIGZvciB0aGUgcGxheWVyLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBDbGlja2FibGVDb21wb25lbnRcclxuICovXHJcblxyXG52YXIgUG9zdGVySW1hZ2UgPSBmdW5jdGlvbiAoX0NsaWNrYWJsZUNvbXBvbmVudCkge1xyXG4gIGluaGVyaXRzKFBvc3RlckltYWdlLCBfQ2xpY2thYmxlQ29tcG9uZW50KTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXHJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGF0dGFjaCB0by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBQb3N0ZXJJbWFnZShwbGF5ZXIsIG9wdGlvbnMpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBvc3RlckltYWdlKTtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9DbGlja2FibGVDb21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcclxuXHJcbiAgICBfdGhpcy51cGRhdGUoKTtcclxuICAgIHBsYXllci5vbigncG9zdGVyY2hhbmdlJywgYmluZChfdGhpcywgX3RoaXMudXBkYXRlKSk7XHJcbiAgICByZXR1cm4gX3RoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhbiB1cCBhbmQgZGlzcG9zZSBvZiB0aGUgYFBvc3RlckltYWdlYC5cclxuICAgKi9cclxuXHJcblxyXG4gIFBvc3RlckltYWdlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcclxuICAgIHRoaXMucGxheWVyKCkub2ZmKCdwb3N0ZXJjaGFuZ2UnLCB0aGlzLnVwZGF0ZSk7XHJcbiAgICBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBgUG9zdGVySW1hZ2VgcyBET00gZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIFBvc3RlckltYWdlLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xyXG4gICAgdmFyIGVsID0gY3JlYXRlRWwoJ2RpdicsIHtcclxuICAgICAgY2xhc3NOYW1lOiAndmpzLXBvc3RlcicsXHJcblxyXG4gICAgICAvLyBEb24ndCB3YW50IHBvc3RlciB0byBiZSB0YWJiYWJsZS5cclxuICAgICAgdGFiSW5kZXg6IC0xXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBUbyBlbnN1cmUgdGhlIHBvc3RlciBpbWFnZSByZXNpemVzIHdoaWxlIG1haW50YWluaW5nIGl0cyBvcmlnaW5hbCBhc3BlY3RcclxuICAgIC8vIHJhdGlvLCB1c2UgYSBkaXYgd2l0aCBgYmFja2dyb3VuZC1zaXplYCB3aGVuIGF2YWlsYWJsZS4gRm9yIGJyb3dzZXJzIHRoYXRcclxuICAgIC8vIGRvIG5vdCBzdXBwb3J0IGBiYWNrZ3JvdW5kLXNpemVgIChlLmcuIElFOCksIGZhbGwgYmFjayBvbiB1c2luZyBhIHJlZ3VsYXJcclxuICAgIC8vIGltZyBlbGVtZW50LlxyXG4gICAgaWYgKCFCQUNLR1JPVU5EX1NJWkVfU1VQUE9SVEVEKSB7XHJcbiAgICAgIHRoaXMuZmFsbGJhY2tJbWdfID0gY3JlYXRlRWwoJ2ltZycpO1xyXG4gICAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmZhbGxiYWNrSW1nXyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuIHtAbGluayBFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBmb3Ige0BsaW5rIFBsYXllciNwb3N0ZXJjaGFuZ2V9IGV2ZW50cy5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIFBsYXllciNwb3N0ZXJjaGFuZ2VcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXIjcG9zdGVyY2hhbmdlYCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgUG9zdGVySW1hZ2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xyXG4gICAgdmFyIHVybCA9IHRoaXMucGxheWVyKCkucG9zdGVyKCk7XHJcblxyXG4gICAgdGhpcy5zZXRTcmModXJsKTtcclxuXHJcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHBvc3RlciBzb3VyY2Ugd2Ugc2hvdWxkIGRpc3BsYXk6bm9uZSBvbiB0aGlzIGNvbXBvbmVudFxyXG4gICAgLy8gc28gaXQncyBub3Qgc3RpbGwgY2xpY2thYmxlIG9yIHJpZ2h0LWNsaWNrYWJsZVxyXG4gICAgaWYgKHVybCkge1xyXG4gICAgICB0aGlzLnNob3coKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgc291cmNlIG9mIHRoZSBgUG9zdGVySW1hZ2VgIGRlcGVuZGluZyBvbiB0aGUgZGlzcGxheSBtZXRob2QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXHJcbiAgICogICAgICAgIFRoZSBVUkwgdG8gdGhlIHNvdXJjZSBmb3IgdGhlIGBQb3N0ZXJJbWFnZWAuXHJcbiAgICovXHJcblxyXG5cclxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUuc2V0U3JjID0gZnVuY3Rpb24gc2V0U3JjKHVybCkge1xyXG4gICAgaWYgKHRoaXMuZmFsbGJhY2tJbWdfKSB7XHJcbiAgICAgIHRoaXMuZmFsbGJhY2tJbWdfLnNyYyA9IHVybDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBiYWNrZ3JvdW5kSW1hZ2UgPSAnJztcclxuXHJcbiAgICAgIC8vIEFueSBmYWxzZXkgdmFsdWVzIHNob3VsZCBzdGF5IGFzIGFuIGVtcHR5IHN0cmluZywgb3RoZXJ3aXNlXHJcbiAgICAgIC8vIHRoaXMgd2lsbCB0aHJvdyBhbiBleHRyYSBlcnJvclxyXG4gICAgICBpZiAodXJsKSB7XHJcbiAgICAgICAgYmFja2dyb3VuZEltYWdlID0gJ3VybChcIicgKyB1cmwgKyAnXCIpJztcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5lbF8uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gYmFja2dyb3VuZEltYWdlO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuIHtAbGluayBFdmVudFRhcmdldH5FdmVudExpc3RlbmVyfSBmb3IgY2xpY2tzIG9uIHRoZSBgUG9zdGVySW1hZ2VgLiBTZWVcclxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50I2hhbmRsZUNsaWNrfSBmb3IgaW5zdGFuY2VzIHdoZXJlIHRoaXMgd2lsbCBiZSB0cmlnZ2VyZWQuXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyB0YXBcclxuICAgKiBAbGlzdGVucyBjbGlja1xyXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICsgICAgICAgIFRoZSBgY2xpY2tgLCBgdGFwYCBvciBga2V5ZG93bmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXHJcbiAgICovXHJcblxyXG5cclxuICBQb3N0ZXJJbWFnZS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xyXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBhIGNsaWNrIHRvIHRyaWdnZXIgcGxheWJhY2sgd2hlbiBjb250cm9scyBhcmUgZGlzYWJsZWRcclxuICAgIGlmICghdGhpcy5wbGF5ZXJfLmNvbnRyb2xzKCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnBsYXllcl8ucGF1c2VkKCkpIHtcclxuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJldHVybiBQb3N0ZXJJbWFnZTtcclxufShDbGlja2FibGVDb21wb25lbnQpO1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQb3N0ZXJJbWFnZScsIFBvc3RlckltYWdlKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSB0ZXh0LXRyYWNrLWRpc3BsYXkuanNcclxuICovXHJcbnZhciBkYXJrR3JheSA9ICcjMjIyJztcclxudmFyIGxpZ2h0R3JheSA9ICcjY2NjJztcclxudmFyIGZvbnRNYXAgPSB7XHJcbiAgbW9ub3NwYWNlOiAnbW9ub3NwYWNlJyxcclxuICBzYW5zU2VyaWY6ICdzYW5zLXNlcmlmJyxcclxuICBzZXJpZjogJ3NlcmlmJyxcclxuICBtb25vc3BhY2VTYW5zU2VyaWY6ICdcIkFuZGFsZSBNb25vXCIsIFwiTHVjaWRhIENvbnNvbGVcIiwgbW9ub3NwYWNlJyxcclxuICBtb25vc3BhY2VTZXJpZjogJ1wiQ291cmllciBOZXdcIiwgbW9ub3NwYWNlJyxcclxuICBwcm9wb3J0aW9uYWxTYW5zU2VyaWY6ICdzYW5zLXNlcmlmJyxcclxuICBwcm9wb3J0aW9uYWxTZXJpZjogJ3NlcmlmJyxcclxuICBjYXN1YWw6ICdcIkNvbWljIFNhbnMgTVNcIiwgSW1wYWN0LCBmYW50YXN5JyxcclxuICBzY3JpcHQ6ICdcIk1vbm90eXBlIENvcnNpdmFcIiwgY3Vyc2l2ZScsXHJcbiAgc21hbGxjYXBzOiAnXCJBbmRhbGUgTW9ub1wiLCBcIkx1Y2lkYSBDb25zb2xlXCIsIG1vbm9zcGFjZSwgc2Fucy1zZXJpZidcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3QgYW4gcmdiYSBjb2xvciBmcm9tIGEgZ2l2ZW4gaGV4IGNvbG9yIGNvZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2xvclxyXG4gKiAgICAgICAgSGV4IG51bWJlciBmb3IgY29sb3IsIGxpa2UgI2YwZS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IG9wYWNpdHlcclxuICogICAgICAgIFZhbHVlIGZvciBvcGFjaXR5LCAwLjAgLSAxLjAuXHJcbiAqXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICogICAgICAgICBUaGUgcmdiYSBjb2xvciB0aGF0IHdhcyBjcmVhdGVkLCBsaWtlICdyZ2JhKDI1NSwgMCwgMCwgMC4zKScuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25zdHJ1Y3RDb2xvcihjb2xvciwgb3BhY2l0eSkge1xyXG4gIHJldHVybiAncmdiYSgnICtcclxuICAvLyBjb2xvciBsb29rcyBsaWtlIFwiI2YwZVwiXHJcbiAgcGFyc2VJbnQoY29sb3JbMV0gKyBjb2xvclsxXSwgMTYpICsgJywnICsgcGFyc2VJbnQoY29sb3JbMl0gKyBjb2xvclsyXSwgMTYpICsgJywnICsgcGFyc2VJbnQoY29sb3JbM10gKyBjb2xvclszXSwgMTYpICsgJywnICsgb3BhY2l0eSArICcpJztcclxufVxyXG5cclxuLyoqXHJcbiAqIFRyeSB0byB1cGRhdGUgdGhlIHN0eWxlIG9mIGEgRE9NIGVsZW1lbnQuIFNvbWUgc3R5bGUgY2hhbmdlcyB3aWxsIHRocm93IGFuIGVycm9yLFxyXG4gKiBwYXJ0aWN1bGFybHkgaW4gSUU4LiBUaG9zZSBzaG91bGQgYmUgbm9vcHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcclxuICogICAgICAgIFRoZSBET00gZWxlbWVudCB0byBiZSBzdHlsZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVxyXG4gKiAgICAgICAgVGhlIENTUyBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBzdHlsZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBydWxlXHJcbiAqICAgICAgICBUaGUgc3R5bGUgcnVsZSB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSBwcm9wZXJ0eS5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHRyeVVwZGF0ZVN0eWxlKGVsLCBzdHlsZSwgcnVsZSkge1xyXG4gIHRyeSB7XHJcbiAgICBlbC5zdHlsZVtzdHlsZV0gPSBydWxlO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuXHJcbiAgICAvLyBTYXRpc2ZpZXMgbGludGVyLlxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgdGV4dCB0cmFjayBjdWVzLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcclxuICovXHJcblxyXG52YXIgVGV4dFRyYWNrRGlzcGxheSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XHJcbiAgaW5oZXJpdHMoVGV4dFRyYWNrRGlzcGxheSwgX0NvbXBvbmVudCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXHJcbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gYFRleHRUcmFja0Rpc3BsYXlgIGlzIHJlYWR5LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFRleHRUcmFja0Rpc3BsYXkocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dFRyYWNrRGlzcGxheSk7XHJcblxyXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zLCByZWFkeSkpO1xyXG5cclxuICAgIHBsYXllci5vbignbG9hZHN0YXJ0JywgYmluZChfdGhpcywgX3RoaXMudG9nZ2xlRGlzcGxheSkpO1xyXG4gICAgcGxheWVyLm9uKCd0ZXh0dHJhY2tjaGFuZ2UnLCBiaW5kKF90aGlzLCBfdGhpcy51cGRhdGVEaXNwbGF5KSk7XHJcbiAgICBwbGF5ZXIub24oJ2xvYWRzdGFydCcsIGJpbmQoX3RoaXMsIF90aGlzLnByZXNlbGVjdFRyYWNrKSk7XHJcblxyXG4gICAgLy8gVGhpcyB1c2VkIHRvIGJlIGNhbGxlZCBkdXJpbmcgcGxheWVyIGluaXQsIGJ1dCB3YXMgY2F1c2luZyBhbiBlcnJvclxyXG4gICAgLy8gaWYgYSB0cmFjayBzaG91bGQgc2hvdyBieSBkZWZhdWx0IGFuZCB0aGUgZGlzcGxheSBoYWRuJ3QgbG9hZGVkIHlldC5cclxuICAgIC8vIFNob3VsZCBwcm9iYWJseSBiZSBtb3ZlZCB0byBhbiBleHRlcm5hbCB0cmFjayBsb2FkZXIgd2hlbiB3ZSBzdXBwb3J0XHJcbiAgICAvLyB0cmFja3MgdGhhdCBkb24ndCBuZWVkIGEgZGlzcGxheS5cclxuICAgIHBsYXllci5yZWFkeShiaW5kKF90aGlzLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChwbGF5ZXIudGVjaF8gJiYgcGxheWVyLnRlY2hfLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xyXG4gICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcGxheWVyLm9uKCdmdWxsc2NyZWVuY2hhbmdlJywgYmluZCh0aGlzLCB0aGlzLnVwZGF0ZURpc3BsYXkpKTtcclxuXHJcbiAgICAgIHZhciB0cmFja3MgPSB0aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnMudHJhY2tzIHx8IFtdO1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0aGlzLnBsYXllcl8uYWRkUmVtb3RlVGV4dFRyYWNrKHRyYWNrc1tpXSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucHJlc2VsZWN0VHJhY2soKTtcclxuICAgIH0pKTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogUHJlc2VsZWN0IGEgdHJhY2sgZm9sbG93aW5nIHRoaXMgcHJlY2VkZW5jZTpcclxuICAqIC0gbWF0Y2hlcyB0aGUgcHJldmlvdXNseSBzZWxlY3RlZCB7QGxpbmsgVGV4dFRyYWNrfSdzIGxhbmd1YWdlIGFuZCBraW5kXHJcbiAgKiAtIG1hdGNoZXMgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQge0BsaW5rIFRleHRUcmFja30ncyBsYW5ndWFnZSBvbmx5XHJcbiAgKiAtIGlzIHRoZSBmaXJzdCBkZWZhdWx0IGNhcHRpb25zIHRyYWNrXHJcbiAgKiAtIGlzIHRoZSBmaXJzdCBkZWZhdWx0IGRlc2NyaXB0aW9ucyB0cmFja1xyXG4gICpcclxuICAqIEBsaXN0ZW5zIFBsYXllciNsb2Fkc3RhcnRcclxuICAqL1xyXG5cclxuXHJcbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUucHJlc2VsZWN0VHJhY2sgPSBmdW5jdGlvbiBwcmVzZWxlY3RUcmFjaygpIHtcclxuICAgIHZhciBtb2RlcyA9IHsgY2FwdGlvbnM6IDEsIHN1YnRpdGxlczogMSB9O1xyXG4gICAgdmFyIHRyYWNrTGlzdCA9IHRoaXMucGxheWVyXy50ZXh0VHJhY2tzKCk7XHJcbiAgICB2YXIgdXNlclByZWYgPSB0aGlzLnBsYXllcl8uY2FjaGVfLnNlbGVjdGVkTGFuZ3VhZ2U7XHJcbiAgICB2YXIgZmlyc3REZXNjID0gdm9pZCAwO1xyXG4gICAgdmFyIGZpcnN0Q2FwdGlvbnMgPSB2b2lkIDA7XHJcbiAgICB2YXIgcHJlZmVycmVkVHJhY2sgPSB2b2lkIDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja0xpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHRyYWNrID0gdHJhY2tMaXN0W2ldO1xyXG5cclxuICAgICAgaWYgKHVzZXJQcmVmICYmIHVzZXJQcmVmLmVuYWJsZWQgJiYgdXNlclByZWYubGFuZ3VhZ2UgPT09IHRyYWNrLmxhbmd1YWdlKSB7XHJcbiAgICAgICAgLy8gQWx3YXlzIGNob29zZSB0aGUgdHJhY2sgdGhhdCBtYXRjaGVzIGJvdGggbGFuZ3VhZ2UgYW5kIGtpbmRcclxuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gdXNlclByZWYua2luZCkge1xyXG4gICAgICAgICAgcHJlZmVycmVkVHJhY2sgPSB0cmFjaztcclxuICAgICAgICAgIC8vIG9yIGNob29zZSB0aGUgZmlyc3QgdHJhY2sgdGhhdCBtYXRjaGVzIGxhbmd1YWdlXHJcbiAgICAgICAgfSBlbHNlIGlmICghcHJlZmVycmVkVHJhY2spIHtcclxuICAgICAgICAgIHByZWZlcnJlZFRyYWNrID0gdHJhY2s7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjbGVhciBldmVyeXRoaW5nIGlmIG9mZlRleHRUcmFja01lbnVJdGVtIHdhcyBjbGlja2VkXHJcbiAgICAgIH0gZWxzZSBpZiAodXNlclByZWYgJiYgIXVzZXJQcmVmLmVuYWJsZWQpIHtcclxuICAgICAgICBwcmVmZXJyZWRUcmFjayA9IG51bGw7XHJcbiAgICAgICAgZmlyc3REZXNjID0gbnVsbDtcclxuICAgICAgICBmaXJzdENhcHRpb25zID0gbnVsbDtcclxuICAgICAgfSBlbHNlIGlmICh0cmFja1snZGVmYXVsdCddKSB7XHJcbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdkZXNjcmlwdGlvbnMnICYmICFmaXJzdERlc2MpIHtcclxuICAgICAgICAgIGZpcnN0RGVzYyA9IHRyYWNrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCBpbiBtb2RlcyAmJiAhZmlyc3RDYXB0aW9ucykge1xyXG4gICAgICAgICAgZmlyc3RDYXB0aW9ucyA9IHRyYWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBwcmVmZXJyZWRUcmFjayBtYXRjaGVzIHRoZSB1c2VyIHByZWZlcmVuY2UgYW5kIHRha2VzXHJcbiAgICAvLyBwcmVjZW5kZW5jZSBvdmVyIGFsbCB0aGUgb3RoZXIgdHJhY2tzLlxyXG4gICAgLy8gU28sIGRpc3BsYXkgdGhlIHByZWZlcnJlZFRyYWNrIGJlZm9yZSB0aGUgZmlyc3QgZGVmYXVsdCB0cmFja1xyXG4gICAgLy8gYW5kIHRoZSBzdWJ0aXRsZXMvY2FwdGlvbnMgdHJhY2sgYmVmb3JlIHRoZSBkZXNjcmlwdGlvbnMgdHJhY2tcclxuICAgIGlmIChwcmVmZXJyZWRUcmFjaykge1xyXG4gICAgICBwcmVmZXJyZWRUcmFjay5tb2RlID0gJ3Nob3dpbmcnO1xyXG4gICAgfSBlbHNlIGlmIChmaXJzdENhcHRpb25zKSB7XHJcbiAgICAgIGZpcnN0Q2FwdGlvbnMubW9kZSA9ICdzaG93aW5nJztcclxuICAgIH0gZWxzZSBpZiAoZmlyc3REZXNjKSB7XHJcbiAgICAgIGZpcnN0RGVzYy5tb2RlID0gJ3Nob3dpbmcnO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFR1cm4gZGlzcGxheSBvZiB7QGxpbmsgVGV4dFRyYWNrfSdzIGZyb20gdGhlIGN1cnJlbnQgc3RhdGUgaW50byB0aGUgb3RoZXIgc3RhdGUuXHJcbiAgICogVGhlcmUgYXJlIG9ubHkgdHdvIHN0YXRlczpcclxuICAgKiAtICdzaG93bidcclxuICAgKiAtICdoaWRkZW4nXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBQbGF5ZXIjbG9hZHN0YXJ0XHJcbiAgICovXHJcblxyXG5cclxuICBUZXh0VHJhY2tEaXNwbGF5LnByb3RvdHlwZS50b2dnbGVEaXNwbGF5ID0gZnVuY3Rpb24gdG9nZ2xlRGlzcGxheSgpIHtcclxuICAgIGlmICh0aGlzLnBsYXllcl8udGVjaF8gJiYgdGhpcy5wbGF5ZXJfLnRlY2hfLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xyXG4gICAgICB0aGlzLmhpZGUoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc2hvdygpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUge0BsaW5rIENvbXBvbmVudH0ncyBET00gZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcclxuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10ZXh0LXRyYWNrLWRpc3BsYXknXHJcbiAgICB9LCB7XHJcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJyxcclxuICAgICAgJ2FyaWEtYXRvbWljJzogJ3RydWUnXHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDbGVhciBhbGwgZGlzcGxheWVkIHtAbGluayBUZXh0VHJhY2t9cy5cclxuICAgKi9cclxuXHJcblxyXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLmNsZWFyRGlzcGxheSA9IGZ1bmN0aW9uIGNsZWFyRGlzcGxheSgpIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93XzEuV2ViVlRUID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHdpbmRvd18xLldlYlZUVC5wcm9jZXNzQ3Vlcyh3aW5kb3dfMSwgW10sIHRoaXMuZWxfKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGRpc3BsYXllZCBUZXh0VHJhY2sgd2hlbiBhIGVpdGhlciBhIHtAbGluayBQbGF5ZXIjdGV4dHRyYWNrY2hhbmdlfSBvclxyXG4gICAqIGEge0BsaW5rIFBsYXllciNmdWxsc2NyZWVuY2hhbmdlfSBpcyBmaXJlZC5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIFBsYXllciN0ZXh0dHJhY2tjaGFuZ2VcclxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGV4dFRyYWNrRGlzcGxheS5wcm90b3R5cGUudXBkYXRlRGlzcGxheSA9IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XHJcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja3MoKTtcclxuXHJcbiAgICB0aGlzLmNsZWFyRGlzcGxheSgpO1xyXG5cclxuICAgIC8vIFRyYWNrIGRpc3BsYXkgcHJpb3JpdGl6YXRpb24gbW9kZWw6IGlmIG11bHRpcGxlIHRyYWNrcyBhcmUgJ3Nob3dpbmcnLFxyXG4gICAgLy8gIGRpc3BsYXkgdGhlIGZpcnN0ICdzdWJ0aXRsZXMnIG9yICdjYXB0aW9ucycgdHJhY2sgd2hpY2ggaXMgJ3Nob3dpbmcnLFxyXG4gICAgLy8gIG90aGVyd2lzZSBkaXNwbGF5IHRoZSBmaXJzdCAnZGVzY3JpcHRpb25zJyB0cmFjayB3aGljaCBpcyAnc2hvd2luZydcclxuXHJcbiAgICB2YXIgZGVzY3JpcHRpb25zVHJhY2sgPSBudWxsO1xyXG4gICAgdmFyIGNhcHRpb25zU3VidGl0bGVzVHJhY2sgPSBudWxsO1xyXG4gICAgdmFyIGkgPSB0cmFja3MubGVuZ3RoO1xyXG5cclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xyXG5cclxuICAgICAgaWYgKHRyYWNrLm1vZGUgPT09ICdzaG93aW5nJykge1xyXG4gICAgICAgIGlmICh0cmFjay5raW5kID09PSAnZGVzY3JpcHRpb25zJykge1xyXG4gICAgICAgICAgZGVzY3JpcHRpb25zVHJhY2sgPSB0cmFjaztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2FwdGlvbnNTdWJ0aXRsZXNUcmFjayA9IHRyYWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChjYXB0aW9uc1N1YnRpdGxlc1RyYWNrKSB7XHJcbiAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnYXJpYS1saXZlJykgIT09ICdvZmYnKSB7XHJcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdvZmYnKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnVwZGF0ZUZvclRyYWNrKGNhcHRpb25zU3VidGl0bGVzVHJhY2spO1xyXG4gICAgfSBlbHNlIGlmIChkZXNjcmlwdGlvbnNUcmFjaykge1xyXG4gICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScpICE9PSAnYXNzZXJ0aXZlJykge1xyXG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnYXNzZXJ0aXZlJyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy51cGRhdGVGb3JUcmFjayhkZXNjcmlwdGlvbnNUcmFjayk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGFuIHtAbGluayBUZXh0dHJhY2t9IHRvIHRvIHRoZSB7QGxpbmsgVGVjaH1zIHtAbGluayBUZXh0VHJhY2tMaXN0fS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrfSB0cmFja1xyXG4gICAqICAgICAgICBUZXh0IHRyYWNrIG9iamVjdCB0byBiZSBhZGRlZCB0byB0aGUgbGlzdC5cclxuICAgKi9cclxuXHJcblxyXG4gIFRleHRUcmFja0Rpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUZvclRyYWNrID0gZnVuY3Rpb24gdXBkYXRlRm9yVHJhY2sodHJhY2spIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93XzEuV2ViVlRUICE9PSAnZnVuY3Rpb24nIHx8ICF0cmFjay5hY3RpdmVDdWVzKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgb3ZlcnJpZGVzID0gdGhpcy5wbGF5ZXJfLnRleHRUcmFja1NldHRpbmdzLmdldFZhbHVlcygpO1xyXG4gICAgdmFyIGN1ZXMgPSBbXTtcclxuXHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdHJhY2suYWN0aXZlQ3Vlcy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgY3Vlcy5wdXNoKHRyYWNrLmFjdGl2ZUN1ZXNbX2ldKTtcclxuICAgIH1cclxuXHJcbiAgICB3aW5kb3dfMS5XZWJWVFQucHJvY2Vzc0N1ZXMod2luZG93XzEsIGN1ZXMsIHRoaXMuZWxfKTtcclxuXHJcbiAgICB2YXIgaSA9IGN1ZXMubGVuZ3RoO1xyXG5cclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgdmFyIGN1ZSA9IGN1ZXNbaV07XHJcblxyXG4gICAgICBpZiAoIWN1ZSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgY3VlRGl2ID0gY3VlLmRpc3BsYXlTdGF0ZTtcclxuXHJcbiAgICAgIGlmIChvdmVycmlkZXMuY29sb3IpIHtcclxuICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS5jb2xvciA9IG92ZXJyaWRlcy5jb2xvcjtcclxuICAgICAgfVxyXG4gICAgICBpZiAob3ZlcnJpZGVzLnRleHRPcGFjaXR5KSB7XHJcbiAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LmZpcnN0Q2hpbGQsICdjb2xvcicsIGNvbnN0cnVjdENvbG9yKG92ZXJyaWRlcy5jb2xvciB8fCAnI2ZmZicsIG92ZXJyaWRlcy50ZXh0T3BhY2l0eSkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChvdmVycmlkZXMuYmFja2dyb3VuZENvbG9yKSB7XHJcbiAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3ZlcnJpZGVzLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgfVxyXG4gICAgICBpZiAob3ZlcnJpZGVzLmJhY2tncm91bmRPcGFjaXR5KSB7XHJcbiAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LmZpcnN0Q2hpbGQsICdiYWNrZ3JvdW5kQ29sb3InLCBjb25zdHJ1Y3RDb2xvcihvdmVycmlkZXMuYmFja2dyb3VuZENvbG9yIHx8ICcjMDAwJywgb3ZlcnJpZGVzLmJhY2tncm91bmRPcGFjaXR5KSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG92ZXJyaWRlcy53aW5kb3dDb2xvcikge1xyXG4gICAgICAgIGlmIChvdmVycmlkZXMud2luZG93T3BhY2l0eSkge1xyXG4gICAgICAgICAgdHJ5VXBkYXRlU3R5bGUoY3VlRGl2LCAnYmFja2dyb3VuZENvbG9yJywgY29uc3RydWN0Q29sb3Iob3ZlcnJpZGVzLndpbmRvd0NvbG9yLCBvdmVycmlkZXMud2luZG93T3BhY2l0eSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjdWVEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gb3ZlcnJpZGVzLndpbmRvd0NvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSkge1xyXG4gICAgICAgIGlmIChvdmVycmlkZXMuZWRnZVN0eWxlID09PSAnZHJvcHNoYWRvdycpIHtcclxuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMnB4IDJweCAzcHggJyArIGRhcmtHcmF5ICsgJywgMnB4IDJweCA0cHggJyArIGRhcmtHcmF5ICsgJywgMnB4IDJweCA1cHggJyArIGRhcmtHcmF5O1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ3JhaXNlZCcpIHtcclxuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMXB4IDFweCAnICsgZGFya0dyYXkgKyAnLCAycHggMnB4ICcgKyBkYXJrR3JheSArICcsIDNweCAzcHggJyArIGRhcmtHcmF5O1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ2RlcHJlc3NlZCcpIHtcclxuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLnRleHRTaGFkb3cgPSAnMXB4IDFweCAnICsgbGlnaHRHcmF5ICsgJywgMCAxcHggJyArIGxpZ2h0R3JheSArICcsIC0xcHggLTFweCAnICsgZGFya0dyYXkgKyAnLCAwIC0xcHggJyArIGRhcmtHcmF5O1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3ZlcnJpZGVzLmVkZ2VTdHlsZSA9PT0gJ3VuaWZvcm0nKSB7XHJcbiAgICAgICAgICBjdWVEaXYuZmlyc3RDaGlsZC5zdHlsZS50ZXh0U2hhZG93ID0gJzAgMCA0cHggJyArIGRhcmtHcmF5ICsgJywgMCAwIDRweCAnICsgZGFya0dyYXkgKyAnLCAwIDAgNHB4ICcgKyBkYXJrR3JheSArICcsIDAgMCA0cHggJyArIGRhcmtHcmF5O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAob3ZlcnJpZGVzLmZvbnRQZXJjZW50ICYmIG92ZXJyaWRlcy5mb250UGVyY2VudCAhPT0gMSkge1xyXG4gICAgICAgIHZhciBmb250U2l6ZSA9IHdpbmRvd18xLnBhcnNlRmxvYXQoY3VlRGl2LnN0eWxlLmZvbnRTaXplKTtcclxuXHJcbiAgICAgICAgY3VlRGl2LnN0eWxlLmZvbnRTaXplID0gZm9udFNpemUgKiBvdmVycmlkZXMuZm9udFBlcmNlbnQgKyAncHgnO1xyXG4gICAgICAgIGN1ZURpdi5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XHJcbiAgICAgICAgY3VlRGl2LnN0eWxlLnRvcCA9ICdhdXRvJztcclxuICAgICAgICBjdWVEaXYuc3R5bGUuYm90dG9tID0gJzJweCc7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG92ZXJyaWRlcy5mb250RmFtaWx5ICYmIG92ZXJyaWRlcy5mb250RmFtaWx5ICE9PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICBpZiAob3ZlcnJpZGVzLmZvbnRGYW1pbHkgPT09ICdzbWFsbC1jYXBzJykge1xyXG4gICAgICAgICAgY3VlRGl2LmZpcnN0Q2hpbGQuc3R5bGUuZm9udFZhcmlhbnQgPSAnc21hbGwtY2Fwcyc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGN1ZURpdi5maXJzdENoaWxkLnN0eWxlLmZvbnRGYW1pbHkgPSBmb250TWFwW292ZXJyaWRlcy5mb250RmFtaWx5XTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4gVGV4dFRyYWNrRGlzcGxheTtcclxufShDb21wb25lbnQpO1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUZXh0VHJhY2tEaXNwbGF5JywgVGV4dFRyYWNrRGlzcGxheSk7XHJcblxyXG4vKipcclxuICogQGZpbGUgbG9hZGluZy1zcGlubmVyLmpzXHJcbiAqL1xyXG4vKipcclxuICogQSBsb2FkaW5nIHNwaW5uZXIgZm9yIHVzZSBkdXJpbmcgd2FpdGluZy9sb2FkaW5nIGV2ZW50cy5cclxuICpcclxuICogQGV4dGVuZHMgQ29tcG9uZW50XHJcbiAqL1xyXG5cclxudmFyIExvYWRpbmdTcGlubmVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcclxuICBpbmhlcml0cyhMb2FkaW5nU3Bpbm5lciwgX0NvbXBvbmVudCk7XHJcblxyXG4gIGZ1bmN0aW9uIExvYWRpbmdTcGlubmVyKCkge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9hZGluZ1NwaW5uZXIpO1xyXG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgYExvYWRpbmdTcGlubmVyYHMgRE9NIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gICAqICAgICAgICAgVGhlIGRvbSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxyXG4gICAqL1xyXG4gIExvYWRpbmdTcGlubmVyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xyXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcclxuICAgICAgY2xhc3NOYW1lOiAndmpzLWxvYWRpbmctc3Bpbm5lcicsXHJcbiAgICAgIGRpcjogJ2x0cidcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBMb2FkaW5nU3Bpbm5lcjtcclxufShDb21wb25lbnQpO1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdMb2FkaW5nU3Bpbm5lcicsIExvYWRpbmdTcGlubmVyKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBidXR0b24uanNcclxuICovXHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgYnV0dG9ucy5cclxuICpcclxuICogQGV4dGVuZHMgQ2xpY2thYmxlQ29tcG9uZW50XHJcbiAqL1xyXG5cclxudmFyIEJ1dHRvbiA9IGZ1bmN0aW9uIChfQ2xpY2thYmxlQ29tcG9uZW50KSB7XHJcbiAgaW5oZXJpdHMoQnV0dG9uLCBfQ2xpY2thYmxlQ29tcG9uZW50KTtcclxuXHJcbiAgZnVuY3Rpb24gQnV0dG9uKCkge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQnV0dG9uKTtcclxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9DbGlja2FibGVDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIGBCdXR0b25gcyBET00gZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFnPVwiYnV0dG9uXCJdXHJcbiAgICogICAgICAgIFRoZSBlbGVtZW50J3Mgbm9kZSB0eXBlLiBUaGlzIGFyZ3VtZW50IGlzIElHTk9SRUQ6IG5vIG1hdHRlciB3aGF0XHJcbiAgICogICAgICAgIGlzIHBhc3NlZCwgaXQgd2lsbCBhbHdheXMgY3JlYXRlIGEgYGJ1dHRvbmAgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHM9e31dXHJcbiAgICogICAgICAgIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGUgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlcz17fV1cclxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RWxlbWVudH1cclxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxyXG4gICAqL1xyXG4gIEJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCh0YWcpIHtcclxuICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XHJcbiAgICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XHJcblxyXG4gICAgdGFnID0gJ2J1dHRvbic7XHJcblxyXG4gICAgcHJvcHMgPSBhc3NpZ24oe1xyXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cInZqcy1pY29uLXBsYWNlaG9sZGVyXCI+PC9zcGFuPicsXHJcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKClcclxuICAgIH0sIHByb3BzKTtcclxuXHJcbiAgICAvLyBBZGQgYXR0cmlidXRlcyBmb3IgYnV0dG9uIGVsZW1lbnRcclxuICAgIGF0dHJpYnV0ZXMgPSBhc3NpZ24oe1xyXG5cclxuICAgICAgLy8gTmVjZXNzYXJ5IHNpbmNlIHRoZSBkZWZhdWx0IGJ1dHRvbiB0eXBlIGlzIFwic3VibWl0XCJcclxuICAgICAgJ3R5cGUnOiAnYnV0dG9uJyxcclxuXHJcbiAgICAgIC8vIGxldCB0aGUgc2NyZWVuIHJlYWRlciB1c2VyIGtub3cgdGhhdCB0aGUgdGV4dCBvZiB0aGUgYnV0dG9uIG1heSBjaGFuZ2VcclxuICAgICAgJ2FyaWEtbGl2ZSc6ICdwb2xpdGUnXHJcbiAgICB9LCBhdHRyaWJ1dGVzKTtcclxuXHJcbiAgICB2YXIgZWwgPSBDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgdGFnLCBwcm9wcywgYXR0cmlidXRlcyk7XHJcblxyXG4gICAgdGhpcy5jcmVhdGVDb250cm9sVGV4dEVsKGVsKTtcclxuXHJcbiAgICByZXR1cm4gZWw7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgY2hpbGQgYENvbXBvbmVudGAgaW5zaWRlIG9mIHRoaXMgYEJ1dHRvbmAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ3xDb21wb25lbnR9IGNoaWxkXHJcbiAgICogICAgICAgIFRoZSBuYW1lIG9yIGluc3RhbmNlIG9mIGEgY2hpbGQgdG8gYWRkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxyXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIG9wdGlvbnMgdGhhdCB3aWxsIGdldCBwYXNzZWQgdG8gY2hpbGRyZW4gb2ZcclxuICAgKiAgICAgICAgdGhlIGNoaWxkLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Q29tcG9uZW50fVxyXG4gICAqICAgICAgICAgVGhlIGBDb21wb25lbnRgIHRoYXQgZ2V0cyBhZGRlZCBhcyBhIGNoaWxkLiBXaGVuIHVzaW5nIGEgc3RyaW5nIHRoZVxyXG4gICAqICAgICAgICAgYENvbXBvbmVudGAgd2lsbCBnZXQgY3JlYXRlZCBieSB0aGlzIHByb2Nlc3MuXHJcbiAgICpcclxuICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDVcclxuICAgKi9cclxuXHJcblxyXG4gIEJ1dHRvbi5wcm90b3R5cGUuYWRkQ2hpbGQgPSBmdW5jdGlvbiBhZGRDaGlsZChjaGlsZCkge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xyXG5cclxuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XHJcblxyXG4gICAgbG9nJDEud2FybignQWRkaW5nIGFuIGFjdGlvbmFibGUgKHVzZXIgY29udHJvbGxhYmxlKSBjaGlsZCB0byBhIEJ1dHRvbiAoJyArIGNsYXNzTmFtZSArICcpIGlzIG5vdCBzdXBwb3J0ZWQ7IHVzZSBhIENsaWNrYWJsZUNvbXBvbmVudCBpbnN0ZWFkLicpO1xyXG5cclxuICAgIC8vIEF2b2lkIHRoZSBlcnJvciBtZXNzYWdlIGdlbmVyYXRlZCBieSBDbGlja2FibGVDb21wb25lbnQncyBhZGRDaGlsZCBtZXRob2RcclxuICAgIHJldHVybiBDb21wb25lbnQucHJvdG90eXBlLmFkZENoaWxkLmNhbGwodGhpcywgY2hpbGQsIG9wdGlvbnMpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEVuYWJsZSB0aGUgYEJ1dHRvbmAgZWxlbWVudCBzbyB0aGF0IGl0IGNhbiBiZSBhY3RpdmF0ZWQgb3IgY2xpY2tlZC4gVXNlIHRoaXMgd2l0aFxyXG4gICAqIHtAbGluayBCdXR0b24jZGlzYWJsZX0uXHJcbiAgICovXHJcblxyXG5cclxuICBCdXR0b24ucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcclxuICAgIF9DbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmVuYWJsZS5jYWxsKHRoaXMpO1xyXG4gICAgdGhpcy5lbF8ucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEVuYWJsZSB0aGUgYEJ1dHRvbmAgZWxlbWVudCBzbyB0aGF0IGl0IGNhbm5vdCBiZSBhY3RpdmF0ZWQgb3IgY2xpY2tlZC4gVXNlIHRoaXMgd2l0aFxyXG4gICAqIHtAbGluayBCdXR0b24jZW5hYmxlfS5cclxuICAgKi9cclxuXHJcblxyXG4gIEJ1dHRvbi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUoKSB7XHJcbiAgICBfQ2xpY2thYmxlQ29tcG9uZW50LnByb3RvdHlwZS5kaXNhYmxlLmNhbGwodGhpcyk7XHJcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGEgYEJ1dHRvbmAgaGFzIGZvY3VzIGFuZCBga2V5ZG93bmAgaXMgdHJpZ2dlcmVkIHZpYSBhIGtleVxyXG4gICAqIHByZXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcclxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gZ2V0IGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cclxuICAgKi9cclxuXHJcblxyXG4gIEJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xyXG5cclxuICAgIC8vIElnbm9yZSBTcGFjZSAoMzIpIG9yIEVudGVyICgxMykga2V5IG9wZXJhdGlvbiwgd2hpY2ggaXMgaGFuZGxlZCBieSB0aGUgYnJvd3NlciBmb3IgYSBidXR0b24uXHJcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDMyIHx8IGV2ZW50LndoaWNoID09PSAxMykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFzcyBrZXlwcmVzcyBoYW5kbGluZyB1cCBmb3IgdW5zdXBwb3J0ZWQga2V5c1xyXG4gICAgX0NsaWNrYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MuY2FsbCh0aGlzLCBldmVudCk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIEJ1dHRvbjtcclxufShDbGlja2FibGVDb21wb25lbnQpO1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdCdXR0b24nLCBCdXR0b24pO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIGJpZy1wbGF5LWJ1dHRvbi5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBpbml0aWFsIHBsYXkgYnV0dG9uIHRoYXQgc2hvd3MgYmVmb3JlIHRoZSB2aWRlbyBoYXMgcGxheWVkLiBUaGUgaGlkaW5nIG9mIHRoZVxyXG4gKiBgQmlnUGxheUJ1dHRvbmAgZ2V0IGRvbmUgdmlhIENTUyBhbmQgYFBsYXllcmAgc3RhdGVzLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBCdXR0b25cclxuICovXHJcblxyXG52YXIgQmlnUGxheUJ1dHRvbiA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XHJcbiAgaW5oZXJpdHMoQmlnUGxheUJ1dHRvbiwgX0J1dHRvbik7XHJcblxyXG4gIGZ1bmN0aW9uIEJpZ1BsYXlCdXR0b24ocGxheWVyLCBvcHRpb25zKSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBCaWdQbGF5QnV0dG9uKTtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcclxuXHJcbiAgICBfdGhpcy5tb3VzZXVzZWRfID0gZmFsc2U7XHJcblxyXG4gICAgX3RoaXMub24oJ21vdXNlZG93bicsIF90aGlzLmhhbmRsZU1vdXNlRG93bik7XHJcbiAgICByZXR1cm4gX3RoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuIEFsd2F5cyByZXR1cm5zICd2anMtYmlnLXBsYXktYnV0dG9uJy5cclxuICAgKi9cclxuXHJcblxyXG4gIEJpZ1BsYXlCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xyXG4gICAgcmV0dXJuICd2anMtYmlnLXBsYXktYnV0dG9uJztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYSBgQmlnUGxheUJ1dHRvbmAgXCJjbGlja2VkXCIuIFNlZSB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fVxyXG4gICAqIGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXHJcbiAgICogICAgICAgIGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIHRhcFxyXG4gICAqIEBsaXN0ZW5zIGNsaWNrXHJcbiAgICovXHJcblxyXG5cclxuICBCaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XHJcbiAgICB2YXIgcGxheVByb21pc2UgPSB0aGlzLnBsYXllcl8ucGxheSgpO1xyXG5cclxuICAgIC8vIGV4aXQgZWFybHkgaWYgY2xpY2tlZCB2aWEgdGhlIG1vdXNlXHJcbiAgICBpZiAodGhpcy5tb3VzZXVzZWRfICYmIGV2ZW50LmNsaWVudFggJiYgZXZlbnQuY2xpZW50WSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNiID0gdGhpcy5wbGF5ZXJfLmdldENoaWxkKCdjb250cm9sQmFyJyk7XHJcbiAgICB2YXIgcGxheVRvZ2dsZSA9IGNiICYmIGNiLmdldENoaWxkKCdwbGF5VG9nZ2xlJyk7XHJcblxyXG4gICAgaWYgKCFwbGF5VG9nZ2xlKSB7XHJcbiAgICAgIHRoaXMucGxheWVyXy5mb2N1cygpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHBsYXlGb2N1cyA9IGZ1bmN0aW9uIHBsYXlGb2N1cygpIHtcclxuICAgICAgcmV0dXJuIHBsYXlUb2dnbGUuZm9jdXMoKTtcclxuICAgIH07XHJcblxyXG4gICAgaWYgKHBsYXlQcm9taXNlICYmIHBsYXlQcm9taXNlLnRoZW4pIHtcclxuICAgICAgdmFyIGlnbm9yZVJlamVjdGVkUGxheVByb21pc2UgPSBmdW5jdGlvbiBpZ25vcmVSZWplY3RlZFBsYXlQcm9taXNlKCkge307XHJcblxyXG4gICAgICBwbGF5UHJvbWlzZS50aGVuKHBsYXlGb2N1cywgaWdub3JlUmVqZWN0ZWRQbGF5UHJvbWlzZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnNldFRpbWVvdXQocGxheUZvY3VzLCAxKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBCaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XHJcbiAgICB0aGlzLm1vdXNldXNlZF8gPSBmYWxzZTtcclxuXHJcbiAgICBfQnV0dG9uLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcy5jYWxsKHRoaXMsIGV2ZW50KTtcclxuICB9O1xyXG5cclxuICBCaWdQbGF5QnV0dG9uLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oZXZlbnQpIHtcclxuICAgIHRoaXMubW91c2V1c2VkXyA9IHRydWU7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIEJpZ1BsYXlCdXR0b247XHJcbn0oQnV0dG9uKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgdGV4dCB0aGF0IHNob3VsZCBkaXNwbGF5IG92ZXIgdGhlIGBCaWdQbGF5QnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIHRvIGZvciBsb2NhbGl6YXRpb24uXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5cclxuXHJcbkJpZ1BsYXlCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdQbGF5IFZpZGVvJztcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQmlnUGxheUJ1dHRvbicsIEJpZ1BsYXlCdXR0b24pO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIGNsb3NlLWJ1dHRvbi5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBgQ2xvc2VCdXR0b25gIGlzIGEgYHtAbGluayBCdXR0b259YCB0aGF0IGZpcmVzIGEgYGNsb3NlYCBldmVudCB3aGVuXHJcbiAqIGl0IGdldHMgY2xpY2tlZC5cclxuICpcclxuICogQGV4dGVuZHMgQnV0dG9uXHJcbiAqL1xyXG5cclxudmFyIENsb3NlQnV0dG9uID0gZnVuY3Rpb24gKF9CdXR0b24pIHtcclxuICBpbmhlcml0cyhDbG9zZUJ1dHRvbiwgX0J1dHRvbik7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHRoaXMgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBDbG9zZUJ1dHRvbihwbGF5ZXIsIG9wdGlvbnMpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENsb3NlQnV0dG9uKTtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9CdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcclxuXHJcbiAgICBfdGhpcy5jb250cm9sVGV4dChvcHRpb25zICYmIG9wdGlvbnMuY29udHJvbFRleHQgfHwgX3RoaXMubG9jYWxpemUoJ0Nsb3NlJykpO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ2xvc2VCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xyXG4gICAgcmV0dXJuICd2anMtY2xvc2UtYnV0dG9uICcgKyBfQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGEgYENsb3NlQnV0dG9uYCBnZXRzIGNsaWNrZWQuIFNlZVxyXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlQ2xpY2t9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHdoZW4gdGhpcyB3aWxsIGJlXHJcbiAgICogdHJpZ2dlcmVkXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXHJcbiAgICogICAgICAgIGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIHRhcFxyXG4gICAqIEBsaXN0ZW5zIGNsaWNrXHJcbiAgICogQGZpcmVzIENsb3NlQnV0dG9uI2Nsb3NlXHJcbiAgICovXHJcblxyXG5cclxuICBDbG9zZUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIGEgYENsb3NlQnV0dG9uYCBpcyBjbGlja2VkLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudCBDbG9zZUJ1dHRvbiNjbG9zZVxyXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICpcclxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdXHJcbiAgICAgKiAgICAgICAgICAgc2V0IHRvIGZhbHNlIHNvIHRoYXQgdGhlIGNsb3NlIGV2ZW50IGRvZXMgbm90XHJcbiAgICAgKiAgICAgICAgICAgYnViYmxlIHVwIHRvIHBhcmVudHMgaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgdGhpcy50cmlnZ2VyKHsgdHlwZTogJ2Nsb3NlJywgYnViYmxlczogZmFsc2UgfSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIENsb3NlQnV0dG9uO1xyXG59KEJ1dHRvbik7XHJcblxyXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0Nsb3NlQnV0dG9uJywgQ2xvc2VCdXR0b24pO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIHBsYXktdG9nZ2xlLmpzXHJcbiAqL1xyXG4vKipcclxuICogQnV0dG9uIHRvIHRvZ2dsZSBiZXR3ZWVuIHBsYXkgYW5kIHBhdXNlLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBCdXR0b25cclxuICovXHJcblxyXG52YXIgUGxheVRvZ2dsZSA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XHJcbiAgaW5oZXJpdHMoUGxheVRvZ2dsZSwgX0J1dHRvbik7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gUGxheVRvZ2dsZShwbGF5ZXIsIG9wdGlvbnMpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXlUb2dnbGUpO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xyXG5cclxuICAgIF90aGlzLm9uKHBsYXllciwgJ3BsYXknLCBfdGhpcy5oYW5kbGVQbGF5KTtcclxuICAgIF90aGlzLm9uKHBsYXllciwgJ3BhdXNlJywgX3RoaXMuaGFuZGxlUGF1c2UpO1xyXG4gICAgX3RoaXMub24ocGxheWVyLCAnZW5kZWQnLCBfdGhpcy5oYW5kbGVFbmRlZCk7XHJcbiAgICByZXR1cm4gX3RoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5VG9nZ2xlLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcclxuICAgIHJldHVybiAndmpzLXBsYXktY29udHJvbCAnICsgX0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgUGxheVRvZ2dsZWAgaXMgXCJjbGlja2VkXCIuIFNlZVxyXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXHJcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcclxuICAgKiAgICAgICAgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgdGFwXHJcbiAgICogQGxpc3RlbnMgY2xpY2tcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXlUb2dnbGUucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcclxuICAgIGlmICh0aGlzLnBsYXllcl8ucGF1c2VkKCkpIHtcclxuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCB0aGUgdmpzLXBsYXlpbmcgY2xhc3MgdG8gdGhlIGVsZW1lbnQgc28gaXQgY2FuIGNoYW5nZSBhcHBlYXJhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxyXG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBQbGF5ZXIjcGxheVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlUGxheSA9IGZ1bmN0aW9uIGhhbmRsZVBsYXkoZXZlbnQpIHtcclxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xyXG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBhdXNlZCcpO1xyXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBsYXlpbmcnKTtcclxuICAgIC8vIGNoYW5nZSB0aGUgYnV0dG9uIHRleHQgdG8gXCJQYXVzZVwiXHJcbiAgICB0aGlzLmNvbnRyb2xUZXh0KCdQYXVzZScpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCB0aGUgdmpzLXBhdXNlZCBjbGFzcyB0byB0aGUgZWxlbWVudCBzbyBpdCBjYW4gY2hhbmdlIGFwcGVhcmFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXHJcbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIFBsYXllciNwYXVzZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlUGF1c2UgPSBmdW5jdGlvbiBoYW5kbGVQYXVzZShldmVudCkge1xyXG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBsYXlpbmcnKTtcclxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcclxuICAgIC8vIGNoYW5nZSB0aGUgYnV0dG9uIHRleHQgdG8gXCJQbGF5XCJcclxuICAgIHRoaXMuY29udHJvbFRleHQoJ1BsYXknKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBZGQgdGhlIHZqcy1lbmRlZCBjbGFzcyB0byB0aGUgZWxlbWVudCBzbyBpdCBjYW4gY2hhbmdlIGFwcGVhcmFuY2VcclxuICAgKlxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheVRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlRW5kZWQgPSBmdW5jdGlvbiBoYW5kbGVFbmRlZChldmVudCkge1xyXG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBsYXlpbmcnKTtcclxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xyXG4gICAgLy8gY2hhbmdlIHRoZSBidXR0b24gdGV4dCB0byBcIlJlcGxheVwiXHJcbiAgICB0aGlzLmNvbnRyb2xUZXh0KCdSZXBsYXknKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gUGxheVRvZ2dsZTtcclxufShCdXR0b24pO1xyXG5cclxuLyoqXHJcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFBsYXlUb2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXHJcblxyXG5cclxuUGxheVRvZ2dsZS5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ1BsYXknO1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5VG9nZ2xlJywgUGxheVRvZ2dsZSk7XHJcblxyXG4vKipcclxuICogQGZpbGUgZm9ybWF0LXRpbWUuanNcclxuICogQG1vZHVsZSBGb3JtYXQtdGltZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBGb3JtYXQgc2Vjb25kcyBhcyBhIHRpbWUgc3RyaW5nLCBIOk1NOlNTIG9yIE06U1MuIFN1cHBseWluZyBhIGd1aWRlIChpbiBzZWNvbmRzKVxyXG4gKiB3aWxsIGZvcmNlIGEgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3MgdG8gY292ZXIgdGhlIGxlbmd0aCBvZiB0aGUgZ3VpZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWNvbmRzXHJcbiAqICAgICAgICBOdW1iZXIgb2Ygc2Vjb25kcyB0byBiZSB0dXJuZWQgaW50byBhIHN0cmluZ1xyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZ3VpZGVcclxuICogICAgICAgIE51bWJlciAoaW4gc2Vjb25kcykgdG8gbW9kZWwgdGhlIHN0cmluZyBhZnRlclxyXG4gKlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqICAgICAgICAgVGltZSBmb3JtYXR0ZWQgYXMgSDpNTTpTUyBvciBNOlNTXHJcbiAqL1xyXG5mdW5jdGlvbiBmb3JtYXRUaW1lKHNlY29uZHMpIHtcclxuICB2YXIgZ3VpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHNlY29uZHM7XHJcblxyXG4gIHNlY29uZHMgPSBzZWNvbmRzIDwgMCA/IDAgOiBzZWNvbmRzO1xyXG4gIHZhciBzID0gTWF0aC5mbG9vcihzZWNvbmRzICUgNjApO1xyXG4gIHZhciBtID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gNjAgJSA2MCk7XHJcbiAgdmFyIGggPSBNYXRoLmZsb29yKHNlY29uZHMgLyAzNjAwKTtcclxuICB2YXIgZ20gPSBNYXRoLmZsb29yKGd1aWRlIC8gNjAgJSA2MCk7XHJcbiAgdmFyIGdoID0gTWF0aC5mbG9vcihndWlkZSAvIDM2MDApO1xyXG5cclxuICAvLyBoYW5kbGUgaW52YWxpZCB0aW1lc1xyXG4gIGlmIChpc05hTihzZWNvbmRzKSB8fCBzZWNvbmRzID09PSBJbmZpbml0eSkge1xyXG4gICAgLy8gJy0nIGlzIGZhbHNlIGZvciBhbGwgcmVsYXRpb25hbCBvcGVyYXRvcnMgKGUuZy4gPCwgPj0pIHNvIHRoaXMgc2V0dGluZ1xyXG4gICAgLy8gd2lsbCBhZGQgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGZpZWxkcyBzcGVjaWZpZWQgYnkgdGhlIGd1aWRlXHJcbiAgICBoID0gbSA9IHMgPSAnLSc7XHJcbiAgfVxyXG5cclxuICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHNob3cgaG91cnNcclxuICBoID0gaCA+IDAgfHwgZ2ggPiAwID8gaCArICc6JyA6ICcnO1xyXG5cclxuICAvLyBJZiBob3VycyBhcmUgc2hvd2luZywgd2UgbWF5IG5lZWQgdG8gYWRkIGEgbGVhZGluZyB6ZXJvLlxyXG4gIC8vIEFsd2F5cyBzaG93IGF0IGxlYXN0IG9uZSBkaWdpdCBvZiBtaW51dGVzLlxyXG4gIG0gPSAoKGggfHwgZ20gPj0gMTApICYmIG0gPCAxMCA/ICcwJyArIG0gOiBtKSArICc6JztcclxuXHJcbiAgLy8gQ2hlY2sgaWYgbGVhZGluZyB6ZXJvIGlzIG5lZWQgZm9yIHNlY29uZHNcclxuICBzID0gcyA8IDEwID8gJzAnICsgcyA6IHM7XHJcblxyXG4gIHJldHVybiBoICsgbSArIHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBjdXJyZW50LXRpbWUtZGlzcGxheS5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIERpc3BsYXlzIHRoZSBjdXJyZW50IHRpbWVcclxuICpcclxuICogQGV4dGVuZHMgQ29tcG9uZW50XHJcbiAqL1xyXG5cclxudmFyIEN1cnJlbnRUaW1lRGlzcGxheSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XHJcbiAgaW5oZXJpdHMoQ3VycmVudFRpbWVEaXNwbGF5LCBfQ29tcG9uZW50KTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBDdXJyZW50VGltZURpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDdXJyZW50VGltZURpc3BsYXkpO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xyXG5cclxuICAgIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy51cGRhdGVDb250ZW50KSwgMjUpO1xyXG4gICAgX3RoaXMub24ocGxheWVyLCAndGltZXVwZGF0ZScsIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQpO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIEN1cnJlbnRUaW1lRGlzcGxheS5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcclxuICAgIHZhciBlbCA9IF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcclxuICAgICAgY2xhc3NOYW1lOiAndmpzLWN1cnJlbnQtdGltZSB2anMtdGltZS1jb250cm9sIHZqcy1jb250cm9sJ1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5jb250ZW50RWxfID0gY3JlYXRlRWwoJ2RpdicsIHtcclxuICAgICAgY2xhc3NOYW1lOiAndmpzLWN1cnJlbnQtdGltZS1kaXNwbGF5J1xyXG4gICAgfSwge1xyXG4gICAgICAvLyB0ZWxsIHNjcmVlbiByZWFkZXJzIG5vdCB0byBhdXRvbWF0aWNhbGx5IHJlYWQgdGhlIHRpbWUgYXMgaXQgY2hhbmdlc1xyXG4gICAgICAnYXJpYS1saXZlJzogJ29mZidcclxuICAgIH0sIGNyZWF0ZUVsKCdzcGFuJywge1xyXG4gICAgICBjbGFzc05hbWU6ICd2anMtY29udHJvbC10ZXh0JyxcclxuICAgICAgdGV4dENvbnRlbnQ6IHRoaXMubG9jYWxpemUoJ0N1cnJlbnQgVGltZScpXHJcbiAgICB9KSk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVUZXh0Tm9kZV8oKTtcclxuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsXyk7XHJcbiAgICByZXR1cm4gZWw7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGUgXCJjdXJyZW50IHRpbWVcIiB0ZXh0IG5vZGUgd2l0aCBuZXcgY29udGVudCB1c2luZyB0aGVcclxuICAgKiBjb250ZW50cyBvZiB0aGUgYGZvcm1hdHRlZFRpbWVfYCBwcm9wZXJ0eS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBDdXJyZW50VGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZVRleHROb2RlXyA9IGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlXygpIHtcclxuICAgIGlmICh0aGlzLnRleHROb2RlXykge1xyXG4gICAgICB0aGlzLmNvbnRlbnRFbF8ucmVtb3ZlQ2hpbGQodGhpcy50ZXh0Tm9kZV8pO1xyXG4gICAgfVxyXG4gICAgdGhpcy50ZXh0Tm9kZV8gPSBkb2N1bWVudF8xLmNyZWF0ZVRleHROb2RlKCcgJyArICh0aGlzLmZvcm1hdHRlZFRpbWVfIHx8ICcwOjAwJykpO1xyXG4gICAgdGhpcy5jb250ZW50RWxfLmFwcGVuZENoaWxkKHRoaXMudGV4dE5vZGVfKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgY3VycmVudCB0aW1lIGRpc3BsYXlcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cclxuICAgKiAgICAgICAgVGhlIGB0aW1ldXBkYXRlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIFBsYXllciN0aW1ldXBkYXRlXHJcbiAgICovXHJcblxyXG5cclxuICBDdXJyZW50VGltZURpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiB1cGRhdGVDb250ZW50KGV2ZW50KSB7XHJcbiAgICAvLyBBbGxvd3MgZm9yIHNtb290aCBzY3J1YmJpbmcsIHdoZW4gcGxheWVyIGNhbid0IGtlZXAgdXAuXHJcbiAgICB2YXIgdGltZSA9IHRoaXMucGxheWVyXy5zY3J1YmJpbmcoKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XHJcbiAgICB2YXIgZm9ybWF0dGVkVGltZSA9IGZvcm1hdFRpbWUodGltZSwgdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpO1xyXG5cclxuICAgIGlmIChmb3JtYXR0ZWRUaW1lICE9PSB0aGlzLmZvcm1hdHRlZFRpbWVfKSB7XHJcbiAgICAgIHRoaXMuZm9ybWF0dGVkVGltZV8gPSBmb3JtYXR0ZWRUaW1lO1xyXG4gICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZVRleHROb2RlXyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIEN1cnJlbnRUaW1lRGlzcGxheTtcclxufShDb21wb25lbnQpO1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDdXJyZW50VGltZURpc3BsYXknLCBDdXJyZW50VGltZURpc3BsYXkpO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIGR1cmF0aW9uLWRpc3BsYXkuanNcclxuICovXHJcbi8qKlxyXG4gKiBEaXNwbGF5cyB0aGUgZHVyYXRpb25cclxuICpcclxuICogQGV4dGVuZHMgQ29tcG9uZW50XHJcbiAqL1xyXG5cclxudmFyIER1cmF0aW9uRGlzcGxheSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XHJcbiAgaW5oZXJpdHMoRHVyYXRpb25EaXNwbGF5LCBfQ29tcG9uZW50KTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBEdXJhdGlvbkRpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBEdXJhdGlvbkRpc3BsYXkpO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xyXG5cclxuICAgIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy51cGRhdGVDb250ZW50KSwgMjUpO1xyXG5cclxuICAgIF90aGlzLm9uKHBsYXllciwgWydkdXJhdGlvbmNoYW5nZScsXHJcblxyXG4gICAgLy8gQWxzbyBsaXN0ZW4gZm9yIHRpbWV1cGRhdGUgYW5kIGxvYWRlZG1ldGFkYXRhIGJlY2F1c2UgcmVtb3ZpbmcgdGhvc2VcclxuICAgIC8vIGxpc3RlbmVycyBjb3VsZCBoYXZlIGJyb2tlbiBkZXBlbmRlbnQgYXBwbGljYXRpb25zL2xpYnJhcmllcy4gVGhlc2VcclxuICAgIC8vIGNhbiBsaWtlbHkgYmUgcmVtb3ZlZCBmb3IgNy4wLlxyXG4gICAgJ2xvYWRlZG1ldGFkYXRhJywgJ3RpbWV1cGRhdGUnXSwgX3RoaXMudGhyb3R0bGVkVXBkYXRlQ29udGVudCk7XHJcbiAgICByZXR1cm4gX3RoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgRHVyYXRpb25EaXNwbGF5LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xyXG4gICAgdmFyIGVsID0gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xyXG4gICAgICBjbGFzc05hbWU6ICd2anMtZHVyYXRpb24gdmpzLXRpbWUtY29udHJvbCB2anMtY29udHJvbCdcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuY29udGVudEVsXyA9IGNyZWF0ZUVsKCdkaXYnLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1kdXJhdGlvbi1kaXNwbGF5J1xyXG4gICAgfSwge1xyXG4gICAgICAvLyB0ZWxsIHNjcmVlbiByZWFkZXJzIG5vdCB0byBhdXRvbWF0aWNhbGx5IHJlYWQgdGhlIHRpbWUgYXMgaXQgY2hhbmdlc1xyXG4gICAgICAnYXJpYS1saXZlJzogJ29mZidcclxuICAgIH0sIGNyZWF0ZUVsKCdzcGFuJywge1xyXG4gICAgICBjbGFzc05hbWU6ICd2anMtY29udHJvbC10ZXh0JyxcclxuICAgICAgdGV4dENvbnRlbnQ6IHRoaXMubG9jYWxpemUoJ0R1cmF0aW9uIFRpbWUnKVxyXG4gICAgfSkpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlVGV4dE5vZGVfKCk7XHJcbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xyXG4gICAgcmV0dXJuIGVsO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIFwiY3VycmVudCB0aW1lXCIgdGV4dCBub2RlIHdpdGggbmV3IGNvbnRlbnQgdXNpbmcgdGhlXHJcbiAgICogY29udGVudHMgb2YgdGhlIGBmb3JtYXR0ZWRUaW1lX2AgcHJvcGVydHkuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgRHVyYXRpb25EaXNwbGF5LnByb3RvdHlwZS51cGRhdGVUZXh0Tm9kZV8gPSBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZV8oKSB7XHJcbiAgICBpZiAodGhpcy50ZXh0Tm9kZV8pIHtcclxuICAgICAgdGhpcy5jb250ZW50RWxfLnJlbW92ZUNoaWxkKHRoaXMudGV4dE5vZGVfKTtcclxuICAgIH1cclxuICAgIHRoaXMudGV4dE5vZGVfID0gZG9jdW1lbnRfMS5jcmVhdGVUZXh0Tm9kZSgnICcgKyAodGhpcy5mb3JtYXR0ZWRUaW1lXyB8fCAnMDowMCcpKTtcclxuICAgIHRoaXMuY29udGVudEVsXy5hcHBlbmRDaGlsZCh0aGlzLnRleHROb2RlXyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGR1cmF0aW9uIHRpbWUgZGlzcGxheS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cclxuICAgKiAgICAgICAgVGhlIGBkdXJhdGlvbmNoYW5nZWAsIGB0aW1ldXBkYXRlYCwgb3IgYGxvYWRlZG1ldGFkYXRhYCBldmVudCB0aGF0IGNhdXNlZFxyXG4gICAqICAgICAgICB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIFBsYXllciNkdXJhdGlvbmNoYW5nZVxyXG4gICAqIEBsaXN0ZW5zIFBsYXllciN0aW1ldXBkYXRlXHJcbiAgICogQGxpc3RlbnMgUGxheWVyI2xvYWRlZG1ldGFkYXRhXHJcbiAgICovXHJcblxyXG5cclxuICBEdXJhdGlvbkRpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUNvbnRlbnQgPSBmdW5jdGlvbiB1cGRhdGVDb250ZW50KGV2ZW50KSB7XHJcbiAgICB2YXIgZHVyYXRpb24gPSB0aGlzLnBsYXllcl8uZHVyYXRpb24oKTtcclxuXHJcbiAgICBpZiAoZHVyYXRpb24gJiYgdGhpcy5kdXJhdGlvbl8gIT09IGR1cmF0aW9uKSB7XHJcbiAgICAgIHRoaXMuZHVyYXRpb25fID0gZHVyYXRpb247XHJcbiAgICAgIHRoaXMuZm9ybWF0dGVkVGltZV8gPSBmb3JtYXRUaW1lKGR1cmF0aW9uKTtcclxuICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVUZXh0Tm9kZV8pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJldHVybiBEdXJhdGlvbkRpc3BsYXk7XHJcbn0oQ29tcG9uZW50KTtcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnRHVyYXRpb25EaXNwbGF5JywgRHVyYXRpb25EaXNwbGF5KTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSB0aW1lLWRpdmlkZXIuanNcclxuICovXHJcbi8qKlxyXG4gKiBUaGUgc2VwYXJhdG9yIGJldHdlZW4gdGhlIGN1cnJlbnQgdGltZSBhbmQgZHVyYXRpb24uXHJcbiAqIENhbiBiZSBoaWRkZW4gaWYgaXQncyBub3QgbmVlZGVkIGluIHRoZSBkZXNpZ24uXHJcbiAqXHJcbiAqIEBleHRlbmRzIENvbXBvbmVudFxyXG4gKi9cclxuXHJcbnZhciBUaW1lRGl2aWRlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XHJcbiAgaW5oZXJpdHMoVGltZURpdmlkZXIsIF9Db21wb25lbnQpO1xyXG5cclxuICBmdW5jdGlvbiBUaW1lRGl2aWRlcigpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVEaXZpZGVyKTtcclxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIGNvbXBvbmVudCdzIERPTSBlbGVtZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cclxuICAgKi9cclxuICBUaW1lRGl2aWRlci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcclxuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy10aW1lLWNvbnRyb2wgdmpzLXRpbWUtZGl2aWRlcicsXHJcbiAgICAgIGlubmVySFRNTDogJzxkaXY+PHNwYW4+Lzwvc3Bhbj48L2Rpdj4nXHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gVGltZURpdmlkZXI7XHJcbn0oQ29tcG9uZW50KTtcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGltZURpdmlkZXInLCBUaW1lRGl2aWRlcik7XHJcblxyXG4vKipcclxuICogQGZpbGUgcmVtYWluaW5nLXRpbWUtZGlzcGxheS5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIERpc3BsYXlzIHRoZSB0aW1lIGxlZnQgaW4gdGhlIHZpZGVvXHJcbiAqXHJcbiAqIEBleHRlbmRzIENvbXBvbmVudFxyXG4gKi9cclxuXHJcbnZhciBSZW1haW5pbmdUaW1lRGlzcGxheSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XHJcbiAgaW5oZXJpdHMoUmVtYWluaW5nVGltZURpc3BsYXksIF9Db21wb25lbnQpO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXHJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFJlbWFpbmluZ1RpbWVEaXNwbGF5KHBsYXllciwgb3B0aW9ucykge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVtYWluaW5nVGltZURpc3BsYXkpO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xyXG5cclxuICAgIF90aGlzLnRocm90dGxlZFVwZGF0ZUNvbnRlbnQgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy51cGRhdGVDb250ZW50KSwgMjUpO1xyXG4gICAgX3RoaXMub24ocGxheWVyLCBbJ3RpbWV1cGRhdGUnLCAnZHVyYXRpb25jaGFuZ2UnXSwgX3RoaXMudGhyb3R0bGVkVXBkYXRlQ29udGVudCk7XHJcbiAgICByZXR1cm4gX3RoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgUmVtYWluaW5nVGltZURpc3BsYXkucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XHJcbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1yZW1haW5pbmctdGltZSB2anMtdGltZS1jb250cm9sIHZqcy1jb250cm9sJ1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5jb250ZW50RWxfID0gY3JlYXRlRWwoJ2RpdicsIHtcclxuICAgICAgY2xhc3NOYW1lOiAndmpzLXJlbWFpbmluZy10aW1lLWRpc3BsYXknXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIHRlbGwgc2NyZWVuIHJlYWRlcnMgbm90IHRvIGF1dG9tYXRpY2FsbHkgcmVhZCB0aGUgdGltZSBhcyBpdCBjaGFuZ2VzXHJcbiAgICAgICdhcmlhLWxpdmUnOiAnb2ZmJ1xyXG4gICAgfSwgY3JlYXRlRWwoJ3NwYW4nLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1jb250cm9sLXRleHQnLFxyXG4gICAgICB0ZXh0Q29udGVudDogdGhpcy5sb2NhbGl6ZSgnUmVtYWluaW5nIFRpbWUnKVxyXG4gICAgfSkpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlVGV4dE5vZGVfKCk7XHJcbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xyXG4gICAgcmV0dXJuIGVsO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIFwicmVtYWluaW5nIHRpbWVcIiB0ZXh0IG5vZGUgd2l0aCBuZXcgY29udGVudCB1c2luZyB0aGVcclxuICAgKiBjb250ZW50cyBvZiB0aGUgYGZvcm1hdHRlZFRpbWVfYCBwcm9wZXJ0eS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBSZW1haW5pbmdUaW1lRGlzcGxheS5wcm90b3R5cGUudXBkYXRlVGV4dE5vZGVfID0gZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGVfKCkge1xyXG4gICAgaWYgKHRoaXMudGV4dE5vZGVfKSB7XHJcbiAgICAgIHRoaXMuY29udGVudEVsXy5yZW1vdmVDaGlsZCh0aGlzLnRleHROb2RlXyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnRleHROb2RlXyA9IGRvY3VtZW50XzEuY3JlYXRlVGV4dE5vZGUoJyAtJyArICh0aGlzLmZvcm1hdHRlZFRpbWVfIHx8ICcwOjAwJykpO1xyXG4gICAgdGhpcy5jb250ZW50RWxfLmFwcGVuZENoaWxkKHRoaXMudGV4dE5vZGVfKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgcmVtYWluaW5nIHRpbWUgZGlzcGxheS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cclxuICAgKiAgICAgICAgVGhlIGB0aW1ldXBkYXRlYCBvciBgZHVyYXRpb25jaGFuZ2VgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgUGxheWVyI3RpbWV1cGRhdGVcclxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcclxuICAgKi9cclxuXHJcblxyXG4gIFJlbWFpbmluZ1RpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gdXBkYXRlQ29udGVudChldmVudCkge1xyXG4gICAgaWYgKHRoaXMucGxheWVyXy5kdXJhdGlvbigpKSB7XHJcbiAgICAgIHZhciBmb3JtYXR0ZWRUaW1lID0gZm9ybWF0VGltZSh0aGlzLnBsYXllcl8ucmVtYWluaW5nVGltZSgpKTtcclxuXHJcbiAgICAgIGlmIChmb3JtYXR0ZWRUaW1lICE9PSB0aGlzLmZvcm1hdHRlZFRpbWVfKSB7XHJcbiAgICAgICAgdGhpcy5mb3JtYXR0ZWRUaW1lXyA9IGZvcm1hdHRlZFRpbWU7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVUZXh0Tm9kZV8pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFJlbWFpbmluZ1RpbWVEaXNwbGF5O1xyXG59KENvbXBvbmVudCk7XHJcblxyXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1JlbWFpbmluZ1RpbWVEaXNwbGF5JywgUmVtYWluaW5nVGltZURpc3BsYXkpO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIGxpdmUtZGlzcGxheS5qc1xyXG4gKi9cclxuLy8gVE9ETyAtIEZ1dHVyZSBtYWtlIGl0IGNsaWNrIHRvIHNuYXAgdG8gbGl2ZVxyXG5cclxuLyoqXHJcbiAqIERpc3BsYXlzIHRoZSBsaXZlIGluZGljYXRvciB3aGVuIGR1cmF0aW9uIGlzIEluZmluaXR5LlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcclxuICovXHJcblxyXG52YXIgTGl2ZURpc3BsYXkgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xyXG4gIGluaGVyaXRzKExpdmVEaXNwbGF5LCBfQ29tcG9uZW50KTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBMaXZlRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIExpdmVEaXNwbGF5KTtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcclxuXHJcbiAgICBfdGhpcy51cGRhdGVTaG93aW5nKCk7XHJcbiAgICBfdGhpcy5vbihfdGhpcy5wbGF5ZXIoKSwgJ2R1cmF0aW9uY2hhbmdlJywgX3RoaXMudXBkYXRlU2hvd2luZyk7XHJcbiAgICByZXR1cm4gX3RoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgTGl2ZURpc3BsYXkucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XHJcbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1saXZlLWNvbnRyb2wgdmpzLWNvbnRyb2wnXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBjcmVhdGVFbCgnZGl2Jywge1xyXG4gICAgICBjbGFzc05hbWU6ICd2anMtbGl2ZS1kaXNwbGF5JyxcclxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+JyArIHRoaXMubG9jYWxpemUoJ1N0cmVhbSBUeXBlJykgKyAnPC9zcGFuPicgKyB0aGlzLmxvY2FsaXplKCdMSVZFJylcclxuICAgIH0sIHtcclxuICAgICAgJ2FyaWEtbGl2ZSc6ICdvZmYnXHJcbiAgICB9KTtcclxuXHJcbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRFbF8pO1xyXG4gICAgcmV0dXJuIGVsO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIHRoZSBkdXJhdGlvbiB0byBzZWUgaWYgdGhlIExpdmVEaXNwbGF5IHNob3VsZCBiZSBzaG93aW5nIG9yIG5vdC4gVGhlbiBzaG93L2hpZGVcclxuICAgKiBpdCBhY2NvcmRpbmdseVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxyXG4gICAqICAgICAgICBUaGUge0BsaW5rIFBsYXllciNkdXJhdGlvbmNoYW5nZX0gZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBQbGF5ZXIjZHVyYXRpb25jaGFuZ2VcclxuICAgKi9cclxuXHJcblxyXG4gIExpdmVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGVTaG93aW5nID0gZnVuY3Rpb24gdXBkYXRlU2hvd2luZyhldmVudCkge1xyXG4gICAgaWYgKHRoaXMucGxheWVyKCkuZHVyYXRpb24oKSA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgdGhpcy5zaG93KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmhpZGUoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4gTGl2ZURpc3BsYXk7XHJcbn0oQ29tcG9uZW50KTtcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTGl2ZURpc3BsYXknLCBMaXZlRGlzcGxheSk7XHJcblxyXG4vKipcclxuICogQGZpbGUgc2xpZGVyLmpzXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGJhc2UgZnVuY3Rpb25hbGl0eSBmb3IgYSBzbGlkZXIuIENhbiBiZSB2ZXJ0aWNhbCBvciBob3Jpem9udGFsLlxyXG4gKiBGb3IgaW5zdGFuY2UgdGhlIHZvbHVtZSBiYXIgb3IgdGhlIHNlZWsgYmFyIG9uIGEgdmlkZW8gaXMgYSBzbGlkZXIuXHJcbiAqXHJcbiAqIEBleHRlbmRzIENvbXBvbmVudFxyXG4gKi9cclxuXHJcbnZhciBTbGlkZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xyXG4gIGluaGVyaXRzKFNsaWRlciwgX0NvbXBvbmVudCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXHJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFNsaWRlcihwbGF5ZXIsIG9wdGlvbnMpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFNsaWRlcik7XHJcblxyXG4gICAgLy8gU2V0IHByb3BlcnR5IG5hbWVzIHRvIGJhciB0byBtYXRjaCB3aXRoIHRoZSBjaGlsZCBTbGlkZXIgY2xhc3MgaXMgbG9va2luZyBmb3JcclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xyXG5cclxuICAgIF90aGlzLmJhciA9IF90aGlzLmdldENoaWxkKF90aGlzLm9wdGlvbnNfLmJhck5hbWUpO1xyXG5cclxuICAgIC8vIFNldCBhIGhvcml6b250YWwgb3IgdmVydGljYWwgY2xhc3Mgb24gdGhlIHNsaWRlciBkZXBlbmRpbmcgb24gdGhlIHNsaWRlciB0eXBlXHJcbiAgICBfdGhpcy52ZXJ0aWNhbCghIV90aGlzLm9wdGlvbnNfLnZlcnRpY2FsKTtcclxuXHJcbiAgICBfdGhpcy5vbignbW91c2Vkb3duJywgX3RoaXMuaGFuZGxlTW91c2VEb3duKTtcclxuICAgIF90aGlzLm9uKCd0b3VjaHN0YXJ0JywgX3RoaXMuaGFuZGxlTW91c2VEb3duKTtcclxuICAgIF90aGlzLm9uKCdmb2N1cycsIF90aGlzLmhhbmRsZUZvY3VzKTtcclxuICAgIF90aGlzLm9uKCdibHVyJywgX3RoaXMuaGFuZGxlQmx1cik7XHJcbiAgICBfdGhpcy5vbignY2xpY2snLCBfdGhpcy5oYW5kbGVDbGljayk7XHJcblxyXG4gICAgX3RoaXMub24ocGxheWVyLCAnY29udHJvbHN2aXNpYmxlJywgX3RoaXMudXBkYXRlKTtcclxuXHJcbiAgICBpZiAoX3RoaXMucGxheWVyRXZlbnQpIHtcclxuICAgICAgX3RoaXMub24ocGxheWVyLCBfdGhpcy5wbGF5ZXJFdmVudCwgX3RoaXMudXBkYXRlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgYEJ1dHRvbmBzIERPTSBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcclxuICAgKiAgICAgICAgVHlwZSBvZiBlbGVtZW50IHRvIGNyZWF0ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHM9e31dXHJcbiAgICogICAgICAgIExpc3Qgb2YgcHJvcGVydGllcyBpbiBPYmplY3QgZm9ybS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlcz17fV1cclxuICAgKiAgICAgICAgbGlzdCBvZiBhdHRyaWJ1dGVzIGluIE9iamVjdCBmb3JtLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RWxlbWVudH1cclxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgU2xpZGVyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKHR5cGUpIHtcclxuICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XHJcbiAgICB2YXIgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XHJcblxyXG4gICAgLy8gQWRkIHRoZSBzbGlkZXIgZWxlbWVudCBjbGFzcyB0byBhbGwgc3ViIGNsYXNzZXNcclxuICAgIHByb3BzLmNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSArICcgdmpzLXNsaWRlcic7XHJcbiAgICBwcm9wcyA9IGFzc2lnbih7XHJcbiAgICAgIHRhYkluZGV4OiAwXHJcbiAgICB9LCBwcm9wcyk7XHJcblxyXG4gICAgYXR0cmlidXRlcyA9IGFzc2lnbih7XHJcbiAgICAgICdyb2xlJzogJ3NsaWRlcicsXHJcbiAgICAgICdhcmlhLXZhbHVlbm93JzogMCxcclxuICAgICAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxyXG4gICAgICAnYXJpYS12YWx1ZW1heCc6IDEwMCxcclxuICAgICAgJ3RhYkluZGV4JzogMFxyXG4gICAgfSwgYXR0cmlidXRlcyk7XHJcblxyXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgdHlwZSwgcHJvcHMsIGF0dHJpYnV0ZXMpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnRzIG9uIHRoZSBgU2xpZGVyYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cclxuICAgKiBAbGlzdGVucyB0b3VjaHN0YXJ0XHJcbiAgICogQGZpcmVzIFNsaWRlciNzbGlkZXJhY3RpdmVcclxuICAgKi9cclxuXHJcblxyXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duKGV2ZW50KSB7XHJcbiAgICB2YXIgZG9jID0gdGhpcy5iYXIuZWxfLm93bmVyRG9jdW1lbnQ7XHJcblxyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIGJsb2NrVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkaW5nJyk7XHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBzbGlkZXIgaXMgaW4gYW4gYWN0aXZlIHN0YXRlXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50IFNsaWRlciNzbGlkZXJhY3RpdmVcclxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy50cmlnZ2VyKCdzbGlkZXJhY3RpdmUnKTtcclxuXHJcbiAgICB0aGlzLm9uKGRvYywgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcclxuICAgIHRoaXMub24oZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XHJcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcclxuICAgIHRoaXMub24oZG9jLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xyXG5cclxuICAgIHRoaXMuaGFuZGxlTW91c2VNb3ZlKGV2ZW50KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgdGhlIGBtb3VzZW1vdmVgLCBgdG91Y2htb3ZlYCwgYW5kIGBtb3VzZWRvd25gIGV2ZW50cyBvbiB0aGlzIGBTbGlkZXJgLlxyXG4gICAqIFRoZSBgbW91c2Vtb3ZlYCBhbmQgYHRvdWNobW92ZWAgZXZlbnRzIHdpbGwgb25seSBvbmx5IHRyaWdnZXIgdGhpcyBmdW5jdGlvbiBkdXJpbmdcclxuICAgKiBgbW91c2Vkb3duYCBhbmQgYHRvdWNoc3RhcnRgLiBUaGlzIGlzIGR1ZSB0byB7QGxpbmsgU2xpZGVyI2hhbmRsZU1vdXNlRG93bn0gYW5kXHJcbiAgICoge0BsaW5rIFNsaWRlciNoYW5kbGVNb3VzZVVwfS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIGBtb3VzZWRvd25gLCBgbW91c2Vtb3ZlYCwgYHRvdWNoc3RhcnRgLCBvciBgdG91Y2htb3ZlYCBldmVudCB0aGF0IHRyaWdnZXJlZFxyXG4gICAqICAgICAgICB0aGlzIGZ1bmN0aW9uXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBtb3VzZW1vdmVcclxuICAgKiBAbGlzdGVucyB0b3VjaG1vdmVcclxuICAgKi9cclxuXHJcblxyXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7fTtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50cyBvbiB0aGUgYFNsaWRlcmAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgdG91Y2hlbmRcclxuICAgKiBAbGlzdGVucyBtb3VzZXVwXHJcbiAgICogQGZpcmVzIFNsaWRlciNzbGlkZXJpbmFjdGl2ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gaGFuZGxlTW91c2VVcCgpIHtcclxuICAgIHZhciBkb2MgPSB0aGlzLmJhci5lbF8ub3duZXJEb2N1bWVudDtcclxuXHJcbiAgICB1bmJsb2NrVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zbGlkaW5nJyk7XHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHRoZSBzbGlkZXIgaXMgbm8gbG9uZ2VyIGluIGFuIGFjdGl2ZSBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnQgU2xpZGVyI3NsaWRlcmluYWN0aXZlXHJcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudHJpZ2dlcignc2xpZGVyaW5hY3RpdmUnKTtcclxuXHJcbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSk7XHJcbiAgICB0aGlzLm9mZihkb2MsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcclxuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcclxuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgcHJvZ3Jlc3MgYmFyIG9mIHRoZSBgU2xpZGVyYC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICogICAgICAgICAgVGhlIHBlcmNlbnRhZ2Ugb2YgcHJvZ3Jlc3MgdGhlIHByb2dyZXNzIGJhciByZXByZXNlbnRzIGFzIGFcclxuICAgKiAgICAgICAgICBudW1iZXIgZnJvbSAwIHRvIDEuXHJcbiAgICovXHJcblxyXG5cclxuICBTbGlkZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcclxuXHJcbiAgICAvLyBJbiBWb2x1bWVCYXIgaW5pdCB3ZSBoYXZlIGEgc2V0VGltZW91dCBmb3IgdXBkYXRlIHRoYXQgcG9wcyBhbmQgdXBkYXRlXHJcbiAgICAvLyB0byB0aGUgZW5kIG9mIHRoZSBleGVjdXRpb24gc3RhY2suIFRoZSBwbGF5ZXIgaXMgZGVzdHJveWVkIGJlZm9yZSB0aGVuXHJcbiAgICAvLyB1cGRhdGUgd2lsbCBjYXVzZSBhbiBlcnJvclxyXG4gICAgaWYgKCF0aGlzLmVsXykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgc2NydWJiaW5nLCB3ZSBjb3VsZCB1c2UgYSBjYWNoZWQgdmFsdWUgdG8gbWFrZSB0aGUgaGFuZGxlIGtlZXAgdXBcclxuICAgIC8vIHdpdGggdGhlIHVzZXIncyBtb3VzZS4gT24gSFRNTDUgYnJvd3NlcnMgc2NydWJiaW5nIGlzIHJlYWxseSBzbW9vdGgsIGJ1dFxyXG4gICAgLy8gc29tZSBmbGFzaCBwbGF5ZXJzIGFyZSBzbG93LCBzbyB3ZSBtaWdodCB3YW50IHRvIHV0aWxpemUgdGhpcyBsYXRlci5cclxuICAgIC8vIHZhciBwcm9ncmVzcyA9ICAodGhpcy5wbGF5ZXJfLnNjcnViYmluZygpKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIC8gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkgOiB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKSAvIHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xyXG4gICAgdmFyIHByb2dyZXNzID0gdGhpcy5nZXRQZXJjZW50KCk7XHJcbiAgICB2YXIgYmFyID0gdGhpcy5iYXI7XHJcblxyXG4gICAgLy8gSWYgdGhlcmUncyBubyBiYXIuLi5cclxuICAgIGlmICghYmFyKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcm90ZWN0IGFnYWluc3Qgbm8gZHVyYXRpb24gYW5kIG90aGVyIGRpdmlzaW9uIGlzc3Vlc1xyXG4gICAgaWYgKHR5cGVvZiBwcm9ncmVzcyAhPT0gJ251bWJlcicgfHwgcHJvZ3Jlc3MgIT09IHByb2dyZXNzIHx8IHByb2dyZXNzIDwgMCB8fCBwcm9ncmVzcyA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgcHJvZ3Jlc3MgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnZlcnQgdG8gYSBwZXJjZW50YWdlIGZvciBzZXR0aW5nXHJcbiAgICB2YXIgcGVyY2VudGFnZSA9IChwcm9ncmVzcyAqIDEwMCkudG9GaXhlZCgyKSArICclJztcclxuICAgIHZhciBzdHlsZSA9IGJhci5lbCgpLnN0eWxlO1xyXG5cclxuICAgIC8vIFNldCB0aGUgbmV3IGJhciB3aWR0aCBvciBoZWlnaHRcclxuICAgIGlmICh0aGlzLnZlcnRpY2FsKCkpIHtcclxuICAgICAgc3R5bGUuaGVpZ2h0ID0gcGVyY2VudGFnZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0eWxlLndpZHRoID0gcGVyY2VudGFnZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcHJvZ3Jlc3M7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIGRpc3RhbmNlIGZvciBzbGlkZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBTbGlkZXIuXHJcbiAgICogICAgICAgICAtIHBvc3RpdGlvbi54IGZvciB2ZXJ0aWNhbCBgU2xpZGVyYHNcclxuICAgKiAgICAgICAgIC0gcG9zdGl0aW9uLnkgZm9yIGhvcml6b250YWwgYFNsaWRlcmBzXHJcbiAgICovXHJcblxyXG5cclxuICBTbGlkZXIucHJvdG90eXBlLmNhbGN1bGF0ZURpc3RhbmNlID0gZnVuY3Rpb24gY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpIHtcclxuICAgIHZhciBwb3NpdGlvbiA9IGdldFBvaW50ZXJQb3NpdGlvbih0aGlzLmVsXywgZXZlbnQpO1xyXG5cclxuICAgIGlmICh0aGlzLnZlcnRpY2FsKCkpIHtcclxuICAgICAgcmV0dXJuIHBvc2l0aW9uLnk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb24ueDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgYSBgZm9jdXNgIGV2ZW50IG9uIHRoaXMgYFNsaWRlcmAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICBUaGUgYGZvY3VzYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIGZvY3VzXHJcbiAgICovXHJcblxyXG5cclxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZUZvY3VzID0gZnVuY3Rpb24gaGFuZGxlRm9jdXMoKSB7XHJcbiAgICB0aGlzLm9uKHRoaXMuYmFyLmVsXy5vd25lckRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5UHJlc3MpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBhIGBrZXlkb3duYCBldmVudCBvbiB0aGUgYFNsaWRlcmAuIFdhdGNoZXMgZm9yIGxlZnQsIHJpZ3RoLCB1cCwgYW5kIGRvd25cclxuICAgKiBhcnJvdyBrZXlzLiBUaGlzIGZ1bmN0aW9uIHdpbGwgb25seSBiZSBjYWxsZWQgd2hlbiB0aGUgc2xpZGVyIGhhcyBmb2N1cy4gU2VlXHJcbiAgICoge0BsaW5rIFNsaWRlciNoYW5kbGVGb2N1c30gYW5kIHtAbGluayBTbGlkZXIjaGFuZGxlQmx1cn0uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICB0aGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMga2V5ZG93blxyXG4gICAqL1xyXG5cclxuXHJcbiAgU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcyA9IGZ1bmN0aW9uIGhhbmRsZUtleVByZXNzKGV2ZW50KSB7XHJcbiAgICAvLyBMZWZ0IGFuZCBEb3duIEFycm93c1xyXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzNyB8fCBldmVudC53aGljaCA9PT0gNDApIHtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgdGhpcy5zdGVwQmFjaygpO1xyXG5cclxuICAgICAgLy8gVXAgYW5kIFJpZ2h0IEFycm93c1xyXG4gICAgfSBlbHNlIGlmIChldmVudC53aGljaCA9PT0gMzggfHwgZXZlbnQud2hpY2ggPT09IDM5KSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIHRoaXMuc3RlcEZvcndhcmQoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgYSBgYmx1cmAgZXZlbnQgb24gdGhpcyBgU2xpZGVyYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIFRoZSBgYmx1cmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBibHVyXHJcbiAgICovXHJcblxyXG4gIFNsaWRlci5wcm90b3R5cGUuaGFuZGxlQmx1ciA9IGZ1bmN0aW9uIGhhbmRsZUJsdXIoKSB7XHJcbiAgICB0aGlzLm9mZih0aGlzLmJhci5lbF8ub3duZXJEb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleVByZXNzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBMaXN0ZW5lciBmb3IgY2xpY2sgZXZlbnRzIG9uIHNsaWRlciwgdXNlZCB0byBwcmV2ZW50IGNsaWNrc1xyXG4gICAqICAgZnJvbSBidWJibGluZyB1cCB0byBwYXJlbnQgZWxlbWVudHMgbGlrZSBidXR0b24gbWVudXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcclxuICAgKiAgICAgICAgRXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBvYmplY3QgdG8gcnVuXHJcbiAgICovXHJcblxyXG5cclxuICBTbGlkZXIucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcclxuICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXQvc2V0IGlmIHNsaWRlciBpcyBob3Jpem9udGFsIGZvciB2ZXJ0aWNhbFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbF1cclxuICAgKiAgICAgICAgLSB0cnVlIGlmIHNsaWRlciBpcyB2ZXJ0aWNhbCxcclxuICAgKiAgICAgICAgLSBmYWxzZSBpcyBob3Jpem9udGFsXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqICAgICAgICAgLSB0cnVlIGlmIHNsaWRlciBpcyB2ZXJ0aWNhbCwgYW5kIGdldHRpbmdcclxuICAgKiAgICAgICAgIC0gZmFsc2UgaWYgdGhlIHNsaWRlciBpcyBob3Jpem9udGFsLCBhbmQgZ2V0dGluZ1xyXG4gICAqL1xyXG5cclxuXHJcbiAgU2xpZGVyLnByb3RvdHlwZS52ZXJ0aWNhbCA9IGZ1bmN0aW9uIHZlcnRpY2FsKGJvb2wpIHtcclxuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudmVydGljYWxfIHx8IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudmVydGljYWxfID0gISFib29sO1xyXG5cclxuICAgIGlmICh0aGlzLnZlcnRpY2FsXykge1xyXG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLXZlcnRpY2FsJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLWhvcml6b250YWwnKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4gU2xpZGVyO1xyXG59KENvbXBvbmVudCk7XHJcblxyXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1NsaWRlcicsIFNsaWRlcik7XHJcblxyXG4vKipcclxuICogQGZpbGUgbG9hZC1wcm9ncmVzcy1iYXIuanNcclxuICovXHJcbi8qKlxyXG4gKiBTaG93cyBsb2FkaW5nIHByb2dyZXNzXHJcbiAqXHJcbiAqIEBleHRlbmRzIENvbXBvbmVudFxyXG4gKi9cclxuXHJcbnZhciBMb2FkUHJvZ3Jlc3NCYXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xyXG4gIGluaGVyaXRzKExvYWRQcm9ncmVzc0JhciwgX0NvbXBvbmVudCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gTG9hZFByb2dyZXNzQmFyKHBsYXllciwgb3B0aW9ucykge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9hZFByb2dyZXNzQmFyKTtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcclxuXHJcbiAgICBfdGhpcy5wYXJ0RWxzXyA9IFtdO1xyXG4gICAgX3RoaXMub24ocGxheWVyLCAncHJvZ3Jlc3MnLCBfdGhpcy51cGRhdGUpO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIExvYWRQcm9ncmVzc0Jhci5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcclxuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1sb2FkLXByb2dyZXNzJyxcclxuICAgICAgaW5uZXJIVE1MOiAnPHNwYW4gY2xhc3M9XCJ2anMtY29udHJvbC10ZXh0XCI+PHNwYW4+JyArIHRoaXMubG9jYWxpemUoJ0xvYWRlZCcpICsgJzwvc3Bhbj46IDAlPC9zcGFuPidcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBwcm9ncmVzcyBiYXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cclxuICAgKiAgICAgICAgVGhlIGBwcm9ncmVzc2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBQbGF5ZXIjcHJvZ3Jlc3NcclxuICAgKi9cclxuXHJcblxyXG4gIExvYWRQcm9ncmVzc0Jhci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKGV2ZW50KSB7XHJcbiAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLnBsYXllcl8uYnVmZmVyZWQoKTtcclxuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xyXG4gICAgdmFyIGJ1ZmZlcmVkRW5kID0gdGhpcy5wbGF5ZXJfLmJ1ZmZlcmVkRW5kKCk7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnBhcnRFbHNfO1xyXG5cclxuICAgIC8vIGdldCB0aGUgcGVyY2VudCB3aWR0aCBvZiBhIHRpbWUgY29tcGFyZWQgdG8gdGhlIHRvdGFsIGVuZFxyXG4gICAgdmFyIHBlcmNlbnRpZnkgPSBmdW5jdGlvbiBwZXJjZW50aWZ5KHRpbWUsIGVuZCkge1xyXG4gICAgICAvLyBubyBOYU5cclxuICAgICAgdmFyIHBlcmNlbnQgPSB0aW1lIC8gZW5kIHx8IDA7XHJcblxyXG4gICAgICByZXR1cm4gKHBlcmNlbnQgPj0gMSA/IDEgOiBwZXJjZW50KSAqIDEwMCArICclJztcclxuICAgIH07XHJcblxyXG4gICAgLy8gdXBkYXRlIHRoZSB3aWR0aCBvZiB0aGUgcHJvZ3Jlc3MgYmFyXHJcbiAgICB0aGlzLmVsXy5zdHlsZS53aWR0aCA9IHBlcmNlbnRpZnkoYnVmZmVyZWRFbmQsIGR1cmF0aW9uKTtcclxuXHJcbiAgICAvLyBhZGQgY2hpbGQgZWxlbWVudHMgdG8gcmVwcmVzZW50IHRoZSBpbmRpdmlkdWFsIGJ1ZmZlcmVkIHRpbWUgcmFuZ2VzXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBzdGFydCA9IGJ1ZmZlcmVkLnN0YXJ0KGkpO1xyXG4gICAgICB2YXIgZW5kID0gYnVmZmVyZWQuZW5kKGkpO1xyXG4gICAgICB2YXIgcGFydCA9IGNoaWxkcmVuW2ldO1xyXG5cclxuICAgICAgaWYgKCFwYXJ0KSB7XHJcbiAgICAgICAgcGFydCA9IHRoaXMuZWxfLmFwcGVuZENoaWxkKGNyZWF0ZUVsKCkpO1xyXG4gICAgICAgIGNoaWxkcmVuW2ldID0gcGFydDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gc2V0IHRoZSBwZXJjZW50IGJhc2VkIG9uIHRoZSB3aWR0aCBvZiB0aGUgcHJvZ3Jlc3MgYmFyIChidWZmZXJlZEVuZClcclxuICAgICAgcGFydC5zdHlsZS5sZWZ0ID0gcGVyY2VudGlmeShzdGFydCwgYnVmZmVyZWRFbmQpO1xyXG4gICAgICBwYXJ0LnN0eWxlLndpZHRoID0gcGVyY2VudGlmeShlbmQgLSBzdGFydCwgYnVmZmVyZWRFbmQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlbW92ZSB1bnVzZWQgYnVmZmVyZWQgcmFuZ2UgZWxlbWVudHNcclxuICAgIGZvciAodmFyIF9pID0gY2hpbGRyZW4ubGVuZ3RoOyBfaSA+IGJ1ZmZlcmVkLmxlbmd0aDsgX2ktLSkge1xyXG4gICAgICB0aGlzLmVsXy5yZW1vdmVDaGlsZChjaGlsZHJlbltfaSAtIDFdKTtcclxuICAgIH1cclxuICAgIGNoaWxkcmVuLmxlbmd0aCA9IGJ1ZmZlcmVkLmxlbmd0aDtcclxuICB9O1xyXG5cclxuICByZXR1cm4gTG9hZFByb2dyZXNzQmFyO1xyXG59KENvbXBvbmVudCk7XHJcblxyXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0xvYWRQcm9ncmVzc0JhcicsIExvYWRQcm9ncmVzc0Jhcik7XHJcblxyXG4vKipcclxuICogQGZpbGUgdGltZS10b29sdGlwLmpzXHJcbiAqL1xyXG4vKipcclxuICogVGltZSB0b29sdGlwcyBkaXNwbGF5IGEgdGltZSBhYm92ZSB0aGUgcHJvZ3Jlc3MgYmFyLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcclxuICovXHJcblxyXG52YXIgVGltZVRvb2x0aXAgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xyXG4gIGluaGVyaXRzKFRpbWVUb29sdGlwLCBfQ29tcG9uZW50KTtcclxuXHJcbiAgZnVuY3Rpb24gVGltZVRvb2x0aXAoKSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lVG9vbHRpcCk7XHJcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSB0aW1lIHRvb2x0aXAgRE9NIGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxyXG4gICAqL1xyXG4gIFRpbWVUb29sdGlwLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xyXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcclxuICAgICAgY2xhc3NOYW1lOiAndmpzLXRpbWUtdG9vbHRpcCdcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0aW1lIHRvb2x0aXAgcmVsYXRpdmUgdG8gdGhlIGBTZWVrQmFyYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZWVrQmFyUmVjdFxyXG4gICAqICAgICAgICBUaGUgYENsaWVudFJlY3RgIGZvciB0aGUge0BsaW5rIFNlZWtCYXJ9IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Vla0JhclBvaW50XHJcbiAgICogICAgICAgIEEgbnVtYmVyIGZyb20gMCB0byAxLCByZXByZXNlbnRpbmcgYSBob3Jpem9udGFsIHJlZmVyZW5jZSBwb2ludFxyXG4gICAqICAgICAgICBmcm9tIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHtAbGluayBTZWVrQmFyfVxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGltZVRvb2x0aXAucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVrQmFyUmVjdCwgc2Vla0JhclBvaW50LCBjb250ZW50KSB7XHJcbiAgICB2YXIgdG9vbHRpcFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy5lbF8pO1xyXG4gICAgdmFyIHBsYXllclJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy5wbGF5ZXJfLmVsKCkpO1xyXG4gICAgdmFyIHNlZWtCYXJQb2ludFB4ID0gc2Vla0JhclJlY3Qud2lkdGggKiBzZWVrQmFyUG9pbnQ7XHJcblxyXG4gICAgLy8gZG8gbm90aGluZyBpZiBlaXRoZXIgcmVjdCBpc24ndCBhdmFpbGFibGVcclxuICAgIC8vIGZvciBleGFtcGxlLCBpZiB0aGUgcGxheWVyIGlzbid0IGluIHRoZSBET00gZm9yIHRlc3RpbmdcclxuICAgIGlmICghcGxheWVyUmVjdCB8fCAhdG9vbHRpcFJlY3QpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoaXMgaXMgdGhlIHNwYWNlIGxlZnQgb2YgdGhlIGBzZWVrQmFyUG9pbnRgIGF2YWlsYWJsZSB3aXRoaW4gdGhlIGJvdW5kc1xyXG4gICAgLy8gb2YgdGhlIHBsYXllci4gV2UgY2FsY3VsYXRlIGFueSBnYXAgYmV0d2VlbiB0aGUgbGVmdCBlZGdlIG9mIHRoZSBwbGF5ZXJcclxuICAgIC8vIGFuZCB0aGUgbGVmdCBlZGdlIG9mIHRoZSBgU2Vla0JhcmAgYW5kIGFkZCB0aGUgbnVtYmVyIG9mIHBpeGVscyBpbiB0aGVcclxuICAgIC8vIGBTZWVrQmFyYCBiZWZvcmUgaGl0dGluZyB0aGUgYHNlZWtCYXJQb2ludGBcclxuICAgIHZhciBzcGFjZUxlZnRPZlBvaW50ID0gc2Vla0JhclJlY3QubGVmdCAtIHBsYXllclJlY3QubGVmdCArIHNlZWtCYXJQb2ludFB4O1xyXG5cclxuICAgIC8vIFRoaXMgaXMgdGhlIHNwYWNlIHJpZ2h0IG9mIHRoZSBgc2Vla0JhclBvaW50YCBhdmFpbGFibGUgd2l0aGluIHRoZSBib3VuZHNcclxuICAgIC8vIG9mIHRoZSBwbGF5ZXIuIFdlIGNhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHBpeGVscyBmcm9tIHRoZSBgc2Vla0JhclBvaW50YFxyXG4gICAgLy8gdG8gdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIGBTZWVrQmFyYCBhbmQgYWRkIHRvIHRoYXQgYW55IGdhcCBiZXR3ZWVuIHRoZVxyXG4gICAgLy8gcmlnaHQgZWRnZSBvZiB0aGUgYFNlZWtCYXJgIGFuZCB0aGUgcGxheWVyLlxyXG4gICAgdmFyIHNwYWNlUmlnaHRPZlBvaW50ID0gc2Vla0JhclJlY3Qud2lkdGggLSBzZWVrQmFyUG9pbnRQeCArIChwbGF5ZXJSZWN0LnJpZ2h0IC0gc2Vla0JhclJlY3QucmlnaHQpO1xyXG5cclxuICAgIC8vIFRoaXMgaXMgdGhlIG51bWJlciBvZiBwaXhlbHMgYnkgd2hpY2ggdGhlIHRvb2x0aXAgd2lsbCBuZWVkIHRvIGJlIHB1bGxlZFxyXG4gICAgLy8gZnVydGhlciB0byB0aGUgcmlnaHQgdG8gY2VudGVyIGl0IG92ZXIgdGhlIGBzZWVrQmFyUG9pbnRgLlxyXG4gICAgdmFyIHB1bGxUb29sdGlwQnkgPSB0b29sdGlwUmVjdC53aWR0aCAvIDI7XHJcblxyXG4gICAgLy8gQWRqdXN0IHRoZSBgcHVsbFRvb2x0aXBCeWAgZGlzdGFuY2UgdG8gdGhlIGxlZnQgb3IgcmlnaHQgZGVwZW5kaW5nIG9uXHJcbiAgICAvLyB0aGUgcmVzdWx0cyBvZiB0aGUgc3BhY2UgY2FsY3VsYXRpb25zIGFib3ZlLlxyXG4gICAgaWYgKHNwYWNlTGVmdE9mUG9pbnQgPCBwdWxsVG9vbHRpcEJ5KSB7XHJcbiAgICAgIHB1bGxUb29sdGlwQnkgKz0gcHVsbFRvb2x0aXBCeSAtIHNwYWNlTGVmdE9mUG9pbnQ7XHJcbiAgICB9IGVsc2UgaWYgKHNwYWNlUmlnaHRPZlBvaW50IDwgcHVsbFRvb2x0aXBCeSkge1xyXG4gICAgICBwdWxsVG9vbHRpcEJ5ID0gc3BhY2VSaWdodE9mUG9pbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRHVlIHRvIHRoZSBpbXByZWNpc2lvbiBvZiBkZWNpbWFsL3JhdGlvIGJhc2VkIGNhbGN1bGF0aW9ucyBhbmQgdmFyeWluZ1xyXG4gICAgLy8gcm91bmRpbmcgYmVoYXZpb3JzLCB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgdGhlIHNwYWNpbmcgYWRqdXN0bWVudCBpcyBvZmZcclxuICAgIC8vIGJ5IGEgcGl4ZWwgb3IgdHdvLiBUaGlzIGFkZHMgaW5zdXJhbmNlIHRvIHRoZXNlIGNhbGN1bGF0aW9ucy5cclxuICAgIGlmIChwdWxsVG9vbHRpcEJ5IDwgMCkge1xyXG4gICAgICBwdWxsVG9vbHRpcEJ5ID0gMDtcclxuICAgIH0gZWxzZSBpZiAocHVsbFRvb2x0aXBCeSA+IHRvb2x0aXBSZWN0LndpZHRoKSB7XHJcbiAgICAgIHB1bGxUb29sdGlwQnkgPSB0b29sdGlwUmVjdC53aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmVsXy5zdHlsZS5yaWdodCA9ICctJyArIHB1bGxUb29sdGlwQnkgKyAncHgnO1xyXG4gICAgdGV4dENvbnRlbnQodGhpcy5lbF8sIGNvbnRlbnQpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBUaW1lVG9vbHRpcDtcclxufShDb21wb25lbnQpO1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdUaW1lVG9vbHRpcCcsIFRpbWVUb29sdGlwKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBwbGF5LXByb2dyZXNzLWJhci5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIFVzZWQgYnkge0BsaW5rIFNlZWtCYXJ9IHRvIGRpc3BsYXkgbWVkaWEgcGxheWJhY2sgcHJvZ3Jlc3MgYXMgcGFydCBvZiB0aGVcclxuICoge0BsaW5rIFByb2dyZXNzQ29udHJvbH0uXHJcbiAqXHJcbiAqIEBleHRlbmRzIENvbXBvbmVudFxyXG4gKi9cclxuXHJcbnZhciBQbGF5UHJvZ3Jlc3NCYXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xyXG4gIGluaGVyaXRzKFBsYXlQcm9ncmVzc0JhciwgX0NvbXBvbmVudCk7XHJcblxyXG4gIGZ1bmN0aW9uIFBsYXlQcm9ncmVzc0JhcigpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXlQcm9ncmVzc0Jhcik7XHJcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSB0aGUgRE9NIGVsZW1lbnQgZm9yIHRoaXMgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cclxuICAgKi9cclxuICBQbGF5UHJvZ3Jlc3NCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XHJcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xyXG4gICAgICBjbGFzc05hbWU6ICd2anMtcGxheS1wcm9ncmVzcyB2anMtc2xpZGVyLWJhcicsXHJcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPjxzcGFuPicgKyB0aGlzLmxvY2FsaXplKCdQcm9ncmVzcycpICsgJzwvc3Bhbj46IDAlPC9zcGFuPidcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEVucXVldWVzIHVwZGF0ZXMgdG8gaXRzIG93biBET00gYXMgd2VsbCBhcyB0aGUgRE9NIG9mIGl0c1xyXG4gICAqIHtAbGluayBUaW1lVG9vbHRpcH0gY2hpbGQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gc2Vla0JhclJlY3RcclxuICAgKiAgICAgICAgVGhlIGBDbGllbnRSZWN0YCBmb3IgdGhlIHtAbGluayBTZWVrQmFyfSBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlZWtCYXJQb2ludFxyXG4gICAqICAgICAgICBBIG51bWJlciBmcm9tIDAgdG8gMSwgcmVwcmVzZW50aW5nIGEgaG9yaXpvbnRhbCByZWZlcmVuY2UgcG9pbnRcclxuICAgKiAgICAgICAgZnJvbSB0aGUgbGVmdCBlZGdlIG9mIHRoZSB7QGxpbmsgU2Vla0Jhcn1cclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXlQcm9ncmVzc0Jhci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNlZWtCYXJSZWN0LCBzZWVrQmFyUG9pbnQpIHtcclxuICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG5cclxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHJBRiBJRCwgY2FuY2VsIGl0IHNvIHdlIGRvbid0IG92ZXItcXVldWUuXHJcbiAgICBpZiAodGhpcy5yYWZJZF8pIHtcclxuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkXyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yYWZJZF8gPSB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB0aW1lID0gX3RoaXMyLnBsYXllcl8uc2NydWJiaW5nKCkgPyBfdGhpczIucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogX3RoaXMyLnBsYXllcl8uY3VycmVudFRpbWUoKTtcclxuXHJcbiAgICAgIHZhciBjb250ZW50ID0gZm9ybWF0VGltZSh0aW1lLCBfdGhpczIucGxheWVyXy5kdXJhdGlvbigpKTtcclxuICAgICAgdmFyIHRpbWVUb29sdGlwID0gX3RoaXMyLmdldENoaWxkKCd0aW1lVG9vbHRpcCcpO1xyXG5cclxuICAgICAgaWYgKHRpbWVUb29sdGlwKSB7XHJcbiAgICAgICAgdGltZVRvb2x0aXAudXBkYXRlKHNlZWtCYXJSZWN0LCBzZWVrQmFyUG9pbnQsIGNvbnRlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gUGxheVByb2dyZXNzQmFyO1xyXG59KENvbXBvbmVudCk7XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBvcHRpb25zIGZvciB7QGxpbmsgUGxheVByb2dyZXNzQmFyfS5cclxuICpcclxuICogQHR5cGUge09iamVjdH1cclxuICogQHByaXZhdGVcclxuICovXHJcblxyXG5cclxuUGxheVByb2dyZXNzQmFyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcclxuICBjaGlsZHJlbjogW11cclxufTtcclxuXHJcbi8vIFRpbWUgdG9vbHRpcHMgc2hvdWxkIG5vdCBiZSBhZGRlZCB0byBhIHBsYXllciBvbiBtb2JpbGUgZGV2aWNlcyBvciBJRThcclxuaWYgKCghSUVfVkVSU0lPTiB8fCBJRV9WRVJTSU9OID4gOCkgJiYgIUlTX0lPUyAmJiAhSVNfQU5EUk9JRCkge1xyXG4gIFBsYXlQcm9ncmVzc0Jhci5wcm90b3R5cGUub3B0aW9uc18uY2hpbGRyZW4ucHVzaCgndGltZVRvb2x0aXAnKTtcclxufVxyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5UHJvZ3Jlc3NCYXInLCBQbGF5UHJvZ3Jlc3NCYXIpO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIG1vdXNlLXRpbWUtZGlzcGxheS5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSB7QGxpbmsgTW91c2VUaW1lRGlzcGxheX0gY29tcG9uZW50IHRyYWNrcyBtb3VzZSBtb3ZlbWVudCBvdmVyIHRoZVxyXG4gKiB7QGxpbmsgUHJvZ3Jlc3NDb250cm9sfS4gSXQgZGlzcGxheXMgYW4gaW5kaWNhdG9yIGFuZCBhIHtAbGluayBUaW1lVG9vbHRpcH1cclxuICogaW5kaWNhdGluZyB0aGUgdGltZSB3aGljaCBpcyByZXByZXNlbnRlZCBieSBhIGdpdmVuIHBvaW50IGluIHRoZVxyXG4gKiB7QGxpbmsgUHJvZ3Jlc3NDb250cm9sfS5cclxuICpcclxuICogQGV4dGVuZHMgQ29tcG9uZW50XHJcbiAqL1xyXG5cclxudmFyIE1vdXNlVGltZURpc3BsYXkgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xyXG4gIGluaGVyaXRzKE1vdXNlVGltZURpc3BsYXksIF9Db21wb25lbnQpO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXHJcbiAgICogICAgICAgIFRoZSB7QGxpbmsgUGxheWVyfSB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIE1vdXNlVGltZURpc3BsYXkocGxheWVyLCBvcHRpb25zKSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNb3VzZVRpbWVEaXNwbGF5KTtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcclxuXHJcbiAgICBfdGhpcy51cGRhdGUgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy51cGRhdGUpLCAyNSk7XHJcbiAgICByZXR1cm4gX3RoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIERPTSBlbGVtZW50IGZvciB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RWxlbWVudH1cclxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXHJcbiAgICovXHJcblxyXG5cclxuICBNb3VzZVRpbWVEaXNwbGF5LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xyXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcclxuICAgICAgY2xhc3NOYW1lOiAndmpzLW1vdXNlLWRpc3BsYXknXHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBFbnF1ZXVlcyB1cGRhdGVzIHRvIGl0cyBvd24gRE9NIGFzIHdlbGwgYXMgdGhlIERPTSBvZiBpdHNcclxuICAgKiB7QGxpbmsgVGltZVRvb2x0aXB9IGNoaWxkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHNlZWtCYXJSZWN0XHJcbiAgICogICAgICAgIFRoZSBgQ2xpZW50UmVjdGAgZm9yIHRoZSB7QGxpbmsgU2Vla0Jhcn0gZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZWVrQmFyUG9pbnRcclxuICAgKiAgICAgICAgQSBudW1iZXIgZnJvbSAwIHRvIDEsIHJlcHJlc2VudGluZyBhIGhvcml6b250YWwgcmVmZXJlbmNlIHBvaW50XHJcbiAgICogICAgICAgIGZyb20gdGhlIGxlZnQgZWRnZSBvZiB0aGUge0BsaW5rIFNlZWtCYXJ9XHJcbiAgICovXHJcblxyXG5cclxuICBNb3VzZVRpbWVEaXNwbGF5LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCkge1xyXG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XHJcblxyXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgckFGIElELCBjYW5jZWwgaXQgc28gd2UgZG9uJ3Qgb3Zlci1xdWV1ZS5cclxuICAgIGlmICh0aGlzLnJhZklkXykge1xyXG4gICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWRfKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJhZklkXyA9IHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGR1cmF0aW9uID0gX3RoaXMyLnBsYXllcl8uZHVyYXRpb24oKTtcclxuICAgICAgdmFyIGNvbnRlbnQgPSBmb3JtYXRUaW1lKHNlZWtCYXJQb2ludCAqIGR1cmF0aW9uLCBkdXJhdGlvbik7XHJcblxyXG4gICAgICBfdGhpczIuZWxfLnN0eWxlLmxlZnQgPSBzZWVrQmFyUmVjdC53aWR0aCAqIHNlZWtCYXJQb2ludCArICdweCc7XHJcbiAgICAgIF90aGlzMi5nZXRDaGlsZCgndGltZVRvb2x0aXAnKS51cGRhdGUoc2Vla0JhclJlY3QsIHNlZWtCYXJQb2ludCwgY29udGVudCk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gTW91c2VUaW1lRGlzcGxheTtcclxufShDb21wb25lbnQpO1xyXG5cclxuLyoqXHJcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgYE1vdXNlVGltZURpc3BsYXlgXHJcbiAqXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5cclxuXHJcbk1vdXNlVGltZURpc3BsYXkucHJvdG90eXBlLm9wdGlvbnNfID0ge1xyXG4gIGNoaWxkcmVuOiBbJ3RpbWVUb29sdGlwJ11cclxufTtcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTW91c2VUaW1lRGlzcGxheScsIE1vdXNlVGltZURpc3BsYXkpO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIHNlZWstYmFyLmpzXHJcbiAqL1xyXG4vLyBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdGhlIGBzdGVwKmAgZnVuY3Rpb25zIG1vdmUgdGhlIHRpbWVsaW5lLlxyXG52YXIgU1RFUF9TRUNPTkRTID0gNTtcclxuXHJcbi8qKlxyXG4gKiBTZWVrIGJhciBhbmQgY29udGFpbmVyIGZvciB0aGUgcHJvZ3Jlc3MgYmFycy4gVXNlcyB7QGxpbmsgUGxheVByb2dyZXNzQmFyfVxyXG4gKiBhcyBpdHMgYGJhcmAuXHJcbiAqXHJcbiAqIEBleHRlbmRzIFNsaWRlclxyXG4gKi9cclxuXHJcbnZhciBTZWVrQmFyID0gZnVuY3Rpb24gKF9TbGlkZXIpIHtcclxuICBpbmhlcml0cyhTZWVrQmFyLCBfU2xpZGVyKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBTZWVrQmFyKHBsYXllciwgb3B0aW9ucykge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU2Vla0Jhcik7XHJcblxyXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU2xpZGVyLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XHJcblxyXG4gICAgX3RoaXMudXBkYXRlID0gdGhyb3R0bGUoYmluZChfdGhpcywgX3RoaXMudXBkYXRlKSwgNTApO1xyXG4gICAgX3RoaXMub24ocGxheWVyLCBbJ3RpbWV1cGRhdGUnLCAnZW5kZWQnXSwgX3RoaXMudXBkYXRlKTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RWxlbWVudH1cclxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXHJcbiAgICovXHJcblxyXG5cclxuICBTZWVrQmFyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xyXG4gICAgcmV0dXJuIF9TbGlkZXIucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcclxuICAgICAgY2xhc3NOYW1lOiAndmpzLXByb2dyZXNzLWhvbGRlcidcclxuICAgIH0sIHtcclxuICAgICAgJ2FyaWEtbGFiZWwnOiB0aGlzLmxvY2FsaXplKCdQcm9ncmVzcyBCYXInKVxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBzZWVrIGJhcidzIFVJLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxyXG4gICAqICAgICAgICBUaGUgYHRpbWV1cGRhdGVgIG9yIGBlbmRlZGAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBQbGF5ZXIjdGltZXVwZGF0ZVxyXG4gICAqIEBsaXN0ZW5zIFBsYXllciNlbmRlZFxyXG4gICAqL1xyXG5cclxuXHJcbiAgU2Vla0Jhci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xyXG4gICAgdmFyIHBlcmNlbnQgPSBfU2xpZGVyLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMucGxheWVyXy5kdXJhdGlvbigpO1xyXG5cclxuICAgIC8vIEFsbG93cyBmb3Igc21vb3RoIHNjcnViYmluZywgd2hlbiBwbGF5ZXIgY2FuJ3Qga2VlcCB1cC5cclxuICAgIHZhciB0aW1lID0gdGhpcy5wbGF5ZXJfLnNjcnViYmluZygpID8gdGhpcy5wbGF5ZXJfLmdldENhY2hlKCkuY3VycmVudFRpbWUgOiB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUoKTtcclxuXHJcbiAgICAvLyBtYWNoaW5lIHJlYWRhYmxlIHZhbHVlIG9mIHByb2dyZXNzIGJhciAocGVyY2VudGFnZSBjb21wbGV0ZSlcclxuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycsIChwZXJjZW50ICogMTAwKS50b0ZpeGVkKDIpKTtcclxuXHJcbiAgICAvLyBodW1hbiByZWFkYWJsZSB2YWx1ZSBvZiBwcm9ncmVzcyBiYXIgKHRpbWUgY29tcGxldGUpXHJcbiAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWV0ZXh0JywgdGhpcy5sb2NhbGl6ZSgncHJvZ3Jlc3MgYmFyIHRpbWluZzogY3VycmVudFRpbWU9ezF9IGR1cmF0aW9uPXsyfScsIFtmb3JtYXRUaW1lKHRpbWUsIGR1cmF0aW9uKSwgZm9ybWF0VGltZShkdXJhdGlvbiwgZHVyYXRpb24pXSwgJ3sxfSBvZiB7Mn0nKSk7XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBgUGxheVByb2dyZXNzQmFyYC5cclxuICAgIHRoaXMuYmFyLnVwZGF0ZShnZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy5lbF8pLCBwZXJjZW50KTtcclxuXHJcbiAgICByZXR1cm4gcGVyY2VudDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHBlcmNlbnRhZ2Ugb2YgbWVkaWEgcGxheWVkIHNvIGZhci5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKiAgICAgICAgIFRoZSBwZXJjZW50YWdlIG9mIG1lZGlhIHBsYXllZCBzbyBmYXIgKDAgdG8gMSkuXHJcbiAgICovXHJcblxyXG5cclxuICBTZWVrQmFyLnByb3RvdHlwZS5nZXRQZXJjZW50ID0gZnVuY3Rpb24gZ2V0UGVyY2VudCgpIHtcclxuXHJcbiAgICAvLyBBbGxvd3MgZm9yIHNtb290aCBzY3J1YmJpbmcsIHdoZW4gcGxheWVyIGNhbid0IGtlZXAgdXAuXHJcbiAgICB2YXIgdGltZSA9IHRoaXMucGxheWVyXy5zY3J1YmJpbmcoKSA/IHRoaXMucGxheWVyXy5nZXRDYWNoZSgpLmN1cnJlbnRUaW1lIDogdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCk7XHJcblxyXG4gICAgdmFyIHBlcmNlbnQgPSB0aW1lIC8gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XHJcblxyXG4gICAgcmV0dXJuIHBlcmNlbnQgPj0gMSA/IDEgOiBwZXJjZW50O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBtb3VzZSBkb3duIG9uIHNlZWsgYmFyXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICBUaGUgYG1vdXNlZG93bmAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byBydW4uXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cclxuICAgKi9cclxuXHJcblxyXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xyXG4gICAgdGhpcy5wbGF5ZXJfLnNjcnViYmluZyh0cnVlKTtcclxuXHJcbiAgICB0aGlzLnZpZGVvV2FzUGxheWluZyA9ICF0aGlzLnBsYXllcl8ucGF1c2VkKCk7XHJcbiAgICB0aGlzLnBsYXllcl8ucGF1c2UoKTtcclxuXHJcbiAgICBfU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24uY2FsbCh0aGlzLCBldmVudCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIG1vdXNlIG1vdmUgb24gc2VlayBiYXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIFRoZSBgbW91c2Vtb3ZlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIG1vdXNlbW92ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgU2Vla0Jhci5wcm90b3R5cGUuaGFuZGxlTW91c2VNb3ZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7XHJcbiAgICB2YXIgbmV3VGltZSA9IHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpICogdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCk7XHJcblxyXG4gICAgLy8gRG9uJ3QgbGV0IHZpZGVvIGVuZCB3aGlsZSBzY3J1YmJpbmcuXHJcbiAgICBpZiAobmV3VGltZSA9PT0gdGhpcy5wbGF5ZXJfLmR1cmF0aW9uKCkpIHtcclxuICAgICAgbmV3VGltZSA9IG5ld1RpbWUgLSAwLjE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IG5ldyB0aW1lICh0ZWxsIHBsYXllciB0byBzZWVrIHRvIG5ldyB0aW1lKVxyXG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKG5ld1RpbWUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBtb3VzZSB1cCBvbiBzZWVrIGJhclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcclxuICAgKiAgICAgICAgVGhlIGBtb3VzZXVwYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIHRvIHJ1bi5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIG1vdXNldXBcclxuICAgKi9cclxuXHJcblxyXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGV2ZW50KSB7XHJcbiAgICBfU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwLmNhbGwodGhpcywgZXZlbnQpO1xyXG5cclxuICAgIHRoaXMucGxheWVyXy5zY3J1YmJpbmcoZmFsc2UpO1xyXG4gICAgaWYgKHRoaXMudmlkZW9XYXNQbGF5aW5nKSB7XHJcbiAgICAgIHRoaXMucGxheWVyXy5wbGF5KCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogTW92ZSBtb3JlIHF1aWNrbHkgZmFzdCBmb3J3YXJkIGZvciBrZXlib2FyZC1vbmx5IHVzZXJzXHJcbiAgICovXHJcblxyXG5cclxuICBTZWVrQmFyLnByb3RvdHlwZS5zdGVwRm9yd2FyZCA9IGZ1bmN0aW9uIHN0ZXBGb3J3YXJkKCkge1xyXG4gICAgdGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpICsgU1RFUF9TRUNPTkRTKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBNb3ZlIG1vcmUgcXVpY2tseSByZXdpbmQgZm9yIGtleWJvYXJkLW9ubHkgdXNlcnNcclxuICAgKi9cclxuXHJcblxyXG4gIFNlZWtCYXIucHJvdG90eXBlLnN0ZXBCYWNrID0gZnVuY3Rpb24gc3RlcEJhY2soKSB7XHJcbiAgICB0aGlzLnBsYXllcl8uY3VycmVudFRpbWUodGhpcy5wbGF5ZXJfLmN1cnJlbnRUaW1lKCkgLSBTVEVQX1NFQ09ORFMpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRvZ2dsZXMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBwbGF5ZXJcclxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gZW50ZXIgb3Igc3BhY2UgaXMgdXNlZCBvbiB0aGUgc2Vla2JhclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcclxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxyXG4gICAqXHJcbiAgICovXHJcblxyXG5cclxuICBTZWVrQmFyLnByb3RvdHlwZS5oYW5kbGVBY3Rpb24gPSBmdW5jdGlvbiBoYW5kbGVBY3Rpb24oZXZlbnQpIHtcclxuICAgIGlmICh0aGlzLnBsYXllcl8ucGF1c2VkKCkpIHtcclxuICAgICAgdGhpcy5wbGF5ZXJfLnBsYXkoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMucGxheWVyXy5wYXVzZSgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIHRoaXMgU2Vla0JhciBoYXMgZm9jdXMgYW5kIGEga2V5IGdldHMgcHJlc3NlZCBkb3duLiBCeVxyXG4gICAqIGRlZmF1bHQgaXQgd2lsbCBjYWxsIGB0aGlzLmhhbmRsZUFjdGlvbmAgd2hlbiB0aGUga2V5IGlzIHNwYWNlIG9yIGVudGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcclxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIGtleWRvd25cclxuICAgKi9cclxuXHJcblxyXG4gIFNlZWtCYXIucHJvdG90eXBlLmhhbmRsZUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlS2V5UHJlc3MoZXZlbnQpIHtcclxuXHJcbiAgICAvLyBTdXBwb3J0IFNwYWNlICgzMikgb3IgRW50ZXIgKDEzKSBrZXkgb3BlcmF0aW9uIHRvIGZpcmUgYSBjbGljayBldmVudFxyXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAzMiB8fCBldmVudC53aGljaCA9PT0gMTMpIHtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgdGhpcy5oYW5kbGVBY3Rpb24oZXZlbnQpO1xyXG4gICAgfSBlbHNlIGlmIChfU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcykge1xyXG5cclxuICAgICAgLy8gUGFzcyBrZXlwcmVzcyBoYW5kbGluZyB1cCBmb3IgdW5zdXBwb3J0ZWQga2V5c1xyXG4gICAgICBfU2xpZGVyLnByb3RvdHlwZS5oYW5kbGVLZXlQcmVzcy5jYWxsKHRoaXMsIGV2ZW50KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4gU2Vla0JhcjtcclxufShTbGlkZXIpO1xyXG5cclxuLyoqXHJcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIGBTZWVrQmFyYFxyXG4gKlxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuXHJcblxyXG5TZWVrQmFyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcclxuICBjaGlsZHJlbjogWydsb2FkUHJvZ3Jlc3NCYXInLCAncGxheVByb2dyZXNzQmFyJ10sXHJcbiAgYmFyTmFtZTogJ3BsYXlQcm9ncmVzc0JhcidcclxufTtcclxuXHJcbi8vIE1vdXNlVGltZURpc3BsYXkgdG9vbHRpcHMgc2hvdWxkIG5vdCBiZSBhZGRlZCB0byBhIHBsYXllciBvbiBtb2JpbGUgZGV2aWNlcyBvciBJRThcclxuaWYgKCghSUVfVkVSU0lPTiB8fCBJRV9WRVJTSU9OID4gOCkgJiYgIUlTX0lPUyAmJiAhSVNfQU5EUk9JRCkge1xyXG4gIFNlZWtCYXIucHJvdG90eXBlLm9wdGlvbnNfLmNoaWxkcmVuLnNwbGljZSgxLCAwLCAnbW91c2VUaW1lRGlzcGxheScpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsbCB0aGUgdXBkYXRlIGV2ZW50IGZvciB0aGlzIFNsaWRlciB3aGVuIHRoaXMgZXZlbnQgaGFwcGVucyBvbiB0aGUgcGxheWVyLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cclxuU2Vla0Jhci5wcm90b3R5cGUucGxheWVyRXZlbnQgPSAndGltZXVwZGF0ZSc7XHJcblxyXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1NlZWtCYXInLCBTZWVrQmFyKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBwcm9ncmVzcy1jb250cm9sLmpzXHJcbiAqL1xyXG4vKipcclxuICogVGhlIFByb2dyZXNzIENvbnRyb2wgY29tcG9uZW50IGNvbnRhaW5zIHRoZSBzZWVrIGJhciwgbG9hZCBwcm9ncmVzcyxcclxuICogYW5kIHBsYXkgcHJvZ3Jlc3MuXHJcbiAqXHJcbiAqIEBleHRlbmRzIENvbXBvbmVudFxyXG4gKi9cclxuXHJcbnZhciBQcm9ncmVzc0NvbnRyb2wgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xyXG4gIGluaGVyaXRzKFByb2dyZXNzQ29udHJvbCwgX0NvbXBvbmVudCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gUHJvZ3Jlc3NDb250cm9sKHBsYXllciwgb3B0aW9ucykge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvZ3Jlc3NDb250cm9sKTtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcclxuXHJcbiAgICBfdGhpcy5oYW5kbGVNb3VzZU1vdmUgPSB0aHJvdHRsZShiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVNb3VzZU1vdmUpLCAyNSk7XHJcbiAgICBfdGhpcy5vbihfdGhpcy5lbF8sICdtb3VzZW1vdmUnLCBfdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xyXG5cclxuICAgIF90aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2VlayA9IHRocm90dGxlKGJpbmQoX3RoaXMsIF90aGlzLmhhbmRsZU1vdXNlU2VlayksIDI1KTtcclxuICAgIF90aGlzLm9uKFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXSwgX3RoaXMuaGFuZGxlTW91c2VEb3duKTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RWxlbWVudH1cclxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXHJcbiAgICovXHJcblxyXG5cclxuICBQcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XHJcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xyXG4gICAgICBjbGFzc05hbWU6ICd2anMtcHJvZ3Jlc3MtY29udHJvbCB2anMtY29udHJvbCdcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZW4gdGhlIG1vdXNlIG1vdmVzIG92ZXIgdGhlIGBQcm9ncmVzc0NvbnRyb2xgLCB0aGUgcG9pbnRlciBwb3NpdGlvblxyXG4gICAqIGdldHMgcGFzc2VkIGRvd24gdG8gdGhlIGBNb3VzZVRpbWVEaXNwbGF5YCBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICBUaGUgYG1vdXNlbW92ZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXHJcbiAgICpcclxuICAgKiBAbGlzdGVuIG1vdXNlbW92ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUHJvZ3Jlc3NDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcclxuICAgIHZhciBzZWVrQmFyID0gdGhpcy5nZXRDaGlsZCgnc2Vla0JhcicpO1xyXG4gICAgdmFyIG1vdXNlVGltZURpc3BsYXkgPSBzZWVrQmFyLmdldENoaWxkKCdtb3VzZVRpbWVEaXNwbGF5Jyk7XHJcbiAgICB2YXIgc2Vla0JhckVsID0gc2Vla0Jhci5lbCgpO1xyXG4gICAgdmFyIHNlZWtCYXJSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHNlZWtCYXJFbCk7XHJcbiAgICB2YXIgc2Vla0JhclBvaW50ID0gZ2V0UG9pbnRlclBvc2l0aW9uKHNlZWtCYXJFbCwgZXZlbnQpLng7XHJcblxyXG4gICAgLy8gVGhlIGRlZmF1bHQgc2tpbiBoYXMgYSBnYXAgb24gZWl0aGVyIHNpZGUgb2YgdGhlIGBTZWVrQmFyYC4gVGhpcyBtZWFuc1xyXG4gICAgLy8gdGhhdCBpdCdzIHBvc3NpYmxlIHRvIHRyaWdnZXIgdGhpcyBiZWhhdmlvciBvdXRzaWRlIHRoZSBib3VuZGFyaWVzIG9mXHJcbiAgICAvLyB0aGUgYFNlZWtCYXJgLiBUaGlzIGVuc3VyZXMgd2Ugc3RheSB3aXRoaW4gaXQgYXQgYWxsIHRpbWVzLlxyXG4gICAgaWYgKHNlZWtCYXJQb2ludCA+IDEpIHtcclxuICAgICAgc2Vla0JhclBvaW50ID0gMTtcclxuICAgIH0gZWxzZSBpZiAoc2Vla0JhclBvaW50IDwgMCkge1xyXG4gICAgICBzZWVrQmFyUG9pbnQgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtb3VzZVRpbWVEaXNwbGF5KSB7XHJcbiAgICAgIG1vdXNlVGltZURpc3BsYXkudXBkYXRlKHNlZWtCYXJSZWN0LCBzZWVrQmFyUG9pbnQpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgdGhyb3R0bGVkIHZlcnNpb24gb2YgdGhlIHtAbGluayBQcm9ncmVzc0NvbnRyb2wjaGFuZGxlTW91c2VTZWVrfSBsaXN0ZW5lci5cclxuICAgKlxyXG4gICAqIEBtZXRob2QgUHJvZ3Jlc3NDb250cm9sI3Rocm90dGxlZEhhbmRsZU1vdXNlU2Vla1xyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIFRoZSBgbW91c2Vtb3ZlYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW4gbW91c2Vtb3ZlXHJcbiAgICogQGxpc3RlbiB0b3VjaG1vdmVcclxuICAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIGBtb3VzZW1vdmVgIG9yIGB0b3VjaG1vdmVgIGV2ZW50cyBvbiB0aGUgYFByb2dyZXNzQ29udHJvbGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyBmdW5jdGlvblxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgbW91c2Vtb3ZlXHJcbiAgICogQGxpc3RlbnMgdG91Y2htb3ZlXHJcbiAgICovXHJcblxyXG5cclxuICBQcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLmhhbmRsZU1vdXNlU2VlayA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlU2VlayhldmVudCkge1xyXG4gICAgdmFyIHNlZWtCYXIgPSB0aGlzLmdldENoaWxkKCdzZWVrQmFyJyk7XHJcblxyXG4gICAgc2Vla0Jhci5oYW5kbGVNb3VzZU1vdmUoZXZlbnQpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBgbW91c2Vkb3duYCBvciBgdG91Y2hzdGFydGAgZXZlbnRzIG9uIHRoZSBgUHJvZ3Jlc3NDb250cm9sYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cclxuICAgKiBAbGlzdGVucyB0b3VjaHN0YXJ0XHJcbiAgICovXHJcblxyXG5cclxuICBQcm9ncmVzc0NvbnRyb2wucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xyXG4gICAgdmFyIGRvYyA9IHRoaXMuZWxfLm93bmVyRG9jdW1lbnQ7XHJcblxyXG4gICAgdGhpcy5vbihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlU2Vlayk7XHJcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNobW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VTZWVrKTtcclxuICAgIHRoaXMub24oZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XHJcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgYG1vdXNldXBgIG9yIGB0b3VjaGVuZGAgZXZlbnRzIG9uIHRoZSBgUHJvZ3Jlc3NDb250cm9sYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIGBtb3VzZXVwYCBvciBgdG91Y2hlbmRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyB0b3VjaGVuZFxyXG4gICAqIEBsaXN0ZW5zIG1vdXNldXBcclxuICAgKi9cclxuXHJcblxyXG4gIFByb2dyZXNzQ29udHJvbC5wcm90b3R5cGUuaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlVXAoZXZlbnQpIHtcclxuICAgIHZhciBkb2MgPSB0aGlzLmVsXy5vd25lckRvY3VtZW50O1xyXG5cclxuICAgIHRoaXMub2ZmKGRvYywgJ21vdXNlbW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VTZWVrKTtcclxuICAgIHRoaXMub2ZmKGRvYywgJ3RvdWNobW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VTZWVrKTtcclxuICAgIHRoaXMub2ZmKGRvYywgJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xyXG4gICAgdGhpcy5vZmYoZG9jLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBQcm9ncmVzc0NvbnRyb2w7XHJcbn0oQ29tcG9uZW50KTtcclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGBQcm9ncmVzc0NvbnRyb2xgXHJcbiAqXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5cclxuXHJcblByb2dyZXNzQ29udHJvbC5wcm90b3R5cGUub3B0aW9uc18gPSB7XHJcbiAgY2hpbGRyZW46IFsnc2Vla0JhciddXHJcbn07XHJcblxyXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1Byb2dyZXNzQ29udHJvbCcsIFByb2dyZXNzQ29udHJvbCk7XHJcblxyXG4vKipcclxuICogQGZpbGUgZnVsbHNjcmVlbi10b2dnbGUuanNcclxuICovXHJcbi8qKlxyXG4gKiBUb2dnbGUgZnVsbHNjcmVlbiB2aWRlb1xyXG4gKlxyXG4gKiBAZXh0ZW5kcyBCdXR0b25cclxuICovXHJcblxyXG52YXIgRnVsbHNjcmVlblRvZ2dsZSA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XHJcbiAgaW5oZXJpdHMoRnVsbHNjcmVlblRvZ2dsZSwgX0J1dHRvbik7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gRnVsbHNjcmVlblRvZ2dsZShwbGF5ZXIsIG9wdGlvbnMpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1bGxzY3JlZW5Ub2dnbGUpO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xyXG5cclxuICAgIF90aGlzLm9uKHBsYXllciwgJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBfdGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cclxuICAgKi9cclxuXHJcblxyXG4gIEZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xyXG4gICAgcmV0dXJuICd2anMtZnVsbHNjcmVlbi1jb250cm9sICcgKyBfQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBmdWxsc2NyZWVuY2hhbmdlIG9uIHRoZSBwbGF5ZXIgYW5kIGNoYW5nZSBjb250cm9sIHRleHQgYWNjb3JkaW5nbHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXHJcbiAgICogICAgICAgIFRoZSB7QGxpbmsgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2V9IGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcclxuICAgKiAgICAgICAgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcclxuICAgKi9cclxuXHJcblxyXG4gIEZ1bGxzY3JlZW5Ub2dnbGUucHJvdG90eXBlLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKGV2ZW50KSB7XHJcbiAgICBpZiAodGhpcy5wbGF5ZXJfLmlzRnVsbHNjcmVlbigpKSB7XHJcbiAgICAgIHRoaXMuY29udHJvbFRleHQoJ05vbi1GdWxsc2NyZWVuJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmNvbnRyb2xUZXh0KCdGdWxsc2NyZWVuJyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBGdWxsc2NyZWVuVG9nZ2xlYCBpcyBcImNsaWNrZWRcIi4gU2VlXHJcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cclxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxyXG4gICAqICAgICAgICBjYWxsZWQuXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyB0YXBcclxuICAgKiBAbGlzdGVucyBjbGlja1xyXG4gICAqL1xyXG5cclxuXHJcbiAgRnVsbHNjcmVlblRvZ2dsZS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xyXG4gICAgaWYgKCF0aGlzLnBsYXllcl8uaXNGdWxsc2NyZWVuKCkpIHtcclxuICAgICAgdGhpcy5wbGF5ZXJfLnJlcXVlc3RGdWxsc2NyZWVuKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnBsYXllcl8uZXhpdEZ1bGxzY3JlZW4oKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4gRnVsbHNjcmVlblRvZ2dsZTtcclxufShCdXR0b24pO1xyXG5cclxuLyoqXHJcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYEZ1bGxzY3JlZW5Ub2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXHJcblxyXG5cclxuRnVsbHNjcmVlblRvZ2dsZS5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ0Z1bGxzY3JlZW4nO1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdGdWxsc2NyZWVuVG9nZ2xlJywgRnVsbHNjcmVlblRvZ2dsZSk7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdm9sdW1lIGNvbnRyb2wgaXMgc3VwcG9ydGVkIGFuZCBpZiBpdCBpc24ndCBoaWRlIHRoZVxyXG4gKiBgQ29tcG9uZW50YCB0aGF0IHdhcyBwYXNzZWQgIHVzaW5nIHRoZSBgdmpzLWhpZGRlbmAgY2xhc3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBzZWxmXHJcbiAqICAgICAgICBUaGUgY29tcG9uZW50IHRoYXQgc2hvdWxkIGJlIGhpZGRlbiBpZiB2b2x1bWUgaXMgdW5zdXBwb3J0ZWRcclxuICpcclxuICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxyXG4gKiAgICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHBsYXllclxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxudmFyIGNoZWNrVm9sdW1lU3VwcG9ydCA9IGZ1bmN0aW9uIGNoZWNrVm9sdW1lU3VwcG9ydChzZWxmLCBwbGF5ZXIpIHtcclxuICAvLyBoaWRlIHZvbHVtZSBjb250cm9scyB3aGVuIHRoZXkncmUgbm90IHN1cHBvcnRlZCBieSB0aGUgY3VycmVudCB0ZWNoXHJcbiAgaWYgKHBsYXllci50ZWNoXyAmJiAhcGxheWVyLnRlY2hfLmZlYXR1cmVzVm9sdW1lQ29udHJvbCkge1xyXG4gICAgc2VsZi5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xyXG4gIH1cclxuXHJcbiAgc2VsZi5vbihwbGF5ZXIsICdsb2Fkc3RhcnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoIXBsYXllci50ZWNoXy5mZWF0dXJlc1ZvbHVtZUNvbnRyb2wpIHtcclxuICAgICAgc2VsZi5hZGRDbGFzcygndmpzLWhpZGRlbicpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2VsZi5yZW1vdmVDbGFzcygndmpzLWhpZGRlbicpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIHZvbHVtZS1sZXZlbC5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIFNob3dzIHZvbHVtZSBsZXZlbFxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcclxuICovXHJcblxyXG52YXIgVm9sdW1lTGV2ZWwgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xyXG4gIGluaGVyaXRzKFZvbHVtZUxldmVsLCBfQ29tcG9uZW50KTtcclxuXHJcbiAgZnVuY3Rpb24gVm9sdW1lTGV2ZWwoKSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWb2x1bWVMZXZlbCk7XHJcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cclxuICAgKi9cclxuICBWb2x1bWVMZXZlbC5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCgpIHtcclxuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy12b2x1bWUtbGV2ZWwnLFxyXG4gICAgICBpbm5lckhUTUw6ICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj48L3NwYW4+J1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFZvbHVtZUxldmVsO1xyXG59KENvbXBvbmVudCk7XHJcblxyXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZUxldmVsJywgVm9sdW1lTGV2ZWwpO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIHZvbHVtZS1iYXIuanNcclxuICovXHJcbi8vIFJlcXVpcmVkIGNoaWxkcmVuXHJcbi8qKlxyXG4gKiBUaGUgYmFyIHRoYXQgY29udGFpbnMgdGhlIHZvbHVtZSBsZXZlbCBhbmQgY2FuIGJlIGNsaWNrZWQgb24gdG8gYWRqdXN0IHRoZSBsZXZlbFxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBTbGlkZXJcclxuICovXHJcblxyXG52YXIgVm9sdW1lQmFyID0gZnVuY3Rpb24gKF9TbGlkZXIpIHtcclxuICBpbmhlcml0cyhWb2x1bWVCYXIsIF9TbGlkZXIpO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXHJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFZvbHVtZUJhcihwbGF5ZXIsIG9wdGlvbnMpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFZvbHVtZUJhcik7XHJcblxyXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfU2xpZGVyLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XHJcblxyXG4gICAgX3RoaXMub24oJ3NsaWRlcmFjdGl2ZScsIF90aGlzLnVwZGF0ZUxhc3RWb2x1bWVfKTtcclxuICAgIF90aGlzLm9uKHBsYXllciwgJ3ZvbHVtZWNoYW5nZScsIF90aGlzLnVwZGF0ZUFSSUFBdHRyaWJ1dGVzKTtcclxuICAgIHBsYXllci5yZWFkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBfdGhpcy51cGRhdGVBUklBQXR0cmlidXRlcygpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gX3RoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgVm9sdW1lQmFyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xyXG4gICAgcmV0dXJuIF9TbGlkZXIucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcclxuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1iYXIgdmpzLXNsaWRlci1iYXInXHJcbiAgICB9LCB7XHJcbiAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5sb2NhbGl6ZSgnVm9sdW1lIExldmVsJyksXHJcbiAgICAgICdhcmlhLWxpdmUnOiAncG9saXRlJ1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIG1vdmVtZW50IGV2ZW50cyBvbiB0aGUge0BsaW5rIFZvbHVtZU1lbnVCdXR0b259LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcclxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgbW91c2Vtb3ZlXHJcbiAgICovXHJcblxyXG5cclxuICBWb2x1bWVCYXIucHJvdG90eXBlLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xyXG4gICAgdGhpcy5jaGVja011dGVkKCk7XHJcbiAgICB0aGlzLnBsYXllcl8udm9sdW1lKHRoaXMuY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBJZiB0aGUgcGxheWVyIGlzIG11dGVkIHVubXV0ZSBpdC5cclxuICAgKi9cclxuXHJcblxyXG4gIFZvbHVtZUJhci5wcm90b3R5cGUuY2hlY2tNdXRlZCA9IGZ1bmN0aW9uIGNoZWNrTXV0ZWQoKSB7XHJcbiAgICBpZiAodGhpcy5wbGF5ZXJfLm11dGVkKCkpIHtcclxuICAgICAgdGhpcy5wbGF5ZXJfLm11dGVkKGZhbHNlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgcGVyY2VudCBvZiB2b2x1bWUgbGV2ZWxcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKiAgICAgICAgIFZvbHVtZSBsZXZlbCBwZXJjZW50IGFzIGEgZGVjaW1hbCBudW1iZXIuXHJcbiAgICovXHJcblxyXG5cclxuICBWb2x1bWVCYXIucHJvdG90eXBlLmdldFBlcmNlbnQgPSBmdW5jdGlvbiBnZXRQZXJjZW50KCkge1xyXG4gICAgaWYgKHRoaXMucGxheWVyXy5tdXRlZCgpKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMucGxheWVyXy52b2x1bWUoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBJbmNyZWFzZSB2b2x1bWUgbGV2ZWwgZm9yIGtleWJvYXJkIHVzZXJzXHJcbiAgICovXHJcblxyXG5cclxuICBWb2x1bWVCYXIucHJvdG90eXBlLnN0ZXBGb3J3YXJkID0gZnVuY3Rpb24gc3RlcEZvcndhcmQoKSB7XHJcbiAgICB0aGlzLmNoZWNrTXV0ZWQoKTtcclxuICAgIHRoaXMucGxheWVyXy52b2x1bWUodGhpcy5wbGF5ZXJfLnZvbHVtZSgpICsgMC4xKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBEZWNyZWFzZSB2b2x1bWUgbGV2ZWwgZm9yIGtleWJvYXJkIHVzZXJzXHJcbiAgICovXHJcblxyXG5cclxuICBWb2x1bWVCYXIucHJvdG90eXBlLnN0ZXBCYWNrID0gZnVuY3Rpb24gc3RlcEJhY2soKSB7XHJcbiAgICB0aGlzLmNoZWNrTXV0ZWQoKTtcclxuICAgIHRoaXMucGxheWVyXy52b2x1bWUodGhpcy5wbGF5ZXJfLnZvbHVtZSgpIC0gMC4xKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgQVJJQSBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cclxuICAgKiAgICAgICAgVGhlIGB2b2x1bWVjaGFuZ2VgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgUGxheWVyI3ZvbHVtZWNoYW5nZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgVm9sdW1lQmFyLnByb3RvdHlwZS51cGRhdGVBUklBQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHVwZGF0ZUFSSUFBdHRyaWJ1dGVzKGV2ZW50KSB7XHJcbiAgICB2YXIgYXJpYVZhbHVlID0gdGhpcy5wbGF5ZXJfLm11dGVkKCkgPyAwIDogdGhpcy52b2x1bWVBc1BlcmNlbnRhZ2VfKCk7XHJcblxyXG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVlbm93JywgYXJpYVZhbHVlKTtcclxuICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZXRleHQnLCBhcmlhVmFsdWUgKyAnJScpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHBsYXllciB2b2x1bWUgYXMgYSBwZXJjZW50YWdlXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgVm9sdW1lQmFyLnByb3RvdHlwZS52b2x1bWVBc1BlcmNlbnRhZ2VfID0gZnVuY3Rpb24gdm9sdW1lQXNQZXJjZW50YWdlXygpIHtcclxuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMucGxheWVyXy52b2x1bWUoKSAqIDEwMCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogV2hlbiB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgVm9sdW1lQmFyLCBzdG9yZSB0aGUgdm9sdW1lIGFuZCBsaXN0ZW4gZm9yXHJcbiAgICogdGhlIGVuZCBvZiB0aGUgZHJhZy4gV2hlbiB0aGUgZHJhZyBlbmRzLCBpZiB0aGUgdm9sdW1lIHdhcyBzZXQgdG8gemVybyxcclxuICAgKiBzZXQgbGFzdFZvbHVtZSB0byB0aGUgc3RvcmVkIHZvbHVtZS5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIHNsaWRlcmFjdGl2ZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBWb2x1bWVCYXIucHJvdG90eXBlLnVwZGF0ZUxhc3RWb2x1bWVfID0gZnVuY3Rpb24gdXBkYXRlTGFzdFZvbHVtZV8oKSB7XHJcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuXHJcbiAgICB2YXIgdm9sdW1lQmVmb3JlRHJhZyA9IHRoaXMucGxheWVyXy52b2x1bWUoKTtcclxuXHJcbiAgICB0aGlzLm9uZSgnc2xpZGVyaW5hY3RpdmUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChfdGhpczIucGxheWVyXy52b2x1bWUoKSA9PT0gMCkge1xyXG4gICAgICAgIF90aGlzMi5wbGF5ZXJfLmxhc3RWb2x1bWVfKHZvbHVtZUJlZm9yZURyYWcpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gVm9sdW1lQmFyO1xyXG59KFNsaWRlcik7XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgYFZvbHVtZUJhcmBcclxuICpcclxuICogQHR5cGUge09iamVjdH1cclxuICogQHByaXZhdGVcclxuICovXHJcblxyXG5cclxuVm9sdW1lQmFyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcclxuICBjaGlsZHJlbjogWyd2b2x1bWVMZXZlbCddLFxyXG4gIGJhck5hbWU6ICd2b2x1bWVMZXZlbCdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxsIHRoZSB1cGRhdGUgZXZlbnQgZm9yIHRoaXMgU2xpZGVyIHdoZW4gdGhpcyBldmVudCBoYXBwZW5zIG9uIHRoZSBwbGF5ZXIuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xyXG5Wb2x1bWVCYXIucHJvdG90eXBlLnBsYXllckV2ZW50ID0gJ3ZvbHVtZWNoYW5nZSc7XHJcblxyXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1ZvbHVtZUJhcicsIFZvbHVtZUJhcik7XHJcblxyXG4vKipcclxuICogQGZpbGUgdm9sdW1lLWNvbnRyb2wuanNcclxuICovXHJcbi8vIFJlcXVpcmVkIGNoaWxkcmVuXHJcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBjb250cm9sbGluZyB0aGUgdm9sdW1lIGxldmVsXHJcbiAqXHJcbiAqIEBleHRlbmRzIENvbXBvbmVudFxyXG4gKi9cclxuXHJcbnZhciBWb2x1bWVDb250cm9sID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcclxuICBpbmhlcml0cyhWb2x1bWVDb250cm9sLCBfQ29tcG9uZW50KTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cclxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBWb2x1bWVDb250cm9sKHBsYXllcikge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVm9sdW1lQ29udHJvbCk7XHJcblxyXG4gICAgb3B0aW9ucy52ZXJ0aWNhbCA9IG9wdGlvbnMudmVydGljYWwgfHwgZmFsc2U7XHJcblxyXG4gICAgLy8gUGFzcyB0aGUgdmVydGljYWwgb3B0aW9uIGRvd24gdG8gdGhlIFZvbHVtZUJhciBpZlxyXG4gICAgLy8gdGhlIFZvbHVtZUJhciBpcyB0dXJuZWQgb24uXHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudm9sdW1lQmFyID09PSAndW5kZWZpbmVkJyB8fCBpc1BsYWluKG9wdGlvbnMudm9sdW1lQmFyKSkge1xyXG4gICAgICBvcHRpb25zLnZvbHVtZUJhciA9IG9wdGlvbnMudm9sdW1lQmFyIHx8IHt9O1xyXG4gICAgICBvcHRpb25zLnZvbHVtZUJhci52ZXJ0aWNhbCA9IG9wdGlvbnMudmVydGljYWw7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaGlkZSB0aGlzIGNvbnRyb2wgaWYgdm9sdW1lIHN1cHBvcnQgaXMgbWlzc2luZ1xyXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XHJcblxyXG4gICAgY2hlY2tWb2x1bWVTdXBwb3J0KF90aGlzLCBwbGF5ZXIpO1xyXG5cclxuICAgIF90aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlTW92ZSA9IHRocm90dGxlKGJpbmQoX3RoaXMsIF90aGlzLmhhbmRsZU1vdXNlTW92ZSksIDI1KTtcclxuXHJcbiAgICBfdGhpcy5vbignbW91c2Vkb3duJywgX3RoaXMuaGFuZGxlTW91c2VEb3duKTtcclxuICAgIF90aGlzLm9uKCd0b3VjaHN0YXJ0JywgX3RoaXMuaGFuZGxlTW91c2VEb3duKTtcclxuXHJcbiAgICAvLyB3aGlsZSB0aGUgc2xpZGVyIGlzIGFjdGl2ZSAodGhlIG1vdXNlIGhhcyBiZWVuIHByZXNzZWQgZG93biBhbmRcclxuICAgIC8vIGlzIGRyYWdnaW5nKSBvciBpbiBmb2N1cyB3ZSBkbyBub3Qgd2FudCB0byBoaWRlIHRoZSBWb2x1bWVCYXJcclxuICAgIF90aGlzLm9uKF90aGlzLnZvbHVtZUJhciwgWydmb2N1cycsICdzbGlkZXJhY3RpdmUnXSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICBfdGhpcy52b2x1bWVCYXIuYWRkQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XHJcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xyXG4gICAgICBfdGhpcy50cmlnZ2VyKCdzbGlkZXJhY3RpdmUnKTtcclxuICAgIH0pO1xyXG5cclxuICAgIF90aGlzLm9uKF90aGlzLnZvbHVtZUJhciwgWydibHVyJywgJ3NsaWRlcmluYWN0aXZlJ10sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgX3RoaXMudm9sdW1lQmFyLnJlbW92ZUNsYXNzKCd2anMtc2xpZGVyLWFjdGl2ZScpO1xyXG4gICAgICBfdGhpcy5yZW1vdmVDbGFzcygndmpzLXNsaWRlci1hY3RpdmUnKTtcclxuICAgICAgX3RoaXMudHJpZ2dlcignc2xpZGVyaW5hY3RpdmUnKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIFZvbHVtZUNvbnRyb2wucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XHJcbiAgICB2YXIgb3JpZW50YXRpb25DbGFzcyA9ICd2anMtdm9sdW1lLWhvcml6b250YWwnO1xyXG5cclxuICAgIGlmICh0aGlzLm9wdGlvbnNfLnZlcnRpY2FsKSB7XHJcbiAgICAgIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS12ZXJ0aWNhbCc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcclxuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1jb250cm9sIHZqcy1jb250cm9sICcgKyBvcmllbnRhdGlvbkNsYXNzXHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50cyBvbiB0aGUgYFZvbHVtZUNvbnRyb2xgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcclxuICAgKiAgICAgICAgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIG1vdXNlZG93blxyXG4gICAqIEBsaXN0ZW5zIHRvdWNoc3RhcnRcclxuICAgKi9cclxuXHJcblxyXG4gIFZvbHVtZUNvbnRyb2wucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlRG93bihldmVudCkge1xyXG4gICAgdmFyIGRvYyA9IHRoaXMuZWxfLm93bmVyRG9jdW1lbnQ7XHJcblxyXG4gICAgdGhpcy5vbihkb2MsICdtb3VzZW1vdmUnLCB0aGlzLnRocm90dGxlZEhhbmRsZU1vdXNlTW92ZSk7XHJcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNobW92ZScsIHRoaXMudGhyb3R0bGVkSGFuZGxlTW91c2VNb3ZlKTtcclxuICAgIHRoaXMub24oZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XHJcbiAgICB0aGlzLm9uKGRvYywgJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgYG1vdXNldXBgIG9yIGB0b3VjaGVuZGAgZXZlbnRzIG9uIHRoZSBgVm9sdW1lQ29udHJvbGAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICBgbW91c2V1cGAgb3IgYHRvdWNoZW5kYCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgdG91Y2hlbmRcclxuICAgKiBAbGlzdGVucyBtb3VzZXVwXHJcbiAgICovXHJcblxyXG5cclxuICBWb2x1bWVDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gaGFuZGxlTW91c2VVcChldmVudCkge1xyXG4gICAgdmFyIGRvYyA9IHRoaXMuZWxfLm93bmVyRG9jdW1lbnQ7XHJcblxyXG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2Vtb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZU1vdmUpO1xyXG4gICAgdGhpcy5vZmYoZG9jLCAndG91Y2htb3ZlJywgdGhpcy50aHJvdHRsZWRIYW5kbGVNb3VzZU1vdmUpO1xyXG4gICAgdGhpcy5vZmYoZG9jLCAnbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XHJcbiAgICB0aGlzLm9mZihkb2MsICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlTW91c2VVcCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudHMgb24gdGhlIGBWb2x1bWVDb250cm9sYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBtb3VzZWRvd25cclxuICAgKiBAbGlzdGVucyB0b3VjaHN0YXJ0XHJcbiAgICovXHJcblxyXG5cclxuICBWb2x1bWVDb250cm9sLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcclxuICAgIHRoaXMudm9sdW1lQmFyLmhhbmRsZU1vdXNlTW92ZShldmVudCk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFZvbHVtZUNvbnRyb2w7XHJcbn0oQ29tcG9uZW50KTtcclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBgVm9sdW1lQ29udHJvbGBcclxuICpcclxuICogQHR5cGUge09iamVjdH1cclxuICogQHByaXZhdGVcclxuICovXHJcblxyXG5cclxuVm9sdW1lQ29udHJvbC5wcm90b3R5cGUub3B0aW9uc18gPSB7XHJcbiAgY2hpbGRyZW46IFsndm9sdW1lQmFyJ11cclxufTtcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVm9sdW1lQ29udHJvbCcsIFZvbHVtZUNvbnRyb2wpO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIG11dGUtdG9nZ2xlLmpzXHJcbiAqL1xyXG4vKipcclxuICogQSBidXR0b24gY29tcG9uZW50IGZvciBtdXRpbmcgdGhlIGF1ZGlvLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBCdXR0b25cclxuICovXHJcblxyXG52YXIgTXV0ZVRvZ2dsZSA9IGZ1bmN0aW9uIChfQnV0dG9uKSB7XHJcbiAgaW5oZXJpdHMoTXV0ZVRvZ2dsZSwgX0J1dHRvbik7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gTXV0ZVRvZ2dsZShwbGF5ZXIsIG9wdGlvbnMpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE11dGVUb2dnbGUpO1xyXG5cclxuICAgIC8vIGhpZGUgdGhpcyBjb250cm9sIGlmIHZvbHVtZSBzdXBwb3J0IGlzIG1pc3NpbmdcclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xyXG5cclxuICAgIGNoZWNrVm9sdW1lU3VwcG9ydChfdGhpcywgcGxheWVyKTtcclxuXHJcbiAgICBfdGhpcy5vbihwbGF5ZXIsIFsnbG9hZHN0YXJ0JywgJ3ZvbHVtZWNoYW5nZSddLCBfdGhpcy51cGRhdGUpO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxyXG4gICAqL1xyXG5cclxuXHJcbiAgTXV0ZVRvZ2dsZS5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XHJcbiAgICByZXR1cm4gJ3Zqcy1tdXRlLWNvbnRyb2wgJyArIF9CdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGdldHMgY2FsbGVkIHdoZW4gYW4gYE11dGVUb2dnbGVgIGlzIFwiY2xpY2tlZFwiLiBTZWVcclxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxyXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXHJcbiAgICogICAgICAgIGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIHRhcFxyXG4gICAqIEBsaXN0ZW5zIGNsaWNrXHJcbiAgICovXHJcblxyXG5cclxuICBNdXRlVG9nZ2xlLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XHJcbiAgICB2YXIgdm9sID0gdGhpcy5wbGF5ZXJfLnZvbHVtZSgpO1xyXG4gICAgdmFyIGxhc3RWb2x1bWUgPSB0aGlzLnBsYXllcl8ubGFzdFZvbHVtZV8oKTtcclxuXHJcbiAgICBpZiAodm9sID09PSAwKSB7XHJcbiAgICAgIHZhciB2b2x1bWVUb1NldCA9IGxhc3RWb2x1bWUgPCAwLjEgPyAwLjEgOiBsYXN0Vm9sdW1lO1xyXG5cclxuICAgICAgdGhpcy5wbGF5ZXJfLnZvbHVtZSh2b2x1bWVUb1NldCk7XHJcbiAgICAgIHRoaXMucGxheWVyXy5tdXRlZChmYWxzZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnBsYXllcl8ubXV0ZWQodGhpcy5wbGF5ZXJfLm11dGVkKCkgPyBmYWxzZSA6IHRydWUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgYE11dGVUb2dnbGVgIGJ1dHRvbiBiYXNlZCBvbiB0aGUgc3RhdGUgb2YgYHZvbHVtZWAgYW5kIGBtdXRlZGBcclxuICAgKiBvbiB0aGUgcGxheWVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxyXG4gICAqICAgICAgICBUaGUge0BsaW5rIFBsYXllciNsb2Fkc3RhcnR9IGV2ZW50IGlmIHRoaXMgZnVuY3Rpb24gd2FzIGNhbGxlZFxyXG4gICAqICAgICAgICB0aHJvdWdoIGFuIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgUGxheWVyI2xvYWRzdGFydFxyXG4gICAqIEBsaXN0ZW5zIFBsYXllciN2b2x1bWVjaGFuZ2VcclxuICAgKi9cclxuXHJcblxyXG4gIE11dGVUb2dnbGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xyXG4gICAgdGhpcy51cGRhdGVJY29uXygpO1xyXG4gICAgdGhpcy51cGRhdGVDb250cm9sVGV4dF8oKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGBNdXRlVG9nZ2xlYCBpY29uLlxyXG4gICAqXHJcbiAgICogUG9zc2libGUgc3RhdGVzIChnaXZlbiBgbGV2ZWxgIHZhcmlhYmxlIGJlbG93KTpcclxuICAgKiAtIDA6IGNyb3NzZWQgb3V0XHJcbiAgICogLSAxOiB6ZXJvIGJhcnMgb2Ygdm9sdW1lXHJcbiAgICogLSAyOiBvbmUgYmFyIG9mIHZvbHVtZVxyXG4gICAqIC0gMzogdHdvIGJhcnMgb2Ygdm9sdW1lXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgTXV0ZVRvZ2dsZS5wcm90b3R5cGUudXBkYXRlSWNvbl8gPSBmdW5jdGlvbiB1cGRhdGVJY29uXygpIHtcclxuICAgIHZhciB2b2wgPSB0aGlzLnBsYXllcl8udm9sdW1lKCk7XHJcbiAgICB2YXIgbGV2ZWwgPSAzO1xyXG5cclxuICAgIGlmICh2b2wgPT09IDAgfHwgdGhpcy5wbGF5ZXJfLm11dGVkKCkpIHtcclxuICAgICAgbGV2ZWwgPSAwO1xyXG4gICAgfSBlbHNlIGlmICh2b2wgPCAwLjMzKSB7XHJcbiAgICAgIGxldmVsID0gMTtcclxuICAgIH0gZWxzZSBpZiAodm9sIDwgMC42Nykge1xyXG4gICAgICBsZXZlbCA9IDI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETyBpbXByb3ZlIG11dGVkIGljb24gY2xhc3Nlc1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcclxuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbF8sICd2anMtdm9sLScgKyBpKTtcclxuICAgIH1cclxuICAgIGFkZENsYXNzKHRoaXMuZWxfLCAndmpzLXZvbC0nICsgbGV2ZWwpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIElmIGBtdXRlZGAgaGFzIGNoYW5nZWQgb24gdGhlIHBsYXllciwgdXBkYXRlIHRoZSBjb250cm9sIHRleHRcclxuICAgKiAoYHRpdGxlYCBhdHRyaWJ1dGUgb24gYHZqcy1tdXRlLWNvbnRyb2xgIGVsZW1lbnQgYW5kIGNvbnRlbnQgb2ZcclxuICAgKiBgdmpzLWNvbnRyb2wtdGV4dGAgZWxlbWVudCkuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgTXV0ZVRvZ2dsZS5wcm90b3R5cGUudXBkYXRlQ29udHJvbFRleHRfID0gZnVuY3Rpb24gdXBkYXRlQ29udHJvbFRleHRfKCkge1xyXG4gICAgdmFyIHNvdW5kT2ZmID0gdGhpcy5wbGF5ZXJfLm11dGVkKCkgfHwgdGhpcy5wbGF5ZXJfLnZvbHVtZSgpID09PSAwO1xyXG4gICAgdmFyIHRleHQgPSBzb3VuZE9mZiA/ICdVbm11dGUnIDogJ011dGUnO1xyXG5cclxuICAgIGlmICh0aGlzLmNvbnRyb2xUZXh0KCkgIT09IHRleHQpIHtcclxuICAgICAgdGhpcy5jb250cm9sVGV4dCh0ZXh0KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4gTXV0ZVRvZ2dsZTtcclxufShCdXR0b24pO1xyXG5cclxuLyoqXHJcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYE11dGVUb2dnbGVgcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXHJcblxyXG5cclxuTXV0ZVRvZ2dsZS5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ011dGUnO1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdNdXRlVG9nZ2xlJywgTXV0ZVRvZ2dsZSk7XHJcblxyXG4vKipcclxuICogQGZpbGUgdm9sdW1lLWNvbnRyb2wuanNcclxuICovXHJcbi8vIFJlcXVpcmVkIGNoaWxkcmVuXHJcbi8qKlxyXG4gKiBBIENvbXBvbmVudCB0byBjb250YWluIHRoZSBNdXRlVG9nZ2xlIGFuZCBWb2x1bWVDb250cm9sIHNvIHRoYXRcclxuICogdGhleSBjYW4gd29yayB0b2dldGhlci5cclxuICpcclxuICogQGV4dGVuZHMgQ29tcG9uZW50XHJcbiAqL1xyXG5cclxudmFyIFZvbHVtZVBhbmVsID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcclxuICBpbmhlcml0cyhWb2x1bWVQYW5lbCwgX0NvbXBvbmVudCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXHJcbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gVm9sdW1lUGFuZWwocGxheWVyKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBWb2x1bWVQYW5lbCk7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmlubGluZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgb3B0aW9ucy5pbmxpbmUgPSBvcHRpb25zLmlubGluZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9wdGlvbnMuaW5saW5lID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBwYXNzIHRoZSBpbmxpbmUgb3B0aW9uIGRvd24gdG8gdGhlIFZvbHVtZUNvbnRyb2wgYXMgdmVydGljYWwgaWZcclxuICAgIC8vIHRoZSBWb2x1bWVDb250cm9sIGlzIG9uLlxyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnZvbHVtZUNvbnRyb2wgPT09ICd1bmRlZmluZWQnIHx8IGlzUGxhaW4ob3B0aW9ucy52b2x1bWVDb250cm9sKSkge1xyXG4gICAgICBvcHRpb25zLnZvbHVtZUNvbnRyb2wgPSBvcHRpb25zLnZvbHVtZUNvbnRyb2wgfHwge307XHJcbiAgICAgIG9wdGlvbnMudm9sdW1lQ29udHJvbC52ZXJ0aWNhbCA9ICFvcHRpb25zLmlubGluZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBoaWRlIHRoaXMgY29udHJvbCBpZiB2b2x1bWUgc3VwcG9ydCBpcyBtaXNzaW5nXHJcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcclxuXHJcbiAgICBjaGVja1ZvbHVtZVN1cHBvcnQoX3RoaXMsIHBsYXllcik7XHJcblxyXG4gICAgLy8gd2hpbGUgdGhlIHNsaWRlciBpcyBhY3RpdmUgKHRoZSBtb3VzZSBoYXMgYmVlbiBwcmVzc2VkIGRvd24gYW5kXHJcbiAgICAvLyBpcyBkcmFnZ2luZykgb3IgaW4gZm9jdXMgd2UgZG8gbm90IHdhbnQgdG8gaGlkZSB0aGUgVm9sdW1lQmFyXHJcbiAgICBfdGhpcy5vbihfdGhpcy52b2x1bWVDb250cm9sLCBbJ3NsaWRlcmFjdGl2ZSddLCBfdGhpcy5zbGlkZXJBY3RpdmVfKTtcclxuICAgIF90aGlzLm9uKF90aGlzLm11dGVUb2dnbGUsICdmb2N1cycsIF90aGlzLnNsaWRlckFjdGl2ZV8pO1xyXG5cclxuICAgIF90aGlzLm9uKF90aGlzLnZvbHVtZUNvbnRyb2wsIFsnc2xpZGVyaW5hY3RpdmUnXSwgX3RoaXMuc2xpZGVySW5hY3RpdmVfKTtcclxuICAgIF90aGlzLm9uKF90aGlzLm11dGVUb2dnbGUsICdibHVyJywgX3RoaXMuc2xpZGVySW5hY3RpdmVfKTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCB2anMtc2xpZGVyLWFjdGl2ZSBjbGFzcyB0byB0aGUgVm9sdW1lUGFuZWxcclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIFZvbHVtZUNvbnRyb2wjc2xpZGVyYWN0aXZlXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIFZvbHVtZVBhbmVsLnByb3RvdHlwZS5zbGlkZXJBY3RpdmVfID0gZnVuY3Rpb24gc2xpZGVyQWN0aXZlXygpIHtcclxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyB2anMtc2xpZGVyLWFjdGl2ZSBjbGFzcyB0byB0aGUgVm9sdW1lUGFuZWxcclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIFZvbHVtZUNvbnRyb2wjc2xpZGVyaW5hY3RpdmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgVm9sdW1lUGFuZWwucHJvdG90eXBlLnNsaWRlckluYWN0aXZlXyA9IGZ1bmN0aW9uIHNsaWRlckluYWN0aXZlXygpIHtcclxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1zbGlkZXItYWN0aXZlJyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBgQ29tcG9uZW50YCdzIERPTSBlbGVtZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIFZvbHVtZVBhbmVsLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xyXG4gICAgdmFyIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS1wYW5lbC1ob3Jpem9udGFsJztcclxuXHJcbiAgICBpZiAoIXRoaXMub3B0aW9uc18uaW5saW5lKSB7XHJcbiAgICAgIG9yaWVudGF0aW9uQ2xhc3MgPSAndmpzLXZvbHVtZS1wYW5lbC12ZXJ0aWNhbCc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcclxuICAgICAgY2xhc3NOYW1lOiAndmpzLXZvbHVtZS1wYW5lbCB2anMtY29udHJvbCAnICsgb3JpZW50YXRpb25DbGFzc1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFZvbHVtZVBhbmVsO1xyXG59KENvbXBvbmVudCk7XHJcblxyXG4vKipcclxuICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgYFZvbHVtZUNvbnRyb2xgXHJcbiAqXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5cclxuXHJcblZvbHVtZVBhbmVsLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcclxuICBjaGlsZHJlbjogWydtdXRlVG9nZ2xlJywgJ3ZvbHVtZUNvbnRyb2wnXVxyXG59O1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdWb2x1bWVQYW5lbCcsIFZvbHVtZVBhbmVsKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBtZW51LmpzXHJcbiAqL1xyXG4vKipcclxuICogVGhlIE1lbnUgY29tcG9uZW50IGlzIHVzZWQgdG8gYnVpbGQgcG9wdXAgbWVudXMsIGluY2x1ZGluZyBzdWJ0aXRsZSBhbmRcclxuICogY2FwdGlvbnMgc2VsZWN0aW9uIG1lbnVzLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcclxuICovXHJcblxyXG52YXIgTWVudSA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XHJcbiAgaW5oZXJpdHMoTWVudSwgX0NvbXBvbmVudCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICB0aGUgcGxheWVyIHRoYXQgdGhpcyBjb21wb25lbnQgc2hvdWxkIGF0dGFjaCB0b1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgICAgICBPYmplY3Qgb2Ygb3B0aW9uIG5hbWVzIGFuZCB2YWx1ZXNcclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIE1lbnUocGxheWVyLCBvcHRpb25zKSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBNZW51KTtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcclxuXHJcbiAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICBfdGhpcy5tZW51QnV0dG9uXyA9IG9wdGlvbnMubWVudUJ1dHRvbjtcclxuICAgIH1cclxuXHJcbiAgICBfdGhpcy5mb2N1c2VkQ2hpbGRfID0gLTE7XHJcblxyXG4gICAgX3RoaXMub24oJ2tleWRvd24nLCBfdGhpcy5oYW5kbGVLZXlQcmVzcyk7XHJcbiAgICByZXR1cm4gX3RoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSB7QGxpbmsgTWVudUl0ZW19IHRvIHRoZSBtZW51LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBjb21wb25lbnRcclxuICAgKiAgICAgICAgVGhlIG5hbWUgb3IgaW5zdGFuY2Ugb2YgdGhlIGBNZW51SXRlbWAgdG8gYWRkLlxyXG4gICAqXHJcbiAgICovXHJcblxyXG5cclxuICBNZW51LnByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24gYWRkSXRlbShjb21wb25lbnQpIHtcclxuICAgIHRoaXMuYWRkQ2hpbGQoY29tcG9uZW50KTtcclxuICAgIGNvbXBvbmVudC5vbignY2xpY2snLCBiaW5kKHRoaXMsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAvLyBVbnByZXNzIHRoZSBhc3NvY2lhdGVkIE1lbnVCdXR0b24sIGFuZCBtb3ZlIGZvY3VzIGJhY2sgdG8gaXRcclxuICAgICAgaWYgKHRoaXMubWVudUJ1dHRvbl8pIHtcclxuICAgICAgICB0aGlzLm1lbnVCdXR0b25fLnVucHJlc3NCdXR0b24oKTtcclxuXHJcbiAgICAgICAgLy8gZG9uJ3QgZm9jdXMgbWVudSBidXR0b24gaWYgaXRlbSBpcyBhIGNhcHRpb24gc2V0dGluZ3MgaXRlbVxyXG4gICAgICAgIC8vIGJlY2F1c2UgZm9jdXMgd2lsbCBtb3ZlIGVsc2V3aGVyZSBhbmQgaXQgbG9ncyBhbiBlcnJvciBvbiBJRThcclxuICAgICAgICBpZiAoY29tcG9uZW50Lm5hbWUoKSAhPT0gJ0NhcHRpb25TZXR0aW5nc01lbnVJdGVtJykge1xyXG4gICAgICAgICAgdGhpcy5tZW51QnV0dG9uXy5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSkpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgYE1lbnVgcyBET00gZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICB0aGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkXHJcbiAgICovXHJcblxyXG5cclxuICBNZW51LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xyXG4gICAgdmFyIGNvbnRlbnRFbFR5cGUgPSB0aGlzLm9wdGlvbnNfLmNvbnRlbnRFbFR5cGUgfHwgJ3VsJztcclxuXHJcbiAgICB0aGlzLmNvbnRlbnRFbF8gPSBjcmVhdGVFbChjb250ZW50RWxUeXBlLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1tZW51LWNvbnRlbnQnXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmNvbnRlbnRFbF8uc2V0QXR0cmlidXRlKCdyb2xlJywgJ21lbnUnKTtcclxuXHJcbiAgICB2YXIgZWwgPSBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XHJcbiAgICAgIGFwcGVuZDogdGhpcy5jb250ZW50RWxfLFxyXG4gICAgICBjbGFzc05hbWU6ICd2anMtbWVudSdcclxuICAgIH0pO1xyXG5cclxuICAgIGVsLmFwcGVuZENoaWxkKHRoaXMuY29udGVudEVsXyk7XHJcblxyXG4gICAgLy8gUHJldmVudCBjbGlja3MgZnJvbSBidWJibGluZyB1cC4gTmVlZGVkIGZvciBNZW51IEJ1dHRvbnMsXHJcbiAgICAvLyB3aGVyZSBhIGNsaWNrIG9uIHRoZSBwYXJlbnQgaXMgc2lnbmlmaWNhbnRcclxuICAgIG9uKGVsLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZWw7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIGEgYGtleWRvd25gIGV2ZW50IG9uIHRoaXMgbWVudS4gVGhpcyBsaXN0ZW5lciBpcyBhZGRlZCBpbiB0aGUgY29uc3RydWN0b3IuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICBBIGBrZXlkb3duYCBldmVudCB0aGF0IGhhcHBlbmVkIG9uIHRoZSBtZW51LlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMga2V5ZG93blxyXG4gICAqL1xyXG5cclxuXHJcbiAgTWVudS5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xyXG4gICAgLy8gTGVmdCBhbmQgRG93biBBcnJvd3NcclxuICAgIGlmIChldmVudC53aGljaCA9PT0gMzcgfHwgZXZlbnQud2hpY2ggPT09IDQwKSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIHRoaXMuc3RlcEZvcndhcmQoKTtcclxuXHJcbiAgICAgIC8vIFVwIGFuZCBSaWdodCBBcnJvd3NcclxuICAgIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDM4IHx8IGV2ZW50LndoaWNoID09PSAzOSkge1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB0aGlzLnN0ZXBCYWNrKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogTW92ZSB0byBuZXh0IChsb3dlcikgbWVudSBpdGVtIGZvciBrZXlib2FyZCB1c2Vycy5cclxuICAgKi9cclxuXHJcblxyXG4gIE1lbnUucHJvdG90eXBlLnN0ZXBGb3J3YXJkID0gZnVuY3Rpb24gc3RlcEZvcndhcmQoKSB7XHJcbiAgICB2YXIgc3RlcENoaWxkID0gMDtcclxuXHJcbiAgICBpZiAodGhpcy5mb2N1c2VkQ2hpbGRfICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgc3RlcENoaWxkID0gdGhpcy5mb2N1c2VkQ2hpbGRfICsgMTtcclxuICAgIH1cclxuICAgIHRoaXMuZm9jdXMoc3RlcENoaWxkKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBNb3ZlIHRvIHByZXZpb3VzIChoaWdoZXIpIG1lbnUgaXRlbSBmb3Iga2V5Ym9hcmQgdXNlcnMuXHJcbiAgICovXHJcblxyXG5cclxuICBNZW51LnByb3RvdHlwZS5zdGVwQmFjayA9IGZ1bmN0aW9uIHN0ZXBCYWNrKCkge1xyXG4gICAgdmFyIHN0ZXBDaGlsZCA9IDA7XHJcblxyXG4gICAgaWYgKHRoaXMuZm9jdXNlZENoaWxkXyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHN0ZXBDaGlsZCA9IHRoaXMuZm9jdXNlZENoaWxkXyAtIDE7XHJcbiAgICB9XHJcbiAgICB0aGlzLmZvY3VzKHN0ZXBDaGlsZCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGZvY3VzIG9uIGEge0BsaW5rIE1lbnVJdGVtfSBpbiB0aGUgYE1lbnVgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbaXRlbT0wXVxyXG4gICAqICAgICAgICBJbmRleCBvZiBjaGlsZCBpdGVtIHNldCBmb2N1cyBvbi5cclxuICAgKi9cclxuXHJcblxyXG4gIE1lbnUucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gZm9jdXMoKSB7XHJcbiAgICB2YXIgaXRlbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcclxuXHJcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCkuc2xpY2UoKTtcclxuICAgIHZhciBoYXZlVGl0bGUgPSBjaGlsZHJlbi5sZW5ndGggJiYgY2hpbGRyZW5bMF0uY2xhc3NOYW1lICYmIC92anMtbWVudS10aXRsZS8udGVzdChjaGlsZHJlblswXS5jbGFzc05hbWUpO1xyXG5cclxuICAgIGlmIChoYXZlVGl0bGUpIHtcclxuICAgICAgY2hpbGRyZW4uc2hpZnQoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICBpZiAoaXRlbSA8IDApIHtcclxuICAgICAgICBpdGVtID0gMDtcclxuICAgICAgfSBlbHNlIGlmIChpdGVtID49IGNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgIGl0ZW0gPSBjaGlsZHJlbi5sZW5ndGggLSAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmZvY3VzZWRDaGlsZF8gPSBpdGVtO1xyXG5cclxuICAgICAgY2hpbGRyZW5baXRlbV0uZWxfLmZvY3VzKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIE1lbnU7XHJcbn0oQ29tcG9uZW50KTtcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTWVudScsIE1lbnUpO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIG1lbnUtYnV0dG9uLmpzXHJcbiAqL1xyXG4vKipcclxuICogQSBgTWVudUJ1dHRvbmAgY2xhc3MgZm9yIGFueSBwb3B1cCB7QGxpbmsgTWVudX0uXHJcbiAqXHJcbiAqIEBleHRlbmRzIENvbXBvbmVudFxyXG4gKi9cclxuXHJcbnZhciBNZW51QnV0dG9uID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcclxuICBpbmhlcml0cyhNZW51QnV0dG9uLCBfQ29tcG9uZW50KTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cclxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBNZW51QnV0dG9uKHBsYXllcikge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVudUJ1dHRvbik7XHJcblxyXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XHJcblxyXG4gICAgX3RoaXMubWVudUJ1dHRvbl8gPSBuZXcgQnV0dG9uKHBsYXllciwgb3B0aW9ucyk7XHJcblxyXG4gICAgX3RoaXMubWVudUJ1dHRvbl8uY29udHJvbFRleHQoX3RoaXMuY29udHJvbFRleHRfKTtcclxuICAgIF90aGlzLm1lbnVCdXR0b25fLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGFzcG9wdXAnLCAndHJ1ZScpO1xyXG5cclxuICAgIC8vIEFkZCBidWlsZENTU0NsYXNzIHZhbHVlcyB0byB0aGUgYnV0dG9uLCBub3QgdGhlIHdyYXBwZXJcclxuICAgIHZhciBidXR0b25DbGFzcyA9IEJ1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcygpO1xyXG5cclxuICAgIF90aGlzLm1lbnVCdXR0b25fLmVsXy5jbGFzc05hbWUgPSBfdGhpcy5idWlsZENTU0NsYXNzKCkgKyAnICcgKyBidXR0b25DbGFzcztcclxuICAgIF90aGlzLm1lbnVCdXR0b25fLnJlbW92ZUNsYXNzKCd2anMtY29udHJvbCcpO1xyXG5cclxuICAgIF90aGlzLmFkZENoaWxkKF90aGlzLm1lbnVCdXR0b25fKTtcclxuXHJcbiAgICBfdGhpcy51cGRhdGUoKTtcclxuXHJcbiAgICBfdGhpcy5lbmFibGVkXyA9IHRydWU7XHJcblxyXG4gICAgX3RoaXMub24oX3RoaXMubWVudUJ1dHRvbl8sICd0YXAnLCBfdGhpcy5oYW5kbGVDbGljayk7XHJcbiAgICBfdGhpcy5vbihfdGhpcy5tZW51QnV0dG9uXywgJ2NsaWNrJywgX3RoaXMuaGFuZGxlQ2xpY2spO1xyXG4gICAgX3RoaXMub24oX3RoaXMubWVudUJ1dHRvbl8sICdmb2N1cycsIF90aGlzLmhhbmRsZUZvY3VzKTtcclxuICAgIF90aGlzLm9uKF90aGlzLm1lbnVCdXR0b25fLCAnYmx1cicsIF90aGlzLmhhbmRsZUJsdXIpO1xyXG5cclxuICAgIF90aGlzLm9uKCdrZXlkb3duJywgX3RoaXMuaGFuZGxlU3VibWVudUtleVByZXNzKTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgbWVudSBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBvZiBpdHMgaXRlbXMuXHJcbiAgICovXHJcblxyXG5cclxuICBNZW51QnV0dG9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XHJcbiAgICB2YXIgbWVudSA9IHRoaXMuY3JlYXRlTWVudSgpO1xyXG5cclxuICAgIGlmICh0aGlzLm1lbnUpIHtcclxuICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLm1lbnUpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubWVudSA9IG1lbnU7XHJcbiAgICB0aGlzLmFkZENoaWxkKG1lbnUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhY2sgdGhlIHN0YXRlIG9mIHRoZSBtZW51IGJ1dHRvblxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5idXR0b25QcmVzc2VkXyA9IGZhbHNlO1xyXG4gICAgdGhpcy5tZW51QnV0dG9uXy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XHJcblxyXG4gICAgaWYgKHRoaXMuaXRlbXMgJiYgdGhpcy5pdGVtcy5sZW5ndGggPD0gdGhpcy5oaWRlVGhyZXNob2xkXykge1xyXG4gICAgICB0aGlzLmhpZGUoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuc2hvdygpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgbWVudSBhbmQgYWRkIGFsbCBpdGVtcyB0byBpdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge01lbnV9XHJcbiAgICogICAgICAgICBUaGUgY29uc3RydWN0ZWQgbWVudVxyXG4gICAqL1xyXG5cclxuXHJcbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlTWVudSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbnUoKSB7XHJcbiAgICB2YXIgbWVudSA9IG5ldyBNZW51KHRoaXMucGxheWVyXywgeyBtZW51QnV0dG9uOiB0aGlzIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGlkZSB0aGUgbWVudSBpZiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGlzIHRocmVzaG9sZC4gVGhpcyBkZWZhdWx0c1xyXG4gICAgICogdG8gMCBhbmQgd2hlbmV2ZXIgd2UgYWRkIGl0ZW1zIHdoaWNoIGNhbiBiZSBoaWRkZW4gdG8gdGhlIG1lbnUgd2UnbGwgaW5jcmVtZW50IGl0LiBXZSBsaXN0XHJcbiAgICAgKiBpdCBoZXJlIGJlY2F1c2UgZXZlcnkgdGltZSB3ZSBydW4gYGNyZWF0ZU1lbnVgIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gPSAwO1xyXG5cclxuICAgIC8vIEFkZCBhIHRpdGxlIGxpc3QgaXRlbSB0byB0aGUgdG9wXHJcbiAgICBpZiAodGhpcy5vcHRpb25zXy50aXRsZSkge1xyXG4gICAgICB2YXIgdGl0bGUgPSBjcmVhdGVFbCgnbGknLCB7XHJcbiAgICAgICAgY2xhc3NOYW1lOiAndmpzLW1lbnUtdGl0bGUnLFxyXG4gICAgICAgIGlubmVySFRNTDogdG9UaXRsZUNhc2UodGhpcy5vcHRpb25zXy50aXRsZSksXHJcbiAgICAgICAgdGFiSW5kZXg6IC0xXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdGhpcy5oaWRlVGhyZXNob2xkXyArPSAxO1xyXG5cclxuICAgICAgbWVudS5jaGlsZHJlbl8udW5zaGlmdCh0aXRsZSk7XHJcbiAgICAgIHByZXBlbmRUbyh0aXRsZSwgbWVudS5jb250ZW50RWwoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pdGVtcyA9IHRoaXMuY3JlYXRlSXRlbXMoKTtcclxuXHJcbiAgICBpZiAodGhpcy5pdGVtcykge1xyXG4gICAgICAvLyBBZGQgbWVudSBpdGVtcyB0byB0aGUgbWVudVxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBtZW51LmFkZEl0ZW0odGhpcy5pdGVtc1tpXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWVudTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIGxpc3Qgb2YgbWVudSBpdGVtcy4gU3BlY2lmaWMgdG8gZWFjaCBzdWJjbGFzcy5cclxuICAgKlxyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqL1xyXG5cclxuXHJcbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMgPSBmdW5jdGlvbiBjcmVhdGVJdGVtcygpIHt9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIGBNZW51QnV0dG9uc2BzIERPTSBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RWxlbWVudH1cclxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgZ2V0cyBjcmVhdGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuY3JlYXRlRWwgPSBmdW5jdGlvbiBjcmVhdGVFbCQkMSgpIHtcclxuICAgIHJldHVybiBfQ29tcG9uZW50LnByb3RvdHlwZS5jcmVhdGVFbC5jYWxsKHRoaXMsICdkaXYnLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZFdyYXBwZXJDU1NDbGFzcygpXHJcbiAgICB9LCB7fSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQWxsb3cgc3ViIGNvbXBvbmVudHMgdG8gc3RhY2sgQ1NTIGNsYXNzIG5hbWVzIGZvciB0aGUgd3JhcHBlciBlbGVtZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICogICAgICAgICBUaGUgY29uc3RydWN0ZWQgd3JhcHBlciBET00gYGNsYXNzTmFtZWBcclxuICAgKi9cclxuXHJcblxyXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XHJcbiAgICB2YXIgbWVudUJ1dHRvbkNsYXNzID0gJ3Zqcy1tZW51LWJ1dHRvbic7XHJcblxyXG4gICAgLy8gSWYgdGhlIGlubGluZSBvcHRpb24gaXMgcGFzc2VkLCB3ZSB3YW50IHRvIHVzZSBkaWZmZXJlbnQgc3R5bGVzIGFsdG9nZXRoZXIuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zXy5pbmxpbmUgPT09IHRydWUpIHtcclxuICAgICAgbWVudUJ1dHRvbkNsYXNzICs9ICctaW5saW5lJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLXBvcHVwJztcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBGaXggdGhlIENTUyBzbyB0aGF0IHRoaXMgaXNuJ3QgbmVjZXNzYXJ5XHJcbiAgICB2YXIgYnV0dG9uQ2xhc3MgPSBCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MoKTtcclxuXHJcbiAgICByZXR1cm4gJ3Zqcy1tZW51LWJ1dHRvbiAnICsgbWVudUJ1dHRvbkNsYXNzICsgJyAnICsgYnV0dG9uQ2xhc3MgKyAnICcgKyBfQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZENTU0NsYXNzLmNhbGwodGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxyXG4gICAqL1xyXG5cclxuXHJcbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XHJcbiAgICB2YXIgbWVudUJ1dHRvbkNsYXNzID0gJ3Zqcy1tZW51LWJ1dHRvbic7XHJcblxyXG4gICAgLy8gSWYgdGhlIGlubGluZSBvcHRpb24gaXMgcGFzc2VkLCB3ZSB3YW50IHRvIHVzZSBkaWZmZXJlbnQgc3R5bGVzIGFsdG9nZXRoZXIuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zXy5pbmxpbmUgPT09IHRydWUpIHtcclxuICAgICAgbWVudUJ1dHRvbkNsYXNzICs9ICctaW5saW5lJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1lbnVCdXR0b25DbGFzcyArPSAnLXBvcHVwJztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gJ3Zqcy1tZW51LWJ1dHRvbiAnICsgbWVudUJ1dHRvbkNsYXNzICsgJyAnICsgX0NvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBvciBzZXQgdGhlIGxvY2FsaXplZCBjb250cm9sIHRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIGFjY2Vzc2liaWxpdHkuXHJcbiAgICpcclxuICAgKiA+IE5PVEU6IFRoaXMgd2lsbCBjb21lIGZyb20gdGhlIGludGVybmFsIGBtZW51QnV0dG9uX2AgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dF1cclxuICAgKiAgICAgICAgQ29udHJvbCB0ZXh0IGZvciBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBbZWw9dGhpcy5tZW51QnV0dG9uXy5lbCgpXVxyXG4gICAqICAgICAgICBFbGVtZW50IHRvIHNldCB0aGUgdGl0bGUgb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICogICAgICAgICAtIFRoZSBjb250cm9sIHRleHQgd2hlbiBnZXR0aW5nXHJcbiAgICovXHJcblxyXG5cclxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dCA9IGZ1bmN0aW9uIGNvbnRyb2xUZXh0KHRleHQpIHtcclxuICAgIHZhciBlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5tZW51QnV0dG9uXy5lbCgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLm1lbnVCdXR0b25fLmNvbnRyb2xUZXh0KHRleHQsIGVsKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgYSBjbGljayBvbiBhIGBNZW51QnV0dG9uYC5cclxuICAgKiBTZWUge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVDbGlja30gZm9yIGluc3RhbmNlcyB3aGVyZSB0aGlzIGlzIGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcclxuICAgKiAgICAgICAgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgdGFwXHJcbiAgICogQGxpc3RlbnMgY2xpY2tcclxuICAgKi9cclxuXHJcblxyXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcclxuICAgIC8vIFdoZW4geW91IGNsaWNrIHRoZSBidXR0b24gaXQgYWRkcyBmb2N1cywgd2hpY2ggd2lsbCBzaG93IHRoZSBtZW51LlxyXG4gICAgLy8gU28gd2UnbGwgcmVtb3ZlIGZvY3VzIHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgYnV0dG9uLiBGb2N1cyBpcyBuZWVkZWRcclxuICAgIC8vIGZvciB0YWIgbmF2aWdhdGlvbi5cclxuXHJcbiAgICB0aGlzLm9uZSh0aGlzLm1lbnUuY29udGVudEVsKCksICdtb3VzZWxlYXZlJywgYmluZCh0aGlzLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICB0aGlzLnVucHJlc3NCdXR0b24oKTtcclxuICAgICAgdGhpcy5lbF8uYmx1cigpO1xyXG4gICAgfSkpO1xyXG4gICAgaWYgKHRoaXMuYnV0dG9uUHJlc3NlZF8pIHtcclxuICAgICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnByZXNzQnV0dG9uKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBmb2N1cyB0byB0aGUgYWN0dWFsIGJ1dHRvbiwgbm90IHRvIHRoaXMgZWxlbWVudFxyXG4gICAqL1xyXG5cclxuXHJcbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiBmb2N1cygpIHtcclxuICAgIHRoaXMubWVudUJ1dHRvbl8uZm9jdXMoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgdGhlIGZvY3VzIGZyb20gdGhlIGFjdHVhbCBidXR0b24sIG5vdCB0aGlzIGVsZW1lbnRcclxuICAgKi9cclxuXHJcblxyXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiBibHVyKCkge1xyXG4gICAgdGhpcy5tZW51QnV0dG9uXy5ibHVyKCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGEgYE1lbnVCdXR0b25gIGdhaW5zIGZvY3VzIHZpYSBhIGBmb2N1c2AgZXZlbnQuXHJcbiAgICogVHVybnMgb24gbGlzdGVuaW5nIGZvciBga2V5ZG93bmAgZXZlbnRzLiBXaGVuIHRoZXkgaGFwcGVuIGl0XHJcbiAgICogY2FsbHMgYHRoaXMuaGFuZGxlS2V5UHJlc3NgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcclxuICAgKiAgICAgICAgVGhlIGBmb2N1c2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBmb2N1c1xyXG4gICAqL1xyXG5cclxuXHJcbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlRm9jdXMgPSBmdW5jdGlvbiBoYW5kbGVGb2N1cygpIHtcclxuICAgIG9uKGRvY3VtZW50XzEsICdrZXlkb3duJywgYmluZCh0aGlzLCB0aGlzLmhhbmRsZUtleVByZXNzKSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW4gYSBgTWVudUJ1dHRvbmAgbG9zZXMgZm9jdXMuIFR1cm5zIG9mZiB0aGUgbGlzdGVuZXIgZm9yXHJcbiAgICogYGtleWRvd25gIGV2ZW50cy4gV2hpY2ggU3RvcHMgYHRoaXMuaGFuZGxlS2V5UHJlc3NgIGZyb20gZ2V0dGluZyBjYWxsZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICBUaGUgYGJsdXJgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgYmx1clxyXG4gICAqL1xyXG5cclxuXHJcbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQmx1ciA9IGZ1bmN0aW9uIGhhbmRsZUJsdXIoKSB7XHJcbiAgICBvZmYoZG9jdW1lbnRfMSwgJ2tleWRvd24nLCBiaW5kKHRoaXMsIHRoaXMuaGFuZGxlS2V5UHJlc3MpKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgdGFiLCBlc2NhcGUsIGRvd24gYXJyb3csIGFuZCB1cCBhcnJvdyBrZXlzIGZvciBgTWVudUJ1dHRvbmAuIFNlZVxyXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnQjaGFuZGxlS2V5UHJlc3N9IGZvciBpbnN0YW5jZXMgd2hlcmUgdGhpcyBpcyBjYWxsZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmUgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMga2V5ZG93blxyXG4gICAqL1xyXG5cclxuXHJcbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldmVudCkge1xyXG5cclxuICAgIC8vIEVzY2FwZSAoMjcpIGtleSBvciBUYWIgKDkpIGtleSB1bnByZXNzIHRoZSAnYnV0dG9uJ1xyXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAyNyB8fCBldmVudC53aGljaCA9PT0gOSkge1xyXG4gICAgICBpZiAodGhpcy5idXR0b25QcmVzc2VkXykge1xyXG4gICAgICAgIHRoaXMudW5wcmVzc0J1dHRvbigpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIERvbid0IHByZXZlbnREZWZhdWx0IGZvciBUYWIga2V5IC0gd2Ugc3RpbGwgd2FudCB0byBsb3NlIGZvY3VzXHJcbiAgICAgIGlmIChldmVudC53aGljaCAhPT0gOSkge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgLy8gU2V0IGZvY3VzIGJhY2sgdG8gdGhlIG1lbnUgYnV0dG9uJ3MgYnV0dG9uXHJcbiAgICAgICAgdGhpcy5tZW51QnV0dG9uXy5lbF8uZm9jdXMoKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBVcCAoMzgpIGtleSBvciBEb3duICg0MCkga2V5IHByZXNzIHRoZSAnYnV0dG9uJ1xyXG4gICAgfSBlbHNlIGlmIChldmVudC53aGljaCA9PT0gMzggfHwgZXZlbnQud2hpY2ggPT09IDQwKSB7XHJcbiAgICAgIGlmICghdGhpcy5idXR0b25QcmVzc2VkXykge1xyXG4gICAgICAgIHRoaXMucHJlc3NCdXR0b24oKTtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIGEgYGtleWRvd25gIGV2ZW50IG9uIGEgc3ViLW1lbnUuIFRoZSBsaXN0ZW5lciBmb3IgdGhpcyBpcyBhZGRlZCBpblxyXG4gICAqIHRoZSBjb25zdHJ1Y3Rvci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIEtleSBwcmVzcyBldmVudFxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMga2V5ZG93blxyXG4gICAqL1xyXG5cclxuXHJcbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlU3VibWVudUtleVByZXNzID0gZnVuY3Rpb24gaGFuZGxlU3VibWVudUtleVByZXNzKGV2ZW50KSB7XHJcblxyXG4gICAgLy8gRXNjYXBlICgyNykga2V5IG9yIFRhYiAoOSkga2V5IHVucHJlc3MgdGhlICdidXR0b24nXHJcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDI3IHx8IGV2ZW50LndoaWNoID09PSA5KSB7XHJcbiAgICAgIGlmICh0aGlzLmJ1dHRvblByZXNzZWRfKSB7XHJcbiAgICAgICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gRG9uJ3QgcHJldmVudERlZmF1bHQgZm9yIFRhYiBrZXkgLSB3ZSBzdGlsbCB3YW50IHRvIGxvc2UgZm9jdXNcclxuICAgICAgaWYgKGV2ZW50LndoaWNoICE9PSA5KSB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAvLyBTZXQgZm9jdXMgYmFjayB0byB0aGUgbWVudSBidXR0b24ncyBidXR0b25cclxuICAgICAgICB0aGlzLm1lbnVCdXR0b25fLmVsXy5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUHV0IHRoZSBjdXJyZW50IGBNZW51QnV0dG9uYCBpbnRvIGEgcHJlc3NlZCBzdGF0ZS5cclxuICAgKi9cclxuXHJcblxyXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLnByZXNzQnV0dG9uID0gZnVuY3Rpb24gcHJlc3NCdXR0b24oKSB7XHJcbiAgICBpZiAodGhpcy5lbmFibGVkXykge1xyXG4gICAgICB0aGlzLmJ1dHRvblByZXNzZWRfID0gdHJ1ZTtcclxuICAgICAgdGhpcy5tZW51LmxvY2tTaG93aW5nKCk7XHJcbiAgICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XHJcbiAgICAgIC8vIHNldCB0aGUgZm9jdXMgaW50byB0aGUgc3VibWVudVxyXG4gICAgICB0aGlzLm1lbnUuZm9jdXMoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUYWtlIHRoZSBjdXJyZW50IGBNZW51QnV0dG9uYCBvdXQgb2YgYSBwcmVzc2VkIHN0YXRlLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgTWVudUJ1dHRvbi5wcm90b3R5cGUudW5wcmVzc0J1dHRvbiA9IGZ1bmN0aW9uIHVucHJlc3NCdXR0b24oKSB7XHJcbiAgICBpZiAodGhpcy5lbmFibGVkXykge1xyXG4gICAgICB0aGlzLmJ1dHRvblByZXNzZWRfID0gZmFsc2U7XHJcbiAgICAgIHRoaXMubWVudS51bmxvY2tTaG93aW5nKCk7XHJcbiAgICAgIHRoaXMubWVudUJ1dHRvbl8uZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc2FibGUgdGhlIGBNZW51QnV0dG9uYC4gRG9uJ3QgYWxsb3cgaXQgdG8gYmUgY2xpY2tlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIE1lbnVCdXR0b24ucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xyXG4gICAgdGhpcy51bnByZXNzQnV0dG9uKCk7XHJcblxyXG4gICAgdGhpcy5lbmFibGVkXyA9IGZhbHNlO1xyXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWRpc2FibGVkJyk7XHJcblxyXG4gICAgdGhpcy5tZW51QnV0dG9uXy5kaXNhYmxlKCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRW5hYmxlIHRoZSBgTWVudUJ1dHRvbmAuIEFsbG93IGl0IHRvIGJlIGNsaWNrZWQuXHJcbiAgICovXHJcblxyXG5cclxuICBNZW51QnV0dG9uLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiBlbmFibGUoKSB7XHJcbiAgICB0aGlzLmVuYWJsZWRfID0gdHJ1ZTtcclxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1kaXNhYmxlZCcpO1xyXG5cclxuICAgIHRoaXMubWVudUJ1dHRvbl8uZW5hYmxlKCk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIE1lbnVCdXR0b247XHJcbn0oQ29tcG9uZW50KTtcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnTWVudUJ1dHRvbicsIE1lbnVCdXR0b24pO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIHRyYWNrLWJ1dHRvbi5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBidXR0b25zIHRoYXQgdG9nZ2xlIHNwZWNpZmljICB0cmFjayB0eXBlcyAoZS5nLiBzdWJ0aXRsZXMpLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBNZW51QnV0dG9uXHJcbiAqL1xyXG5cclxudmFyIFRyYWNrQnV0dG9uID0gZnVuY3Rpb24gKF9NZW51QnV0dG9uKSB7XHJcbiAgaW5oZXJpdHMoVHJhY2tCdXR0b24sIF9NZW51QnV0dG9uKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBUcmFja0J1dHRvbihwbGF5ZXIsIG9wdGlvbnMpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYWNrQnV0dG9uKTtcclxuXHJcbiAgICB2YXIgdHJhY2tzID0gb3B0aW9ucy50cmFja3M7XHJcblxyXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVudUJ1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xyXG5cclxuICAgIGlmIChfdGhpcy5pdGVtcy5sZW5ndGggPD0gMSkge1xyXG4gICAgICBfdGhpcy5oaWRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0cmFja3MpIHtcclxuICAgICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB1cGRhdGVIYW5kbGVyID0gYmluZChfdGhpcywgX3RoaXMudXBkYXRlKTtcclxuXHJcbiAgICB0cmFja3MuYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB1cGRhdGVIYW5kbGVyKTtcclxuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHVwZGF0ZUhhbmRsZXIpO1xyXG4gICAgX3RoaXMucGxheWVyXy5vbigncmVhZHknLCB1cGRhdGVIYW5kbGVyKTtcclxuXHJcbiAgICBfdGhpcy5wbGF5ZXJfLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCB1cGRhdGVIYW5kbGVyKTtcclxuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FkZHRyYWNrJywgdXBkYXRlSGFuZGxlcik7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIHJldHVybiBUcmFja0J1dHRvbjtcclxufShNZW51QnV0dG9uKTtcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVHJhY2tCdXR0b24nLCBUcmFja0J1dHRvbik7XHJcblxyXG4vKipcclxuICogQGZpbGUgbWVudS1pdGVtLmpzXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgYSBtZW51IGl0ZW0uIGA8bGk+YFxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBDbGlja2FibGVDb21wb25lbnRcclxuICovXHJcblxyXG52YXIgTWVudUl0ZW0gPSBmdW5jdGlvbiAoX0NsaWNrYWJsZUNvbXBvbmVudCkge1xyXG4gIGluaGVyaXRzKE1lbnVJdGVtLCBfQ2xpY2thYmxlQ29tcG9uZW50KTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXHJcbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE1lbnVJdGVtKTtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9DbGlja2FibGVDb21wb25lbnQuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcclxuXHJcbiAgICBfdGhpcy5zZWxlY3RhYmxlID0gb3B0aW9ucy5zZWxlY3RhYmxlO1xyXG5cclxuICAgIF90aGlzLnNlbGVjdGVkKG9wdGlvbnMuc2VsZWN0ZWQpO1xyXG5cclxuICAgIGlmIChfdGhpcy5zZWxlY3RhYmxlKSB7XHJcbiAgICAgIC8vIFRPRE86IE1heSBuZWVkIHRvIGJlIGVpdGhlciBtZW51aXRlbWNoZWNrYm94IG9yIG1lbnVpdGVtcmFkaW8sXHJcbiAgICAgIC8vICAgICAgIGFuZCBtYXkgbmVlZCBsb2dpY2FsIGdyb3VwaW5nIG9mIG1lbnUgaXRlbXMuXHJcbiAgICAgIF90aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbWVudWl0ZW1jaGVja2JveCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgX3RoaXMuZWxfLnNldEF0dHJpYnV0ZSgncm9sZScsICdtZW51aXRlbScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBgTWVudUl0ZW0ncyBET00gZWxlbWVudFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlPWxpXVxyXG4gICAqICAgICAgICBFbGVtZW50J3Mgbm9kZSB0eXBlLCBub3QgYWN0dWFsbHkgdXNlZCwgYWx3YXlzIHNldCB0byBgbGlgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcz17fV1cclxuICAgKiAgICAgICAgQW4gb2JqZWN0IG9mIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgc2V0IG9uIHRoZSBlbGVtZW50XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJzPXt9XVxyXG4gICAqICAgICAgICBBbiBvYmplY3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIE1lbnVJdGVtLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKHR5cGUsIHByb3BzLCBhdHRycykge1xyXG4gICAgLy8gVGhlIGNvbnRyb2wgaXMgdGV4dHVhbCwgbm90IGp1c3QgYW4gaWNvblxyXG4gICAgdGhpcy5ub25JY29uQ29udHJvbCA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIF9DbGlja2FibGVDb21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2xpJywgYXNzaWduKHtcclxuICAgICAgY2xhc3NOYW1lOiAndmpzLW1lbnUtaXRlbScsXHJcbiAgICAgIGlubmVySFRNTDogJzxzcGFuIGNsYXNzPVwidmpzLW1lbnUtaXRlbS10ZXh0XCI+JyArIHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zXy5sYWJlbCkgKyAnPC9zcGFuPicsXHJcbiAgICAgIHRhYkluZGV4OiAtMVxyXG4gICAgfSwgcHJvcHMpLCBhdHRycyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQW55IGNsaWNrIG9uIGEgYE1lbnVJdGVtYCBwdXRzIGludCBpbnRvIHRoZSBzZWxlY3RlZCBzdGF0ZS5cclxuICAgKiBTZWUge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudCNoYW5kbGVDbGlja30gZm9yIGluc3RhbmNlcyB3aGVyZSB0aGlzIGlzIGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcclxuICAgKiAgICAgICAgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgdGFwXHJcbiAgICogQGxpc3RlbnMgY2xpY2tcclxuICAgKi9cclxuXHJcblxyXG4gIE1lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XHJcbiAgICB0aGlzLnNlbGVjdGVkKHRydWUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgc3RhdGUgZm9yIHRoaXMgbWVudSBpdGVtIGFzIHNlbGVjdGVkIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcclxuICAgKiAgICAgICAgaWYgdGhlIG1lbnUgaXRlbSBpcyBzZWxlY3RlZCBvciBub3RcclxuICAgKi9cclxuXHJcblxyXG4gIE1lbnVJdGVtLnByb3RvdHlwZS5zZWxlY3RlZCA9IGZ1bmN0aW9uIHNlbGVjdGVkKF9zZWxlY3RlZCkge1xyXG4gICAgaWYgKHRoaXMuc2VsZWN0YWJsZSkge1xyXG4gICAgICBpZiAoX3NlbGVjdGVkKSB7XHJcbiAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXNlbGVjdGVkJyk7XHJcbiAgICAgICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnLCAndHJ1ZScpO1xyXG4gICAgICAgIC8vIGFyaWEtY2hlY2tlZCBpc24ndCBmdWxseSBzdXBwb3J0ZWQgYnkgYnJvd3NlcnMvc2NyZWVuIHJlYWRlcnMsXHJcbiAgICAgICAgLy8gc28gaW5kaWNhdGUgc2VsZWN0ZWQgc3RhdGUgdG8gc2NyZWVuIHJlYWRlciBpbiB0aGUgY29udHJvbCB0ZXh0LlxyXG4gICAgICAgIHRoaXMuY29udHJvbFRleHQoJywgc2VsZWN0ZWQnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2VsZWN0ZWQnKTtcclxuICAgICAgICB0aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcsICdmYWxzZScpO1xyXG4gICAgICAgIC8vIEluZGljYXRlIHVuLXNlbGVjdGVkIHN0YXRlIHRvIHNjcmVlbiByZWFkZXJcclxuICAgICAgICAvLyBOb3RlIHRoYXQgYSBzcGFjZSBjbGVhcnMgb3V0IHRoZSBzZWxlY3RlZCBzdGF0ZSB0ZXh0XHJcbiAgICAgICAgdGhpcy5jb250cm9sVGV4dCgnICcpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIE1lbnVJdGVtO1xyXG59KENsaWNrYWJsZUNvbXBvbmVudCk7XHJcblxyXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ01lbnVJdGVtJywgTWVudUl0ZW0pO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIHRleHQtdHJhY2stbWVudS1pdGVtLmpzXHJcbiAqL1xyXG4vKipcclxuICogVGhlIHNwZWNpZmljIG1lbnUgaXRlbSB0eXBlIGZvciBzZWxlY3RpbmcgYSBsYW5ndWFnZSB3aXRoaW4gYSB0ZXh0IHRyYWNrIGtpbmRcclxuICpcclxuICogQGV4dGVuZHMgTWVudUl0ZW1cclxuICovXHJcblxyXG52YXIgVGV4dFRyYWNrTWVudUl0ZW0gPSBmdW5jdGlvbiAoX01lbnVJdGVtKSB7XHJcbiAgaW5oZXJpdHMoVGV4dFRyYWNrTWVudUl0ZW0sIF9NZW51SXRlbSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gVGV4dFRyYWNrTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0VHJhY2tNZW51SXRlbSk7XHJcblxyXG4gICAgdmFyIHRyYWNrID0gb3B0aW9ucy50cmFjaztcclxuICAgIHZhciB0cmFja3MgPSBwbGF5ZXIudGV4dFRyYWNrcygpO1xyXG5cclxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxyXG4gICAgb3B0aW9ucy5sYWJlbCA9IHRyYWNrLmxhYmVsIHx8IHRyYWNrLmxhbmd1YWdlIHx8ICdVbmtub3duJztcclxuICAgIG9wdGlvbnMuc2VsZWN0ZWQgPSB0cmFjay5tb2RlID09PSAnc2hvd2luZyc7XHJcblxyXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVudUl0ZW0uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcclxuXHJcbiAgICBfdGhpcy50cmFjayA9IHRyYWNrO1xyXG4gICAgdmFyIGNoYW5nZUhhbmRsZXIgPSBiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UpO1xyXG4gICAgdmFyIHNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2VIYW5kbGVyID0gYmluZChfdGhpcywgX3RoaXMuaGFuZGxlU2VsZWN0ZWRMYW5ndWFnZUNoYW5nZSk7XHJcblxyXG4gICAgcGxheWVyLm9uKFsnbG9hZHN0YXJ0JywgJ3RleHR0cmFja2NoYW5nZSddLCBjaGFuZ2VIYW5kbGVyKTtcclxuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcclxuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RlZGxhbmd1YWdlY2hhbmdlJywgc2VsZWN0ZWRMYW5ndWFnZUNoYW5nZUhhbmRsZXIpO1xyXG4gICAgX3RoaXMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcclxuICAgICAgdHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdGVkbGFuZ3VhZ2VjaGFuZ2UnLCBzZWxlY3RlZExhbmd1YWdlQ2hhbmdlSGFuZGxlcik7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBpT1M3IGRvZXNuJ3QgZGlzcGF0Y2ggY2hhbmdlIGV2ZW50cyB0byBUZXh0VHJhY2tMaXN0cyB3aGVuIGFuXHJcbiAgICAvLyBhc3NvY2lhdGVkIHRyYWNrJ3MgbW9kZSBjaGFuZ2VzLiBXaXRob3V0IHNvbWV0aGluZyBsaWtlXHJcbiAgICAvLyBPYmplY3Qub2JzZXJ2ZSgpIChhbHNvIG5vdCBwcmVzZW50IG9uIGlPUzcpLCBpdCdzIG5vdFxyXG4gICAgLy8gcG9zc2libGUgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gdGhlIG1vZGUgYXR0cmlidXRlIGFuZCBwb2x5ZmlsbFxyXG4gICAgLy8gdGhlIGNoYW5nZSBldmVudC4gQXMgYSBwb29yIHN1YnN0aXR1dGUsIHdlIG1hbnVhbGx5IGRpc3BhdGNoXHJcbiAgICAvLyBjaGFuZ2UgZXZlbnRzIHdoZW5ldmVyIHRoZSBjb250cm9scyBtb2RpZnkgdGhlIG1vZGUuXHJcbiAgICBpZiAodHJhY2tzLm9uY2hhbmdlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdmFyIGV2ZW50ID0gdm9pZCAwO1xyXG5cclxuICAgICAgX3RoaXMub24oWyd0YXAnLCAnY2xpY2snXSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChfdHlwZW9mKHdpbmRvd18xLkV2ZW50KSAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIC8vIEFuZHJvaWQgMi4zIHRocm93cyBhbiBJbGxlZ2FsIENvbnN0cnVjdG9yIGVycm9yIGZvciB3aW5kb3cuRXZlbnRcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IHdpbmRvd18xLkV2ZW50KCdjaGFuZ2UnKTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWV2ZW50KSB7XHJcbiAgICAgICAgICBldmVudCA9IGRvY3VtZW50XzEuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XHJcbiAgICAgICAgICBldmVudC5pbml0RXZlbnQoJ2NoYW5nZScsIHRydWUsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJhY2tzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgVGV4dFRyYWNrTWVudUl0ZW1gIGlzIFwiY2xpY2tlZFwiLiBTZWVcclxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcclxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxyXG4gICAqICAgICAgICBjYWxsZWQuXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyB0YXBcclxuICAgKiBAbGlzdGVucyBjbGlja1xyXG4gICAqL1xyXG5cclxuXHJcbiAgVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcclxuICAgIHZhciBraW5kID0gdGhpcy50cmFjay5raW5kO1xyXG4gICAgdmFyIGtpbmRzID0gdGhpcy50cmFjay5raW5kcztcclxuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xyXG5cclxuICAgIGlmICgha2luZHMpIHtcclxuICAgICAga2luZHMgPSBba2luZF07XHJcbiAgICB9XHJcblxyXG4gICAgX01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljay5jYWxsKHRoaXMsIGV2ZW50KTtcclxuXHJcbiAgICBpZiAoIXRyYWNrcykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xyXG5cclxuICAgICAgaWYgKHRyYWNrID09PSB0aGlzLnRyYWNrICYmIGtpbmRzLmluZGV4T2YodHJhY2sua2luZCkgPiAtMSkge1xyXG4gICAgICAgIGlmICh0cmFjay5tb2RlICE9PSAnc2hvd2luZycpIHtcclxuICAgICAgICAgIHRyYWNrLm1vZGUgPSAnc2hvd2luZyc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLm1vZGUgIT09ICdkaXNhYmxlZCcpIHtcclxuICAgICAgICB0cmFjay5tb2RlID0gJ2Rpc2FibGVkJztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSB0ZXh0IHRyYWNrIGxpc3QgY2hhbmdlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICBUaGUgYGNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZSBjYWxsZWQuXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBUZXh0VHJhY2tMaXN0I2NoYW5nZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVRyYWNrc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCkge1xyXG4gICAgdGhpcy5zZWxlY3RlZCh0aGlzLnRyYWNrLm1vZGUgPT09ICdzaG93aW5nJyk7XHJcbiAgfTtcclxuXHJcbiAgVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVTZWxlY3RlZExhbmd1YWdlQ2hhbmdlKGV2ZW50KSB7XHJcbiAgICBpZiAodGhpcy50cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcclxuICAgICAgdmFyIHNlbGVjdGVkTGFuZ3VhZ2UgPSB0aGlzLnBsYXllcl8uY2FjaGVfLnNlbGVjdGVkTGFuZ3VhZ2U7XHJcblxyXG4gICAgICAvLyBEb24ndCByZXBsYWNlIHRoZSBraW5kIG9mIHRyYWNrIGFjcm9zcyB0aGUgc2FtZSBsYW5ndWFnZVxyXG4gICAgICBpZiAoc2VsZWN0ZWRMYW5ndWFnZSAmJiBzZWxlY3RlZExhbmd1YWdlLmVuYWJsZWQgJiYgc2VsZWN0ZWRMYW5ndWFnZS5sYW5ndWFnZSA9PT0gdGhpcy50cmFjay5sYW5ndWFnZSAmJiBzZWxlY3RlZExhbmd1YWdlLmtpbmQgIT09IHRoaXMudHJhY2sua2luZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5wbGF5ZXJfLmNhY2hlXy5zZWxlY3RlZExhbmd1YWdlID0ge1xyXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgbGFuZ3VhZ2U6IHRoaXMudHJhY2subGFuZ3VhZ2UsXHJcbiAgICAgICAga2luZDogdGhpcy50cmFjay5raW5kXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFRleHRUcmFja01lbnVJdGVtO1xyXG59KE1lbnVJdGVtKTtcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGV4dFRyYWNrTWVudUl0ZW0nLCBUZXh0VHJhY2tNZW51SXRlbSk7XHJcblxyXG4vKipcclxuICogQGZpbGUgb2ZmLXRleHQtdHJhY2stbWVudS1pdGVtLmpzXHJcbiAqL1xyXG4vKipcclxuICogQSBzcGVjaWFsIG1lbnUgaXRlbSBmb3IgdHVybmluZyBvZiBhIHNwZWNpZmljIHR5cGUgb2YgdGV4dCB0cmFja1xyXG4gKlxyXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tNZW51SXRlbVxyXG4gKi9cclxuXHJcbnZhciBPZmZUZXh0VHJhY2tNZW51SXRlbSA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrTWVudUl0ZW0pIHtcclxuICBpbmhlcml0cyhPZmZUZXh0VHJhY2tNZW51SXRlbSwgX1RleHRUcmFja01lbnVJdGVtKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBPZmZUZXh0VHJhY2tNZW51SXRlbShwbGF5ZXIsIG9wdGlvbnMpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIE9mZlRleHRUcmFja01lbnVJdGVtKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgcHNldWRvIHRyYWNrIGluZm9cclxuICAgIC8vIFJlcXVpcmVzIG9wdGlvbnNbJ2tpbmQnXVxyXG4gICAgb3B0aW9ucy50cmFjayA9IHtcclxuICAgICAgcGxheWVyOiBwbGF5ZXIsXHJcbiAgICAgIGtpbmQ6IG9wdGlvbnMua2luZCxcclxuICAgICAga2luZHM6IG9wdGlvbnMua2luZHMsXHJcbiAgICAgICdkZWZhdWx0JzogZmFsc2UsXHJcbiAgICAgIG1vZGU6ICdkaXNhYmxlZCdcclxuICAgIH07XHJcblxyXG4gICAgaWYgKCFvcHRpb25zLmtpbmRzKSB7XHJcbiAgICAgIG9wdGlvbnMua2luZHMgPSBbb3B0aW9ucy5raW5kXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucy5sYWJlbCkge1xyXG4gICAgICBvcHRpb25zLnRyYWNrLmxhYmVsID0gb3B0aW9ucy5sYWJlbDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG9wdGlvbnMudHJhY2subGFiZWwgPSBvcHRpb25zLmtpbmRzLmpvaW4oJyBhbmQgJykgKyAnIG9mZic7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWVudUl0ZW0gaXMgc2VsZWN0YWJsZVxyXG4gICAgb3B0aW9ucy5zZWxlY3RhYmxlID0gdHJ1ZTtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tNZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xyXG5cclxuICAgIF90aGlzLnNlbGVjdGVkKHRydWUpO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIHRleHQgdHJhY2sgY2hhbmdlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBldmVudFxyXG4gICAqICAgICAgICBUaGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW5cclxuICAgKi9cclxuXHJcblxyXG4gIE9mZlRleHRUcmFja01lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVUcmFja3NDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVUcmFja3NDaGFuZ2UoZXZlbnQpIHtcclxuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcigpLnRleHRUcmFja3MoKTtcclxuICAgIHZhciBzZWxlY3RlZCA9IHRydWU7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0cmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnNfLmtpbmRzLmluZGV4T2YodHJhY2sua2luZCkgPiAtMSAmJiB0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcclxuICAgICAgICBzZWxlY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZWxlY3RlZChzZWxlY3RlZCk7XHJcbiAgfTtcclxuXHJcbiAgT2ZmVGV4dFRyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVNlbGVjdGVkTGFuZ3VhZ2VDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVTZWxlY3RlZExhbmd1YWdlQ2hhbmdlKGV2ZW50KSB7XHJcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5wbGF5ZXIoKS50ZXh0VHJhY2tzKCk7XHJcbiAgICB2YXIgYWxsSGlkZGVuID0gdHJ1ZTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRyYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xyXG5cclxuICAgICAgaWYgKFsnY2FwdGlvbnMnLCAnZGVzY3JpcHRpb25zJywgJ3N1YnRpdGxlcyddLmluZGV4T2YodHJhY2sua2luZCkgPiAtMSAmJiB0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcclxuICAgICAgICBhbGxIaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChhbGxIaWRkZW4pIHtcclxuICAgICAgdGhpcy5wbGF5ZXJfLmNhY2hlXy5zZWxlY3RlZExhbmd1YWdlID0ge1xyXG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIE9mZlRleHRUcmFja01lbnVJdGVtO1xyXG59KFRleHRUcmFja01lbnVJdGVtKTtcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnT2ZmVGV4dFRyYWNrTWVudUl0ZW0nLCBPZmZUZXh0VHJhY2tNZW51SXRlbSk7XHJcblxyXG4vKipcclxuICogQGZpbGUgdGV4dC10cmFjay1idXR0b24uanNcclxuICovXHJcbi8qKlxyXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYnV0dG9ucyB0aGF0IHRvZ2dsZSBzcGVjaWZpYyB0ZXh0IHRyYWNrIHR5cGVzIChlLmcuIHN1YnRpdGxlcylcclxuICpcclxuICogQGV4dGVuZHMgTWVudUJ1dHRvblxyXG4gKi9cclxuXHJcbnZhciBUZXh0VHJhY2tCdXR0b24gPSBmdW5jdGlvbiAoX1RyYWNrQnV0dG9uKSB7XHJcbiAgaW5oZXJpdHMoVGV4dFRyYWNrQnV0dG9uLCBfVHJhY2tCdXR0b24pO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXHJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxyXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFRleHRUcmFja0J1dHRvbihwbGF5ZXIpIHtcclxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRUcmFja0J1dHRvbik7XHJcblxyXG4gICAgb3B0aW9ucy50cmFja3MgPSBwbGF5ZXIudGV4dFRyYWNrcygpO1xyXG5cclxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbWVudSBpdGVtIGZvciBlYWNoIHRleHQgdHJhY2tcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VGV4dFRyYWNrTWVudUl0ZW1bXX0gW2l0ZW1zPVtdXVxyXG4gICAqICAgICAgICBFeGlzdGluZyBhcnJheSBvZiBpdGVtcyB0byB1c2UgZHVyaW5nIGNyZWF0aW9uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2tNZW51SXRlbVtdfVxyXG4gICAqICAgICAgICAgQXJyYXkgb2YgbWVudSBpdGVtcyB0aGF0IHdlcmUgY3JlYXRlZFxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVJdGVtcyA9IGZ1bmN0aW9uIGNyZWF0ZUl0ZW1zKCkge1xyXG4gICAgdmFyIGl0ZW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcclxuICAgIHZhciBUcmFja01lbnVJdGVtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBUZXh0VHJhY2tNZW51SXRlbTtcclxuXHJcblxyXG4gICAgLy8gTGFiZWwgaXMgYW4gb3ZlcmlkZSBmb3IgdGhlIFt0cmFja10gb2ZmIGxhYmVsXHJcbiAgICAvLyBVU2VkIHRvIGxvY2FsaXNlIGNhcHRpb25zL3N1YnRpdGxlc1xyXG4gICAgdmFyIGxhYmVsID0gdm9pZCAwO1xyXG5cclxuICAgIGlmICh0aGlzLmxhYmVsXykge1xyXG4gICAgICBsYWJlbCA9IHRoaXMubGFiZWxfICsgJyBvZmYnO1xyXG4gICAgfVxyXG4gICAgLy8gQWRkIGFuIE9GRiBtZW51IGl0ZW0gdG8gdHVybiBhbGwgdHJhY2tzIG9mZlxyXG4gICAgaXRlbXMucHVzaChuZXcgT2ZmVGV4dFRyYWNrTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7XHJcbiAgICAgIGtpbmRzOiB0aGlzLmtpbmRzXyxcclxuICAgICAga2luZDogdGhpcy5raW5kXyxcclxuICAgICAgbGFiZWw6IGxhYmVsXHJcbiAgICB9KSk7XHJcblxyXG4gICAgdGhpcy5oaWRlVGhyZXNob2xkXyArPSAxO1xyXG5cclxuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmtpbmRzXykpIHtcclxuICAgICAgdGhpcy5raW5kc18gPSBbdGhpcy5raW5kX107XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xyXG5cclxuICAgICAgLy8gb25seSBhZGQgdHJhY2tzIHRoYXQgYXJlIG9mIGFuIGFwcHJvcHJpYXRlIGtpbmQgYW5kIGhhdmUgYSBsYWJlbFxyXG4gICAgICBpZiAodGhpcy5raW5kc18uaW5kZXhPZih0cmFjay5raW5kKSA+IC0xKSB7XHJcblxyXG4gICAgICAgIHZhciBpdGVtID0gbmV3IFRyYWNrTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7XHJcbiAgICAgICAgICB0cmFjazogdHJhY2ssXHJcbiAgICAgICAgICAvLyBNZW51SXRlbSBpcyBzZWxlY3RhYmxlXHJcbiAgICAgICAgICBzZWxlY3RhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0ZW0uYWRkQ2xhc3MoJ3Zqcy0nICsgdHJhY2sua2luZCArICctbWVudS1pdGVtJyk7XHJcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpdGVtcztcclxuICB9O1xyXG5cclxuICByZXR1cm4gVGV4dFRyYWNrQnV0dG9uO1xyXG59KFRyYWNrQnV0dG9uKTtcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGV4dFRyYWNrQnV0dG9uJywgVGV4dFRyYWNrQnV0dG9uKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBjaGFwdGVycy10cmFjay1tZW51LWl0ZW0uanNcclxuICovXHJcbi8qKlxyXG4gKiBUaGUgY2hhcHRlciB0cmFjayBtZW51IGl0ZW1cclxuICpcclxuICogQGV4dGVuZHMgTWVudUl0ZW1cclxuICovXHJcblxyXG52YXIgQ2hhcHRlcnNUcmFja01lbnVJdGVtID0gZnVuY3Rpb24gKF9NZW51SXRlbSkge1xyXG4gIGluaGVyaXRzKENoYXB0ZXJzVHJhY2tNZW51SXRlbSwgX01lbnVJdGVtKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBDaGFwdGVyc1RyYWNrTWVudUl0ZW0ocGxheWVyLCBvcHRpb25zKSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDaGFwdGVyc1RyYWNrTWVudUl0ZW0pO1xyXG5cclxuICAgIHZhciB0cmFjayA9IG9wdGlvbnMudHJhY2s7XHJcbiAgICB2YXIgY3VlID0gb3B0aW9ucy5jdWU7XHJcbiAgICB2YXIgY3VycmVudFRpbWUgPSBwbGF5ZXIuY3VycmVudFRpbWUoKTtcclxuXHJcbiAgICAvLyBNb2RpZnkgb3B0aW9ucyBmb3IgcGFyZW50IE1lbnVJdGVtIGNsYXNzJ3MgaW5pdC5cclxuICAgIG9wdGlvbnMuc2VsZWN0YWJsZSA9IHRydWU7XHJcbiAgICBvcHRpb25zLmxhYmVsID0gY3VlLnRleHQ7XHJcbiAgICBvcHRpb25zLnNlbGVjdGVkID0gY3VlLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSAmJiBjdXJyZW50VGltZSA8IGN1ZS5lbmRUaW1lO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVJdGVtLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XHJcblxyXG4gICAgX3RoaXMudHJhY2sgPSB0cmFjaztcclxuICAgIF90aGlzLmN1ZSA9IGN1ZTtcclxuICAgIHRyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ2N1ZWNoYW5nZScsIGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZSkpO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBDaGFwdGVyc1RyYWNrTWVudUl0ZW1gIGlzIFwiY2xpY2tlZFwiLiBTZWVcclxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxyXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXHJcbiAgICogICAgICAgIGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIHRhcFxyXG4gICAqIEBsaXN0ZW5zIGNsaWNrXHJcbiAgICovXHJcblxyXG5cclxuICBDaGFwdGVyc1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcclxuICAgIF9NZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2suY2FsbCh0aGlzKTtcclxuICAgIHRoaXMucGxheWVyXy5jdXJyZW50VGltZSh0aGlzLmN1ZS5zdGFydFRpbWUpO1xyXG4gICAgdGhpcy51cGRhdGUodGhpcy5jdWUuc3RhcnRUaW1lKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgY2hhcHRlciBtZW51IGl0ZW1cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cclxuICAgKiAgICAgICAgVGhlIGBjdWVjaGFuZ2VgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgVGV4dFRyYWNrI2N1ZWNoYW5nZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ2hhcHRlcnNUcmFja01lbnVJdGVtLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcclxuICAgIHZhciBjdWUgPSB0aGlzLmN1ZTtcclxuICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMucGxheWVyXy5jdXJyZW50VGltZSgpO1xyXG5cclxuICAgIC8vIHZqcy5sb2coY3VycmVudFRpbWUsIGN1ZS5zdGFydFRpbWUpO1xyXG4gICAgdGhpcy5zZWxlY3RlZChjdWUuc3RhcnRUaW1lIDw9IGN1cnJlbnRUaW1lICYmIGN1cnJlbnRUaW1lIDwgY3VlLmVuZFRpbWUpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBDaGFwdGVyc1RyYWNrTWVudUl0ZW07XHJcbn0oTWVudUl0ZW0pO1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDaGFwdGVyc1RyYWNrTWVudUl0ZW0nLCBDaGFwdGVyc1RyYWNrTWVudUl0ZW0pO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIGNoYXB0ZXJzLWJ1dHRvbi5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIGNoYXB0ZXJzXHJcbiAqIENoYXB0ZXJzIGFjdCBtdWNoIGRpZmZlcmVudGx5IHRoYW4gb3RoZXIgdGV4dCB0cmFja3NcclxuICogQ3VlcyBhcmUgbmF2aWdhdGlvbiB2cy4gb3RoZXIgdHJhY2tzIG9mIGFsdGVybmF0aXZlIGxhbmd1YWdlc1xyXG4gKlxyXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tCdXR0b25cclxuICovXHJcblxyXG52YXIgQ2hhcHRlcnNCdXR0b24gPSBmdW5jdGlvbiAoX1RleHRUcmFja0J1dHRvbikge1xyXG4gIGluaGVyaXRzKENoYXB0ZXJzQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cclxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIGZ1bmN0aW9uIGlzIHJlYWR5LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIENoYXB0ZXJzQnV0dG9uKHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENoYXB0ZXJzQnV0dG9uKTtcclxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXHJcbiAgICovXHJcblxyXG5cclxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XHJcbiAgICByZXR1cm4gJ3Zqcy1jaGFwdGVycy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcclxuICB9O1xyXG5cclxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcclxuICAgIHJldHVybiAndmpzLWNoYXB0ZXJzLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIG1lbnUgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgaXRzIGl0ZW1zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxyXG4gICAqICAgICAgICBBbiBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIFRleHRUcmFja0xpc3QjYWRkdHJhY2tcclxuICAgKiBAbGlzdGVucyBUZXh0VHJhY2tMaXN0I3JlbW92ZXRyYWNrXHJcbiAgICogQGxpc3RlbnMgVGV4dFRyYWNrTGlzdCNjaGFuZ2VcclxuICAgKi9cclxuXHJcblxyXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoZXZlbnQpIHtcclxuICAgIGlmICghdGhpcy50cmFja18gfHwgZXZlbnQgJiYgKGV2ZW50LnR5cGUgPT09ICdhZGR0cmFjaycgfHwgZXZlbnQudHlwZSA9PT0gJ3JlbW92ZXRyYWNrJykpIHtcclxuICAgICAgdGhpcy5zZXRUcmFjayh0aGlzLmZpbmRDaGFwdGVyc1RyYWNrKCkpO1xyXG4gICAgfVxyXG4gICAgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdHJhY2sgZm9yIHRoZSBjaGFwdGVycyBidXR0b24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcclxuICAgKiAgICAgICAgVGhlIG5ldyB0cmFjayB0byBzZWxlY3QuIE5vdGhpbmcgd2lsbCBjaGFuZ2UgaWYgdGhpcyBpcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkXHJcbiAgICogICAgICAgIHRyYWNrLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLnNldFRyYWNrID0gZnVuY3Rpb24gc2V0VHJhY2sodHJhY2spIHtcclxuICAgIGlmICh0aGlzLnRyYWNrXyA9PT0gdHJhY2spIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy51cGRhdGVIYW5kbGVyXykge1xyXG4gICAgICB0aGlzLnVwZGF0ZUhhbmRsZXJfID0gdGhpcy51cGRhdGUuYmluZCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBoZXJlIHRoaXMudHJhY2tfIHJlZmVycyB0byB0aGUgb2xkIHRyYWNrIGluc3RhbmNlXHJcbiAgICBpZiAodGhpcy50cmFja18pIHtcclxuICAgICAgdmFyIHJlbW90ZVRleHRUcmFja0VsID0gdGhpcy5wbGF5ZXJfLnJlbW90ZVRleHRUcmFja0VscygpLmdldFRyYWNrRWxlbWVudEJ5VHJhY2tfKHRoaXMudHJhY2tfKTtcclxuXHJcbiAgICAgIGlmIChyZW1vdGVUZXh0VHJhY2tFbCkge1xyXG4gICAgICAgIHJlbW90ZVRleHRUcmFja0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLnVwZGF0ZUhhbmRsZXJfKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy50cmFja18gPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudHJhY2tfID0gdHJhY2s7XHJcblxyXG4gICAgLy8gaGVyZSB0aGlzLnRyYWNrXyByZWZlcnMgdG8gdGhlIG5ldyB0cmFjayBpbnN0YW5jZVxyXG4gICAgaWYgKHRoaXMudHJhY2tfKSB7XHJcbiAgICAgIHRoaXMudHJhY2tfLm1vZGUgPSAnaGlkZGVuJztcclxuXHJcbiAgICAgIHZhciBfcmVtb3RlVGV4dFRyYWNrRWwgPSB0aGlzLnBsYXllcl8ucmVtb3RlVGV4dFRyYWNrRWxzKCkuZ2V0VHJhY2tFbGVtZW50QnlUcmFja18odGhpcy50cmFja18pO1xyXG5cclxuICAgICAgaWYgKF9yZW1vdGVUZXh0VHJhY2tFbCkge1xyXG4gICAgICAgIF9yZW1vdGVUZXh0VHJhY2tFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy51cGRhdGVIYW5kbGVyXyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBGaW5kIHRoZSB0cmFjayBvYmplY3QgdGhhdCBpcyBjdXJyZW50bHkgaW4gdXNlIGJ5IHRoaXMgQ2hhcHRlcnNCdXR0b25cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1RleHRUcmFja3x1bmRlZmluZWR9XHJcbiAgICogICAgICAgICBUaGUgY3VycmVudCB0cmFjayBvciB1bmRlZmluZWQgaWYgbm9uZSB3YXMgZm91bmQuXHJcbiAgICovXHJcblxyXG5cclxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuZmluZENoYXB0ZXJzVHJhY2sgPSBmdW5jdGlvbiBmaW5kQ2hhcHRlcnNUcmFjaygpIHtcclxuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8udGV4dFRyYWNrcygpIHx8IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSB0cmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgLy8gV2Ugd2lsbCBhbHdheXMgY2hvb3NlIHRoZSBsYXN0IHRyYWNrIGFzIG91ciBjaGFwdGVyc1RyYWNrXHJcbiAgICAgIHZhciB0cmFjayA9IHRyYWNrc1tpXTtcclxuXHJcbiAgICAgIGlmICh0cmFjay5raW5kID09PSB0aGlzLmtpbmRfKSB7XHJcbiAgICAgICAgcmV0dXJuIHRyYWNrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjYXB0aW9uIGZvciB0aGUgQ2hhcHRlcnNCdXR0b24gYmFzZWQgb24gdGhlIHRyYWNrIGxhYmVsLiBUaGlzIHdpbGwgYWxzb1xyXG4gICAqIHVzZSB0aGUgY3VycmVudCB0cmFja3MgbG9jYWxpemVkIGtpbmQgYXMgYSBmYWxsYmFjayBpZiBhIGxhYmVsIGRvZXMgbm90IGV4aXN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqICAgICAgICAgVGhlIHRyYWNrcyBjdXJyZW50IGxhYmVsIG9yIHRoZSBsb2NhbGl6ZWQgdHJhY2sga2luZC5cclxuICAgKi9cclxuXHJcblxyXG4gIENoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5nZXRNZW51Q2FwdGlvbiA9IGZ1bmN0aW9uIGdldE1lbnVDYXB0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMudHJhY2tfICYmIHRoaXMudHJhY2tfLmxhYmVsKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRyYWNrXy5sYWJlbDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKHRvVGl0bGVDYXNlKHRoaXMua2luZF8pKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgbWVudSBmcm9tIGNoYXB0ZXIgdHJhY2tcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge01lbnV9XHJcbiAgICogICAgICAgICBOZXcgbWVudSBmb3IgdGhlIGNoYXB0ZXIgYnV0dG9uc1xyXG4gICAqL1xyXG5cclxuXHJcbiAgQ2hhcHRlcnNCdXR0b24ucHJvdG90eXBlLmNyZWF0ZU1lbnUgPSBmdW5jdGlvbiBjcmVhdGVNZW51KCkge1xyXG4gICAgdGhpcy5vcHRpb25zXy50aXRsZSA9IHRoaXMuZ2V0TWVudUNhcHRpb24oKTtcclxuICAgIHJldHVybiBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5jcmVhdGVNZW51LmNhbGwodGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbWVudSBpdGVtIGZvciBlYWNoIHRleHQgdHJhY2tcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1RleHRUcmFja01lbnVJdGVtW119XHJcbiAgICogICAgICAgICBBcnJheSBvZiBtZW51IGl0ZW1zXHJcbiAgICovXHJcblxyXG5cclxuICBDaGFwdGVyc0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMgPSBmdW5jdGlvbiBjcmVhdGVJdGVtcygpIHtcclxuICAgIHZhciBpdGVtcyA9IFtdO1xyXG5cclxuICAgIGlmICghdGhpcy50cmFja18pIHtcclxuICAgICAgcmV0dXJuIGl0ZW1zO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBjdWVzID0gdGhpcy50cmFja18uY3VlcztcclxuXHJcbiAgICBpZiAoIWN1ZXMpIHtcclxuICAgICAgcmV0dXJuIGl0ZW1zO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY3Vlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgdmFyIGN1ZSA9IGN1ZXNbaV07XHJcbiAgICAgIHZhciBtaSA9IG5ldyBDaGFwdGVyc1RyYWNrTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7IHRyYWNrOiB0aGlzLnRyYWNrXywgY3VlOiBjdWUgfSk7XHJcblxyXG4gICAgICBpdGVtcy5wdXNoKG1pKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIENoYXB0ZXJzQnV0dG9uO1xyXG59KFRleHRUcmFja0J1dHRvbik7XHJcblxyXG4vKipcclxuICogYGtpbmRgIG9mIFRleHRUcmFjayB0byBsb29rIGZvciB0byBhc3NvY2lhdGUgaXQgd2l0aCB0aGlzIG1lbnUuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5cclxuXHJcbkNoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5raW5kXyA9ICdjaGFwdGVycyc7XHJcblxyXG4vKipcclxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgQ2hhcHRlcnNCdXR0b25gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXHJcbkNoYXB0ZXJzQnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnQ2hhcHRlcnMnO1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdDaGFwdGVyc0J1dHRvbicsIENoYXB0ZXJzQnV0dG9uKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBkZXNjcmlwdGlvbnMtYnV0dG9uLmpzXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHRvZ2dsaW5nIGFuZCBzZWxlY3RpbmcgZGVzY3JpcHRpb25zXHJcbiAqXHJcbiAqIEBleHRlbmRzIFRleHRUcmFja0J1dHRvblxyXG4gKi9cclxuXHJcbnZhciBEZXNjcmlwdGlvbnNCdXR0b24gPSBmdW5jdGlvbiAoX1RleHRUcmFja0J1dHRvbikge1xyXG4gIGluaGVyaXRzKERlc2NyaXB0aW9uc0J1dHRvbiwgX1RleHRUcmFja0J1dHRvbik7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXHJcbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgcmVhZHkuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gRGVzY3JpcHRpb25zQnV0dG9uKHBsYXllciwgb3B0aW9ucywgcmVhZHkpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIERlc2NyaXB0aW9uc0J1dHRvbik7XHJcblxyXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGV4dFRyYWNrQnV0dG9uLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zLCByZWFkeSkpO1xyXG5cclxuICAgIHZhciB0cmFja3MgPSBwbGF5ZXIudGV4dFRyYWNrcygpO1xyXG4gICAgdmFyIGNoYW5nZUhhbmRsZXIgPSBiaW5kKF90aGlzLCBfdGhpcy5oYW5kbGVUcmFja3NDaGFuZ2UpO1xyXG5cclxuICAgIHRyYWNrcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcclxuICAgIF90aGlzLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICB0cmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlSGFuZGxlcik7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSB0ZXh0IHRyYWNrIGNoYW5nZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gZXZlbnRcclxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBUZXh0VHJhY2tMaXN0I2NoYW5nZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgRGVzY3JpcHRpb25zQnV0dG9uLnByb3RvdHlwZS5oYW5kbGVUcmFja3NDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVUcmFja3NDaGFuZ2UoZXZlbnQpIHtcclxuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcigpLnRleHRUcmFja3MoKTtcclxuICAgIHZhciBkaXNhYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIENoZWNrIHdoZXRoZXIgYSB0cmFjayBvZiBhIGRpZmZlcmVudCBraW5kIGlzIHNob3dpbmdcclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdHJhY2tzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XHJcblxyXG4gICAgICBpZiAodHJhY2sua2luZCAhPT0gdGhpcy5raW5kXyAmJiB0cmFjay5tb2RlID09PSAnc2hvd2luZycpIHtcclxuICAgICAgICBkaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBhbm90aGVyIHRyYWNrIGlzIHNob3dpbmcsIGRpc2FibGUgdGhpcyBtZW51IGJ1dHRvblxyXG4gICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5lbmFibGUoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXHJcbiAgICovXHJcblxyXG5cclxuICBEZXNjcmlwdGlvbnNCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xyXG4gICAgcmV0dXJuICd2anMtZGVzY3JpcHRpb25zLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xyXG4gIH07XHJcblxyXG4gIERlc2NyaXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcclxuICAgIHJldHVybiAndmpzLWRlc2NyaXB0aW9ucy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIERlc2NyaXB0aW9uc0J1dHRvbjtcclxufShUZXh0VHJhY2tCdXR0b24pO1xyXG5cclxuLyoqXHJcbiAqIGBraW5kYCBvZiBUZXh0VHJhY2sgdG8gbG9vayBmb3IgdG8gYXNzb2NpYXRlIGl0IHdpdGggdGhpcyBtZW51LlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuXHJcblxyXG5EZXNjcmlwdGlvbnNCdXR0b24ucHJvdG90eXBlLmtpbmRfID0gJ2Rlc2NyaXB0aW9ucyc7XHJcblxyXG4vKipcclxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgRGVzY3JpcHRpb25zQnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5EZXNjcmlwdGlvbnNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdEZXNjcmlwdGlvbnMnO1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdEZXNjcmlwdGlvbnNCdXR0b24nLCBEZXNjcmlwdGlvbnNCdXR0b24pO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIHN1YnRpdGxlcy1idXR0b24uanNcclxuICovXHJcbi8qKlxyXG4gKiBUaGUgYnV0dG9uIGNvbXBvbmVudCBmb3IgdG9nZ2xpbmcgYW5kIHNlbGVjdGluZyBzdWJ0aXRsZXNcclxuICpcclxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXHJcbiAqL1xyXG5cclxudmFyIFN1YnRpdGxlc0J1dHRvbiA9IGZ1bmN0aW9uIChfVGV4dFRyYWNrQnV0dG9uKSB7XHJcbiAgaW5oZXJpdHMoU3VidGl0bGVzQnV0dG9uLCBfVGV4dFRyYWNrQnV0dG9uKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cclxuICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyByZWFkeS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBTdWJ0aXRsZXNCdXR0b24ocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3VidGl0bGVzQnV0dG9uKTtcclxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMsIHJlYWR5KSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCdWlsZHMgdGhlIGRlZmF1bHQgRE9NIGBjbGFzc05hbWVgLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqICAgICAgICAgVGhlIERPTSBgY2xhc3NOYW1lYCBmb3IgdGhpcyBvYmplY3QuXHJcbiAgICovXHJcblxyXG5cclxuICBTdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZENTU0NsYXNzKCkge1xyXG4gICAgcmV0dXJuICd2anMtc3VidGl0bGVzLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xyXG4gIH07XHJcblxyXG4gIFN1YnRpdGxlc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcclxuICAgIHJldHVybiAndmpzLXN1YnRpdGxlcy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFN1YnRpdGxlc0J1dHRvbjtcclxufShUZXh0VHJhY2tCdXR0b24pO1xyXG5cclxuLyoqXHJcbiAqIGBraW5kYCBvZiBUZXh0VHJhY2sgdG8gbG9vayBmb3IgdG8gYXNzb2NpYXRlIGl0IHdpdGggdGhpcyBtZW51LlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuXHJcblxyXG5TdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmtpbmRfID0gJ3N1YnRpdGxlcyc7XHJcblxyXG4vKipcclxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgU3VidGl0bGVzQnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5TdWJ0aXRsZXNCdXR0b24ucHJvdG90eXBlLmNvbnRyb2xUZXh0XyA9ICdTdWJ0aXRsZXMnO1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTdWJ0aXRsZXNCdXR0b24nLCBTdWJ0aXRsZXNCdXR0b24pO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIGNhcHRpb24tc2V0dGluZ3MtbWVudS1pdGVtLmpzXHJcbiAqL1xyXG4vKipcclxuICogVGhlIG1lbnUgaXRlbSBmb3IgY2FwdGlvbiB0cmFjayBzZXR0aW5ncyBtZW51XHJcbiAqXHJcbiAqIEBleHRlbmRzIFRleHRUcmFja01lbnVJdGVtXHJcbiAqL1xyXG5cclxudmFyIENhcHRpb25TZXR0aW5nc01lbnVJdGVtID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tNZW51SXRlbSkge1xyXG4gIGluaGVyaXRzKENhcHRpb25TZXR0aW5nc01lbnVJdGVtLCBfVGV4dFRyYWNrTWVudUl0ZW0pO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXHJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIENhcHRpb25TZXR0aW5nc01lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0pO1xyXG5cclxuICAgIG9wdGlvbnMudHJhY2sgPSB7XHJcbiAgICAgIHBsYXllcjogcGxheWVyLFxyXG4gICAgICBraW5kOiBvcHRpb25zLmtpbmQsXHJcbiAgICAgIGxhYmVsOiBvcHRpb25zLmtpbmQgKyAnIHNldHRpbmdzJyxcclxuICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXHJcbiAgICAgICdkZWZhdWx0JzogZmFsc2UsXHJcbiAgICAgIG1vZGU6ICdkaXNhYmxlZCdcclxuICAgIH07XHJcblxyXG4gICAgLy8gQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0gaGFzIG5vIGNvbmNlcHQgb2YgJ3NlbGVjdGVkJ1xyXG4gICAgb3B0aW9ucy5zZWxlY3RhYmxlID0gZmFsc2U7XHJcblxyXG4gICAgb3B0aW9ucy5uYW1lID0gJ0NhcHRpb25TZXR0aW5nc01lbnVJdGVtJztcclxuXHJcbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tNZW51SXRlbS5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xyXG5cclxuICAgIF90aGlzLmFkZENsYXNzKCd2anMtdGV4dHRyYWNrLXNldHRpbmdzJyk7XHJcbiAgICBfdGhpcy5jb250cm9sVGV4dCgnLCBvcGVucyAnICsgb3B0aW9ucy5raW5kICsgJyBzZXR0aW5ncyBkaWFsb2cnKTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZ2V0cyBjYWxsZWQgd2hlbiBhbiBgQ2FwdGlvblNldHRpbmdzTWVudUl0ZW1gIGlzIFwiY2xpY2tlZFwiLiBTZWVcclxuICAgKiB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvcm1hdGlvbiBvbiB3aGF0IGEgY2xpY2sgY2FuIGJlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH5FdmVudH0gW2V2ZW50XVxyXG4gICAqICAgICAgICBUaGUgYGtleWRvd25gLCBgdGFwYCwgb3IgYGNsaWNrYCBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIGJlXHJcbiAgICogICAgICAgIGNhbGxlZC5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIHRhcFxyXG4gICAqIEBsaXN0ZW5zIGNsaWNrXHJcbiAgICovXHJcblxyXG5cclxuICBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xyXG4gICAgdGhpcy5wbGF5ZXIoKS5nZXRDaGlsZCgndGV4dFRyYWNrU2V0dGluZ3MnKS5vcGVuKCk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIENhcHRpb25TZXR0aW5nc01lbnVJdGVtO1xyXG59KFRleHRUcmFja01lbnVJdGVtKTtcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2FwdGlvblNldHRpbmdzTWVudUl0ZW0nLCBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSk7XHJcblxyXG4vKipcclxuICogQGZpbGUgY2FwdGlvbnMtYnV0dG9uLmpzXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGJ1dHRvbiBjb21wb25lbnQgZm9yIHRvZ2dsaW5nIGFuZCBzZWxlY3RpbmcgY2FwdGlvbnNcclxuICpcclxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXHJcbiAqL1xyXG5cclxudmFyIENhcHRpb25zQnV0dG9uID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tCdXR0b24pIHtcclxuICBpbmhlcml0cyhDYXB0aW9uc0J1dHRvbiwgX1RleHRUcmFja0J1dHRvbik7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXHJcbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgcmVhZHkuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gQ2FwdGlvbnNCdXR0b24ocGxheWVyLCBvcHRpb25zLCByZWFkeSkge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FwdGlvbnNCdXR0b24pO1xyXG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucywgcmVhZHkpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cclxuICAgKi9cclxuXHJcblxyXG4gIENhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcclxuICAgIHJldHVybiAndmpzLWNhcHRpb25zLWJ1dHRvbiAnICsgX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xyXG4gIH07XHJcblxyXG4gIENhcHRpb25zQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkV3JhcHBlckNTU0NsYXNzKCkge1xyXG4gICAgcmV0dXJuICd2anMtY2FwdGlvbnMtYnV0dG9uICcgKyBfVGV4dFRyYWNrQnV0dG9uLnByb3RvdHlwZS5idWlsZFdyYXBwZXJDU1NDbGFzcy5jYWxsKHRoaXMpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBjYXB0aW9uIG1lbnUgaXRlbXNcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0NhcHRpb25TZXR0aW5nc01lbnVJdGVtW119XHJcbiAgICogICAgICAgICBUaGUgYXJyYXkgb2YgY3VycmVudCBtZW51IGl0ZW1zLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQ2FwdGlvbnNCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zID0gZnVuY3Rpb24gY3JlYXRlSXRlbXMoKSB7XHJcbiAgICB2YXIgaXRlbXMgPSBbXTtcclxuXHJcbiAgICBpZiAoISh0aGlzLnBsYXllcigpLnRlY2hfICYmIHRoaXMucGxheWVyKCkudGVjaF8uZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSkge1xyXG4gICAgICBpdGVtcy5wdXNoKG5ldyBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSh0aGlzLnBsYXllcl8sIHsga2luZDogdGhpcy5raW5kXyB9KSk7XHJcblxyXG4gICAgICB0aGlzLmhpZGVUaHJlc2hvbGRfICs9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zLmNhbGwodGhpcywgaXRlbXMpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBDYXB0aW9uc0J1dHRvbjtcclxufShUZXh0VHJhY2tCdXR0b24pO1xyXG5cclxuLyoqXHJcbiAqIGBraW5kYCBvZiBUZXh0VHJhY2sgdG8gbG9vayBmb3IgdG8gYXNzb2NpYXRlIGl0IHdpdGggdGhpcyBtZW51LlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuXHJcblxyXG5DYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUua2luZF8gPSAnY2FwdGlvbnMnO1xyXG5cclxuLyoqXHJcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYENhcHRpb25zQnV0dG9uYHMgY29udHJvbHMuIEFkZGVkIGZvciBsb2NhbGl6YXRpb24uXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5DYXB0aW9uc0J1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ0NhcHRpb25zJztcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ2FwdGlvbnNCdXR0b24nLCBDYXB0aW9uc0J1dHRvbik7XHJcblxyXG4vKipcclxuICogQGZpbGUgc3Vicy1jYXBzLW1lbnUtaXRlbS5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIFN1YnNDYXBzTWVudUl0ZW0gaGFzIGFuIFtjY10gaWNvbiB0byBkaXN0aW5ndWlzaCBjYXB0aW9ucyBmcm9tIHN1YnRpdGxlc1xyXG4gKiBpbiB0aGUgU3Vic0NhcHNNZW51LlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBUZXh0VHJhY2tNZW51SXRlbVxyXG4gKi9cclxuXHJcbnZhciBTdWJzQ2Fwc01lbnVJdGVtID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tNZW51SXRlbSkge1xyXG4gIGluaGVyaXRzKFN1YnNDYXBzTWVudUl0ZW0sIF9UZXh0VHJhY2tNZW51SXRlbSk7XHJcblxyXG4gIGZ1bmN0aW9uIFN1YnNDYXBzTWVudUl0ZW0oKSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdWJzQ2Fwc01lbnVJdGVtKTtcclxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UZXh0VHJhY2tNZW51SXRlbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcclxuICB9XHJcblxyXG4gIFN1YnNDYXBzTWVudUl0ZW0ucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwodHlwZSwgcHJvcHMsIGF0dHJzKSB7XHJcbiAgICB2YXIgaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwidmpzLW1lbnUtaXRlbS10ZXh0XCI+JyArIHRoaXMubG9jYWxpemUodGhpcy5vcHRpb25zXy5sYWJlbCk7XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9uc18udHJhY2sua2luZCA9PT0gJ2NhcHRpb25zJykge1xyXG4gICAgICBpbm5lckhUTUwgKz0gJ1xcbiAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCIgY2xhc3M9XCJ2anMtaWNvbi1wbGFjZWhvbGRlclwiPjwvc3Bhbj5cXG4gICAgICAgIDxzcGFuIGNsYXNzPVwidmpzLWNvbnRyb2wtdGV4dFwiPiAnICsgdGhpcy5sb2NhbGl6ZSgnQ2FwdGlvbnMnKSArICc8L3NwYW4+XFxuICAgICAgJztcclxuICAgIH1cclxuXHJcbiAgICBpbm5lckhUTUwgKz0gJzwvc3Bhbj4nO1xyXG5cclxuICAgIHZhciBlbCA9IF9UZXh0VHJhY2tNZW51SXRlbS5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB0eXBlLCBhc3NpZ24oe1xyXG4gICAgICBpbm5lckhUTUw6IGlubmVySFRNTFxyXG4gICAgfSwgcHJvcHMpLCBhdHRycyk7XHJcblxyXG4gICAgcmV0dXJuIGVsO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBTdWJzQ2Fwc01lbnVJdGVtO1xyXG59KFRleHRUcmFja01lbnVJdGVtKTtcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnU3Vic0NhcHNNZW51SXRlbScsIFN1YnNDYXBzTWVudUl0ZW0pO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIHN1Yi1jYXBzLWJ1dHRvbi5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBidXR0b24gY29tcG9uZW50IGZvciB0b2dnbGluZyBhbmQgc2VsZWN0aW5nIGNhcHRpb25zIGFuZC9vciBzdWJ0aXRsZXNcclxuICpcclxuICogQGV4dGVuZHMgVGV4dFRyYWNrQnV0dG9uXHJcbiAqL1xyXG5cclxudmFyIFN1YnNDYXBzQnV0dG9uID0gZnVuY3Rpb24gKF9UZXh0VHJhY2tCdXR0b24pIHtcclxuICBpbmhlcml0cyhTdWJzQ2Fwc0J1dHRvbiwgX1RleHRUcmFja0J1dHRvbik7XHJcblxyXG4gIGZ1bmN0aW9uIFN1YnNDYXBzQnV0dG9uKHBsYXllcikge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Vic0NhcHNCdXR0b24pO1xyXG5cclxuICAgIC8vIEFsdGhvdWdoIE5vcnRoIEFtZXJpY2EgdXNlcyBcImNhcHRpb25zXCIgaW4gbW9zdCBjYXNlcyBmb3JcclxuICAgIC8vIFwiY2FwdGlvbnMgYW5kIHN1YnRpdGxlc1wiIG90aGVyIGxvY2FsZXMgdXNlIFwic3VidGl0bGVzXCJcclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1RleHRUcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xyXG5cclxuICAgIF90aGlzLmxhYmVsXyA9ICdzdWJ0aXRsZXMnO1xyXG4gICAgaWYgKFsnZW4nLCAnZW4tdXMnLCAnZW4tY2EnLCAnZnItY2EnXS5pbmRleE9mKF90aGlzLnBsYXllcl8ubGFuZ3VhZ2VfKSA+IC0xKSB7XHJcbiAgICAgIF90aGlzLmxhYmVsXyA9ICdjYXB0aW9ucyc7XHJcbiAgICB9XHJcbiAgICBfdGhpcy5tZW51QnV0dG9uXy5jb250cm9sVGV4dCh0b1RpdGxlQ2FzZShfdGhpcy5sYWJlbF8pKTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cclxuICAgKi9cclxuXHJcblxyXG4gIFN1YnNDYXBzQnV0dG9uLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcclxuICAgIHJldHVybiAndmpzLXN1YnMtY2Fwcy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcclxuICB9O1xyXG5cclxuICBTdWJzQ2Fwc0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MgPSBmdW5jdGlvbiBidWlsZFdyYXBwZXJDU1NDbGFzcygpIHtcclxuICAgIHJldHVybiAndmpzLXN1YnMtY2Fwcy1idXR0b24gJyArIF9UZXh0VHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzLmNhbGwodGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGNhcHRpb24vc3VidGl0bGVzIG1lbnUgaXRlbXNcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0NhcHRpb25TZXR0aW5nc01lbnVJdGVtW119XHJcbiAgICogICAgICAgICBUaGUgYXJyYXkgb2YgY3VycmVudCBtZW51IGl0ZW1zLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgU3Vic0NhcHNCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zID0gZnVuY3Rpb24gY3JlYXRlSXRlbXMoKSB7XHJcbiAgICB2YXIgaXRlbXMgPSBbXTtcclxuXHJcbiAgICBpZiAoISh0aGlzLnBsYXllcigpLnRlY2hfICYmIHRoaXMucGxheWVyKCkudGVjaF8uZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSkge1xyXG4gICAgICBpdGVtcy5wdXNoKG5ldyBDYXB0aW9uU2V0dGluZ3NNZW51SXRlbSh0aGlzLnBsYXllcl8sIHsga2luZDogdGhpcy5sYWJlbF8gfSkpO1xyXG5cclxuICAgICAgdGhpcy5oaWRlVGhyZXNob2xkXyArPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGl0ZW1zID0gX1RleHRUcmFja0J1dHRvbi5wcm90b3R5cGUuY3JlYXRlSXRlbXMuY2FsbCh0aGlzLCBpdGVtcywgU3Vic0NhcHNNZW51SXRlbSk7XHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFN1YnNDYXBzQnV0dG9uO1xyXG59KFRleHRUcmFja0J1dHRvbik7XHJcblxyXG4vKipcclxuICogYGtpbmRgcyBvZiBUZXh0VHJhY2sgdG8gbG9vayBmb3IgdG8gYXNzb2NpYXRlIGl0IHdpdGggdGhpcyBtZW51LlxyXG4gKlxyXG4gKiBAdHlwZSB7YXJyYXl9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5cclxuXHJcblN1YnNDYXBzQnV0dG9uLnByb3RvdHlwZS5raW5kc18gPSBbJ2NhcHRpb25zJywgJ3N1YnRpdGxlcyddO1xyXG5cclxuLyoqXHJcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYFN1YnNDYXBzQnV0dG9uYHMgY29udHJvbHMuXHJcbiAqXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5TdWJzQ2Fwc0J1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ1N1YnRpdGxlcyc7XHJcblxyXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1N1YnNDYXBzQnV0dG9uJywgU3Vic0NhcHNCdXR0b24pO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIGF1ZGlvLXRyYWNrLW1lbnUtaXRlbS5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIEFuIHtAbGluayBBdWRpb1RyYWNrfSB7QGxpbmsgTWVudUl0ZW19XHJcbiAqXHJcbiAqIEBleHRlbmRzIE1lbnVJdGVtXHJcbiAqL1xyXG5cclxudmFyIEF1ZGlvVHJhY2tNZW51SXRlbSA9IGZ1bmN0aW9uIChfTWVudUl0ZW0pIHtcclxuICBpbmhlcml0cyhBdWRpb1RyYWNrTWVudUl0ZW0sIF9NZW51SXRlbSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gQXVkaW9UcmFja01lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQXVkaW9UcmFja01lbnVJdGVtKTtcclxuXHJcbiAgICB2YXIgdHJhY2sgPSBvcHRpb25zLnRyYWNrO1xyXG4gICAgdmFyIHRyYWNrcyA9IHBsYXllci5hdWRpb1RyYWNrcygpO1xyXG5cclxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxyXG4gICAgb3B0aW9ucy5sYWJlbCA9IHRyYWNrLmxhYmVsIHx8IHRyYWNrLmxhbmd1YWdlIHx8ICdVbmtub3duJztcclxuICAgIG9wdGlvbnMuc2VsZWN0ZWQgPSB0cmFjay5lbmFibGVkO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVJdGVtLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XHJcblxyXG4gICAgX3RoaXMudHJhY2sgPSB0cmFjaztcclxuXHJcbiAgICB2YXIgY2hhbmdlSGFuZGxlciA9IGJpbmQoX3RoaXMsIF90aGlzLmhhbmRsZVRyYWNrc0NoYW5nZSk7XHJcblxyXG4gICAgdHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIpO1xyXG4gICAgX3RoaXMub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBBdWRpb1RyYWNrTWVudUl0ZW0gaXMgXCJjbGlja2VkXCIuIFNlZSB7QGxpbmsgQ2xpY2thYmxlQ29tcG9uZW50fVxyXG4gICAqIGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXHJcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcclxuICAgKiAgICAgICAgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgdGFwXHJcbiAgICogQGxpc3RlbnMgY2xpY2tcclxuICAgKi9cclxuXHJcblxyXG4gIEF1ZGlvVHJhY2tNZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xyXG4gICAgdmFyIHRyYWNrcyA9IHRoaXMucGxheWVyXy5hdWRpb1RyYWNrcygpO1xyXG5cclxuICAgIF9NZW51SXRlbS5wcm90b3R5cGUuaGFuZGxlQ2xpY2suY2FsbCh0aGlzLCBldmVudCk7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xyXG5cclxuICAgICAgdHJhY2suZW5hYmxlZCA9IHRyYWNrID09PSB0aGlzLnRyYWNrO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBhbnkge0BsaW5rIEF1ZGlvVHJhY2t9IGNoYW5nZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cclxuICAgKiAgICAgICAgVGhlIHtAbGluayBBdWRpb1RyYWNrTGlzdCNjaGFuZ2V9IGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgdG8gcnVuLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgQXVkaW9UcmFja0xpc3QjY2hhbmdlXHJcbiAgICovXHJcblxyXG5cclxuICBBdWRpb1RyYWNrTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZVRyYWNrc0NoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZVRyYWNrc0NoYW5nZShldmVudCkge1xyXG4gICAgdGhpcy5zZWxlY3RlZCh0aGlzLnRyYWNrLmVuYWJsZWQpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBBdWRpb1RyYWNrTWVudUl0ZW07XHJcbn0oTWVudUl0ZW0pO1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdBdWRpb1RyYWNrTWVudUl0ZW0nLCBBdWRpb1RyYWNrTWVudUl0ZW0pO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIGF1ZGlvLXRyYWNrLWJ1dHRvbi5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBidXR0b25zIHRoYXQgdG9nZ2xlIHNwZWNpZmljIHtAbGluayBBdWRpb1RyYWNrfSB0eXBlcy5cclxuICpcclxuICogQGV4dGVuZHMgVHJhY2tCdXR0b25cclxuICovXHJcblxyXG52YXIgQXVkaW9UcmFja0J1dHRvbiA9IGZ1bmN0aW9uIChfVHJhY2tCdXR0b24pIHtcclxuICBpbmhlcml0cyhBdWRpb1RyYWNrQnV0dG9uLCBfVHJhY2tCdXR0b24pO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXHJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxyXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIEF1ZGlvVHJhY2tCdXR0b24ocGxheWVyKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb1RyYWNrQnV0dG9uKTtcclxuXHJcbiAgICBvcHRpb25zLnRyYWNrcyA9IHBsYXllci5hdWRpb1RyYWNrcygpO1xyXG5cclxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UcmFja0J1dHRvbi5jYWxsKHRoaXMsIHBsYXllciwgb3B0aW9ucykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxyXG4gICAqL1xyXG5cclxuXHJcbiAgQXVkaW9UcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XHJcbiAgICByZXR1cm4gJ3Zqcy1hdWRpby1idXR0b24gJyArIF9UcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xyXG4gIH07XHJcblxyXG4gIEF1ZGlvVHJhY2tCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XHJcbiAgICByZXR1cm4gJ3Zqcy1hdWRpby1idXR0b24gJyArIF9UcmFja0J1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBtZW51IGl0ZW0gZm9yIGVhY2ggYXVkaW8gdHJhY2tcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXVkaW9UcmFja01lbnVJdGVtW119IFtpdGVtcz1bXV1cclxuICAgKiAgICAgICAgQW4gYXJyYXkgb2YgZXhpc3RpbmcgbWVudSBpdGVtcyB0byB1c2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtBdWRpb1RyYWNrTWVudUl0ZW1bXX1cclxuICAgKiAgICAgICAgIEFuIGFycmF5IG9mIG1lbnUgaXRlbXNcclxuICAgKi9cclxuXHJcblxyXG4gIEF1ZGlvVHJhY2tCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUl0ZW1zID0gZnVuY3Rpb24gY3JlYXRlSXRlbXMoKSB7XHJcbiAgICB2YXIgaXRlbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xyXG5cclxuICAgIC8vIGlmIHRoZXJlJ3Mgb25seSBvbmUgYXVkaW8gdHJhY2ssIHRoZXJlIG5vIHBvaW50IGluIHNob3dpbmcgaXRcclxuICAgIHRoaXMuaGlkZVRocmVzaG9sZF8gPSAxO1xyXG5cclxuICAgIHZhciB0cmFja3MgPSB0aGlzLnBsYXllcl8uYXVkaW9UcmFja3MoKTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgdHJhY2sgPSB0cmFja3NbaV07XHJcblxyXG4gICAgICBpdGVtcy5wdXNoKG5ldyBBdWRpb1RyYWNrTWVudUl0ZW0odGhpcy5wbGF5ZXJfLCB7XHJcbiAgICAgICAgdHJhY2s6IHRyYWNrLFxyXG4gICAgICAgIC8vIE1lbnVJdGVtIGlzIHNlbGVjdGFibGVcclxuICAgICAgICBzZWxlY3RhYmxlOiB0cnVlXHJcbiAgICAgIH0pKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIEF1ZGlvVHJhY2tCdXR0b247XHJcbn0oVHJhY2tCdXR0b24pO1xyXG5cclxuLyoqXHJcbiAqIFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGRpc3BsYXkgb3ZlciB0aGUgYEF1ZGlvVHJhY2tCdXR0b25gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXHJcblxyXG5cclxuQXVkaW9UcmFja0J1dHRvbi5wcm90b3R5cGUuY29udHJvbFRleHRfID0gJ0F1ZGlvIFRyYWNrJztcclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdBdWRpb1RyYWNrQnV0dG9uJywgQXVkaW9UcmFja0J1dHRvbik7XHJcblxyXG4vKipcclxuICogQGZpbGUgcGxheWJhY2stcmF0ZS1tZW51LWl0ZW0uanNcclxuICovXHJcbi8qKlxyXG4gKiBUaGUgc3BlY2lmaWMgbWVudSBpdGVtIHR5cGUgZm9yIHNlbGVjdGluZyBhIHBsYXliYWNrIHJhdGUuXHJcbiAqXHJcbiAqIEBleHRlbmRzIE1lbnVJdGVtXHJcbiAqL1xyXG5cclxudmFyIFBsYXliYWNrUmF0ZU1lbnVJdGVtID0gZnVuY3Rpb24gKF9NZW51SXRlbSkge1xyXG4gIGluaGVyaXRzKFBsYXliYWNrUmF0ZU1lbnVJdGVtLCBfTWVudUl0ZW0pO1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1BsYXllcn0gcGxheWVyXHJcbiAgICogICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFBsYXliYWNrUmF0ZU1lbnVJdGVtKHBsYXllciwgb3B0aW9ucykge1xyXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxheWJhY2tSYXRlTWVudUl0ZW0pO1xyXG5cclxuICAgIHZhciBsYWJlbCA9IG9wdGlvbnMucmF0ZTtcclxuICAgIHZhciByYXRlID0gcGFyc2VGbG9hdChsYWJlbCwgMTApO1xyXG5cclxuICAgIC8vIE1vZGlmeSBvcHRpb25zIGZvciBwYXJlbnQgTWVudUl0ZW0gY2xhc3MncyBpbml0LlxyXG4gICAgb3B0aW9ucy5sYWJlbCA9IGxhYmVsO1xyXG4gICAgb3B0aW9ucy5zZWxlY3RlZCA9IHJhdGUgPT09IDE7XHJcbiAgICBvcHRpb25zLnNlbGVjdGFibGUgPSB0cnVlO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVJdGVtLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XHJcblxyXG4gICAgX3RoaXMubGFiZWwgPSBsYWJlbDtcclxuICAgIF90aGlzLnJhdGUgPSByYXRlO1xyXG5cclxuICAgIF90aGlzLm9uKHBsYXllciwgJ3JhdGVjaGFuZ2UnLCBfdGhpcy51cGRhdGUpO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBQbGF5YmFja1JhdGVNZW51SXRlbWAgaXMgXCJjbGlja2VkXCIuIFNlZVxyXG4gICAqIHtAbGluayBDbGlja2FibGVDb21wb25lbnR9IGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uIG9uIHdoYXQgYSBjbGljayBjYW4gYmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXHJcbiAgICogICAgICAgIFRoZSBga2V5ZG93bmAsIGB0YXBgLCBvciBgY2xpY2tgIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gYmVcclxuICAgKiAgICAgICAgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgdGFwXHJcbiAgICogQGxpc3RlbnMgY2xpY2tcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXliYWNrUmF0ZU1lbnVJdGVtLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XHJcbiAgICBfTWVudUl0ZW0ucHJvdG90eXBlLmhhbmRsZUNsaWNrLmNhbGwodGhpcyk7XHJcbiAgICB0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSh0aGlzLnJhdGUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgUGxheWJhY2tSYXRlTWVudUl0ZW0gd2hlbiB0aGUgcGxheWJhY2tyYXRlIGNoYW5nZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXHJcbiAgICogICAgICAgIFRoZSBgcmF0ZWNoYW5nZWAgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBydW4uXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBQbGF5ZXIjcmF0ZWNoYW5nZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWJhY2tSYXRlTWVudUl0ZW0ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShldmVudCkge1xyXG4gICAgdGhpcy5zZWxlY3RlZCh0aGlzLnBsYXllcigpLnBsYXliYWNrUmF0ZSgpID09PSB0aGlzLnJhdGUpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBQbGF5YmFja1JhdGVNZW51SXRlbTtcclxufShNZW51SXRlbSk7XHJcblxyXG4vKipcclxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgUGxheWJhY2tSYXRlTWVudUl0ZW1gcyBjb250cm9scy4gQWRkZWQgZm9yIGxvY2FsaXphdGlvbi5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXHJcblxyXG5cclxuUGxheWJhY2tSYXRlTWVudUl0ZW0ucHJvdG90eXBlLmNvbnRlbnRFbFR5cGUgPSAnYnV0dG9uJztcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnUGxheWJhY2tSYXRlTWVudUl0ZW0nLCBQbGF5YmFja1JhdGVNZW51SXRlbSk7XHJcblxyXG4vKipcclxuICogQGZpbGUgcGxheWJhY2stcmF0ZS1tZW51LWJ1dHRvbi5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNvbnRyb2xsaW5nIHRoZSBwbGF5YmFjayByYXRlLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBNZW51QnV0dG9uXHJcbiAqL1xyXG5cclxudmFyIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24gPSBmdW5jdGlvbiAoX01lbnVCdXR0b24pIHtcclxuICBpbmhlcml0cyhQbGF5YmFja1JhdGVNZW51QnV0dG9uLCBfTWVudUJ1dHRvbik7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcclxuICAgKiAgICAgICAgVGhlIGBQbGF5ZXJgIHRoYXQgdGhpcyBjbGFzcyBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICAgICAgIFRoZSBrZXkvdmFsdWUgc3RvcmUgb2YgcGxheWVyIG9wdGlvbnMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gUGxheWJhY2tSYXRlTWVudUJ1dHRvbihwbGF5ZXIsIG9wdGlvbnMpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24pO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lbnVCdXR0b24uY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcclxuXHJcbiAgICBfdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XHJcbiAgICBfdGhpcy51cGRhdGVMYWJlbCgpO1xyXG5cclxuICAgIF90aGlzLm9uKHBsYXllciwgJ2xvYWRzdGFydCcsIF90aGlzLnVwZGF0ZVZpc2liaWxpdHkpO1xyXG4gICAgX3RoaXMub24ocGxheWVyLCAncmF0ZWNoYW5nZScsIF90aGlzLnVwZGF0ZUxhYmVsKTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RWxlbWVudH1cclxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xyXG4gICAgdmFyIGVsID0gX01lbnVCdXR0b24ucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5sYWJlbEVsXyA9IGNyZWF0ZUVsKCdkaXYnLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogJ3Zqcy1wbGF5YmFjay1yYXRlLXZhbHVlJyxcclxuICAgICAgaW5uZXJIVE1MOiAnMXgnXHJcbiAgICB9KTtcclxuXHJcbiAgICBlbC5hcHBlbmRDaGlsZCh0aGlzLmxhYmVsRWxfKTtcclxuXHJcbiAgICByZXR1cm4gZWw7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XHJcbiAgICByZXR1cm4gJ3Zqcy1wbGF5YmFjay1yYXRlICcgKyBfTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xyXG4gIH07XHJcblxyXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLmJ1aWxkV3JhcHBlckNTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRXcmFwcGVyQ1NTQ2xhc3MoKSB7XHJcbiAgICByZXR1cm4gJ3Zqcy1wbGF5YmFjay1yYXRlICcgKyBfTWVudUJ1dHRvbi5wcm90b3R5cGUuYnVpbGRXcmFwcGVyQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIHBsYXliYWNrIHJhdGUgbWVudVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7TWVudX1cclxuICAgKiAgICAgICAgIE1lbnUgb2JqZWN0IHBvcHVsYXRlZCB3aXRoIHtAbGluayBQbGF5YmFja1JhdGVNZW51SXRlbX1zXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5jcmVhdGVNZW51ID0gZnVuY3Rpb24gY3JlYXRlTWVudSgpIHtcclxuICAgIHZhciBtZW51ID0gbmV3IE1lbnUodGhpcy5wbGF5ZXIoKSk7XHJcbiAgICB2YXIgcmF0ZXMgPSB0aGlzLnBsYXliYWNrUmF0ZXMoKTtcclxuXHJcbiAgICBpZiAocmF0ZXMpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IHJhdGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgbWVudS5hZGRDaGlsZChuZXcgUGxheWJhY2tSYXRlTWVudUl0ZW0odGhpcy5wbGF5ZXIoKSwgeyByYXRlOiByYXRlc1tpXSArICd4JyB9KSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbWVudTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIEFSSUEgYWNjZXNzaWJpbGl0eSBhdHRyaWJ1dGVzXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS51cGRhdGVBUklBQXR0cmlidXRlcyA9IGZ1bmN0aW9uIHVwZGF0ZUFSSUFBdHRyaWJ1dGVzKCkge1xyXG4gICAgLy8gQ3VycmVudCBwbGF5YmFjayByYXRlXHJcbiAgICB0aGlzLmVsKCkuc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVlbm93JywgdGhpcy5wbGF5ZXIoKS5wbGF5YmFja1JhdGUoKSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBnZXRzIGNhbGxlZCB3aGVuIGFuIGBQbGF5YmFja1JhdGVNZW51QnV0dG9uYCBpcyBcImNsaWNrZWRcIi4gU2VlXHJcbiAgICoge0BsaW5rIENsaWNrYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZGV0YWlsZWQgaW5mb3JtYXRpb24gb24gd2hhdCBhIGNsaWNrIGNhbiBiZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cclxuICAgKiAgICAgICAgVGhlIGBrZXlkb3duYCwgYHRhcGAsIG9yIGBjbGlja2AgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyBmdW5jdGlvbiB0byBiZVxyXG4gICAqICAgICAgICBjYWxsZWQuXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyB0YXBcclxuICAgKiBAbGlzdGVucyBjbGlja1xyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xyXG4gICAgLy8gc2VsZWN0IG5leHQgcmF0ZSBvcHRpb25cclxuICAgIHZhciBjdXJyZW50UmF0ZSA9IHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKCk7XHJcbiAgICB2YXIgcmF0ZXMgPSB0aGlzLnBsYXliYWNrUmF0ZXMoKTtcclxuXHJcbiAgICAvLyB0aGlzIHdpbGwgc2VsZWN0IGZpcnN0IG9uZSBpZiB0aGUgbGFzdCBvbmUgY3VycmVudGx5IHNlbGVjdGVkXHJcbiAgICB2YXIgbmV3UmF0ZSA9IHJhdGVzWzBdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHJhdGVzW2ldID4gY3VycmVudFJhdGUpIHtcclxuICAgICAgICBuZXdSYXRlID0gcmF0ZXNbaV07XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKG5ld1JhdGUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBwb3NzaWJsZSBwbGF5YmFjayByYXRlc1xyXG4gICAqXHJcbiAgICogQHJldHVybiB7QXJyYXl9XHJcbiAgICogICAgICAgICBBbGwgcG9zc2libGUgcGxheWJhY2sgcmF0ZXNcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLnBsYXliYWNrUmF0ZXMgPSBmdW5jdGlvbiBwbGF5YmFja1JhdGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMub3B0aW9uc18ucGxheWJhY2tSYXRlcyB8fCB0aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnMgJiYgdGhpcy5vcHRpb25zXy5wbGF5ZXJPcHRpb25zLnBsYXliYWNrUmF0ZXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHdoZXRoZXIgcGxheWJhY2sgcmF0ZXMgaXMgc3VwcG9ydGVkIGJ5IHRoZSB0ZWNoXHJcbiAgICogYW5kIGFuIGFycmF5IG9mIHBsYXliYWNrIHJhdGVzIGV4aXN0c1xyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKiAgICAgICAgIFdoZXRoZXIgY2hhbmdpbmcgcGxheWJhY2sgcmF0ZSBpcyBzdXBwb3J0ZWRcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXliYWNrUmF0ZU1lbnVCdXR0b24ucHJvdG90eXBlLnBsYXliYWNrUmF0ZVN1cHBvcnRlZCA9IGZ1bmN0aW9uIHBsYXliYWNrUmF0ZVN1cHBvcnRlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLnBsYXllcigpLnRlY2hfICYmIHRoaXMucGxheWVyKCkudGVjaF8uZmVhdHVyZXNQbGF5YmFja1JhdGUgJiYgdGhpcy5wbGF5YmFja1JhdGVzKCkgJiYgdGhpcy5wbGF5YmFja1JhdGVzKCkubGVuZ3RoID4gMDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBIaWRlIHBsYXliYWNrIHJhdGUgY29udHJvbHMgd2hlbiB0aGV5J3JlIG5vIHBsYXliYWNrIHJhdGUgb3B0aW9ucyB0byBzZWxlY3RcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IFtldmVudF1cclxuICAgKiAgICAgICAgVGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoaXMgZnVuY3Rpb24gdG8gcnVuLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgUGxheWVyI2xvYWRzdGFydFxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWJhY2tSYXRlTWVudUJ1dHRvbi5wcm90b3R5cGUudXBkYXRlVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIHVwZGF0ZVZpc2liaWxpdHkoZXZlbnQpIHtcclxuICAgIGlmICh0aGlzLnBsYXliYWNrUmF0ZVN1cHBvcnRlZCgpKSB7XHJcbiAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oaWRkZW4nKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgYnV0dG9uIGxhYmVsIHdoZW4gcmF0ZSBjaGFuZ2VkXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fkV2ZW50fSBbZXZlbnRdXHJcbiAgICogICAgICAgIFRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHJ1bi5cclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIFBsYXllciNyYXRlY2hhbmdlXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS51cGRhdGVMYWJlbCA9IGZ1bmN0aW9uIHVwZGF0ZUxhYmVsKGV2ZW50KSB7XHJcbiAgICBpZiAodGhpcy5wbGF5YmFja1JhdGVTdXBwb3J0ZWQoKSkge1xyXG4gICAgICB0aGlzLmxhYmVsRWxfLmlubmVySFRNTCA9IHRoaXMucGxheWVyKCkucGxheWJhY2tSYXRlKCkgKyAneCc7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFBsYXliYWNrUmF0ZU1lbnVCdXR0b247XHJcbn0oTWVudUJ1dHRvbik7XHJcblxyXG4vKipcclxuICogVGhlIHRleHQgdGhhdCBzaG91bGQgZGlzcGxheSBvdmVyIHRoZSBgRnVsbHNjcmVlblRvZ2dsZWBzIGNvbnRyb2xzLiBBZGRlZCBmb3IgbG9jYWxpemF0aW9uLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuXHJcblxyXG5QbGF5YmFja1JhdGVNZW51QnV0dG9uLnByb3RvdHlwZS5jb250cm9sVGV4dF8gPSAnUGxheWJhY2sgUmF0ZSc7XHJcblxyXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ1BsYXliYWNrUmF0ZU1lbnVCdXR0b24nLCBQbGF5YmFja1JhdGVNZW51QnV0dG9uKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBzcGFjZXIuanNcclxuICovXHJcbi8qKlxyXG4gKiBKdXN0IGFuIGVtcHR5IHNwYWNlciBlbGVtZW50IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gYXBwZW5kIHBvaW50IGZvciBwbHVnaW5zLCBldGMuXHJcbiAqIEFsc28gY2FuIGJlIHVzZWQgdG8gY3JlYXRlIHNwYWNlIGJldHdlZW4gZWxlbWVudHMgd2hlbiBuZWNlc3NhcnkuXHJcbiAqXHJcbiAqIEBleHRlbmRzIENvbXBvbmVudFxyXG4gKi9cclxuXHJcbnZhciBTcGFjZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xyXG4gIGluaGVyaXRzKFNwYWNlciwgX0NvbXBvbmVudCk7XHJcblxyXG4gIGZ1bmN0aW9uIFNwYWNlcigpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFNwYWNlcik7XHJcbiAgICByZXR1cm4gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxyXG4gICAqL1xyXG4gIFNwYWNlci5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcyA9IGZ1bmN0aW9uIGJ1aWxkQ1NTQ2xhc3MoKSB7XHJcbiAgICByZXR1cm4gJ3Zqcy1zcGFjZXIgJyArIF9Db21wb25lbnQucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgU3BhY2VyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xyXG4gICAgcmV0dXJuIF9Db21wb25lbnQucHJvdG90eXBlLmNyZWF0ZUVsLmNhbGwodGhpcywgJ2RpdicsIHtcclxuICAgICAgY2xhc3NOYW1lOiB0aGlzLmJ1aWxkQ1NTQ2xhc3MoKVxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFNwYWNlcjtcclxufShDb21wb25lbnQpO1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdTcGFjZXInLCBTcGFjZXIpO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIGN1c3RvbS1jb250cm9sLXNwYWNlci5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIFNwYWNlciBzcGVjaWZpY2FsbHkgbWVhbnQgdG8gYmUgdXNlZCBhcyBhbiBpbnNlcnRpb24gcG9pbnQgZm9yIG5ldyBwbHVnaW5zLCBldGMuXHJcbiAqXHJcbiAqIEBleHRlbmRzIFNwYWNlclxyXG4gKi9cclxuXHJcbnZhciBDdXN0b21Db250cm9sU3BhY2VyID0gZnVuY3Rpb24gKF9TcGFjZXIpIHtcclxuICBpbmhlcml0cyhDdXN0b21Db250cm9sU3BhY2VyLCBfU3BhY2VyKTtcclxuXHJcbiAgZnVuY3Rpb24gQ3VzdG9tQ29udHJvbFNwYWNlcigpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEN1c3RvbUNvbnRyb2xTcGFjZXIpO1xyXG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1NwYWNlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBET00gYGNsYXNzTmFtZWAuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICogICAgICAgICBUaGUgRE9NIGBjbGFzc05hbWVgIGZvciB0aGlzIG9iamVjdC5cclxuICAgKi9cclxuICBDdXN0b21Db250cm9sU3BhY2VyLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcclxuICAgIHJldHVybiAndmpzLWN1c3RvbS1jb250cm9sLXNwYWNlciAnICsgX1NwYWNlci5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgYENvbXBvbmVudGAncyBET00gZWxlbWVudFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RWxlbWVudH1cclxuICAgKiAgICAgICAgIFRoZSBlbGVtZW50IHRoYXQgd2FzIGNyZWF0ZWQuXHJcbiAgICovXHJcblxyXG5cclxuICBDdXN0b21Db250cm9sU3BhY2VyLnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsKCkge1xyXG4gICAgdmFyIGVsID0gX1NwYWNlci5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCB7XHJcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5idWlsZENTU0NsYXNzKClcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIE5vLWZsZXgvdGFibGUtY2VsbCBtb2RlIHJlcXVpcmVzIHRoZXJlIGJlIHNvbWUgY29udGVudFxyXG4gICAgLy8gaW4gdGhlIGNlbGwgdG8gZmlsbCB0aGUgcmVtYWluaW5nIHNwYWNlIG9mIHRoZSB0YWJsZS5cclxuICAgIGVsLmlubmVySFRNTCA9ICcmbmJzcDsnO1xyXG4gICAgcmV0dXJuIGVsO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBDdXN0b21Db250cm9sU3BhY2VyO1xyXG59KFNwYWNlcik7XHJcblxyXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0N1c3RvbUNvbnRyb2xTcGFjZXInLCBDdXN0b21Db250cm9sU3BhY2VyKTtcclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBjb250cm9sLWJhci5qc1xyXG4gKi9cclxuLy8gUmVxdWlyZWQgY2hpbGRyZW5cclxuLyoqXHJcbiAqIENvbnRhaW5lciBvZiBtYWluIGNvbnRyb2xzLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBDb21wb25lbnRcclxuICovXHJcblxyXG52YXIgQ29udHJvbEJhciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XHJcbiAgaW5oZXJpdHMoQ29udHJvbEJhciwgX0NvbXBvbmVudCk7XHJcblxyXG4gIGZ1bmN0aW9uIENvbnRyb2xCYXIoKSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBDb250cm9sQmFyKTtcclxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIGBDb21wb25lbnRgJ3MgRE9NIGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxyXG4gICAqL1xyXG4gIENvbnRyb2xCYXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwoKSB7XHJcbiAgICByZXR1cm4gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jywge1xyXG4gICAgICBjbGFzc05hbWU6ICd2anMtY29udHJvbC1iYXInLFxyXG4gICAgICBkaXI6ICdsdHInXHJcbiAgICB9LCB7XHJcbiAgICAgIC8vIFRoZSBjb250cm9sIGJhciBpcyBhIGdyb3VwLCBidXQgd2UgZG9uJ3QgYXJpYS1sYWJlbCBpdCB0byBhdm9pZFxyXG4gICAgICAvLyAgb3Zlci1hbm5vdW5jaW5nIGJ5IEpBV1NcclxuICAgICAgcm9sZTogJ2dyb3VwJ1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIENvbnRyb2xCYXI7XHJcbn0oQ29tcG9uZW50KTtcclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IG9wdGlvbnMgZm9yIGBDb250cm9sQmFyYFxyXG4gKlxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuXHJcblxyXG5Db250cm9sQmFyLnByb3RvdHlwZS5vcHRpb25zXyA9IHtcclxuICBjaGlsZHJlbjogWydwbGF5VG9nZ2xlJywgJ3ZvbHVtZVBhbmVsJywgJ2N1cnJlbnRUaW1lRGlzcGxheScsICd0aW1lRGl2aWRlcicsICdkdXJhdGlvbkRpc3BsYXknLCAncHJvZ3Jlc3NDb250cm9sJywgJ2xpdmVEaXNwbGF5JywgJ3JlbWFpbmluZ1RpbWVEaXNwbGF5JywgJ2N1c3RvbUNvbnRyb2xTcGFjZXInLCAncGxheWJhY2tSYXRlTWVudUJ1dHRvbicsICdjaGFwdGVyc0J1dHRvbicsICdkZXNjcmlwdGlvbnNCdXR0b24nLCAnc3Vic0NhcHNCdXR0b24nLCAnYXVkaW9UcmFja0J1dHRvbicsICdmdWxsc2NyZWVuVG9nZ2xlJ11cclxufTtcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnQ29udHJvbEJhcicsIENvbnRyb2xCYXIpO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIGVycm9yLWRpc3BsYXkuanNcclxuICovXHJcbi8qKlxyXG4gKiBBIGRpc3BsYXkgdGhhdCBpbmRpY2F0ZXMgYW4gZXJyb3IgaGFzIG9jY3VycmVkLiBUaGlzIG1lYW5zIHRoYXQgdGhlIHZpZGVvXHJcbiAqIGlzIHVucGxheWFibGUuXHJcbiAqXHJcbiAqIEBleHRlbmRzIE1vZGFsRGlhbG9nXHJcbiAqL1xyXG5cclxudmFyIEVycm9yRGlzcGxheSA9IGZ1bmN0aW9uIChfTW9kYWxEaWFsb2cpIHtcclxuICBpbmhlcml0cyhFcnJvckRpc3BsYXksIF9Nb2RhbERpYWxvZyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge1BsYXllcn0gcGxheWVyXHJcbiAgICogICAgICAgICBUaGUgYFBsYXllcmAgdGhhdCB0aGlzIGNsYXNzIHNob3VsZCBiZSBhdHRhY2hlZCB0by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICAgICAgICBUaGUga2V5L3ZhbHVlIHN0b3JlIG9mIHBsYXllciBvcHRpb25zLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIEVycm9yRGlzcGxheShwbGF5ZXIsIG9wdGlvbnMpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEVycm9yRGlzcGxheSk7XHJcblxyXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTW9kYWxEaWFsb2cuY2FsbCh0aGlzLCBwbGF5ZXIsIG9wdGlvbnMpKTtcclxuXHJcbiAgICBfdGhpcy5vbihwbGF5ZXIsICdlcnJvcicsIF90aGlzLm9wZW4pO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGRzIHRoZSBkZWZhdWx0IERPTSBgY2xhc3NOYW1lYC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKiAgICAgICAgIFRoZSBET00gYGNsYXNzTmFtZWAgZm9yIHRoaXMgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQGRlcHJlY2F0ZWQgU2luY2UgdmVyc2lvbiA1LlxyXG4gICAqL1xyXG5cclxuXHJcbiAgRXJyb3JEaXNwbGF5LnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcclxuICAgIHJldHVybiAndmpzLWVycm9yLWRpc3BsYXkgJyArIF9Nb2RhbERpYWxvZy5wcm90b3R5cGUuYnVpbGRDU1NDbGFzcy5jYWxsKHRoaXMpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGxvY2FsaXplZCBlcnJvciBtZXNzYWdlIGJhc2VkIG9uIHRoZSBgUGxheWVyYHMgZXJyb3IuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICogICAgICAgICBUaGUgYFBsYXllcmBzIGVycm9yIG1lc3NhZ2UgbG9jYWxpemVkIG9yIGFuIGVtcHR5IHN0cmluZy5cclxuICAgKi9cclxuXHJcblxyXG4gIEVycm9yRGlzcGxheS5wcm90b3R5cGUuY29udGVudCA9IGZ1bmN0aW9uIGNvbnRlbnQoKSB7XHJcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnBsYXllcigpLmVycm9yKCk7XHJcblxyXG4gICAgcmV0dXJuIGVycm9yID8gdGhpcy5sb2NhbGl6ZShlcnJvci5tZXNzYWdlKSA6ICcnO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBFcnJvckRpc3BsYXk7XHJcbn0oTW9kYWxEaWFsb2cpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIGFuIGBFcnJvckRpc3BsYXlgLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuXHJcblxyXG5FcnJvckRpc3BsYXkucHJvdG90eXBlLm9wdGlvbnNfID0gbWVyZ2VPcHRpb25zKE1vZGFsRGlhbG9nLnByb3RvdHlwZS5vcHRpb25zXywge1xyXG4gIHBhdXNlT25PcGVuOiBmYWxzZSxcclxuICBmaWxsQWx3YXlzOiB0cnVlLFxyXG4gIHRlbXBvcmFyeTogZmFsc2UsXHJcbiAgdW5jbG9zZWFibGU6IHRydWVcclxufSk7XHJcblxyXG5Db21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQoJ0Vycm9yRGlzcGxheScsIEVycm9yRGlzcGxheSk7XHJcblxyXG4vKipcclxuICogQGZpbGUgdGV4dC10cmFjay1zZXR0aW5ncy5qc1xyXG4gKi9cclxudmFyIExPQ0FMX1NUT1JBR0VfS0VZID0gJ3Zqcy10ZXh0LXRyYWNrLXNldHRpbmdzJztcclxuXHJcbnZhciBDT0xPUl9CTEFDSyA9IFsnIzAwMCcsICdCbGFjayddO1xyXG52YXIgQ09MT1JfQkxVRSA9IFsnIzAwRicsICdCbHVlJ107XHJcbnZhciBDT0xPUl9DWUFOID0gWycjMEZGJywgJ0N5YW4nXTtcclxudmFyIENPTE9SX0dSRUVOID0gWycjMEYwJywgJ0dyZWVuJ107XHJcbnZhciBDT0xPUl9NQUdFTlRBID0gWycjRjBGJywgJ01hZ2VudGEnXTtcclxudmFyIENPTE9SX1JFRCA9IFsnI0YwMCcsICdSZWQnXTtcclxudmFyIENPTE9SX1dISVRFID0gWycjRkZGJywgJ1doaXRlJ107XHJcbnZhciBDT0xPUl9ZRUxMT1cgPSBbJyNGRjAnLCAnWWVsbG93J107XHJcblxyXG52YXIgT1BBQ0lUWV9PUEFRVUUgPSBbJzEnLCAnT3BhcXVlJ107XHJcbnZhciBPUEFDSVRZX1NFTUkgPSBbJzAuNScsICdTZW1pLVRyYW5zcGFyZW50J107XHJcbnZhciBPUEFDSVRZX1RSQU5TID0gWycwJywgJ1RyYW5zcGFyZW50J107XHJcblxyXG4vLyBDb25maWd1cmF0aW9uIGZvciB0aGUgdmFyaW91cyA8c2VsZWN0PiBlbGVtZW50cyBpbiB0aGUgRE9NIG9mIHRoaXMgY29tcG9uZW50LlxyXG4vL1xyXG4vLyBQb3NzaWJsZSBrZXlzIGluY2x1ZGU6XHJcbi8vXHJcbi8vIGBkZWZhdWx0YDpcclxuLy8gICBUaGUgZGVmYXVsdCBvcHRpb24gaW5kZXguIE9ubHkgbmVlZHMgdG8gYmUgcHJvdmlkZWQgaWYgbm90IHplcm8uXHJcbi8vIGBwYXJzZXJgOlxyXG4vLyAgIEEgZnVuY3Rpb24gd2hpY2ggaXMgdXNlZCB0byBwYXJzZSB0aGUgdmFsdWUgZnJvbSB0aGUgc2VsZWN0ZWQgb3B0aW9uIGluXHJcbi8vICAgYSBjdXN0b21pemVkIHdheS5cclxuLy8gYHNlbGVjdG9yYDpcclxuLy8gICBUaGUgc2VsZWN0b3IgdXNlZCB0byBmaW5kIHRoZSBhc3NvY2lhdGVkIDxzZWxlY3Q+IGVsZW1lbnQuXHJcbnZhciBzZWxlY3RDb25maWdzID0ge1xyXG4gIGJhY2tncm91bmRDb2xvcjoge1xyXG4gICAgc2VsZWN0b3I6ICcudmpzLWJnLWNvbG9yID4gc2VsZWN0JyxcclxuICAgIGlkOiAnY2FwdGlvbnMtYmFja2dyb3VuZC1jb2xvci0lcycsXHJcbiAgICBsYWJlbDogJ0NvbG9yJyxcclxuICAgIG9wdGlvbnM6IFtDT0xPUl9CTEFDSywgQ09MT1JfV0hJVEUsIENPTE9SX1JFRCwgQ09MT1JfR1JFRU4sIENPTE9SX0JMVUUsIENPTE9SX1lFTExPVywgQ09MT1JfTUFHRU5UQSwgQ09MT1JfQ1lBTl1cclxuICB9LFxyXG5cclxuICBiYWNrZ3JvdW5kT3BhY2l0eToge1xyXG4gICAgc2VsZWN0b3I6ICcudmpzLWJnLW9wYWNpdHkgPiBzZWxlY3QnLFxyXG4gICAgaWQ6ICdjYXB0aW9ucy1iYWNrZ3JvdW5kLW9wYWNpdHktJXMnLFxyXG4gICAgbGFiZWw6ICdUcmFuc3BhcmVuY3knLFxyXG4gICAgb3B0aW9uczogW09QQUNJVFlfT1BBUVVFLCBPUEFDSVRZX1NFTUksIE9QQUNJVFlfVFJBTlNdXHJcbiAgfSxcclxuXHJcbiAgY29sb3I6IHtcclxuICAgIHNlbGVjdG9yOiAnLnZqcy1mZy1jb2xvciA+IHNlbGVjdCcsXHJcbiAgICBpZDogJ2NhcHRpb25zLWZvcmVncm91bmQtY29sb3ItJXMnLFxyXG4gICAgbGFiZWw6ICdDb2xvcicsXHJcbiAgICBvcHRpb25zOiBbQ09MT1JfV0hJVEUsIENPTE9SX0JMQUNLLCBDT0xPUl9SRUQsIENPTE9SX0dSRUVOLCBDT0xPUl9CTFVFLCBDT0xPUl9ZRUxMT1csIENPTE9SX01BR0VOVEEsIENPTE9SX0NZQU5dXHJcbiAgfSxcclxuXHJcbiAgZWRnZVN0eWxlOiB7XHJcbiAgICBzZWxlY3RvcjogJy52anMtZWRnZS1zdHlsZSA+IHNlbGVjdCcsXHJcbiAgICBpZDogJyVzJyxcclxuICAgIGxhYmVsOiAnVGV4dCBFZGdlIFN0eWxlJyxcclxuICAgIG9wdGlvbnM6IFtbJ25vbmUnLCAnTm9uZSddLCBbJ3JhaXNlZCcsICdSYWlzZWQnXSwgWydkZXByZXNzZWQnLCAnRGVwcmVzc2VkJ10sIFsndW5pZm9ybScsICdVbmlmb3JtJ10sIFsnZHJvcHNoYWRvdycsICdEcm9wc2hhZG93J11dXHJcbiAgfSxcclxuXHJcbiAgZm9udEZhbWlseToge1xyXG4gICAgc2VsZWN0b3I6ICcudmpzLWZvbnQtZmFtaWx5ID4gc2VsZWN0JyxcclxuICAgIGlkOiAnY2FwdGlvbnMtZm9udC1mYW1pbHktJXMnLFxyXG4gICAgbGFiZWw6ICdGb250IEZhbWlseScsXHJcbiAgICBvcHRpb25zOiBbWydwcm9wb3J0aW9uYWxTYW5zU2VyaWYnLCAnUHJvcG9ydGlvbmFsIFNhbnMtU2VyaWYnXSwgWydtb25vc3BhY2VTYW5zU2VyaWYnLCAnTW9ub3NwYWNlIFNhbnMtU2VyaWYnXSwgWydwcm9wb3J0aW9uYWxTZXJpZicsICdQcm9wb3J0aW9uYWwgU2VyaWYnXSwgWydtb25vc3BhY2VTZXJpZicsICdNb25vc3BhY2UgU2VyaWYnXSwgWydjYXN1YWwnLCAnQ2FzdWFsJ10sIFsnc2NyaXB0JywgJ1NjcmlwdCddLCBbJ3NtYWxsLWNhcHMnLCAnU21hbGwgQ2FwcyddXVxyXG4gIH0sXHJcblxyXG4gIGZvbnRQZXJjZW50OiB7XHJcbiAgICBzZWxlY3RvcjogJy52anMtZm9udC1wZXJjZW50ID4gc2VsZWN0JyxcclxuICAgIGlkOiAnY2FwdGlvbnMtZm9udC1zaXplLSVzJyxcclxuICAgIGxhYmVsOiAnRm9udCBTaXplJyxcclxuICAgIG9wdGlvbnM6IFtbJzAuNTAnLCAnNTAlJ10sIFsnMC43NScsICc3NSUnXSwgWycxLjAwJywgJzEwMCUnXSwgWycxLjI1JywgJzEyNSUnXSwgWycxLjUwJywgJzE1MCUnXSwgWycxLjc1JywgJzE3NSUnXSwgWycyLjAwJywgJzIwMCUnXSwgWyczLjAwJywgJzMwMCUnXSwgWyc0LjAwJywgJzQwMCUnXV0sXHJcbiAgICAnZGVmYXVsdCc6IDIsXHJcbiAgICBwYXJzZXI6IGZ1bmN0aW9uIHBhcnNlcih2KSB7XHJcbiAgICAgIHJldHVybiB2ID09PSAnMS4wMCcgPyBudWxsIDogTnVtYmVyKHYpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHRleHRPcGFjaXR5OiB7XHJcbiAgICBzZWxlY3RvcjogJy52anMtdGV4dC1vcGFjaXR5ID4gc2VsZWN0JyxcclxuICAgIGlkOiAnY2FwdGlvbnMtZm9yZWdyb3VuZC1vcGFjaXR5LSVzJyxcclxuICAgIGxhYmVsOiAnVHJhbnNwYXJlbmN5JyxcclxuICAgIG9wdGlvbnM6IFtPUEFDSVRZX09QQVFVRSwgT1BBQ0lUWV9TRU1JXVxyXG4gIH0sXHJcblxyXG4gIC8vIE9wdGlvbnMgZm9yIHRoaXMgb2JqZWN0IGFyZSBkZWZpbmVkIGJlbG93LlxyXG4gIHdpbmRvd0NvbG9yOiB7XHJcbiAgICBzZWxlY3RvcjogJy52anMtd2luZG93LWNvbG9yID4gc2VsZWN0JyxcclxuICAgIGlkOiAnY2FwdGlvbnMtd2luZG93LWNvbG9yLSVzJyxcclxuICAgIGxhYmVsOiAnQ29sb3InXHJcbiAgfSxcclxuXHJcbiAgLy8gT3B0aW9ucyBmb3IgdGhpcyBvYmplY3QgYXJlIGRlZmluZWQgYmVsb3cuXHJcbiAgd2luZG93T3BhY2l0eToge1xyXG4gICAgc2VsZWN0b3I6ICcudmpzLXdpbmRvdy1vcGFjaXR5ID4gc2VsZWN0JyxcclxuICAgIGlkOiAnY2FwdGlvbnMtd2luZG93LW9wYWNpdHktJXMnLFxyXG4gICAgbGFiZWw6ICdUcmFuc3BhcmVuY3knLFxyXG4gICAgb3B0aW9uczogW09QQUNJVFlfVFJBTlMsIE9QQUNJVFlfU0VNSSwgT1BBQ0lUWV9PUEFRVUVdXHJcbiAgfVxyXG59O1xyXG5cclxuc2VsZWN0Q29uZmlncy53aW5kb3dDb2xvci5vcHRpb25zID0gc2VsZWN0Q29uZmlncy5iYWNrZ3JvdW5kQ29sb3Iub3B0aW9ucztcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGFjdHVhbCB2YWx1ZSBvZiBhbiBvcHRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWVcclxuICogICAgICAgICBUaGUgdmFsdWUgdG8gZ2V0XHJcbiAqXHJcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbcGFyc2VyXVxyXG4gKiAgICAgICAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFkanVzdCB0aGUgdmFsdWUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge01peGVkfVxyXG4gKiAgICAgICAgIC0gV2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBubyB2YWx1ZSBleGlzdHNcclxuICogICAgICAgICAtIFdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIFwibm9uZVwiLlxyXG4gKiAgICAgICAgIC0gV2lsbCBiZSB0aGUgYWN0dWFsIHZhbHVlIG90aGVyd2lzZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlT3B0aW9uVmFsdWUodmFsdWUsIHBhcnNlcikge1xyXG4gIGlmIChwYXJzZXIpIHtcclxuICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcclxuICB9XHJcblxyXG4gIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPT0gJ25vbmUnKSB7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNlbGVjdGVkIDxvcHRpb24+IGVsZW1lbnQgd2l0aGluIGEgPHNlbGVjdD4gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtICB7RWxlbWVudH0gZWxcclxuICogICAgICAgICB0aGUgZWxlbWVudCB0byBsb29rIGluXHJcbiAqXHJcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbcGFyc2VyXVxyXG4gKiAgICAgICAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFkanVzdCB0aGUgdmFsdWUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge01peGVkfVxyXG4gKiAgICAgICAgIC0gV2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBubyB2YWx1ZSBleGlzdHNcclxuICogICAgICAgICAtIFdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIFwibm9uZVwiLlxyXG4gKiAgICAgICAgIC0gV2lsbCBiZSB0aGUgYWN0dWFsIHZhbHVlIG90aGVyd2lzZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldFNlbGVjdGVkT3B0aW9uVmFsdWUoZWwsIHBhcnNlcikge1xyXG4gIHZhciB2YWx1ZSA9IGVsLm9wdGlvbnNbZWwub3B0aW9ucy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcclxuXHJcbiAgcmV0dXJuIHBhcnNlT3B0aW9uVmFsdWUodmFsdWUsIHBhcnNlcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBzZWxlY3RlZCA8b3B0aW9uPiBlbGVtZW50IHdpdGhpbiBhIDxzZWxlY3Q+IGVsZW1lbnQgYmFzZWQgb24gYVxyXG4gKiBnaXZlbiB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxyXG4gKiAgICAgICAgVGhlIGVsZW1lbnQgdG8gbG9vayBpbi5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXHJcbiAqICAgICAgICB0aGUgcHJvcGVydHkgdG8gbG9vayBvbi5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3BhcnNlcl1cclxuICogICAgICAgIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFkanVzdCB0aGUgdmFsdWUgYmVmb3JlIGNvbXBhcmluZy5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNldFNlbGVjdGVkT3B0aW9uKGVsLCB2YWx1ZSwgcGFyc2VyKSB7XHJcbiAgaWYgKCF2YWx1ZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbC5vcHRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAocGFyc2VPcHRpb25WYWx1ZShlbC5vcHRpb25zW2ldLnZhbHVlLCBwYXJzZXIpID09PSB2YWx1ZSkge1xyXG4gICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogTWFuaXB1bGF0ZSBUZXh0IFRyYWNrcyBzZXR0aW5ncy5cclxuICpcclxuICogQGV4dGVuZHMgTW9kYWxEaWFsb2dcclxuICovXHJcblxyXG52YXIgVGV4dFRyYWNrU2V0dGluZ3MgPSBmdW5jdGlvbiAoX01vZGFsRGlhbG9nKSB7XHJcbiAgaW5oZXJpdHMoVGV4dFRyYWNrU2V0dGluZ3MsIF9Nb2RhbERpYWxvZyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UGxheWVyfSBwbGF5ZXJcclxuICAgKiAgICAgICAgIFRoZSBgUGxheWVyYCB0aGF0IHRoaXMgY2xhc3Mgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gICAqICAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBUZXh0VHJhY2tTZXR0aW5ncyhwbGF5ZXIsIG9wdGlvbnMpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRUcmFja1NldHRpbmdzKTtcclxuXHJcbiAgICBvcHRpb25zLnRlbXBvcmFyeSA9IGZhbHNlO1xyXG5cclxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01vZGFsRGlhbG9nLmNhbGwodGhpcywgcGxheWVyLCBvcHRpb25zKSk7XHJcblxyXG4gICAgX3RoaXMudXBkYXRlRGlzcGxheSA9IGJpbmQoX3RoaXMsIF90aGlzLnVwZGF0ZURpc3BsYXkpO1xyXG5cclxuICAgIC8vIGZpbGwgdGhlIG1vZGFsIGFuZCBwcmV0ZW5kIHdlIGhhdmUgb3BlbmVkIGl0XHJcbiAgICBfdGhpcy5maWxsKCk7XHJcbiAgICBfdGhpcy5oYXNCZWVuT3BlbmVkXyA9IF90aGlzLmhhc0JlZW5GaWxsZWRfID0gdHJ1ZTtcclxuXHJcbiAgICBfdGhpcy5lbmREaWFsb2cgPSBjcmVhdGVFbCgncCcsIHtcclxuICAgICAgY2xhc3NOYW1lOiAndmpzLWNvbnRyb2wtdGV4dCcsXHJcbiAgICAgIHRleHRDb250ZW50OiBfdGhpcy5sb2NhbGl6ZSgnRW5kIG9mIGRpYWxvZyB3aW5kb3cuJylcclxuICAgIH0pO1xyXG4gICAgX3RoaXMuZWwoKS5hcHBlbmRDaGlsZChfdGhpcy5lbmREaWFsb2cpO1xyXG5cclxuICAgIF90aGlzLnNldERlZmF1bHRzKCk7XHJcblxyXG4gICAgLy8gR3JhYiBgcGVyc2lzdFRleHRUcmFja1NldHRpbmdzYCBmcm9tIHRoZSBwbGF5ZXIgb3B0aW9ucyBpZiBub3QgcGFzc2VkIGluIGNoaWxkIG9wdGlvbnNcclxuICAgIGlmIChvcHRpb25zLnBlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIF90aGlzLm9wdGlvbnNfLnBlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncyA9IF90aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnMucGVyc2lzdFRleHRUcmFja1NldHRpbmdzO1xyXG4gICAgfVxyXG5cclxuICAgIF90aGlzLm9uKF90aGlzLiQoJy52anMtZG9uZS1idXR0b24nKSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBfdGhpcy5zYXZlU2V0dGluZ3MoKTtcclxuICAgICAgX3RoaXMuY2xvc2UoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIF90aGlzLm9uKF90aGlzLiQoJy52anMtZGVmYXVsdC1idXR0b24nKSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBfdGhpcy5zZXREZWZhdWx0cygpO1xyXG4gICAgICBfdGhpcy51cGRhdGVEaXNwbGF5KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBlYWNoKHNlbGVjdENvbmZpZ3MsIGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgICAgX3RoaXMub24oX3RoaXMuJChjb25maWcuc2VsZWN0b3IpLCAnY2hhbmdlJywgX3RoaXMudXBkYXRlRGlzcGxheSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoX3RoaXMub3B0aW9uc18ucGVyc2lzdFRleHRUcmFja1NldHRpbmdzKSB7XHJcbiAgICAgIF90aGlzLnJlc3RvcmVTZXR0aW5ncygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgPHNlbGVjdD4gZWxlbWVudCB3aXRoIGNvbmZpZ3VyZWQgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcclxuICAgKiAgICAgICAgQ29uZmlndXJhdGlvbiBrZXkgdG8gdXNlIGR1cmluZyBjcmVhdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKiAgICAgICAgIEFuIEhUTUwgc3RyaW5nLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbFNlbGVjdF8gPSBmdW5jdGlvbiBjcmVhdGVFbFNlbGVjdF8oa2V5KSB7XHJcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcclxuXHJcbiAgICB2YXIgbGVnZW5kSWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xyXG4gICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdsYWJlbCc7XHJcblxyXG4gICAgdmFyIGNvbmZpZyA9IHNlbGVjdENvbmZpZ3Nba2V5XTtcclxuICAgIHZhciBpZCA9IGNvbmZpZy5pZC5yZXBsYWNlKCclcycsIHRoaXMuaWRfKTtcclxuXHJcbiAgICByZXR1cm4gWyc8JyArIHR5cGUgKyAnIGlkPVwiJyArIGlkICsgJ1wiIGNsYXNzPVwiJyArICh0eXBlID09PSAnbGFiZWwnID8gJ3Zqcy1sYWJlbCcgOiAnJykgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZShjb25maWcubGFiZWwpLCAnPC8nICsgdHlwZSArICc+JywgJzxzZWxlY3QgYXJpYS1sYWJlbGxlZGJ5PVwiJyArIGxlZ2VuZElkICsgJyAnICsgaWQgKyAnXCI+J10uY29uY2F0KGNvbmZpZy5vcHRpb25zLm1hcChmdW5jdGlvbiAobykge1xyXG4gICAgICB2YXIgb3B0aW9uSWQgPSBpZCArICctJyArIG9bMV07XHJcblxyXG4gICAgICByZXR1cm4gWyc8b3B0aW9uIGlkPVwiJyArIG9wdGlvbklkICsgJ1wiIHZhbHVlPVwiJyArIG9bMF0gKyAnXCIgJywgJ2FyaWEtbGFiZWxsZWRieT1cIicgKyBsZWdlbmRJZCArICcgJyArIGlkICsgJyAnICsgb3B0aW9uSWQgKyAnXCI+JywgX3RoaXMyLmxvY2FsaXplKG9bMV0pLCAnPC9vcHRpb24+J10uam9pbignJyk7XHJcbiAgICB9KSkuY29uY2F0KCc8L3NlbGVjdD4nKS5qb2luKCcnKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgZm9yZWdyb3VuZCBjb2xvciBlbGVtZW50IGZvciB0aGUgY29tcG9uZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICogICAgICAgICBBbiBIVE1MIHN0cmluZy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxGZ0NvbG9yXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsRmdDb2xvcl8oKSB7XHJcbiAgICB2YXIgbGVnZW5kSWQgPSAnY2FwdGlvbnMtdGV4dC1sZWdlbmQtJyArIHRoaXMuaWRfO1xyXG5cclxuICAgIHJldHVybiBbJzxmaWVsZHNldCBjbGFzcz1cInZqcy1mZy1jb2xvciB2anMtdHJhY2stc2V0dGluZ1wiPicsICc8bGVnZW5kIGlkPVwiJyArIGxlZ2VuZElkICsgJ1wiPicsIHRoaXMubG9jYWxpemUoJ1RleHQnKSwgJzwvbGVnZW5kPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCdjb2xvcicsIGxlZ2VuZElkKSwgJzxzcGFuIGNsYXNzPVwidmpzLXRleHQtb3BhY2l0eSB2anMtb3BhY2l0eVwiPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCd0ZXh0T3BhY2l0eScsIGxlZ2VuZElkKSwgJzwvc3Bhbj4nLCAnPC9maWVsZHNldD4nXS5qb2luKCcnKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYmFja2dyb3VuZCBjb2xvciBlbGVtZW50IGZvciB0aGUgY29tcG9uZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICogICAgICAgICBBbiBIVE1MIHN0cmluZy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxCZ0NvbG9yXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsQmdDb2xvcl8oKSB7XHJcbiAgICB2YXIgbGVnZW5kSWQgPSAnY2FwdGlvbnMtYmFja2dyb3VuZC0nICsgdGhpcy5pZF87XHJcblxyXG4gICAgcmV0dXJuIFsnPGZpZWxkc2V0IGNsYXNzPVwidmpzLWJnLWNvbG9yIHZqcy10cmFjay1zZXR0aW5nXCI+JywgJzxsZWdlbmQgaWQ9XCInICsgbGVnZW5kSWQgKyAnXCI+JywgdGhpcy5sb2NhbGl6ZSgnQmFja2dyb3VuZCcpLCAnPC9sZWdlbmQ+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2JhY2tncm91bmRDb2xvcicsIGxlZ2VuZElkKSwgJzxzcGFuIGNsYXNzPVwidmpzLWJnLW9wYWNpdHkgdmpzLW9wYWNpdHlcIj4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0XygnYmFja2dyb3VuZE9wYWNpdHknLCBsZWdlbmRJZCksICc8L3NwYW4+JywgJzwvZmllbGRzZXQ+J10uam9pbignJyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHdpbmRvdyBjb2xvciBlbGVtZW50IGZvciB0aGUgY29tcG9uZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICogICAgICAgICBBbiBIVE1MIHN0cmluZy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuY3JlYXRlRWxXaW5Db2xvcl8gPSBmdW5jdGlvbiBjcmVhdGVFbFdpbkNvbG9yXygpIHtcclxuICAgIHZhciBsZWdlbmRJZCA9ICdjYXB0aW9ucy13aW5kb3ctJyArIHRoaXMuaWRfO1xyXG5cclxuICAgIHJldHVybiBbJzxmaWVsZHNldCBjbGFzcz1cInZqcy13aW5kb3ctY29sb3IgdmpzLXRyYWNrLXNldHRpbmdcIj4nLCAnPGxlZ2VuZCBpZD1cIicgKyBsZWdlbmRJZCArICdcIj4nLCB0aGlzLmxvY2FsaXplKCdXaW5kb3cnKSwgJzwvbGVnZW5kPicsIHRoaXMuY3JlYXRlRWxTZWxlY3RfKCd3aW5kb3dDb2xvcicsIGxlZ2VuZElkKSwgJzxzcGFuIGNsYXNzPVwidmpzLXdpbmRvdy1vcGFjaXR5IHZqcy1vcGFjaXR5XCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ3dpbmRvd09wYWNpdHknLCBsZWdlbmRJZCksICc8L3NwYW4+JywgJzwvZmllbGRzZXQ+J10uam9pbignJyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGNvbG9yIGVsZW1lbnRzIGZvciB0aGUgY29tcG9uZW50XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxyXG4gICAqICAgICAgICAgVGhlIGVsZW1lbnQgdGhhdCB3YXMgY3JlYXRlZFxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbENvbG9yc18gPSBmdW5jdGlvbiBjcmVhdGVFbENvbG9yc18oKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlRWwoJ2RpdicsIHtcclxuICAgICAgY2xhc3NOYW1lOiAndmpzLXRyYWNrLXNldHRpbmdzLWNvbG9ycycsXHJcbiAgICAgIGlubmVySFRNTDogW3RoaXMuY3JlYXRlRWxGZ0NvbG9yXygpLCB0aGlzLmNyZWF0ZUVsQmdDb2xvcl8oKSwgdGhpcy5jcmVhdGVFbFdpbkNvbG9yXygpXS5qb2luKCcnKVxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGZvbnQgZWxlbWVudHMgZm9yIHRoZSBjb21wb25lbnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbEZvbnRfID0gZnVuY3Rpb24gY3JlYXRlRWxGb250XygpIHtcclxuICAgIHJldHVybiBjcmVhdGVFbCgnZGl2Jywge1xyXG4gICAgICBjbGFzc05hbWU6ICd2anMtdHJhY2stc2V0dGluZ3MtZm9udFwiPicsXHJcbiAgICAgIGlubmVySFRNTDogWyc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtZm9udC1wZXJjZW50IHZqcy10cmFjay1zZXR0aW5nXCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2ZvbnRQZXJjZW50JywgJycsICdsZWdlbmQnKSwgJzwvZmllbGRzZXQ+JywgJzxmaWVsZHNldCBjbGFzcz1cInZqcy1lZGdlLXN0eWxlIHZqcy10cmFjay1zZXR0aW5nXCI+JywgdGhpcy5jcmVhdGVFbFNlbGVjdF8oJ2VkZ2VTdHlsZScsICcnLCAnbGVnZW5kJyksICc8L2ZpZWxkc2V0PicsICc8ZmllbGRzZXQgY2xhc3M9XCJ2anMtZm9udC1mYW1pbHkgdmpzLXRyYWNrLXNldHRpbmdcIj4nLCB0aGlzLmNyZWF0ZUVsU2VsZWN0XygnZm9udEZhbWlseScsICcnLCAnbGVnZW5kJyksICc8L2ZpZWxkc2V0PiddLmpvaW4oJycpXHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgY29udHJvbHMgZm9yIHRoZSBjb21wb25lbnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jcmVhdGVFbENvbnRyb2xzXyA9IGZ1bmN0aW9uIGNyZWF0ZUVsQ29udHJvbHNfKCkge1xyXG4gICAgdmFyIGRlZmF1bHRzRGVzY3JpcHRpb24gPSB0aGlzLmxvY2FsaXplKCdyZXN0b3JlIGFsbCBzZXR0aW5ncyB0byB0aGUgZGVmYXVsdCB2YWx1ZXMnKTtcclxuXHJcbiAgICByZXR1cm4gY3JlYXRlRWwoJ2RpdicsIHtcclxuICAgICAgY2xhc3NOYW1lOiAndmpzLXRyYWNrLXNldHRpbmdzLWNvbnRyb2xzJyxcclxuICAgICAgaW5uZXJIVE1MOiBbJzxidXR0b24gY2xhc3M9XCJ2anMtZGVmYXVsdC1idXR0b25cIiB0aXRsZT1cIicgKyBkZWZhdWx0c0Rlc2NyaXB0aW9uICsgJ1wiPicsIHRoaXMubG9jYWxpemUoJ1Jlc2V0JyksICc8c3BhbiBjbGFzcz1cInZqcy1jb250cm9sLXRleHRcIj4gJyArIGRlZmF1bHRzRGVzY3JpcHRpb24gKyAnPC9zcGFuPicsICc8L2J1dHRvbj4nLCAnPGJ1dHRvbiBjbGFzcz1cInZqcy1kb25lLWJ1dHRvblwiPicgKyB0aGlzLmxvY2FsaXplKCdEb25lJykgKyAnPC9idXR0b24+J10uam9pbignJylcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5jb250ZW50ID0gZnVuY3Rpb24gY29udGVudCgpIHtcclxuICAgIHJldHVybiBbdGhpcy5jcmVhdGVFbENvbG9yc18oKSwgdGhpcy5jcmVhdGVFbEZvbnRfKCksIHRoaXMuY3JlYXRlRWxDb250cm9sc18oKV07XHJcbiAgfTtcclxuXHJcbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmxhYmVsID0gZnVuY3Rpb24gbGFiZWwoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb2NhbGl6ZSgnQ2FwdGlvbiBTZXR0aW5ncyBEaWFsb2cnKTtcclxuICB9O1xyXG5cclxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuZGVzY3JpcHRpb24gPSBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmxvY2FsaXplKCdCZWdpbm5pbmcgb2YgZGlhbG9nIHdpbmRvdy4gRXNjYXBlIHdpbGwgY2FuY2VsIGFuZCBjbG9zZSB0aGUgd2luZG93LicpO1xyXG4gIH07XHJcblxyXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5idWlsZENTU0NsYXNzID0gZnVuY3Rpb24gYnVpbGRDU1NDbGFzcygpIHtcclxuICAgIHJldHVybiBfTW9kYWxEaWFsb2cucHJvdG90eXBlLmJ1aWxkQ1NTQ2xhc3MuY2FsbCh0aGlzKSArICcgdmpzLXRleHQtdHJhY2stc2V0dGluZ3MnO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYW4gb2JqZWN0IG9mIHRleHQgdHJhY2sgc2V0dGluZ3MgKG9yIG51bGwpLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqICAgICAgICAgQW4gb2JqZWN0IHdpdGggY29uZmlnIHZhbHVlcyBwYXJzZWQgZnJvbSB0aGUgRE9NIG9yIGxvY2FsU3RvcmFnZS5cclxuICAgKi9cclxuXHJcblxyXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5nZXRWYWx1ZXMgPSBmdW5jdGlvbiBnZXRWYWx1ZXMoKSB7XHJcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcclxuXHJcbiAgICByZXR1cm4gcmVkdWNlKHNlbGVjdENvbmZpZ3MsIGZ1bmN0aW9uIChhY2N1bSwgY29uZmlnLCBrZXkpIHtcclxuICAgICAgdmFyIHZhbHVlID0gZ2V0U2VsZWN0ZWRPcHRpb25WYWx1ZShfdGhpczMuJChjb25maWcuc2VsZWN0b3IpLCBjb25maWcucGFyc2VyKTtcclxuXHJcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgYWNjdW1ba2V5XSA9IHZhbHVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYWNjdW07XHJcbiAgICB9LCB7fSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0ZXh0IHRyYWNrIHNldHRpbmdzIGZyb20gYW4gb2JqZWN0IG9mIHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXNcclxuICAgKiAgICAgICAgQW4gb2JqZWN0IHdpdGggY29uZmlnIHZhbHVlcyBwYXJzZWQgZnJvbSB0aGUgRE9NIG9yIGxvY2FsU3RvcmFnZS5cclxuICAgKi9cclxuXHJcblxyXG4gIFRleHRUcmFja1NldHRpbmdzLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbiBzZXRWYWx1ZXModmFsdWVzKSB7XHJcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcclxuXHJcbiAgICBlYWNoKHNlbGVjdENvbmZpZ3MsIGZ1bmN0aW9uIChjb25maWcsIGtleSkge1xyXG4gICAgICBzZXRTZWxlY3RlZE9wdGlvbihfdGhpczQuJChjb25maWcuc2VsZWN0b3IpLCB2YWx1ZXNba2V5XSwgY29uZmlnLnBhcnNlcik7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGFsbCBgPHNlbGVjdD5gIGVsZW1lbnRzIHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLnNldERlZmF1bHRzID0gZnVuY3Rpb24gc2V0RGVmYXVsdHMoKSB7XHJcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcclxuXHJcbiAgICBlYWNoKHNlbGVjdENvbmZpZ3MsIGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgICAgdmFyIGluZGV4ID0gY29uZmlnLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBjb25maWdbJ2RlZmF1bHQnXSA6IDA7XHJcblxyXG4gICAgICBfdGhpczUuJChjb25maWcuc2VsZWN0b3IpLnNlbGVjdGVkSW5kZXggPSBpbmRleDtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc3RvcmUgdGV4dHRyYWNrIHNldHRpbmdzIGZyb20gbG9jYWxTdG9yYWdlXHJcbiAgICovXHJcblxyXG5cclxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUucmVzdG9yZVNldHRpbmdzID0gZnVuY3Rpb24gcmVzdG9yZVNldHRpbmdzKCkge1xyXG4gICAgdmFyIHZhbHVlcyA9IHZvaWQgMDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICB2YWx1ZXMgPSBKU09OLnBhcnNlKHdpbmRvd18xLmxvY2FsU3RvcmFnZS5nZXRJdGVtKExPQ0FMX1NUT1JBR0VfS0VZKSk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgbG9nJDEud2FybihlcnIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh2YWx1ZXMpIHtcclxuICAgICAgdGhpcy5zZXRWYWx1ZXModmFsdWVzKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTYXZlIHRleHQgdHJhY2sgc2V0dGluZ3MgdG8gbG9jYWxTdG9yYWdlXHJcbiAgICovXHJcblxyXG5cclxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUuc2F2ZVNldHRpbmdzID0gZnVuY3Rpb24gc2F2ZVNldHRpbmdzKCkge1xyXG4gICAgaWYgKCF0aGlzLm9wdGlvbnNfLnBlcnNpc3RUZXh0VHJhY2tTZXR0aW5ncykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoKSB7XHJcbiAgICAgICAgd2luZG93XzEubG9jYWxTdG9yYWdlLnNldEl0ZW0oTE9DQUxfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHZhbHVlcykpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdpbmRvd18xLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKExPQ0FMX1NUT1JBR0VfS0VZKTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGxvZyQxLndhcm4oZXJyKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgZGlzcGxheSBvZiB0ZXh0IHRyYWNrIHNldHRpbmdzXHJcbiAgICovXHJcblxyXG5cclxuICBUZXh0VHJhY2tTZXR0aW5ncy5wcm90b3R5cGUudXBkYXRlRGlzcGxheSA9IGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXkoKSB7XHJcbiAgICB2YXIgdHREaXNwbGF5ID0gdGhpcy5wbGF5ZXJfLmdldENoaWxkKCd0ZXh0VHJhY2tEaXNwbGF5Jyk7XHJcblxyXG4gICAgaWYgKHR0RGlzcGxheSkge1xyXG4gICAgICB0dERpc3BsYXkudXBkYXRlRGlzcGxheSgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIGNvbmRpdGlvbmFsbHkgYmx1ciB0aGUgZWxlbWVudCBhbmQgcmVmb2N1cyB0aGUgY2FwdGlvbnMgYnV0dG9uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgVGV4dFRyYWNrU2V0dGluZ3MucHJvdG90eXBlLmNvbmRpdGlvbmFsQmx1cl8gPSBmdW5jdGlvbiBjb25kaXRpb25hbEJsdXJfKCkge1xyXG4gICAgdGhpcy5wcmV2aW91c2x5QWN0aXZlRWxfID0gbnVsbDtcclxuICAgIHRoaXMub2ZmKGRvY3VtZW50XzEsICdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duKTtcclxuXHJcbiAgICB2YXIgY2IgPSB0aGlzLnBsYXllcl8uY29udHJvbEJhcjtcclxuICAgIHZhciBzdWJzQ2Fwc0J0biA9IGNiICYmIGNiLnN1YnNDYXBzQnV0dG9uO1xyXG4gICAgdmFyIGNjQnRuID0gY2IgJiYgY2IuY2FwdGlvbnNCdXR0b247XHJcblxyXG4gICAgaWYgKHN1YnNDYXBzQnRuKSB7XHJcbiAgICAgIHN1YnNDYXBzQnRuLmZvY3VzKCk7XHJcbiAgICB9IGVsc2UgaWYgKGNjQnRuKSB7XHJcbiAgICAgIGNjQnRuLmZvY3VzKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFRleHRUcmFja1NldHRpbmdzO1xyXG59KE1vZGFsRGlhbG9nKTtcclxuXHJcbkNvbXBvbmVudC5yZWdpc3RlckNvbXBvbmVudCgnVGV4dFRyYWNrU2V0dGluZ3MnLCBUZXh0VHJhY2tTZXR0aW5ncyk7XHJcblxyXG52YXIgX3RlbXBsYXRlT2JqZWN0JDIgPSB0YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZShbJ1RleHQgVHJhY2tzIGFyZSBiZWluZyBsb2FkZWQgZnJvbSBhbm90aGVyIG9yaWdpbiBidXQgdGhlIGNyb3Nzb3JpZ2luIGF0dHJpYnV0ZSBpc25cXCd0IHVzZWQuXFxuICAgICAgICAgICAgVGhpcyBtYXkgcHJldmVudCB0ZXh0IHRyYWNrcyBmcm9tIGxvYWRpbmcuJ10sIFsnVGV4dCBUcmFja3MgYXJlIGJlaW5nIGxvYWRlZCBmcm9tIGFub3RoZXIgb3JpZ2luIGJ1dCB0aGUgY3Jvc3NvcmlnaW4gYXR0cmlidXRlIGlzblxcJ3QgdXNlZC5cXG4gICAgICAgICAgICBUaGlzIG1heSBwcmV2ZW50IHRleHQgdHJhY2tzIGZyb20gbG9hZGluZy4nXSk7XHJcblxyXG4vKipcclxuICogQGZpbGUgaHRtbDUuanNcclxuICovXHJcbi8qKlxyXG4gKiBIVE1MNSBNZWRpYSBDb250cm9sbGVyIC0gV3JhcHBlciBmb3IgSFRNTDUgTWVkaWEgQVBJXHJcbiAqXHJcbiAqIEBtaXhlcyBUZWNoflNvdWNlSGFuZGxlckFkZGl0aW9uc1xyXG4gKiBAZXh0ZW5kcyBUZWNoXHJcbiAqL1xyXG5cclxudmFyIEh0bWw1ID0gZnVuY3Rpb24gKF9UZWNoKSB7XHJcbiAgaW5oZXJpdHMoSHRtbDUsIF9UZWNoKTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgVGVjaC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgKiAgICAgICAgVGhlIGtleS92YWx1ZSBzdG9yZSBvZiBwbGF5ZXIgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IHJlYWR5XHJcbiAgICogICAgICAgIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgYEhUTUw1YCBUZWNoIGlzIHJlYWR5LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIEh0bWw1KG9wdGlvbnMsIHJlYWR5KSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBIdG1sNSk7XHJcblxyXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfVGVjaC5jYWxsKHRoaXMsIG9wdGlvbnMsIHJlYWR5KSk7XHJcblxyXG4gICAgdmFyIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlO1xyXG4gICAgdmFyIGNyb3Nzb3JpZ2luVHJhY2tzID0gZmFsc2U7XHJcblxyXG4gICAgLy8gU2V0IHRoZSBzb3VyY2UgaWYgb25lIGlzIHByb3ZpZGVkXHJcbiAgICAvLyAxKSBDaGVjayBpZiB0aGUgc291cmNlIGlzIG5ldyAoaWYgbm90LCB3ZSB3YW50IHRvIGtlZXAgdGhlIG9yaWdpbmFsIHNvIHBsYXliYWNrIGlzbid0IGludGVycnVwdGVkKVxyXG4gICAgLy8gMikgQ2hlY2sgdG8gc2VlIGlmIHRoZSBuZXR3b3JrIHN0YXRlIG9mIHRoZSB0YWcgd2FzIGZhaWxlZCBhdCBpbml0LCBhbmQgaWYgc28sIHJlc2V0IHRoZSBzb3VyY2VcclxuICAgIC8vIGFueXdheSBzbyB0aGUgZXJyb3IgZ2V0cyBmaXJlZC5cclxuICAgIGlmIChzb3VyY2UgJiYgKF90aGlzLmVsXy5jdXJyZW50U3JjICE9PSBzb3VyY2Uuc3JjIHx8IG9wdGlvbnMudGFnICYmIG9wdGlvbnMudGFnLmluaXROZXR3b3JrU3RhdGVfID09PSAzKSkge1xyXG4gICAgICBfdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIF90aGlzLmhhbmRsZUxhdGVJbml0XyhfdGhpcy5lbF8pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChfdGhpcy5lbF8uaGFzQ2hpbGROb2RlcygpKSB7XHJcblxyXG4gICAgICB2YXIgbm9kZXMgPSBfdGhpcy5lbF8uY2hpbGROb2RlcztcclxuICAgICAgdmFyIG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xyXG4gICAgICB2YXIgcmVtb3ZlTm9kZXMgPSBbXTtcclxuXHJcbiAgICAgIHdoaWxlIChub2Rlc0xlbmd0aC0tKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tub2Rlc0xlbmd0aF07XHJcbiAgICAgICAgdmFyIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICd0cmFjaycpIHtcclxuICAgICAgICAgIGlmICghX3RoaXMuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzKSB7XHJcbiAgICAgICAgICAgIC8vIEVtcHR5IHZpZGVvIHRhZyB0cmFja3Mgc28gdGhlIGJ1aWx0LWluIHBsYXllciBkb2Vzbid0IHVzZSB0aGVtIGFsc28uXHJcbiAgICAgICAgICAgIC8vIFRoaXMgbWF5IG5vdCBiZSBmYXN0IGVub3VnaCB0byBzdG9wIEhUTUw1IGJyb3dzZXJzIGZyb20gcmVhZGluZyB0aGUgdGFnc1xyXG4gICAgICAgICAgICAvLyBzbyB3ZSdsbCBuZWVkIHRvIHR1cm4gb2ZmIGFueSBkZWZhdWx0IHRyYWNrcyBpZiB3ZSdyZSBtYW51YWxseSBkb2luZ1xyXG4gICAgICAgICAgICAvLyBjYXB0aW9ucyBhbmQgc3VidGl0bGVzLiB2aWRlb0VsZW1lbnQudGV4dFRyYWNrc1xyXG4gICAgICAgICAgICByZW1vdmVOb2Rlcy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gc3RvcmUgSFRNTFRyYWNrRWxlbWVudCBhbmQgVGV4dFRyYWNrIHRvIHJlbW90ZSBsaXN0XHJcbiAgICAgICAgICAgIF90aGlzLnJlbW90ZVRleHRUcmFja0VscygpLmFkZFRyYWNrRWxlbWVudF8obm9kZSk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbW90ZVRleHRUcmFja3MoKS5hZGRUcmFjayhub2RlLnRyYWNrKTtcclxuICAgICAgICAgICAgX3RoaXMudGV4dFRyYWNrcygpLmFkZFRyYWNrKG5vZGUudHJhY2spO1xyXG4gICAgICAgICAgICBpZiAoIWNyb3Nzb3JpZ2luVHJhY2tzICYmICFfdGhpcy5lbF8uaGFzQXR0cmlidXRlKCdjcm9zc29yaWdpbicpICYmIGlzQ3Jvc3NPcmlnaW4obm9kZS5zcmMpKSB7XHJcbiAgICAgICAgICAgICAgY3Jvc3NvcmlnaW5UcmFja3MgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZU5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgX3RoaXMuZWxfLnJlbW92ZUNoaWxkKHJlbW92ZU5vZGVzW2ldKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIF90aGlzLnByb3h5TmF0aXZlVHJhY2tzXygpO1xyXG4gICAgaWYgKF90aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcyAmJiBjcm9zc29yaWdpblRyYWNrcykge1xyXG4gICAgICBsb2ckMS53YXJuKHRzbWwoX3RlbXBsYXRlT2JqZWN0JDIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBwcmV2ZW50IGlPUyBTYWZhcmkgZnJvbSBkaXNhYmxpbmcgbWV0YWRhdGEgdGV4dCB0cmFja3MgZHVyaW5nIG5hdGl2ZSBwbGF5YmFja1xyXG4gICAgX3RoaXMucmVzdG9yZU1ldGFkYXRhVHJhY2tzSW5JT1NOYXRpdmVQbGF5ZXJfKCk7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGlmIG5hdGl2ZSBjb250cm9scyBzaG91bGQgYmUgdXNlZFxyXG4gICAgLy8gT3VyIGdvYWwgc2hvdWxkIGJlIHRvIGdldCB0aGUgY3VzdG9tIGNvbnRyb2xzIG9uIG1vYmlsZSBzb2xpZCBldmVyeXdoZXJlXHJcbiAgICAvLyBzbyB3ZSBjYW4gcmVtb3ZlIHRoaXMgYWxsIHRvZ2V0aGVyLiBSaWdodCBub3cgdGhpcyB3aWxsIGJsb2NrIGN1c3RvbVxyXG4gICAgLy8gY29udHJvbHMgb24gdG91Y2ggZW5hYmxlZCBsYXB0b3BzIGxpa2UgdGhlIENocm9tZSBQaXhlbFxyXG4gICAgaWYgKChUT1VDSF9FTkFCTEVEIHx8IElTX0lQSE9ORSB8fCBJU19OQVRJVkVfQU5EUk9JRCkgJiYgb3B0aW9ucy5uYXRpdmVDb250cm9sc0ZvclRvdWNoID09PSB0cnVlKSB7XHJcbiAgICAgIF90aGlzLnNldENvbnRyb2xzKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG9uIGlPUywgd2Ugd2FudCB0byBwcm94eSBgd2Via2l0YmVnaW5mdWxsc2NyZWVuYCBhbmQgYHdlYmtpdGVuZGZ1bGxzY3JlZW5gXHJcbiAgICAvLyBpbnRvIGEgYGZ1bGxzY3JlZW5jaGFuZ2VgIGV2ZW50XHJcbiAgICBfdGhpcy5wcm94eVdlYmtpdEZ1bGxzY3JlZW5fKCk7XHJcblxyXG4gICAgX3RoaXMudHJpZ2dlclJlYWR5KCk7XHJcbiAgICByZXR1cm4gX3RoaXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEaXNwb3NlIG9mIGBIVE1MNWAgbWVkaWEgZWxlbWVudCBhbmQgcmVtb3ZlIGFsbCB0cmFja3MuXHJcbiAgICovXHJcblxyXG5cclxuICBIdG1sNS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XHJcbiAgICBIdG1sNS5kaXNwb3NlTWVkaWFFbGVtZW50KHRoaXMuZWxfKTtcclxuICAgIC8vIHRlY2ggd2lsbCBoYW5kbGUgY2xlYXJpbmcgb2YgdGhlIGVtdWxhdGVkIHRyYWNrIGxpc3RcclxuICAgIF9UZWNoLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogV2hlbiBhIGNhcHRpb25zIHRyYWNrIGlzIGVuYWJsZWQgaW4gdGhlIGlPUyBTYWZhcmkgbmF0aXZlIHBsYXllciwgYWxsIG90aGVyXHJcbiAgICogdHJhY2tzIGFyZSBkaXNhYmxlZCAoaW5jbHVkaW5nIG1ldGFkYXRhIHRyYWNrcyksIHdoaWNoIG51bGxzIGFsbCBvZiB0aGVpclxyXG4gICAqIGFzc29jaWF0ZWQgY3VlIHBvaW50cy4gVGhpcyB3aWxsIHJlc3RvcmUgbWV0YWRhdGEgdHJhY2tzIHRvIHRoZWlyIHByZS1mdWxsc2NyZWVuXHJcbiAgICogc3RhdGUgaW4gdGhvc2UgY2FzZXMgc28gdGhhdCBjdWUgcG9pbnRzIGFyZSBub3QgbmVlZGxlc3NseSBsb3N0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIEh0bWw1LnByb3RvdHlwZS5yZXN0b3JlTWV0YWRhdGFUcmFja3NJbklPU05hdGl2ZVBsYXllcl8gPSBmdW5jdGlvbiByZXN0b3JlTWV0YWRhdGFUcmFja3NJbklPU05hdGl2ZVBsYXllcl8oKSB7XHJcbiAgICB2YXIgdGV4dFRyYWNrcyA9IHRoaXMudGV4dFRyYWNrcygpO1xyXG4gICAgdmFyIG1ldGFkYXRhVHJhY2tzUHJlRnVsbHNjcmVlblN0YXRlID0gdm9pZCAwO1xyXG5cclxuICAgIC8vIGNhcHR1cmVzIGEgc25hcHNob3Qgb2YgZXZlcnkgbWV0YWRhdGEgdHJhY2sncyBjdXJyZW50IHN0YXRlXHJcbiAgICB2YXIgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCA9IGZ1bmN0aW9uIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QoKSB7XHJcbiAgICAgIG1ldGFkYXRhVHJhY2tzUHJlRnVsbHNjcmVlblN0YXRlID0gW107XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRUcmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgdHJhY2sgPSB0ZXh0VHJhY2tzW2ldO1xyXG5cclxuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ21ldGFkYXRhJykge1xyXG4gICAgICAgICAgbWV0YWRhdGFUcmFja3NQcmVGdWxsc2NyZWVuU3RhdGUucHVzaCh7XHJcbiAgICAgICAgICAgIHRyYWNrOiB0cmFjayxcclxuICAgICAgICAgICAgc3RvcmVkTW9kZTogdHJhY2subW9kZVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHNuYXBzaG90IGVhY2ggbWV0YWRhdGEgdHJhY2sncyBpbml0aWFsIHN0YXRlLCBhbmQgdXBkYXRlIHRoZSBzbmFwc2hvdFxyXG4gICAgLy8gZWFjaCB0aW1lIHRoZXJlIGlzIGEgdHJhY2sgJ2NoYW5nZScgZXZlbnRcclxuICAgIHRha2VNZXRhZGF0YVRyYWNrU25hcHNob3QoKTtcclxuICAgIHRleHRUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCk7XHJcblxyXG4gICAgdmFyIHJlc3RvcmVUcmFja01vZGUgPSBmdW5jdGlvbiByZXN0b3JlVHJhY2tNb2RlKCkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGFkYXRhVHJhY2tzUHJlRnVsbHNjcmVlblN0YXRlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHN0b3JlZFRyYWNrID0gbWV0YWRhdGFUcmFja3NQcmVGdWxsc2NyZWVuU3RhdGVbaV07XHJcblxyXG4gICAgICAgIGlmIChzdG9yZWRUcmFjay50cmFjay5tb2RlID09PSAnZGlzYWJsZWQnICYmIHN0b3JlZFRyYWNrLnRyYWNrLm1vZGUgIT09IHN0b3JlZFRyYWNrLnN0b3JlZE1vZGUpIHtcclxuICAgICAgICAgIHN0b3JlZFRyYWNrLnRyYWNrLm1vZGUgPSBzdG9yZWRUcmFjay5zdG9yZWRNb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyB3ZSBvbmx5IHdhbnQgdGhpcyBoYW5kbGVyIHRvIGJlIGV4ZWN1dGVkIG9uIHRoZSBmaXJzdCAnY2hhbmdlJyBldmVudFxyXG4gICAgICB0ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHJlc3RvcmVUcmFja01vZGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyB3aGVuIHdlIGVudGVyIGZ1bGxzY3JlZW4gcGxheWJhY2ssIHN0b3AgdXBkYXRpbmcgdGhlIHNuYXBzaG90IGFuZFxyXG4gICAgLy8gcmVzdG9yZSBhbGwgdHJhY2sgbW9kZXMgdG8gdGhlaXIgcHJlLWZ1bGxzY3JlZW4gc3RhdGVcclxuICAgIHRoaXMub24oJ3dlYmtpdGJlZ2luZnVsbHNjcmVlbicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgdGV4dFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0YWtlTWV0YWRhdGFUcmFja1NuYXBzaG90KTtcclxuXHJcbiAgICAgIC8vIHJlbW92ZSB0aGUgbGlzdGVuZXIgYmVmb3JlIGFkZGluZyBpdCBqdXN0IGluIGNhc2UgaXQgd2Fzbid0IHByZXZpb3VzbHkgcmVtb3ZlZFxyXG4gICAgICB0ZXh0VHJhY2tzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHJlc3RvcmVUcmFja01vZGUpO1xyXG4gICAgICB0ZXh0VHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHJlc3RvcmVUcmFja01vZGUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gc3RhcnQgdXBkYXRpbmcgdGhlIHNuYXBzaG90IGFnYWluIGFmdGVyIGxlYXZpbmcgZnVsbHNjcmVlblxyXG4gICAgdGhpcy5vbignd2Via2l0ZW5kZnVsbHNjcmVlbicsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBiZWZvcmUgYWRkaW5nIGl0IGp1c3QgaW4gY2FzZSBpdCB3YXNuJ3QgcHJldmlvdXNseSByZW1vdmVkXHJcbiAgICAgIHRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCk7XHJcbiAgICAgIHRleHRUcmFja3MuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGFrZU1ldGFkYXRhVHJhY2tTbmFwc2hvdCk7XHJcblxyXG4gICAgICAvLyByZW1vdmUgdGhlIHJlc3RvcmVUcmFja01vZGUgaGFuZGxlciBpbiBjYXNlIGl0IHdhc24ndCB0cmlnZ2VyZWQgZHVyaW5nIGZ1bGxzY3JlZW4gcGxheWJhY2tcclxuICAgICAgdGV4dFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCByZXN0b3JlVHJhY2tNb2RlKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFByb3h5IGFsbCBuYXRpdmUgdHJhY2sgbGlzdCBldmVudHMgdG8gb3VyIHRyYWNrIGxpc3RzIGlmIHRoZSBicm93c2VyIHdlIGFyZSBwbGF5aW5nXHJcbiAgICogaW4gc3VwcG9ydHMgdGhhdCB0eXBlIG9mIHRyYWNrIGxpc3QuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgSHRtbDUucHJvdG90eXBlLnByb3h5TmF0aXZlVHJhY2tzXyA9IGZ1bmN0aW9uIHByb3h5TmF0aXZlVHJhY2tzXygpIHtcclxuICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG5cclxuICAgIE5PUk1BTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgIHZhciBwcm9wcyA9IE5PUk1BTFtuYW1lXTtcclxuICAgICAgdmFyIGVsVHJhY2tzID0gX3RoaXMyLmVsKClbcHJvcHMuZ2V0dGVyTmFtZV07XHJcbiAgICAgIHZhciB0ZWNoVHJhY2tzID0gX3RoaXMyW3Byb3BzLmdldHRlck5hbWVdKCk7XHJcblxyXG4gICAgICBpZiAoIV90aGlzMlsnZmVhdHVyZXNOYXRpdmUnICsgcHJvcHMuY2FwaXRhbE5hbWUgKyAnVHJhY2tzJ10gfHwgIWVsVHJhY2tzIHx8ICFlbFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB7XHJcbiAgICAgICAgY2hhbmdlOiBmdW5jdGlvbiBjaGFuZ2UoZSkge1xyXG4gICAgICAgICAgdGVjaFRyYWNrcy50cmlnZ2VyKHtcclxuICAgICAgICAgICAgdHlwZTogJ2NoYW5nZScsXHJcbiAgICAgICAgICAgIHRhcmdldDogdGVjaFRyYWNrcyxcclxuICAgICAgICAgICAgY3VycmVudFRhcmdldDogdGVjaFRyYWNrcyxcclxuICAgICAgICAgICAgc3JjRWxlbWVudDogdGVjaFRyYWNrc1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGR0cmFjazogZnVuY3Rpb24gYWRkdHJhY2soZSkge1xyXG4gICAgICAgICAgdGVjaFRyYWNrcy5hZGRUcmFjayhlLnRyYWNrKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZXRyYWNrOiBmdW5jdGlvbiByZW1vdmV0cmFjayhlKSB7XHJcbiAgICAgICAgICB0ZWNoVHJhY2tzLnJlbW92ZVRyYWNrKGUudHJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgdmFyIHJlbW92ZU9sZFRyYWNrcyA9IGZ1bmN0aW9uIHJlbW92ZU9sZFRyYWNrcygpIHtcclxuICAgICAgICB2YXIgcmVtb3ZlVHJhY2tzID0gW107XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVjaFRyYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbFRyYWNrcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoZWxUcmFja3Nbal0gPT09IHRlY2hUcmFja3NbaV0pIHtcclxuICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoIWZvdW5kKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZVRyYWNrcy5wdXNoKHRlY2hUcmFja3NbaV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgd2hpbGUgKHJlbW92ZVRyYWNrcy5sZW5ndGgpIHtcclxuICAgICAgICAgIHRlY2hUcmFja3MucmVtb3ZlVHJhY2socmVtb3ZlVHJhY2tzLnNoaWZ0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIE9iamVjdC5rZXlzKGxpc3RlbmVycykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2V2ZW50TmFtZV07XHJcblxyXG4gICAgICAgIGVsVHJhY2tzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgX3RoaXMyLm9uKCdkaXNwb3NlJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgIHJldHVybiBlbFRyYWNrcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8vIFJlbW92ZSAobmF0aXZlKSB0cmFja3MgdGhhdCBhcmUgbm90IHVzZWQgYW55bW9yZVxyXG4gICAgICBfdGhpczIub24oJ2xvYWRzdGFydCcsIHJlbW92ZU9sZFRyYWNrcyk7XHJcbiAgICAgIF90aGlzMi5vbignZGlzcG9zZScsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzMi5vZmYoJ2xvYWRzdGFydCcsIHJlbW92ZU9sZFRyYWNrcyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBgSHRtbDVgIFRlY2gncyBET00gZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIEh0bWw1LnByb3RvdHlwZS5jcmVhdGVFbCA9IGZ1bmN0aW9uIGNyZWF0ZUVsJCQxKCkge1xyXG4gICAgdmFyIGVsID0gdGhpcy5vcHRpb25zXy50YWc7XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBicm93c2VyIHN1cHBvcnRzIG1vdmluZyB0aGUgZWxlbWVudCBpbnRvIHRoZSBib3guXHJcbiAgICAvLyBPbiB0aGUgaVBob25lIHZpZGVvIHdpbGwgYnJlYWsgaWYgeW91IG1vdmUgdGhlIGVsZW1lbnQsXHJcbiAgICAvLyBTbyB3ZSBoYXZlIHRvIGNyZWF0ZSBhIGJyYW5kIG5ldyBlbGVtZW50LlxyXG4gICAgLy8gSWYgd2UgaW5nZXN0ZWQgdGhlIHBsYXllciBkaXYsIHdlIGRvIG5vdCBuZWVkIHRvIG1vdmUgdGhlIG1lZGlhIGVsZW1lbnQuXHJcbiAgICBpZiAoIWVsIHx8ICEodGhpcy5vcHRpb25zXy5wbGF5ZXJFbEluZ2VzdCB8fCB0aGlzLm1vdmluZ01lZGlhRWxlbWVudEluRE9NKSkge1xyXG5cclxuICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIHRhZyBpcyBzdGlsbCB0aGVyZSwgY2xvbmUgYW5kIHJlbW92ZSBpdC5cclxuICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKHRydWUpO1xyXG5cclxuICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2xvbmUsIGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgSHRtbDUuZGlzcG9zZU1lZGlhRWxlbWVudChlbCk7XHJcbiAgICAgICAgZWwgPSBjbG9uZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbCA9IGRvY3VtZW50XzEuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcclxuXHJcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIG5hdGl2ZSBjb250cm9scyBzaG91bGQgYmUgdXNlZFxyXG4gICAgICAgIHZhciB0YWdBdHRyaWJ1dGVzID0gdGhpcy5vcHRpb25zXy50YWcgJiYgZ2V0QXR0cmlidXRlcyh0aGlzLm9wdGlvbnNfLnRhZyk7XHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBtZXJnZU9wdGlvbnMoe30sIHRhZ0F0dHJpYnV0ZXMpO1xyXG5cclxuICAgICAgICBpZiAoIVRPVUNIX0VOQUJMRUQgfHwgdGhpcy5vcHRpb25zXy5uYXRpdmVDb250cm9sc0ZvclRvdWNoICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5jb250cm9scztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldEF0dHJpYnV0ZXMoZWwsIGFzc2lnbihhdHRyaWJ1dGVzLCB7XHJcbiAgICAgICAgICBpZDogdGhpcy5vcHRpb25zXy50ZWNoSWQsXHJcbiAgICAgICAgICAnY2xhc3MnOiAndmpzLXRlY2gnXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlbC5wbGF5ZXJJZCA9IHRoaXMub3B0aW9uc18ucGxheWVySWQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnNfLnByZWxvYWQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHNldEF0dHJpYnV0ZShlbCwgJ3ByZWxvYWQnLCB0aGlzLm9wdGlvbnNfLnByZWxvYWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVwZGF0ZSBzcGVjaWZpYyB0YWcgc2V0dGluZ3MsIGluIGNhc2UgdGhleSB3ZXJlIG92ZXJyaWRkZW5cclxuICAgIC8vIGBhdXRvcGxheWAgaGFzIHRvIGJlICpsYXN0KiBzbyB0aGF0IGBtdXRlZGAgYW5kIGBwbGF5c2lubGluZWAgYXJlIHByZXNlbnRcclxuICAgIC8vIHdoZW4gaU9TL1NhZmFyaSBvciBvdGhlciBicm93c2VycyBhdHRlbXB0IHRvIGF1dG9wbGF5LlxyXG4gICAgdmFyIHNldHRpbmdzQXR0cnMgPSBbJ2xvb3AnLCAnbXV0ZWQnLCAncGxheXNpbmxpbmUnLCAnYXV0b3BsYXknXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gc2V0dGluZ3NBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICB2YXIgYXR0ciA9IHNldHRpbmdzQXR0cnNbaV07XHJcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMub3B0aW9uc19bYXR0cl07XHJcblxyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgc2V0QXR0cmlidXRlKGVsLCBhdHRyLCBhdHRyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVtb3ZlQXR0cmlidXRlKGVsLCBhdHRyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxbYXR0cl0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIHdpbGwgYmUgdHJpZ2dlcmVkIGlmIHRoZSBsb2Fkc3RhcnQgZXZlbnQgaGFzIGFscmVhZHkgZmlyZWQsIGJlZm9yZSB2aWRlb2pzIHdhc1xyXG4gICAqIHJlYWR5LiBUd28ga25vd24gZXhhbXBsZXMgb2Ygd2hlbiB0aGlzIGNhbiBoYXBwZW4gYXJlOlxyXG4gICAqIDEuIElmIHdlJ3JlIGxvYWRpbmcgdGhlIHBsYXliYWNrIG9iamVjdCBhZnRlciBpdCBoYXMgc3RhcnRlZCBsb2FkaW5nXHJcbiAgICogMi4gVGhlIG1lZGlhIGlzIGFscmVhZHkgcGxheWluZyB0aGUgKG9mdGVuIHdpdGggYXV0b3BsYXkgb24pIHRoZW5cclxuICAgKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBmaXJlIGFub3RoZXIgbG9hZHN0YXJ0IHNvIHRoYXQgdmlkZW9qcyBjYW4gY2F0Y2h1cC5cclxuICAgKlxyXG4gICAqIEBmaXJlcyBUZWNoI2xvYWRzdGFydFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxyXG4gICAqICAgICAgICAgcmV0dXJucyBub3RoaW5nLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgSHRtbDUucHJvdG90eXBlLmhhbmRsZUxhdGVJbml0XyA9IGZ1bmN0aW9uIGhhbmRsZUxhdGVJbml0XyhlbCkge1xyXG4gICAgaWYgKGVsLm5ldHdvcmtTdGF0ZSA9PT0gMCB8fCBlbC5uZXR3b3JrU3RhdGUgPT09IDMpIHtcclxuICAgICAgLy8gVGhlIHZpZGVvIGVsZW1lbnQgaGFzbid0IHN0YXJ0ZWQgbG9hZGluZyB0aGUgc291cmNlIHlldFxyXG4gICAgICAvLyBvciBkaWRuJ3QgZmluZCBhIHNvdXJjZVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPT09IDApIHtcclxuICAgICAgLy8gTmV0d29ya1N0YXRlIGlzIHNldCBzeW5jaHJvbm91c2x5IEJVVCBsb2Fkc3RhcnQgaXMgZmlyZWQgYXQgdGhlXHJcbiAgICAgIC8vIGVuZCBvZiB0aGUgY3VycmVudCBzdGFjaywgdXN1YWxseSBiZWZvcmUgc2V0SW50ZXJ2YWwoZm4sIDApLlxyXG4gICAgICAvLyBTbyBhdCB0aGlzIHBvaW50IHdlIGtub3cgbG9hZHN0YXJ0IG1heSBoYXZlIGFscmVhZHkgZmlyZWQgb3IgaXNcclxuICAgICAgLy8gYWJvdXQgdG8gZmlyZSwgYW5kIGVpdGhlciB3YXkgdGhlIHBsYXllciBoYXNuJ3Qgc2VlbiBpdCB5ZXQuXHJcbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gZmlyZSBsb2Fkc3RhcnQgcHJlbWF0dXJlbHkgaGVyZSBhbmQgY2F1c2UgYVxyXG4gICAgICAvLyBkb3VibGUgbG9hZHN0YXJ0IHNvIHdlJ2xsIHdhaXQgYW5kIHNlZSBpZiBpdCBoYXBwZW5zIGJldHdlZW4gbm93XHJcbiAgICAgIC8vIGFuZCB0aGUgbmV4dCBsb29wLCBhbmQgZmlyZSBpdCBpZiBub3QuXHJcbiAgICAgIC8vIEhPV0VWRVIsIHdlIGFsc28gd2FudCB0byBtYWtlIHN1cmUgaXQgZmlyZXMgYmVmb3JlIGxvYWRlZG1ldGFkYXRhXHJcbiAgICAgIC8vIHdoaWNoIGNvdWxkIGFsc28gaGFwcGVuIGJldHdlZW4gbm93IGFuZCB0aGUgbmV4dCBsb29wLCBzbyB3ZSdsbFxyXG4gICAgICAvLyB3YXRjaCBmb3IgdGhhdCBhbHNvLlxyXG4gICAgICB2YXIgbG9hZHN0YXJ0RmlyZWQgPSBmYWxzZTtcclxuICAgICAgdmFyIHNldExvYWRzdGFydEZpcmVkID0gZnVuY3Rpb24gc2V0TG9hZHN0YXJ0RmlyZWQoKSB7XHJcbiAgICAgICAgbG9hZHN0YXJ0RmlyZWQgPSB0cnVlO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5vbignbG9hZHN0YXJ0Jywgc2V0TG9hZHN0YXJ0RmlyZWQpO1xyXG5cclxuICAgICAgdmFyIHRyaWdnZXJMb2Fkc3RhcnQgPSBmdW5jdGlvbiB0cmlnZ2VyTG9hZHN0YXJ0KCkge1xyXG4gICAgICAgIC8vIFdlIGRpZCBtaXNzIHRoZSBvcmlnaW5hbCBsb2Fkc3RhcnQuIE1ha2Ugc3VyZSB0aGUgcGxheWVyXHJcbiAgICAgICAgLy8gc2VlcyBsb2Fkc3RhcnQgYmVmb3JlIGxvYWRlZG1ldGFkYXRhXHJcbiAgICAgICAgaWYgKCFsb2Fkc3RhcnRGaXJlZCkge1xyXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLm9uKCdsb2FkZWRtZXRhZGF0YScsIHRyaWdnZXJMb2Fkc3RhcnQpO1xyXG5cclxuICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5vZmYoJ2xvYWRzdGFydCcsIHNldExvYWRzdGFydEZpcmVkKTtcclxuICAgICAgICB0aGlzLm9mZignbG9hZGVkbWV0YWRhdGEnLCB0cmlnZ2VyTG9hZHN0YXJ0KTtcclxuXHJcbiAgICAgICAgaWYgKCFsb2Fkc3RhcnRGaXJlZCkge1xyXG4gICAgICAgICAgLy8gV2UgZGlkIG1pc3MgdGhlIG9yaWdpbmFsIG5hdGl2ZSBsb2Fkc3RhcnQuIEZpcmUgaXQgbm93LlxyXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZyb20gaGVyZSBvbiB3ZSBrbm93IHRoYXQgbG9hZHN0YXJ0IGFscmVhZHkgZmlyZWQgYW5kIHdlIG1pc3NlZCBpdC5cclxuICAgIC8vIFRoZSBvdGhlciByZWFkeVN0YXRlIGV2ZW50cyBhcmVuJ3QgYXMgbXVjaCBvZiBhIHByb2JsZW0gaWYgd2UgZG91YmxlXHJcbiAgICAvLyB0aGVtLCBzbyBub3QgZ29pbmcgdG8gZ28gdG8gYXMgbXVjaCB0cm91YmxlIGFzIGxvYWRzdGFydCB0byBwcmV2ZW50XHJcbiAgICAvLyB0aGF0IHVubGVzcyB3ZSBmaW5kIHJlYXNvbiB0by5cclxuICAgIHZhciBldmVudHNUb1RyaWdnZXIgPSBbJ2xvYWRzdGFydCddO1xyXG5cclxuICAgIC8vIGxvYWRlZG1ldGFkYXRhOiBuZXdseSBlcXVhbCB0byBIQVZFX01FVEFEQVRBICgxKSBvciBncmVhdGVyXHJcbiAgICBldmVudHNUb1RyaWdnZXIucHVzaCgnbG9hZGVkbWV0YWRhdGEnKTtcclxuXHJcbiAgICAvLyBsb2FkZWRkYXRhOiBuZXdseSBpbmNyZWFzZWQgdG8gSEFWRV9DVVJSRU5UX0RBVEEgKDIpIG9yIGdyZWF0ZXJcclxuICAgIGlmIChlbC5yZWFkeVN0YXRlID49IDIpIHtcclxuICAgICAgZXZlbnRzVG9UcmlnZ2VyLnB1c2goJ2xvYWRlZGRhdGEnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjYW5wbGF5OiBuZXdseSBpbmNyZWFzZWQgdG8gSEFWRV9GVVRVUkVfREFUQSAoMykgb3IgZ3JlYXRlclxyXG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPj0gMykge1xyXG4gICAgICBldmVudHNUb1RyaWdnZXIucHVzaCgnY2FucGxheScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbnBsYXl0aHJvdWdoOiBuZXdseSBlcXVhbCB0byBIQVZFX0VOT1VHSF9EQVRBICg0KVxyXG4gICAgaWYgKGVsLnJlYWR5U3RhdGUgPj0gNCkge1xyXG4gICAgICBldmVudHNUb1RyaWdnZXIucHVzaCgnY2FucGxheXRocm91Z2gnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBXZSBzdGlsbCBuZWVkIHRvIGdpdmUgdGhlIHBsYXllciB0aW1lIHRvIGFkZCBldmVudCBsaXN0ZW5lcnNcclxuICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICBldmVudHNUb1RyaWdnZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcih0eXBlKTtcclxuICAgICAgfSwgdGhpcyk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBTZXQgY3VycmVudCB0aW1lIGZvciB0aGUgYEhUTUw1YCB0ZWNoLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHNcclxuICAgKiAgICAgICAgU2V0IHRoZSBjdXJyZW50IHRpbWUgb2YgdGhlIG1lZGlhIHRvIHRoaXMuXHJcbiAgICovXHJcblxyXG5cclxuICBIdG1sNS5wcm90b3R5cGUuc2V0Q3VycmVudFRpbWUgPSBmdW5jdGlvbiBzZXRDdXJyZW50VGltZShzZWNvbmRzKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLmVsXy5jdXJyZW50VGltZSA9IHNlY29uZHM7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGxvZyQxKGUsICdWaWRlbyBpcyBub3QgcmVhZHkuIChWaWRlby5qcyknKTtcclxuICAgICAgLy8gdGhpcy53YXJuaW5nKFZpZGVvSlMud2FybmluZ3MudmlkZW9Ob3RSZWFkeSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjdXJyZW50IGR1cmF0aW9uIG9mIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqICAgICAgICAgVGhlIGR1cmF0aW9uIG9mIHRoZSBtZWRpYSBvciAwIGlmIHRoZXJlIGlzIG5vIGR1cmF0aW9uLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgSHRtbDUucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24oKSB7XHJcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcclxuXHJcbiAgICAvLyBBbmRyb2lkIENocm9tZSB3aWxsIHJlcG9ydCBkdXJhdGlvbiBhcyBJbmZpbml0eSBmb3IgVk9EIEhMUyB1bnRpbCBhZnRlclxyXG4gICAgLy8gcGxheWJhY2sgaGFzIHN0YXJ0ZWQsIHdoaWNoIHRyaWdnZXJzIHRoZSBsaXZlIGRpc3BsYXkgZXJyb25lb3VzbHkuXHJcbiAgICAvLyBSZXR1cm4gTmFOIGlmIHBsYXliYWNrIGhhcyBub3Qgc3RhcnRlZCBhbmQgdHJpZ2dlciBhIGR1cmF0aW9udXBkYXRlIG9uY2VcclxuICAgIC8vIHRoZSBkdXJhdGlvbiBjYW4gYmUgcmVsaWFibHkga25vd24uXHJcbiAgICBpZiAodGhpcy5lbF8uZHVyYXRpb24gPT09IEluZmluaXR5ICYmIElTX0FORFJPSUQgJiYgSVNfQ0hST01FICYmIHRoaXMuZWxfLmN1cnJlbnRUaW1lID09PSAwKSB7XHJcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBmaXJzdCBgdGltZXVwZGF0ZWAgd2l0aCBjdXJyZW50VGltZSA+IDAgLSB0aGVyZSBtYXkgYmVcclxuICAgICAgLy8gc2V2ZXJhbCB3aXRoIDBcclxuICAgICAgdmFyIGNoZWNrUHJvZ3Jlc3MgPSBmdW5jdGlvbiBjaGVja1Byb2dyZXNzKCkge1xyXG4gICAgICAgIGlmIChfdGhpczMuZWxfLmN1cnJlbnRUaW1lID4gMCkge1xyXG4gICAgICAgICAgLy8gVHJpZ2dlciBkdXJhdGlvbmNoYW5nZSBmb3IgZ2VudWluZWx5IGxpdmUgdmlkZW9cclxuICAgICAgICAgIGlmIChfdGhpczMuZWxfLmR1cmF0aW9uID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICBfdGhpczMudHJpZ2dlcignZHVyYXRpb25jaGFuZ2UnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIF90aGlzMy5vZmYoJ3RpbWV1cGRhdGUnLCBjaGVja1Byb2dyZXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICB0aGlzLm9uKCd0aW1ldXBkYXRlJywgY2hlY2tQcm9ncmVzcyk7XHJcbiAgICAgIHJldHVybiBOYU47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5lbF8uZHVyYXRpb24gfHwgTmFOO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY3VycmVudCB3aWR0aCBvZiB0aGUgSFRNTDUgbWVkaWEgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKiAgICAgICAgIFRoZSB3aWR0aCBvZiB0aGUgSFRNTDUgbWVkaWEgZWxlbWVudC5cclxuICAgKi9cclxuXHJcblxyXG4gIEh0bWw1LnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uIHdpZHRoKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZWxfLm9mZnNldFdpZHRoO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY3VycmVudCBoZWlnaHQgb2YgdGhlIEhUTUw1IG1lZGlhIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICogICAgICAgICBUaGUgaGVpZ3RoIG9mIHRoZSBIVE1MNSBtZWRpYSBlbGVtZW50LlxyXG4gICAqL1xyXG5cclxuXHJcbiAgSHRtbDUucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uIGhlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLmVsXy5vZmZzZXRIZWlnaHQ7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUHJveHkgaU9TIGB3ZWJraXRiZWdpbmZ1bGxzY3JlZW5gIGFuZCBgd2Via2l0ZW5kZnVsbHNjcmVlbmAgaW50b1xyXG4gICAqIGBmdWxsc2NyZWVuY2hhbmdlYCBldmVudC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQGZpcmVzIGZ1bGxzY3JlZW5jaGFuZ2VcclxuICAgKiBAbGlzdGVucyB3ZWJraXRlbmRmdWxsc2NyZWVuXHJcbiAgICogQGxpc3RlbnMgd2Via2l0YmVnaW5mdWxsc2NyZWVuXHJcbiAgICogQGxpc3RlbnMgd2Via2l0YmVnaW5mdWxsc2NyZWVuXHJcbiAgICovXHJcblxyXG5cclxuICBIdG1sNS5wcm90b3R5cGUucHJveHlXZWJraXRGdWxsc2NyZWVuXyA9IGZ1bmN0aW9uIHByb3h5V2Via2l0RnVsbHNjcmVlbl8oKSB7XHJcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcclxuXHJcbiAgICBpZiAoISgnd2Via2l0RGlzcGxheWluZ0Z1bGxzY3JlZW4nIGluIHRoaXMuZWxfKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVuZEZuID0gZnVuY3Rpb24gZW5kRm4oKSB7XHJcbiAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScsIHsgaXNGdWxsc2NyZWVuOiBmYWxzZSB9KTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGJlZ2luRm4gPSBmdW5jdGlvbiBiZWdpbkZuKCkge1xyXG4gICAgICBpZiAoJ3dlYmtpdFByZXNlbnRhdGlvbk1vZGUnIGluIHRoaXMuZWxfICYmIHRoaXMuZWxfLndlYmtpdFByZXNlbnRhdGlvbk1vZGUgIT09ICdwaWN0dXJlLWluLXBpY3R1cmUnKSB7XHJcbiAgICAgICAgdGhpcy5vbmUoJ3dlYmtpdGVuZGZ1bGxzY3JlZW4nLCBlbmRGbik7XHJcblxyXG4gICAgICAgIHRoaXMudHJpZ2dlcignZnVsbHNjcmVlbmNoYW5nZScsIHsgaXNGdWxsc2NyZWVuOiB0cnVlIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMub24oJ3dlYmtpdGJlZ2luZnVsbHNjcmVlbicsIGJlZ2luRm4pO1xyXG4gICAgdGhpcy5vbignZGlzcG9zZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgX3RoaXM0Lm9mZignd2Via2l0YmVnaW5mdWxsc2NyZWVuJywgYmVnaW5Gbik7XHJcbiAgICAgIF90aGlzNC5vZmYoJ3dlYmtpdGVuZGZ1bGxzY3JlZW4nLCBlbmRGbik7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBmdWxsc2NyZWVuIGlzIHN1cHBvcnRlZCBvbiB0aGUgY3VycmVudCBwbGF5YmFjayBkZXZpY2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqICAgICAgICAgLSBUcnVlIGlmIGZ1bGxzY3JlZW4gaXMgc3VwcG9ydGVkLlxyXG4gICAqICAgICAgICAgLSBGYWxzZSBpZiBmdWxsc2NyZWVuIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICovXHJcblxyXG5cclxuICBIdG1sNS5wcm90b3R5cGUuc3VwcG9ydHNGdWxsU2NyZWVuID0gZnVuY3Rpb24gc3VwcG9ydHNGdWxsU2NyZWVuKCkge1xyXG4gICAgaWYgKHR5cGVvZiB0aGlzLmVsXy53ZWJraXRFbnRlckZ1bGxTY3JlZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdmFyIHVzZXJBZ2VudCA9IHdpbmRvd18xLm5hdmlnYXRvciAmJiB3aW5kb3dfMS5uYXZpZ2F0b3IudXNlckFnZW50IHx8ICcnO1xyXG5cclxuICAgICAgLy8gU2VlbXMgdG8gYmUgYnJva2VuIGluIENocm9taXVtL0Nocm9tZSAmJiBTYWZhcmkgaW4gTGVvcGFyZFxyXG4gICAgICBpZiAoL0FuZHJvaWQvLnRlc3QodXNlckFnZW50KSB8fCAhL0Nocm9tZXxNYWMgT1MgWCAxMC41Ly50ZXN0KHVzZXJBZ2VudCkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcXVlc3QgdGhhdCB0aGUgYEhUTUw1YCBUZWNoIGVudGVyIGZ1bGxzY3JlZW4uXHJcbiAgICovXHJcblxyXG5cclxuICBIdG1sNS5wcm90b3R5cGUuZW50ZXJGdWxsU2NyZWVuID0gZnVuY3Rpb24gZW50ZXJGdWxsU2NyZWVuKCkge1xyXG4gICAgdmFyIHZpZGVvID0gdGhpcy5lbF87XHJcblxyXG4gICAgaWYgKHZpZGVvLnBhdXNlZCAmJiB2aWRlby5uZXR3b3JrU3RhdGUgPD0gdmlkZW8uSEFWRV9NRVRBREFUQSkge1xyXG4gICAgICAvLyBhdHRlbXB0IHRvIHByaW1lIHRoZSB2aWRlbyBlbGVtZW50IGZvciBwcm9ncmFtbWF0aWMgYWNjZXNzXHJcbiAgICAgIC8vIHRoaXMgaXNuJ3QgbmVjZXNzYXJ5IG9uIHRoZSBkZXNrdG9wIGJ1dCBzaG91bGRuJ3QgaHVydFxyXG4gICAgICB0aGlzLmVsXy5wbGF5KCk7XHJcblxyXG4gICAgICAvLyBwbGF5aW5nIGFuZCBwYXVzaW5nIHN5bmNocm9ub3VzbHkgZHVyaW5nIHRoZSB0cmFuc2l0aW9uIHRvIGZ1bGxzY3JlZW5cclxuICAgICAgLy8gY2FuIGdldCBpT1MgfjYuMSBkZXZpY2VzIGludG8gYSBwbGF5L3BhdXNlIGxvb3BcclxuICAgICAgdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2aWRlby5wYXVzZSgpO1xyXG4gICAgICAgIHZpZGVvLndlYmtpdEVudGVyRnVsbFNjcmVlbigpO1xyXG4gICAgICB9LCAwKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZpZGVvLndlYmtpdEVudGVyRnVsbFNjcmVlbigpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcXVlc3QgdGhhdCB0aGUgYEhUTUw1YCBUZWNoIGV4aXQgZnVsbHNjcmVlbi5cclxuICAgKi9cclxuXHJcblxyXG4gIEh0bWw1LnByb3RvdHlwZS5leGl0RnVsbFNjcmVlbiA9IGZ1bmN0aW9uIGV4aXRGdWxsU2NyZWVuKCkge1xyXG4gICAgdGhpcy5lbF8ud2Via2l0RXhpdEZ1bGxTY3JlZW4oKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBIGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgSHRtbDVgIFRlY2gncyBzb3VyY2Ugb2JqZWN0LlxyXG4gICAqID4gTm90ZTogUGxlYXNlIHVzZSB7QGxpbmsgSHRtbDUjc2V0U291cmNlfVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gW3NyY11cclxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3QgeW91IHdhbnQgdG8gc2V0IG9uIHRoZSBgSFRNTDVgIHRlY2hzIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdHx1bmRlZmluZWR9XHJcbiAgICogICAgICAgICAtIFRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3Qgd2hlbiBhIHNvdXJjZSBpcyBub3QgcGFzc2VkIGluLlxyXG4gICAqICAgICAgICAgLSB1bmRlZmluZWQgd2hlbiBzZXR0aW5nXHJcbiAgICpcclxuICAgKiBAZGVwcmVjYXRlZCBTaW5jZSB2ZXJzaW9uIDUuXHJcbiAgICovXHJcblxyXG5cclxuICBIdG1sNS5wcm90b3R5cGUuc3JjID0gZnVuY3Rpb24gc3JjKF9zcmMpIHtcclxuICAgIGlmIChfc3JjID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZWxfLnNyYztcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXR0aW5nIHNyYyB0aHJvdWdoIGBzcmNgIGluc3RlYWQgb2YgYHNldFNyY2Agd2lsbCBiZSBkZXByZWNhdGVkXHJcbiAgICB0aGlzLnNldFNyYyhfc3JjKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXNldCB0aGUgdGVjaCBieSByZW1vdmluZyBhbGwgc291cmNlcyBhbmQgdGhlbiBjYWxsaW5nXHJcbiAgICoge0BsaW5rIEh0bWw1LnJlc2V0TWVkaWFFbGVtZW50fS5cclxuICAgKi9cclxuXHJcblxyXG4gIEh0bWw1LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xyXG4gICAgSHRtbDUucmVzZXRNZWRpYUVsZW1lbnQodGhpcy5lbF8pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY3VycmVudCBzb3VyY2Ugb24gdGhlIGBIVE1MNWAgVGVjaC4gRmFsbHMgYmFjayB0byByZXR1cm5pbmcgdGhlIHNvdXJjZSBmcm9tXHJcbiAgICogdGhlIEhUTUw1IG1lZGlhIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtUZWNoflNvdXJjZU9iamVjdH1cclxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3QgZnJvbSB0aGUgSFRNTDUgdGVjaC4gV2l0aCBhIGZhbGxiYWNrIHRvIHRoZVxyXG4gICAqICAgICAgICAgZWxlbWVudHMgc291cmNlLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgSHRtbDUucHJvdG90eXBlLmN1cnJlbnRTcmMgPSBmdW5jdGlvbiBjdXJyZW50U3JjKCkge1xyXG4gICAgaWYgKHRoaXMuY3VycmVudFNvdXJjZV8pIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNvdXJjZV8uc3JjO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuZWxfLmN1cnJlbnRTcmM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGNvbnRyb2xzIGF0dHJpYnV0ZSBmb3IgdGhlIEhUTUw1IG1lZGlhIEVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsXHJcbiAgICogICAgICAgIFZhbHVlIHRvIHNldCB0aGUgY29udHJvbHMgYXR0cmlidXRlIHRvXHJcbiAgICovXHJcblxyXG5cclxuICBIdG1sNS5wcm90b3R5cGUuc2V0Q29udHJvbHMgPSBmdW5jdGlvbiBzZXRDb250cm9scyh2YWwpIHtcclxuICAgIHRoaXMuZWxfLmNvbnRyb2xzID0gISF2YWw7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm5zIGEgcmVtb3RlIHtAbGluayBUZXh0VHJhY2t9IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBraW5kXHJcbiAgICogICAgICAgIGBUZXh0VHJhY2tgIGtpbmQgKHN1YnRpdGxlcywgY2FwdGlvbnMsIGRlc2NyaXB0aW9ucywgY2hhcHRlcnMsIG9yIG1ldGFkYXRhKVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYWJlbF1cclxuICAgKiAgICAgICAgTGFiZWwgdG8gaWRlbnRpZnkgdGhlIHRleHQgdHJhY2tcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2VdXHJcbiAgICogICAgICAgIFR3byBsZXR0ZXIgbGFuZ3VhZ2UgYWJicmV2aWF0aW9uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtUZXh0VHJhY2t9XHJcbiAgICogICAgICAgICBUaGUgVGV4dFRyYWNrIHRoYXQgZ2V0cyBjcmVhdGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgSHRtbDUucHJvdG90eXBlLmFkZFRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFRleHRUcmFjayhraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpIHtcclxuICAgIGlmICghdGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcclxuICAgICAgcmV0dXJuIF9UZWNoLnByb3RvdHlwZS5hZGRUZXh0VHJhY2suY2FsbCh0aGlzLCBraW5kLCBsYWJlbCwgbGFuZ3VhZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmVsXy5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGVpdGhlciBuYXRpdmUgVGV4dFRyYWNrIG9yIGFuIGVtdWxhdGVkIFRleHRUcmFjayBkZXBlbmRpbmdcclxuICAgKiBvbiB0aGUgdmFsdWUgb2YgYGZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrc2BcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICogICAgICAgIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gdGhlIG9wdGlvbnMgdG8gaW50aWFsaXplIHRoZSBUZXh0VHJhY2sgd2l0aC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5raW5kXVxyXG4gICAqICAgICAgICBgVGV4dFRyYWNrYCBraW5kIChzdWJ0aXRsZXMsIGNhcHRpb25zLCBkZXNjcmlwdGlvbnMsIGNoYXB0ZXJzLCBvciBtZXRhZGF0YSkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGFiZWxdLlxyXG4gICAqICAgICAgICBMYWJlbCB0byBpZGVudGlmeSB0aGUgdGV4dCB0cmFja1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlXVxyXG4gICAqICAgICAgICBUd28gbGV0dGVyIGxhbmd1YWdlIGFiYnJldmlhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVmYXVsdF1cclxuICAgKiAgICAgICAgRGVmYXVsdCB0aGlzIHRyYWNrIHRvIG9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmlkXVxyXG4gICAqICAgICAgICBUaGUgaW50ZXJuYWwgaWQgdG8gYXNzaWduIHRoaXMgdHJhY2suXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3JjXVxyXG4gICAqICAgICAgICBBIHNvdXJjZSB1cmwgZm9yIHRoZSB0cmFjay5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0hUTUxUcmFja0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgdHJhY2sgZWxlbWVudCB0aGF0IGdldHMgY3JlYXRlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIEh0bWw1LnByb3RvdHlwZS5jcmVhdGVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBjcmVhdGVSZW1vdGVUZXh0VHJhY2sob3B0aW9ucykge1xyXG4gICAgaWYgKCF0aGlzLmZlYXR1cmVzTmF0aXZlVGV4dFRyYWNrcykge1xyXG4gICAgICByZXR1cm4gX1RlY2gucHJvdG90eXBlLmNyZWF0ZVJlbW90ZVRleHRUcmFjay5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgdmFyIGh0bWxUcmFja0VsZW1lbnQgPSBkb2N1bWVudF8xLmNyZWF0ZUVsZW1lbnQoJ3RyYWNrJyk7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMua2luZCkge1xyXG4gICAgICBodG1sVHJhY2tFbGVtZW50LmtpbmQgPSBvcHRpb25zLmtpbmQ7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5sYWJlbCkge1xyXG4gICAgICBodG1sVHJhY2tFbGVtZW50LmxhYmVsID0gb3B0aW9ucy5sYWJlbDtcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zLmxhbmd1YWdlIHx8IG9wdGlvbnMuc3JjbGFuZykge1xyXG4gICAgICBodG1sVHJhY2tFbGVtZW50LnNyY2xhbmcgPSBvcHRpb25zLmxhbmd1YWdlIHx8IG9wdGlvbnMuc3JjbGFuZztcclxuICAgIH1cclxuICAgIGlmIChvcHRpb25zWydkZWZhdWx0J10pIHtcclxuICAgICAgaHRtbFRyYWNrRWxlbWVudFsnZGVmYXVsdCddID0gb3B0aW9uc1snZGVmYXVsdCddO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMuaWQpIHtcclxuICAgICAgaHRtbFRyYWNrRWxlbWVudC5pZCA9IG9wdGlvbnMuaWQ7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5zcmMpIHtcclxuICAgICAgaHRtbFRyYWNrRWxlbWVudC5zcmMgPSBvcHRpb25zLnNyYztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaHRtbFRyYWNrRWxlbWVudDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgcmVtb3RlIHRleHQgdHJhY2sgb2JqZWN0IGFuZCByZXR1cm5zIGFuIGh0bWwgdHJhY2sgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4gdmFsdWVzIGZvclxyXG4gICAqIGtpbmQsIGxhbmd1YWdlLCBsYWJlbCwgYW5kIHNyYyAobG9jYXRpb24gb2YgdGhlIFdlYlZUVCBmaWxlKVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hbnVhbENsZWFudXA9dHJ1ZV0gaWYgc2V0IHRvIGZhbHNlLCB0aGUgVGV4dFRyYWNrIHdpbGwgYmVcclxuICAgKiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgZnJvbSB0aGUgdmlkZW8gZWxlbWVudCB3aGVuZXZlciB0aGUgc291cmNlIGNoYW5nZXNcclxuICAgKiBAcmV0dXJuIHtIVE1MVHJhY2tFbGVtZW50fSBBbiBIdG1sIFRyYWNrIEVsZW1lbnQuXHJcbiAgICogVGhpcyBjYW4gYmUgYW4gZW11bGF0ZWQge0BsaW5rIEhUTUxUcmFja0VsZW1lbnR9IG9yIGEgbmF0aXZlIG9uZS5cclxuICAgKiBAZGVwcmVjYXRlZCBUaGUgZGVmYXVsdCB2YWx1ZSBvZiB0aGUgXCJtYW51YWxDbGVhbnVwXCIgcGFyYW1ldGVyIHdpbGwgZGVmYXVsdFxyXG4gICAqIHRvIFwiZmFsc2VcIiBpbiB1cGNvbWluZyB2ZXJzaW9ucyBvZiBWaWRlby5qc1xyXG4gICAqL1xyXG5cclxuXHJcbiAgSHRtbDUucHJvdG90eXBlLmFkZFJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIGFkZFJlbW90ZVRleHRUcmFjayhvcHRpb25zLCBtYW51YWxDbGVhbnVwKSB7XHJcbiAgICB2YXIgaHRtbFRyYWNrRWxlbWVudCA9IF9UZWNoLnByb3RvdHlwZS5hZGRSZW1vdGVUZXh0VHJhY2suY2FsbCh0aGlzLCBvcHRpb25zLCBtYW51YWxDbGVhbnVwKTtcclxuXHJcbiAgICBpZiAodGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcclxuICAgICAgdGhpcy5lbCgpLmFwcGVuZENoaWxkKGh0bWxUcmFja0VsZW1lbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBodG1sVHJhY2tFbGVtZW50O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSByZW1vdGUgYFRleHRUcmFja2AgZnJvbSBgVGV4dFRyYWNrTGlzdGAgb2JqZWN0XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RleHRUcmFja30gdHJhY2tcclxuICAgKiAgICAgICAgYFRleHRUcmFja2Agb2JqZWN0IHRvIHJlbW92ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgSHRtbDUucHJvdG90eXBlLnJlbW92ZVJlbW90ZVRleHRUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVJlbW90ZVRleHRUcmFjayh0cmFjaykge1xyXG4gICAgX1RlY2gucHJvdG90eXBlLnJlbW92ZVJlbW90ZVRleHRUcmFjay5jYWxsKHRoaXMsIHRyYWNrKTtcclxuXHJcbiAgICBpZiAodGhpcy5mZWF0dXJlc05hdGl2ZVRleHRUcmFja3MpIHtcclxuICAgICAgdmFyIHRyYWNrcyA9IHRoaXMuJCQoJ3RyYWNrJyk7XHJcblxyXG4gICAgICB2YXIgaSA9IHRyYWNrcy5sZW5ndGg7XHJcblxyXG4gICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgaWYgKHRyYWNrID09PSB0cmFja3NbaV0gfHwgdHJhY2sgPT09IHRyYWNrc1tpXS50cmFjaykge1xyXG4gICAgICAgICAgdGhpcy5lbCgpLnJlbW92ZUNoaWxkKHRyYWNrc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhdmFpbGFibGUgbWVkaWEgcGxheWJhY2sgcXVhbGl0eSBtZXRyaWNzIGFzIHNwZWNpZmllZCBieSB0aGUgVzNDJ3MgTWVkaWFcclxuICAgKiBQbGF5YmFjayBRdWFsaXR5IEFQSS5cclxuICAgKlxyXG4gICAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd2ljZy5naXRodWIuaW8vbWVkaWEtcGxheWJhY2stcXVhbGl0eX1cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKiAgICAgICAgIEFuIG9iamVjdCB3aXRoIHN1cHBvcnRlZCBtZWRpYSBwbGF5YmFjayBxdWFsaXR5IG1ldHJpY3NcclxuICAgKi9cclxuXHJcblxyXG4gIEh0bWw1LnByb3RvdHlwZS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9IGZ1bmN0aW9uIGdldFZpZGVvUGxheWJhY2tRdWFsaXR5KCkge1xyXG4gICAgaWYgKHR5cGVvZiB0aGlzLmVsKCkuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZWwoKS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB2aWRlb1BsYXliYWNrUXVhbGl0eSA9IHt9O1xyXG5cclxuICAgIGlmICh0eXBlb2YgdGhpcy5lbCgpLndlYmtpdERyb3BwZWRGcmFtZUNvdW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGhpcy5lbCgpLndlYmtpdERlY29kZWRGcmFtZUNvdW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICB2aWRlb1BsYXliYWNrUXVhbGl0eS5kcm9wcGVkVmlkZW9GcmFtZXMgPSB0aGlzLmVsKCkud2Via2l0RHJvcHBlZEZyYW1lQ291bnQ7XHJcbiAgICAgIHZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXMgPSB0aGlzLmVsKCkud2Via2l0RGVjb2RlZEZyYW1lQ291bnQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHdpbmRvd18xLnBlcmZvcm1hbmNlICYmIHR5cGVvZiB3aW5kb3dfMS5wZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdmlkZW9QbGF5YmFja1F1YWxpdHkuY3JlYXRpb25UaW1lID0gd2luZG93XzEucGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICB9IGVsc2UgaWYgKHdpbmRvd18xLnBlcmZvcm1hbmNlICYmIHdpbmRvd18xLnBlcmZvcm1hbmNlLnRpbWluZyAmJiB0eXBlb2Ygd2luZG93XzEucGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgdmlkZW9QbGF5YmFja1F1YWxpdHkuY3JlYXRpb25UaW1lID0gd2luZG93XzEuRGF0ZS5ub3coKSAtIHdpbmRvd18xLnBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZpZGVvUGxheWJhY2tRdWFsaXR5O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBIdG1sNTtcclxufShUZWNoKTtcclxuXHJcbi8qIEhUTUw1IFN1cHBvcnQgVGVzdGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG5pZiAoaXNSZWFsKCkpIHtcclxuXHJcbiAgLyoqXHJcbiAgICogRWxlbWVudCBmb3IgdGVzdGluZyBicm93c2VyIEhUTUw1IG1lZGlhIGNhcGFiaWxpdGllc1xyXG4gICAqXHJcbiAgICogQHR5cGUge0VsZW1lbnR9XHJcbiAgICogQGNvbnN0YW50XHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBIdG1sNS5URVNUX1ZJRCA9IGRvY3VtZW50XzEuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcclxuICB2YXIgdHJhY2sgPSBkb2N1bWVudF8xLmNyZWF0ZUVsZW1lbnQoJ3RyYWNrJyk7XHJcblxyXG4gIHRyYWNrLmtpbmQgPSAnY2FwdGlvbnMnO1xyXG4gIHRyYWNrLnNyY2xhbmcgPSAnZW4nO1xyXG4gIHRyYWNrLmxhYmVsID0gJ0VuZ2xpc2gnO1xyXG4gIEh0bWw1LlRFU1RfVklELmFwcGVuZENoaWxkKHRyYWNrKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIEhUTUw1IG1lZGlhIGlzIHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIvZGV2aWNlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKiAgICAgICAgIC0gVHJ1ZSBpZiBIVE1MNSBtZWRpYSBpcyBzdXBwb3J0ZWQuXHJcbiAqICAgICAgICAgLSBGYWxzZSBpZiBIVE1MNSBtZWRpYSBpcyBub3Qgc3VwcG9ydGVkLlxyXG4gKi9cclxuSHRtbDUuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgLy8gSUU5IHdpdGggbm8gTWVkaWEgUGxheWVyIGlzIGEgTElBUiEgKCM5ODQpXHJcbiAgdHJ5IHtcclxuICAgIEh0bWw1LlRFU1RfVklELnZvbHVtZSA9IDAuNTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gISEoSHRtbDUuVEVTVF9WSUQgJiYgSHRtbDUuVEVTVF9WSUQuY2FuUGxheVR5cGUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSB0ZWNoIGNhbiBzdXBwb3J0IHRoZSBnaXZlbiB0eXBlXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXHJcbiAqICAgICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2tcclxuICogQHJldHVybiB7c3RyaW5nfSAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxyXG4gKi9cclxuSHRtbDUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gIHJldHVybiBIdG1sNS5URVNUX1ZJRC5jYW5QbGF5VHlwZSh0eXBlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgdGVjaCBjYW4gc3VwcG9ydCB0aGUgZ2l2ZW4gc291cmNlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmNPYmpcclxuICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAqICAgICAgICBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIHRlY2hcclxuICogQHJldHVybiB7c3RyaW5nfSAncHJvYmFibHknLCAnbWF5YmUnLCBvciAnJyAoZW1wdHkgc3RyaW5nKVxyXG4gKi9cclxuSHRtbDUuY2FuUGxheVNvdXJjZSA9IGZ1bmN0aW9uIChzcmNPYmosIG9wdGlvbnMpIHtcclxuICByZXR1cm4gSHRtbDUuY2FuUGxheVR5cGUoc3JjT2JqLnR5cGUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSB2b2x1bWUgY2FuIGJlIGNoYW5nZWQgaW4gdGhpcyBicm93c2VyL2RldmljZS5cclxuICogVm9sdW1lIGNhbm5vdCBiZSBjaGFuZ2VkIGluIGEgbG90IG9mIG1vYmlsZSBkZXZpY2VzLlxyXG4gKiBTcGVjaWZpY2FsbHksIGl0IGNhbid0IGJlIGNoYW5nZWQgZnJvbSAxIG9uIGlPUy5cclxuICpcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICogICAgICAgICAtIFRydWUgaWYgdm9sdW1lIGNhbiBiZSBjb250cm9sbGVkXHJcbiAqICAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcclxuICovXHJcbkh0bWw1LmNhbkNvbnRyb2xWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgLy8gSUUgd2lsbCBlcnJvciBpZiBXaW5kb3dzIE1lZGlhIFBsYXllciBub3QgaW5zdGFsbGVkICMzMzE1XHJcbiAgdHJ5IHtcclxuICAgIHZhciB2b2x1bWUgPSBIdG1sNS5URVNUX1ZJRC52b2x1bWU7XHJcblxyXG4gICAgSHRtbDUuVEVTVF9WSUQudm9sdW1lID0gdm9sdW1lIC8gMiArIDAuMTtcclxuICAgIHJldHVybiB2b2x1bWUgIT09IEh0bWw1LlRFU1RfVklELnZvbHVtZTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBwbGF5YmFjayByYXRlIGNhbiBiZSBjaGFuZ2VkIGluIHRoaXMgYnJvd3Nlci9kZXZpY2UuXHJcbiAqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqICAgICAgICAgLSBUcnVlIGlmIHBsYXliYWNrIHJhdGUgY2FuIGJlIGNvbnRyb2xsZWRcclxuICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxyXG4gKi9cclxuSHRtbDUuY2FuQ29udHJvbFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAvLyBQbGF5YmFjayByYXRlIEFQSSBpcyBpbXBsZW1lbnRlZCBpbiBBbmRyb2lkIENocm9tZSwgYnV0IGRvZXNuJ3QgZG8gYW55dGhpbmdcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvMzE4MFxyXG4gIGlmIChJU19BTkRST0lEICYmIElTX0NIUk9NRSAmJiBDSFJPTUVfVkVSU0lPTiA8IDU4KSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIC8vIElFIHdpbGwgZXJyb3IgaWYgV2luZG93cyBNZWRpYSBQbGF5ZXIgbm90IGluc3RhbGxlZCAjMzMxNVxyXG4gIHRyeSB7XHJcbiAgICB2YXIgcGxheWJhY2tSYXRlID0gSHRtbDUuVEVTVF9WSUQucGxheWJhY2tSYXRlO1xyXG5cclxuICAgIEh0bWw1LlRFU1RfVklELnBsYXliYWNrUmF0ZSA9IHBsYXliYWNrUmF0ZSAvIDIgKyAwLjE7XHJcbiAgICByZXR1cm4gcGxheWJhY2tSYXRlICE9PSBIdG1sNS5URVNUX1ZJRC5wbGF5YmFja1JhdGU7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayB0byBzZWUgaWYgbmF0aXZlIGBUZXh0VHJhY2tgcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2UuXHJcbiAqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqICAgICAgICAgLSBUcnVlIGlmIG5hdGl2ZSBgVGV4dFRyYWNrYHMgYXJlIHN1cHBvcnRlZC5cclxuICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxyXG4gKi9cclxuSHRtbDUuc3VwcG9ydHNOYXRpdmVUZXh0VHJhY2tzID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBJU19BTllfU0FGQVJJO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIHRvIHNlZSBpZiBuYXRpdmUgYFZpZGVvVHJhY2tgcyBhcmUgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci9kZXZpY2VcclxuICpcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICogICAgICAgIC0gVHJ1ZSBpZiBuYXRpdmUgYFZpZGVvVHJhY2tgcyBhcmUgc3VwcG9ydGVkLlxyXG4gKiAgICAgICAgLSBGYWxzZSBvdGhlcndpc2VcclxuICovXHJcbkh0bWw1LnN1cHBvcnRzTmF0aXZlVmlkZW9UcmFja3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuICEhKEh0bWw1LlRFU1RfVklEICYmIEh0bWw1LlRFU1RfVklELnZpZGVvVHJhY2tzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayB0byBzZWUgaWYgbmF0aXZlIGBBdWRpb1RyYWNrYHMgYXJlIHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXIvZGV2aWNlXHJcbiAqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqICAgICAgICAtIFRydWUgaWYgbmF0aXZlIGBBdWRpb1RyYWNrYHMgYXJlIHN1cHBvcnRlZC5cclxuICogICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXHJcbiAqL1xyXG5IdG1sNS5zdXBwb3J0c05hdGl2ZUF1ZGlvVHJhY2tzID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiAhIShIdG1sNS5URVNUX1ZJRCAmJiBIdG1sNS5URVNUX1ZJRC5hdWRpb1RyYWNrcyk7XHJcbn07XHJcblxyXG4vKipcclxuICogQW4gYXJyYXkgb2YgZXZlbnRzIGF2YWlsYWJsZSBvbiB0aGUgSHRtbDUgdGVjaC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHR5cGUge0FycmF5fVxyXG4gKi9cclxuSHRtbDUuRXZlbnRzID0gWydsb2Fkc3RhcnQnLCAnc3VzcGVuZCcsICdhYm9ydCcsICdlcnJvcicsICdlbXB0aWVkJywgJ3N0YWxsZWQnLCAnbG9hZGVkbWV0YWRhdGEnLCAnbG9hZGVkZGF0YScsICdjYW5wbGF5JywgJ2NhbnBsYXl0aHJvdWdoJywgJ3BsYXlpbmcnLCAnd2FpdGluZycsICdzZWVraW5nJywgJ3NlZWtlZCcsICdlbmRlZCcsICdkdXJhdGlvbmNoYW5nZScsICd0aW1ldXBkYXRlJywgJ3Byb2dyZXNzJywgJ3BsYXknLCAncGF1c2UnLCAncmF0ZWNoYW5nZScsICdyZXNpemUnLCAndm9sdW1lY2hhbmdlJ107XHJcblxyXG4vKipcclxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBUZWNoYCBzdXBwb3J0cyB2b2x1bWUgY29udHJvbC5cclxuICpcclxuICogQHR5cGUge2Jvb2xlYW59XHJcbiAqIEBkZWZhdWx0IHtAbGluayBIdG1sNS5jYW5Db250cm9sVm9sdW1lfVxyXG4gKi9cclxuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzVm9sdW1lQ29udHJvbCA9IEh0bWw1LmNhbkNvbnRyb2xWb2x1bWUoKTtcclxuXHJcbi8qKlxyXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYFRlY2hgIHN1cHBvcnRzIGNoYW5naW5nIHRoZSBzcGVlZCBhdCB3aGljaCB0aGUgbWVkaWFcclxuICogcGxheXMuIEV4YW1wbGVzOlxyXG4gKiAgIC0gU2V0IHBsYXllciB0byBwbGF5IDJ4ICh0d2ljZSkgYXMgZmFzdFxyXG4gKiAgIC0gU2V0IHBsYXllciB0byBwbGF5IDAuNXggKGhhbGYpIGFzIGZhc3RcclxuICpcclxuICogQHR5cGUge2Jvb2xlYW59XHJcbiAqIEBkZWZhdWx0IHtAbGluayBIdG1sNS5jYW5Db250cm9sUGxheWJhY2tSYXRlfVxyXG4gKi9cclxuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzUGxheWJhY2tSYXRlID0gSHRtbDUuY2FuQ29udHJvbFBsYXliYWNrUmF0ZSgpO1xyXG5cclxuLyoqXHJcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIHRoZSBtZWRpYSBlbGVtZW50XHJcbiAqIG1vdmluZyBpbiB0aGUgRE9NLiBpT1MgYnJlYWtzIGlmIHlvdSBtb3ZlIHRoZSBtZWRpYSBlbGVtZW50LCBzbyB0aGlzIGlzIHNldCB0aGlzIHRvXHJcbiAqIGZhbHNlIHRoZXJlLiBFdmVyeXdoZXJlIGVsc2UgdGhpcyBzaG91bGQgYmUgdHJ1ZS5cclxuICpcclxuICogQHR5cGUge2Jvb2xlYW59XHJcbiAqIEBkZWZhdWx0XHJcbiAqL1xyXG5IdG1sNS5wcm90b3R5cGUubW92aW5nTWVkaWFFbGVtZW50SW5ET00gPSAhSVNfSU9TO1xyXG5cclxuLy8gVE9ETzogUHJldmlvdXMgY29tbWVudDogTm8gbG9uZ2VyIGFwcGVhcnMgdG8gYmUgdXNlZC4gQ2FuIHByb2JhYmx5IGJlIHJlbW92ZWQuXHJcbi8vICAgICAgIElzIHRoaXMgdHJ1ZT9cclxuLyoqXHJcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIGF1dG9tYXRpYyBtZWRpYSByZXNpemVcclxuICogd2hlbiBnb2luZyBpbnRvIGZ1bGxzY3JlZW4uXHJcbiAqXHJcbiAqIEB0eXBlIHtib29sZWFufVxyXG4gKiBAZGVmYXVsdFxyXG4gKi9cclxuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzRnVsbHNjcmVlblJlc2l6ZSA9IHRydWU7XHJcblxyXG4vKipcclxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBIVE1MNWAgdGVjaCBjdXJyZW50bHkgc3VwcG9ydHMgdGhlIHByb2dyZXNzIGV2ZW50LlxyXG4gKiBJZiB0aGlzIGlzIGZhbHNlLCBtYW51YWwgYHByb2dyZXNzYCBldmVudHMgd2lsbCBiZSB0cmlnZ3JlZCBpbnN0ZWFkLlxyXG4gKlxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICogQGRlZmF1bHRcclxuICovXHJcbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc1Byb2dyZXNzRXZlbnRzID0gdHJ1ZTtcclxuXHJcbi8qKlxyXG4gKiBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgYEhUTUw1YCB0ZWNoIGN1cnJlbnRseSBzdXBwb3J0cyB0aGUgdGltZXVwZGF0ZSBldmVudC5cclxuICogSWYgdGhpcyBpcyBmYWxzZSwgbWFudWFsIGB0aW1ldXBkYXRlYCBldmVudHMgd2lsbCBiZSB0cmlnZ3JlZCBpbnN0ZWFkLlxyXG4gKlxyXG4gKiBAZGVmYXVsdFxyXG4gKi9cclxuSHRtbDUucHJvdG90eXBlLmZlYXR1cmVzVGltZXVwZGF0ZUV2ZW50cyA9IHRydWU7XHJcblxyXG4vKipcclxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBIVE1MNWAgdGVjaCBjdXJyZW50bHkgc3VwcG9ydHMgbmF0aXZlIGBUZXh0VHJhY2tgcy5cclxuICpcclxuICogQHR5cGUge2Jvb2xlYW59XHJcbiAqIEBkZWZhdWx0IHtAbGluayBIdG1sNS5zdXBwb3J0c05hdGl2ZVRleHRUcmFja3N9XHJcbiAqL1xyXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNOYXRpdmVUZXh0VHJhY2tzID0gSHRtbDUuc3VwcG9ydHNOYXRpdmVUZXh0VHJhY2tzKCk7XHJcblxyXG4vKipcclxuICogQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGBIVE1MNWAgdGVjaCBjdXJyZW50bHkgc3VwcG9ydHMgbmF0aXZlIGBWaWRlb1RyYWNrYHMuXHJcbiAqXHJcbiAqIEB0eXBlIHtib29sZWFufVxyXG4gKiBAZGVmYXVsdCB7QGxpbmsgSHRtbDUuc3VwcG9ydHNOYXRpdmVWaWRlb1RyYWNrc31cclxuICovXHJcbkh0bWw1LnByb3RvdHlwZS5mZWF0dXJlc05hdGl2ZVZpZGVvVHJhY2tzID0gSHRtbDUuc3VwcG9ydHNOYXRpdmVWaWRlb1RyYWNrcygpO1xyXG5cclxuLyoqXHJcbiAqIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBgSFRNTDVgIHRlY2ggY3VycmVudGx5IHN1cHBvcnRzIG5hdGl2ZSBgQXVkaW9UcmFja2BzLlxyXG4gKlxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICogQGRlZmF1bHQge0BsaW5rIEh0bWw1LnN1cHBvcnRzTmF0aXZlQXVkaW9UcmFja3N9XHJcbiAqL1xyXG5IdG1sNS5wcm90b3R5cGUuZmVhdHVyZXNOYXRpdmVBdWRpb1RyYWNrcyA9IEh0bWw1LnN1cHBvcnRzTmF0aXZlQXVkaW9UcmFja3MoKTtcclxuXHJcbi8vIEhUTUw1IEZlYXR1cmUgZGV0ZWN0aW9uIGFuZCBEZXZpY2UgRml4ZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcbnZhciBjYW5QbGF5VHlwZSA9IEh0bWw1LlRFU1RfVklEICYmIEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZTtcclxudmFyIG1wZWd1cmxSRSA9IC9eYXBwbGljYXRpb25cXC8oPzp4LXx2bmRcXC5hcHBsZVxcLiltcGVndXJsL2k7XHJcbnZhciBtcDRSRSA9IC9edmlkZW9cXC9tcDQvaTtcclxuXHJcbkh0bWw1LnBhdGNoQ2FuUGxheVR5cGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIC8vIEFuZHJvaWQgNC4wIGFuZCBhYm92ZSBjYW4gcGxheSBITFMgdG8gc29tZSBleHRlbnQgYnV0IGl0IHJlcG9ydHMgYmVpbmcgdW5hYmxlIHRvIGRvIHNvXHJcbiAgaWYgKEFORFJPSURfVkVSU0lPTiA+PSA0LjAgJiYgIUlTX0ZJUkVGT1gpIHtcclxuICAgIEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgIGlmICh0eXBlICYmIG1wZWd1cmxSRS50ZXN0KHR5cGUpKSB7XHJcbiAgICAgICAgcmV0dXJuICdtYXliZSc7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNhblBsYXlUeXBlLmNhbGwodGhpcywgdHlwZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE92ZXJyaWRlIEFuZHJvaWQgMi4yIGFuZCBsZXNzIGNhblBsYXlUeXBlIG1ldGhvZCB3aGljaCBpcyBicm9rZW5cclxuICB9IGVsc2UgaWYgKElTX09MRF9BTkRST0lEKSB7XHJcbiAgICBIdG1sNS5URVNUX1ZJRC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuY2FuUGxheVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICBpZiAodHlwZSAmJiBtcDRSRS50ZXN0KHR5cGUpKSB7XHJcbiAgICAgICAgcmV0dXJuICdtYXliZSc7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNhblBsYXlUeXBlLmNhbGwodGhpcywgdHlwZSk7XHJcbiAgICB9O1xyXG4gIH1cclxufTtcclxuXHJcbkh0bWw1LnVucGF0Y2hDYW5QbGF5VHlwZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgciA9IEh0bWw1LlRFU1RfVklELmNvbnN0cnVjdG9yLnByb3RvdHlwZS5jYW5QbGF5VHlwZTtcclxuXHJcbiAgSHRtbDUuVEVTVF9WSUQuY29uc3RydWN0b3IucHJvdG90eXBlLmNhblBsYXlUeXBlID0gY2FuUGxheVR5cGU7XHJcbiAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG4vLyBieSBkZWZhdWx0LCBwYXRjaCB0aGUgbWVkaWEgZWxlbWVudFxyXG5IdG1sNS5wYXRjaENhblBsYXlUeXBlKCk7XHJcblxyXG5IdG1sNS5kaXNwb3NlTWVkaWFFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgaWYgKCFlbCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgaWYgKGVsLnBhcmVudE5vZGUpIHtcclxuICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIGFueSBjaGlsZCB0cmFjayBvciBzb3VyY2Ugbm9kZXMgdG8gcHJldmVudCB0aGVpciBsb2FkaW5nXHJcbiAgd2hpbGUgKGVsLmhhc0NoaWxkTm9kZXMoKSkge1xyXG4gICAgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgYW55IHNyYyByZWZlcmVuY2UuIG5vdCBzZXR0aW5nIGBzcmM9JydgIGJlY2F1c2UgdGhhdCBjYXVzZXMgYSB3YXJuaW5nXHJcbiAgLy8gaW4gZmlyZWZveFxyXG4gIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XHJcblxyXG4gIC8vIGZvcmNlIHRoZSBtZWRpYSBlbGVtZW50IHRvIHVwZGF0ZSBpdHMgbG9hZGluZyBzdGF0ZSBieSBjYWxsaW5nIGxvYWQoKVxyXG4gIC8vIGhvd2V2ZXIgSUUgb24gV2luZG93cyA3TiBoYXMgYSBidWcgdGhhdCB0aHJvd3MgYW4gZXJyb3Igc28gbmVlZCBhIHRyeS9jYXRjaCAoIzc5MylcclxuICBpZiAodHlwZW9mIGVsLmxvYWQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIC8vIHdyYXBwaW5nIGluIGFuIGlpZmUgc28gaXQncyBub3QgZGVvcHRpbWl6ZWQgKCMxMDYwI2Rpc2N1c3Npb25fcjEwMzI0NDczKVxyXG4gICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBlbC5sb2FkKCk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkXHJcbiAgICAgIH1cclxuICAgIH0pKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuSHRtbDUucmVzZXRNZWRpYUVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcclxuICBpZiAoIWVsKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgc291cmNlcyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NvdXJjZScpO1xyXG4gIHZhciBpID0gc291cmNlcy5sZW5ndGg7XHJcblxyXG4gIHdoaWxlIChpLS0pIHtcclxuICAgIGVsLnJlbW92ZUNoaWxkKHNvdXJjZXNbaV0pO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIGFueSBzcmMgcmVmZXJlbmNlLlxyXG4gIC8vIG5vdCBzZXR0aW5nIGBzcmM9JydgIGJlY2F1c2UgdGhhdCB0aHJvd3MgYW4gZXJyb3JcclxuICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xyXG5cclxuICBpZiAodHlwZW9mIGVsLmxvYWQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIC8vIHdyYXBwaW5nIGluIGFuIGlpZmUgc28gaXQncyBub3QgZGVvcHRpbWl6ZWQgKCMxMDYwI2Rpc2N1c3Npb25fcjEwMzI0NDczKVxyXG4gICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBlbC5sb2FkKCk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyBzYXRpc2Z5IGxpbnRlclxyXG4gICAgICB9XHJcbiAgICB9KSgpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qIE5hdGl2ZSBIVE1MNSBlbGVtZW50IHByb3BlcnR5IHdyYXBwaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbi8vIFdyYXAgbmF0aXZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aXRoIGdldHRlcnMgdGhhdCBjaGVjayBib3RoIHByb3BlcnR5IGFuZCBhdHRyaWJ1dGVcclxuLy8gVGhlIGxpc3QgaXMgYXMgZm9sbG93ZWQ6XHJcbi8vIG11dGVkLCBkZWZhdWx0TXV0ZWQsIGF1dG9wbGF5LCBjb250cm9scywgbG9vcCwgcGxheXNpbmxpbmVcclxuW1xyXG4vKipcclxuICogR2V0IHRoZSB2YWx1ZSBvZiBgbXV0ZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBtdXRlZGAgaW5kaWNhdGVzXHJcbiAqIHRoYXQgdGhlIHZvbHVtZSBmb3IgdGhlIG1lZGlhIHNob3VsZCBiZSBzZXQgdG8gc2lsZW50LiBUaGlzIGRvZXMgbm90IGFjdHVhbGx5IGNoYW5nZVxyXG4gKiB0aGUgYHZvbHVtZWAgYXR0cmlidXRlLlxyXG4gKlxyXG4gKiBAbWV0aG9kIEh0bWw1I211dGVkXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqICAgICAgICAgLSBUcnVlIGlmIHRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBzaG91bGQgYmUgaWdub3JlZCBhbmQgdGhlIGF1ZGlvIHNldCB0byBzaWxlbnQuXHJcbiAqICAgICAgICAgLSBGYWxzZSBpZiB0aGUgdmFsdWUgb2YgYHZvbHVtZWAgc2hvdWxkIGJlIHVzZWQuXHJcbiAqXHJcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtbXV0ZWR9XHJcbiAqL1xyXG4nbXV0ZWQnLFxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRNdXRlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGRlZmF1bHRNdXRlZGAgaW5kaWNhdGVzXHJcbiAqIHdoZXRoZXIgdGhlIG1lZGlhIHNob3VsZCBzdGFydCBtdXRlZCBvciBub3QuIE9ubHkgY2hhbmdlcyB0aGUgZGVmYXVsdCBzdGF0ZSBvZiB0aGVcclxuICogbWVkaWEuIGBtdXRlZGAgYW5kIGBkZWZhdWx0TXV0ZWRgIGNhbiBoYXZlIGRpZmZlcmVudCB2YWx1ZXMuIHtAbGluayBIdG1sNSNtdXRlZH0gaW5kaWNhdGVzIHRoZVxyXG4gKiBjdXJyZW50IHN0YXRlLlxyXG4gKlxyXG4gKiBAbWV0aG9kIEh0bWw1I2RlZmF1bHRNdXRlZFxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGBkZWZhdWx0TXV0ZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXHJcbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgbXV0ZWQuXHJcbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBzdGFydCBtdXRlZFxyXG4gKlxyXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWRlZmF1bHRtdXRlZH1cclxuICovXHJcbidkZWZhdWx0TXV0ZWQnLFxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGF1dG9wbGF5YCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgYXV0b3BsYXlgIGluZGljYXRlc1xyXG4gKiB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgdG8gcGxheSBhcyBzb29uIGFzIHRoZSBwYWdlIGlzIHJlYWR5LlxyXG4gKlxyXG4gKiBAbWV0aG9kIEh0bWw1I2F1dG9wbGF5XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGF1dG9wbGF5YCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxyXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHN0YXJ0IGFzIHNvb24gYXMgdGhlIHBhZ2UgbG9hZHMuXHJcbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBzdGFydCBhcyBzb29uIGFzIHRoZSBwYWdlIGxvYWRzLlxyXG4gKlxyXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1hdXRvcGxheX1cclxuICovXHJcbidhdXRvcGxheScsXHJcblxyXG4vKipcclxuICogR2V0IHRoZSB2YWx1ZSBvZiBgY29udHJvbHNgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBjb250cm9sc2AgaW5kaWNhdGVzXHJcbiAqIHdoZXRoZXIgdGhlIG5hdGl2ZSBtZWRpYSBjb250cm9scyBzaG91bGQgYmUgc2hvd24gb3IgaGlkZGVuLlxyXG4gKlxyXG4gKiBAbWV0aG9kIEh0bWw1I2NvbnRyb2xzXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYGNvbnRyb2xzYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxyXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCBuYXRpdmUgY29udHJvbHMgc2hvdWxkIGJlIHNob3dpbmcuXHJcbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCBuYXRpdmUgY29udHJvbHMgc2hvdWxkIGJlIGhpZGRlbi5cclxuICpcclxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2F0dHItbWVkaWEtY29udHJvbHN9XHJcbiAqL1xyXG4nY29udHJvbHMnLFxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGxvb3BgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBsb29wYCBpbmRpY2F0ZXNcclxuICogdGhhdCB0aGUgbWVkaWEgc2hvdWxkIHJldHVybiB0byB0aGUgc3RhcnQgb2YgdGhlIG1lZGlhIGFuZCBjb250aW51ZSBwbGF5aW5nIG9uY2VcclxuICogaXQgcmVhY2hlcyB0aGUgZW5kLlxyXG4gKlxyXG4gKiBAbWV0aG9kIEh0bWw1I2xvb3BcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgbG9vcGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cclxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgcGxheWJhY2sgc2hvdWxkIHNlZWsgYmFjayB0byBzdGFydCBvbmNlXHJcbiAqICAgICAgICAgICB0aGUgZW5kIG9mIGEgbWVkaWEgaXMgcmVhY2hlZC5cclxuICogICAgICAgICAtIEZhbHNlIGluZGljYXRlcyB0aGF0IHBsYXliYWNrIHNob3VsZCBub3QgbG9vcCBiYWNrIHRvIHRoZSBzdGFydCB3aGVuIHRoZVxyXG4gKiAgICAgICAgICAgZW5kIG9mIHRoZSBtZWRpYSBpcyByZWFjaGVkLlxyXG4gKlxyXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci1tZWRpYS1sb29wfVxyXG4gKi9cclxuJ2xvb3AnLFxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHBsYXlzaW5saW5lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheXNpbmxpbmVgIGluZGljYXRlc1xyXG4gKiB0byB0aGUgYnJvd3NlciB0aGF0IG5vbi1mdWxsc2NyZWVuIHBsYXliYWNrIGlzIHByZWZlcnJlZCB3aGVuIGZ1bGxzY3JlZW5cclxuICogcGxheWJhY2sgaXMgdGhlIG5hdGl2ZSBkZWZhdWx0LCBzdWNoIGFzIGluIGlPUyBTYWZhcmkuXHJcbiAqXHJcbiAqIEBtZXRob2QgSHRtbDUjcGxheXNpbmxpbmVcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgcGxheXNpbmxpbmVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXHJcbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgcGxheSBpbmxpbmUuXHJcbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBwbGF5IGlubGluZS5cclxuICpcclxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jYXR0ci12aWRlby1wbGF5c2lubGluZX1cclxuICovXHJcbidwbGF5c2lubGluZSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICBIdG1sNS5wcm90b3R5cGVbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lbF9bcHJvcF0gfHwgdGhpcy5lbF8uaGFzQXR0cmlidXRlKHByb3ApO1xyXG4gIH07XHJcbn0pO1xyXG5cclxuLy8gV3JhcCBuYXRpdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdpdGggc2V0dGVycyB0aGF0IHNldCBib3RoIHByb3BlcnR5IGFuZCBhdHRyaWJ1dGVcclxuLy8gVGhlIGxpc3QgaXMgYXMgZm9sbG93ZWQ6XHJcbi8vIHNldE11dGVkLCBzZXREZWZhdWx0TXV0ZWQsIHNldEF1dG9wbGF5LCBzZXRMb29wLCBzZXRQbGF5c2lubGluZVxyXG4vLyBzZXRDb250cm9scyBpcyBzcGVjaWFsLWNhc2VkIGFib3ZlXHJcbltcclxuLyoqXHJcbiAqIFNldCB0aGUgdmFsdWUgb2YgYG11dGVkYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYG11dGVkYCBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudFxyXG4gKiBhdWRpbyBsZXZlbCBzaG91bGQgYmUgc2lsZW50LlxyXG4gKlxyXG4gKiBAbWV0aG9kIEh0bWw1I3NldE11dGVkXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXV0ZWRcclxuICogICAgICAgIC0gVHJ1ZSBpZiB0aGUgYXVkaW8gc2hvdWxkIGJlIHNldCB0byBzaWxlbnRcclxuICogICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXHJcbiAqXHJcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtbXV0ZWR9XHJcbiAqL1xyXG4nbXV0ZWQnLFxyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRNdXRlZGAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBkZWZhdWx0TXV0ZWRgIGluZGljYXRlcyB0aGF0IHRoZSBjdXJyZW50XHJcbiAqIGF1ZGlvIGxldmVsIHNob3VsZCBiZSBzaWxlbnQsIGJ1dCB3aWxsIG9ubHkgZWZmZWN0IHRoZSBtdXRlZCBsZXZlbCBvbiBpbnRpYWwgcGxheWJhY2suLlxyXG4gKlxyXG4gKiBAbWV0aG9kIEh0bWw1LnByb3RvdHlwZS5zZXREZWZhdWx0TXV0ZWRcclxuICogQHBhcmFtIHtib29sZWFufSBkZWZhdWx0TXV0ZWRcclxuICogICAgICAgIC0gVHJ1ZSBpZiB0aGUgYXVkaW8gc2hvdWxkIGJlIHNldCB0byBzaWxlbnRcclxuICogICAgICAgIC0gRmFsc2Ugb3RoZXJ3aXNlXHJcbiAqXHJcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtZGVmYXVsdG11dGVkfVxyXG4gKi9cclxuJ2RlZmF1bHRNdXRlZCcsXHJcblxyXG4vKipcclxuICogU2V0IHRoZSB2YWx1ZSBvZiBgYXV0b3BsYXlgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgYXV0b3BsYXlgIGluZGljYXRlc1xyXG4gKiB0aGF0IHRoZSBtZWRpYSBzaG91bGQgc3RhcnQgdG8gcGxheSBhcyBzb29uIGFzIHRoZSBwYWdlIGlzIHJlYWR5LlxyXG4gKlxyXG4gKiBAbWV0aG9kIEh0bWw1I3NldEF1dG9wbGF5XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b3BsYXlcclxuICogICAgICAgICAtIFRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBzdGFydCBhcyBzb29uIGFzIHRoZSBwYWdlIGxvYWRzLlxyXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgdGhlIG1lZGlhIHNob3VsZCBub3Qgc3RhcnQgYXMgc29vbiBhcyB0aGUgcGFnZSBsb2Fkcy5cclxuICpcclxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2F0dHItbWVkaWEtYXV0b3BsYXl9XHJcbiAqL1xyXG4nYXV0b3BsYXknLFxyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgdmFsdWUgb2YgYGxvb3BgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgbG9vcGAgaW5kaWNhdGVzXHJcbiAqIHRoYXQgdGhlIG1lZGlhIHNob3VsZCByZXR1cm4gdG8gdGhlIHN0YXJ0IG9mIHRoZSBtZWRpYSBhbmQgY29udGludWUgcGxheWluZyBvbmNlXHJcbiAqIGl0IHJlYWNoZXMgdGhlIGVuZC5cclxuICpcclxuICogQG1ldGhvZCBIdG1sNSNzZXRMb29wXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxyXG4gKiAgICAgICAgIC0gVHJ1ZSBpbmRpY2F0ZXMgdGhhdCBwbGF5YmFjayBzaG91bGQgc2VlayBiYWNrIHRvIHN0YXJ0IG9uY2VcclxuICogICAgICAgICAgIHRoZSBlbmQgb2YgYSBtZWRpYSBpcyByZWFjaGVkLlxyXG4gKiAgICAgICAgIC0gRmFsc2UgaW5kaWNhdGVzIHRoYXQgcGxheWJhY2sgc2hvdWxkIG5vdCBsb29wIGJhY2sgdG8gdGhlIHN0YXJ0IHdoZW4gdGhlXHJcbiAqICAgICAgICAgICBlbmQgb2YgdGhlIG1lZGlhIGlzIHJlYWNoZWQuXHJcbiAqXHJcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLWxvb3B9XHJcbiAqL1xyXG4nbG9vcCcsXHJcblxyXG4vKipcclxuICogU2V0IHRoZSB2YWx1ZSBvZiBgcGxheXNpbmxpbmVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwbGF5c2lubGluZWAgaW5kaWNhdGVzXHJcbiAqIHRvIHRoZSBicm93c2VyIHRoYXQgbm9uLWZ1bGxzY3JlZW4gcGxheWJhY2sgaXMgcHJlZmVycmVkIHdoZW4gZnVsbHNjcmVlblxyXG4gKiBwbGF5YmFjayBpcyB0aGUgbmF0aXZlIGRlZmF1bHQsIHN1Y2ggYXMgaW4gaU9TIFNhZmFyaS5cclxuICpcclxuICogQG1ldGhvZCBIdG1sNSNzZXRQbGF5c2lubGluZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBsYXlzaW5saW5lXHJcbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBzaG91bGQgcGxheSBpbmxpbmUuXHJcbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgc2hvdWxkIG5vdCBwbGF5IGlubGluZS5cclxuICpcclxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jYXR0ci12aWRlby1wbGF5c2lubGluZX1cclxuICovXHJcbidwbGF5c2lubGluZSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICBIdG1sNS5wcm90b3R5cGVbJ3NldCcgKyB0b1RpdGxlQ2FzZShwcm9wKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgdGhpcy5lbF9bcHJvcF0gPSB2O1xyXG5cclxuICAgIGlmICh2KSB7XHJcbiAgICAgIHRoaXMuZWxfLnNldEF0dHJpYnV0ZShwcm9wLCBwcm9wKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZWxfLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcclxuICAgIH1cclxuICB9O1xyXG59KTtcclxuXHJcbi8vIFdyYXAgbmF0aXZlIHByb3BlcnRpZXMgd2l0aCBhIGdldHRlclxyXG4vLyBUaGUgbGlzdCBpcyBhcyBmb2xsb3dlZFxyXG4vLyBwYXVzZWQsIGN1cnJlbnRUaW1lLCBidWZmZXJlZCwgdm9sdW1lLCBwb3N0ZXIsIHByZWxvYWQsIGVycm9yLCBzZWVraW5nXHJcbi8vIHNlZWthYmxlLCBlbmRlZCwgcGxheWJhY2tSYXRlLCBkZWZhdWx0UGxheWJhY2tSYXRlLCBwbGF5ZWQsIG5ldHdvcmtTdGF0ZVxyXG4vLyByZWFkeVN0YXRlLCB2aWRlb1dpZHRoLCB2aWRlb0hlaWdodFxyXG5bXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwYXVzZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwYXVzZWRgIGluZGljYXRlcyB3aGV0aGVyIHRoZSBtZWRpYSBlbGVtZW50XHJcbiAqIGlzIGN1cnJlbnRseSBwYXVzZWQgb3Igbm90LlxyXG4gKlxyXG4gKiBAbWV0aG9kIEh0bWw1I3BhdXNlZFxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcGF1c2VkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXBhdXNlZH1cclxuICovXHJcbidwYXVzZWQnLFxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGN1cnJlbnRUaW1lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgY3VycmVudFRpbWVgIGluZGljYXRlc1xyXG4gKiB0aGUgY3VycmVudCBzZWNvbmQgdGhhdCB0aGUgbWVkaWEgaXMgYXQgaW4gcGxheWJhY2suXHJcbiAqXHJcbiAqIEBtZXRob2QgSHRtbDUjY3VycmVudFRpbWVcclxuICogQHJldHVybiB7bnVtYmVyfVxyXG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgY3VycmVudFRpbWVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtY3VycmVudHRpbWV9XHJcbiAqL1xyXG4nY3VycmVudFRpbWUnLFxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGJ1ZmZlcmVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgYnVmZmVyZWRgIGlzIGEgYFRpbWVSYW5nZWBcclxuICogb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGFydHMgb2YgdGhlIG1lZGlhIHRoYXQgYXJlIGFscmVhZHkgZG93bmxvYWRlZCBhbmRcclxuICogYXZhaWxhYmxlIGZvciBwbGF5YmFjay5cclxuICpcclxuICogQG1ldGhvZCBIdG1sNSNidWZmZXJlZFxyXG4gKiBAcmV0dXJuIHtUaW1lUmFuZ2V9XHJcbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBidWZmZXJlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC5cclxuICpcclxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1idWZmZXJlZH1cclxuICovXHJcbididWZmZXJlZCcsXHJcblxyXG4vKipcclxuICogR2V0IHRoZSB2YWx1ZSBvZiBgdm9sdW1lYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgdm9sdW1lYCBpbmRpY2F0ZXNcclxuICogdGhlIGN1cnJlbnQgcGxheWJhY2sgdm9sdW1lIG9mIGF1ZGlvIGZvciBhIG1lZGlhLiBgdm9sdW1lYCB3aWxsIGJlIGEgdmFsdWUgZnJvbSAwXHJcbiAqIChzaWxlbnQpIHRvIDEgKGxvdWRlc3QgYW5kIGRlZmF1bHQpLlxyXG4gKlxyXG4gKiBAbWV0aG9kIEh0bWw1I3ZvbHVtZVxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGB2b2x1bWVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIFZhbHVlIHdpbGwgYmUgYmV0d2VlbiAwLTEuXHJcbiAqXHJcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tYS12b2x1bWV9XHJcbiAqL1xyXG4ndm9sdW1lJyxcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwb3N0ZXJgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBwb3N0ZXJgIGluZGljYXRlc1xyXG4gKiB0aGF0IHRoZSB1cmwgb2YgYW4gaW1hZ2UgZmlsZSB0aGF0IGNhbi93aWxsIGJlIHNob3duIHdoZW4gbm8gbWVkaWEgZGF0YSBpcyBhdmFpbGFibGUuXHJcbiAqXHJcbiAqIEBtZXRob2QgSHRtbDUjcG9zdGVyXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHBvc3RlcmAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gVmFsdWUgd2lsbCBiZSBhIHVybCB0byBhblxyXG4gKiAgICAgICAgIGltYWdlLlxyXG4gKlxyXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjYXR0ci12aWRlby1wb3N0ZXJ9XHJcbiAqL1xyXG4ncG9zdGVyJyxcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBwcmVsb2FkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcHJlbG9hZGAgaW5kaWNhdGVzXHJcbiAqIHdoYXQgc2hvdWxkIGRvd25sb2FkIGJlZm9yZSB0aGUgbWVkaWEgaXMgaW50ZXJhY3RlZCB3aXRoLiBJdCBjYW4gaGF2ZSB0aGUgZm9sbG93aW5nXHJcbiAqIHZhbHVlczpcclxuICogLSBub25lOiBub3RoaW5nIHNob3VsZCBiZSBkb3dubG9hZGVkXHJcbiAqIC0gbWV0YWRhdGE6IHBvc3RlciBhbmQgdGhlIGZpcnN0IGZldyBmcmFtZXMgb2YgdGhlIG1lZGlhIG1heSBiZSBkb3dubG9hZGVkIHRvIGdldFxyXG4gKiAgIG1lZGlhIGRpbWVuc2lvbnMgYW5kIG90aGVyIG1ldGFkYXRhXHJcbiAqIC0gYXV0bzogYWxsb3cgdGhlIG1lZGlhIGFuZCBtZXRhZGF0YSBmb3IgdGhlIG1lZGlhIHRvIGJlIGRvd25sb2FkZWQgYmVmb3JlXHJcbiAqICAgIGludGVyYWN0aW9uXHJcbiAqXHJcbiAqIEBtZXRob2QgSHRtbDUjcHJlbG9hZFxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwcmVsb2FkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBXaWxsIGJlICdub25lJywgJ21ldGFkYXRhJyxcclxuICogICAgICAgICBvciAnYXV0bycuXHJcbiAqXHJcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLXByZWxvYWR9XHJcbiAqL1xyXG4ncHJlbG9hZCcsXHJcblxyXG4vKipcclxuICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgYGVycm9yYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgZXJyb3JgIGluZGljYXRlcyBhbnlcclxuICogTWVkaWFFcnJvciB0aGF0IG1heSBoYXZlIG9jY3VyZWQgZHVyaW5nIHBsYXliYWNrLiBJZiBlcnJvciByZXR1cm5zIG51bGwgdGhlcmUgaXMgbm9cclxuICogY3VycmVudCBlcnJvci5cclxuICpcclxuICogQG1ldGhvZCBIdG1sNSNlcnJvclxyXG4gKiBAcmV0dXJuIHtNZWRpYUVycm9yfG51bGx9XHJcbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBlcnJvcmAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gV2lsbCBiZSBgTWVkaWFFcnJvcmAgaWYgdGhlcmVcclxuICogICAgICAgICBpcyBhIGN1cnJlbnQgZXJyb3IgYW5kIG51bGwgb3RoZXJ3aXNlLlxyXG4gKlxyXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWVycm9yfVxyXG4gKi9cclxuJ2Vycm9yJyxcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBzZWVraW5nYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgc2Vla2luZ2AgaW5kaWNhdGVzIHdoZXRoZXIgdGhlXHJcbiAqIG1lZGlhIGlzIGN1cnJlbnRseSBzZWVraW5nIHRvIGEgbmV3IHBvc2l0aW9uIG9yIG5vdC5cclxuICpcclxuICogQG1ldGhvZCBIdG1sNSNzZWVraW5nXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqICAgICAgICAgLSBUaGUgdmFsdWUgb2YgYHNlZWtpbmdgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXHJcbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBpcyBjdXJyZW50bHkgc2Vla2luZyB0byBhIG5ldyBwb3NpdGlvbi5cclxuICogICAgICAgICAtIEZsYXNlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBpcyBub3Qgc2Vla2luZyB0byBhIG5ldyBwb3NpdGlvbiBhdCB0aGlzIHRpbWUuXHJcbiAqXHJcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtc2Vla2luZ31cclxuICovXHJcbidzZWVraW5nJyxcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBzZWVrYWJsZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYHNlZWthYmxlYCByZXR1cm5zIGFcclxuICogYFRpbWVSYW5nZWAgb2JqZWN0IGluZGljYXRpbmcgcmFuZ2VzIG9mIHRpbWUgdGhhdCBjYW4gY3VycmVudGx5IGJlIGBzZWVrZWRgIHRvLlxyXG4gKlxyXG4gKiBAbWV0aG9kIEh0bWw1I3NlZWthYmxlXHJcbiAqIEByZXR1cm4ge1RpbWVSYW5nZX1cclxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHNlZWthYmxlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIGBUaW1lUmFuZ2VgIG9iamVjdFxyXG4gKiAgICAgICAgIGluZGljYXRpbmcgdGhlIGN1cnJlbnQgcmFuZ2VzIG9mIHRpbWUgdGhhdCBjYW4gYmUgc2Vla2VkIHRvLlxyXG4gKlxyXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXNlZWthYmxlfVxyXG4gKi9cclxuJ3NlZWthYmxlJyxcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBlbmRlZGAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gYGVuZGVkYCBpbmRpY2F0ZXMgd2hldGhlclxyXG4gKiB0aGUgbWVkaWEgaGFzIHJlYWNoZWQgdGhlIGVuZCBvciBub3QuXHJcbiAqXHJcbiAqIEBtZXRob2QgSHRtbDUjZW5kZWRcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICogICAgICAgICAtIFRoZSB2YWx1ZSBvZiBgZW5kZWRgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuXHJcbiAqICAgICAgICAgLSBUcnVlIGluZGljYXRlcyB0aGF0IHRoZSBtZWRpYSBoYXMgZW5kZWQuXHJcbiAqICAgICAgICAgLSBGYWxzZSBpbmRpY2F0ZXMgdGhhdCB0aGUgbWVkaWEgaGFzIG5vdCBlbmRlZC5cclxuICpcclxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1lbmRlZH1cclxuICovXHJcbidlbmRlZCcsXHJcblxyXG4vKipcclxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheWJhY2tSYXRlYCBpbmRpY2F0ZXNcclxuICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBwbGF5aW5nIGJhY2suIEV4YW1wbGVzOlxyXG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAyLCBtZWRpYSB3aWxsIHBsYXkgdHdpY2UgYXMgZmFzdC5cclxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMC41LCBtZWRpYSB3aWxsIHBsYXkgaGFsZiBhcyBmYXN0LlxyXG4gKlxyXG4gKiBAbWV0aG9kIEh0bWw1I3BsYXliYWNrUmF0ZVxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBwbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIEEgbnVtYmVyIGluZGljYXRpbmdcclxuICogICAgICAgICB0aGUgY3VycmVudCBwbGF5YmFjayBzcGVlZCBvZiB0aGUgbWVkaWEsIHdoZXJlIDEgaXMgbm9ybWFsIHNwZWVkLlxyXG4gKlxyXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXBsYXliYWNrcmF0ZX1cclxuICovXHJcbidwbGF5YmFja1JhdGUnLFxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdmFsdWUgb2YgYGRlZmF1bHRQbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBpbmRpY2F0ZXNcclxuICogdGhlIHJhdGUgYXQgd2hpY2ggdGhlIG1lZGlhIGlzIGN1cnJlbnRseSBwbGF5aW5nIGJhY2suIFRoaXMgdmFsdWUgd2lsbCBub3QgaW5kaWNhdGUgdGhlIGN1cnJlbnRcclxuICogYHBsYXliYWNrUmF0ZWAgYWZ0ZXIgcGxheWJhY2sgaGFzIHN0YXJ0ZWQsIHVzZSB7QGxpbmsgSHRtbDUjcGxheWJhY2tSYXRlfSBmb3IgdGhhdC5cclxuICpcclxuICogRXhhbXBsZXM6XHJcbiAqICAgLSBpZiBkZWZhdWx0UGxheWJhY2tSYXRlIGlzIHNldCB0byAyLCBtZWRpYSB3aWxsIHBsYXkgdHdpY2UgYXMgZmFzdC5cclxuICogICAtIGlmIGRlZmF1bHRQbGF5YmFja1JhdGUgaXMgc2V0IHRvIDAuNSwgbWVkaWEgd2lsbCBwbGF5IGhhbGYgYXMgZmFzdC5cclxuICpcclxuICogQG1ldGhvZCBIdG1sNS5wcm90b3R5cGUuZGVmYXVsdFBsYXliYWNrUmF0ZVxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAqICAgICAgICAgVGhlIHZhbHVlIG9mIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIG51bWJlciBpbmRpY2F0aW5nXHJcbiAqICAgICAgICAgdGhlIGN1cnJlbnQgcGxheWJhY2sgc3BlZWQgb2YgdGhlIG1lZGlhLCB3aGVyZSAxIGlzIG5vcm1hbCBzcGVlZC5cclxuICpcclxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5YmFja3JhdGV9XHJcbiAqL1xyXG4nZGVmYXVsdFBsYXliYWNrUmF0ZScsXHJcblxyXG4vKipcclxuICogR2V0IHRoZSB2YWx1ZSBvZiBgcGxheWVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBgcGxheWVkYCByZXR1cm5zIGEgYFRpbWVSYW5nZWBcclxuICogb2JqZWN0IHJlcHJlc2VudGluZyBwb2ludHMgaW4gdGhlIG1lZGlhIHRpbWVsaW5lIHRoYXQgaGF2ZSBiZWVuIHBsYXllZC5cclxuICpcclxuICogQG1ldGhvZCBIdG1sNSNwbGF5ZWRcclxuICogQHJldHVybiB7VGltZVJhbmdlfVxyXG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcGxheWVkYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIGBUaW1lUmFuZ2VgIG9iamVjdCBpbmRpY2F0aW5nXHJcbiAqICAgICAgICAgdGhlIHJhbmdlcyBvZiB0aW1lIHRoYXQgaGF2ZSBiZWVuIHBsYXllZC5cclxuICpcclxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5ZWR9XHJcbiAqL1xyXG4ncGxheWVkJyxcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGBuZXR3b3JrU3RhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGBuZXR3b3JrU3RhdGVgIGluZGljYXRlc1xyXG4gKiB0aGUgY3VycmVudCBuZXR3b3JrIHN0YXRlLiBJdCByZXR1cm5zIGFuIGVudW1lcmF0aW9uIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0OlxyXG4gKiAtIDA6IE5FVFdPUktfRU1QVFlcclxuICogLSAxOiBORVdPUktfSURMRVxyXG4gKiAtIDI6IE5FVFdPUktfTE9BRElOR1xyXG4gKiAtIDM6IE5FVFdPUktfTk9fU09VUkNFXHJcbiAqXHJcbiAqIEBtZXRob2QgSHRtbDUjbmV0d29ya1N0YXRlXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYG5ldHdvcmtTdGF0ZWAgZnJvbSB0aGUgbWVkaWEgZWxlbWVudC4gVGhpcyB3aWxsIGJlIGEgbnVtYmVyXHJcbiAqICAgICAgICAgZnJvbSB0aGUgbGlzdCBpbiB0aGUgZGVzY3JpcHRpb24uXHJcbiAqXHJcbiAqIEBzZWUgW1NwZWNdIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLW5ldHdvcmtzdGF0ZX1cclxuICovXHJcbiduZXR3b3JrU3RhdGUnLFxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdmFsdWUgb2YgYHJlYWR5U3RhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIGByZWFkeVN0YXRlYCBpbmRpY2F0ZXNcclxuICogdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIG1lZGlhIGVsZW1lbnQuIEl0IHJldHVybnMgYW4gZW51bWVyYXRpb24gZnJvbSB0aGVcclxuICogZm9sbG93aW5nIGxpc3Q6XHJcbiAqIC0gMDogSEFWRV9OT1RISU5HXHJcbiAqIC0gMTogSEFWRV9NRVRBREFUQVxyXG4gKiAtIDI6IEhBVkVfQ1VSUkVOVF9EQVRBXHJcbiAqIC0gMzogSEFWRV9GVVRVUkVfREFUQVxyXG4gKiAtIDQ6IEhBVkVfRU5PVUdIX0RBVEFcclxuICpcclxuICogQG1ldGhvZCBIdG1sNSNyZWFkeVN0YXRlXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHJlYWR5U3RhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIFRoaXMgd2lsbCBiZSBhIG51bWJlclxyXG4gKiAgICAgICAgIGZyb20gdGhlIGxpc3QgaW4gdGhlIGRlc2NyaXB0aW9uLlxyXG4gKlxyXG4gKiBAc2VlIFtTcGVjXSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI3JlYWR5LXN0YXRlc31cclxuICovXHJcbidyZWFkeVN0YXRlJyxcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGB2aWRlb1dpZHRoYCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LiBgdmlkZW9XaWR0aGAgaW5kaWNhdGVzXHJcbiAqIHRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSB2aWRlbyBpbiBjc3MgcGl4ZWxzLlxyXG4gKlxyXG4gKiBAbWV0aG9kIEh0bWw1I3ZpZGVvV2lkdGhcclxuICogQHJldHVybiB7bnVtYmVyfVxyXG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgdmlkZW9XaWR0aGAgZnJvbSB0aGUgdmlkZW8gZWxlbWVudC4gVGhpcyB3aWxsIGJlIGEgbnVtYmVyXHJcbiAqICAgICAgICAgaW4gY3NzIHBpeGVscy5cclxuICpcclxuICogQHNlZSBbU3BlY10ge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tdmlkZW8tdmlkZW93aWR0aH1cclxuICovXHJcbid2aWRlb1dpZHRoJyxcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGB2aWRlb0hlaWdodGAgZnJvbSB0aGUgdmlkZW8gZWxlbWVudC4gYHZpZGVvSGVpZ3RoYCBpbmRpY2F0ZXNcclxuICogdGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSB2aWRlbyBpbiBjc3MgcGl4ZWxzLlxyXG4gKlxyXG4gKiBAbWV0aG9kIEh0bWw1I3ZpZGVvSGVpZ2h0XHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYHZpZGVvSGVpZ2h0YCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50LiBUaGlzIHdpbGwgYmUgYSBudW1iZXJcclxuICogICAgICAgICBpbiBjc3MgcGl4ZWxzLlxyXG4gKlxyXG4gKiBAc2VlIFtTcGVjXSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS12aWRlby12aWRlb3dpZHRofVxyXG4gKi9cclxuJ3ZpZGVvSGVpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xyXG4gIEh0bWw1LnByb3RvdHlwZVtwcm9wXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLmVsX1twcm9wXTtcclxuICB9O1xyXG59KTtcclxuXHJcbi8vIFdyYXAgbmF0aXZlIHByb3BlcnRpZXMgd2l0aCBhIHNldHRlciBpbiB0aGlzIGZvcm1hdDpcclxuLy8gc2V0ICsgdG9UaXRsZUNhc2UobmFtZSlcclxuLy8gVGhlIGxpc3QgaXMgYXMgZm9sbG93czpcclxuLy8gc2V0Vm9sdW1lLCBzZXRTcmMsIHNldFBvc3Rlciwgc2V0UHJlbG9hZCwgc2V0UGxheWJhY2tSYXRlLCBzZXREZWZhdWx0UGxheWJhY2tSYXRlXHJcbltcclxuLyoqXHJcbiAqIFNldCB0aGUgdmFsdWUgb2YgYHZvbHVtZWAgb24gdGhlIG1lZGlhIGVsZW1lbnQuIGB2b2x1bWVgIGluZGljYXRlcyB0aGUgY3VycmVudFxyXG4gKiBhdWRpbyBsZXZlbCBhcyBhIHBlcmNlbnRhZ2UgaW4gZGVjaW1hbCBmb3JtLiBUaGlzIG1lYW5zIHRoYXQgMSBpcyAxMDAlLCAwLjUgaXMgNTAlLCBhbmRcclxuICogc28gb24uXHJcbiAqXHJcbiAqIEBtZXRob2QgSHRtbDUjc2V0Vm9sdW1lXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwZXJjZW50QXNEZWNpbWFsXHJcbiAqICAgICAgICBUaGUgdm9sdW1lIHBlcmNlbnQgYXMgYSBkZWNpbWFsLiBWYWxpZCByYW5nZSBpcyBmcm9tIDAtMS5cclxuICpcclxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1hLXZvbHVtZX1cclxuICovXHJcbid2b2x1bWUnLFxyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgdmFsdWUgb2YgYHNyY2Agb24gdGhlIG1lZGlhIGVsZW1lbnQuIGBzcmNgIGluZGljYXRlcyB0aGUgY3VycmVudFxyXG4gKiB7QGxpbmsgVGVjaH5Tb3VyY2VPYmplY3R9IGZvciB0aGUgbWVkaWEuXHJcbiAqXHJcbiAqIEBtZXRob2QgSHRtbDUjc2V0U3JjXHJcbiAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNyY1xyXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3QgdG8gc2V0IGFzIHRoZSBjdXJyZW50IHNvdXJjZS5cclxuICpcclxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1zcmN9XHJcbiAqL1xyXG4nc3JjJyxcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBwb3N0ZXJgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgcG9zdGVyYCBpcyB0aGUgdXJsIHRvXHJcbiAqIGFuIGltYWdlIGZpbGUgdGhhdCBjYW4vd2lsbCBiZSBzaG93biB3aGVuIG5vIG1lZGlhIGRhdGEgaXMgYXZhaWxhYmxlLlxyXG4gKlxyXG4gKiBAbWV0aG9kIEh0bWw1I3NldFBvc3RlclxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9zdGVyXHJcbiAqICAgICAgICBUaGUgdXJsIHRvIGFuIGltYWdlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIGBwb3N0ZXJgIGZvciB0aGUgbWVkaWFcclxuICogICAgICAgIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLXBvc3Rlcn1cclxuICovXHJcbidwb3N0ZXInLFxyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgdmFsdWUgb2YgYHByZWxvYWRgIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBgcHJlbG9hZGAgaW5kaWNhdGVzXHJcbiAqIHdoYXQgc2hvdWxkIGRvd25sb2FkIGJlZm9yZSB0aGUgbWVkaWEgaXMgaW50ZXJhY3RlZCB3aXRoLiBJdCBjYW4gaGF2ZSB0aGUgZm9sbG93aW5nXHJcbiAqIHZhbHVlczpcclxuICogLSBub25lOiBub3RoaW5nIHNob3VsZCBiZSBkb3dubG9hZGVkXHJcbiAqIC0gbWV0YWRhdGE6IHBvc3RlciBhbmQgdGhlIGZpcnN0IGZldyBmcmFtZXMgb2YgdGhlIG1lZGlhIG1heSBiZSBkb3dubG9hZGVkIHRvIGdldFxyXG4gKiAgIG1lZGlhIGRpbWVuc2lvbnMgYW5kIG90aGVyIG1ldGFkYXRhXHJcbiAqIC0gYXV0bzogYWxsb3cgdGhlIG1lZGlhIGFuZCBtZXRhZGF0YSBmb3IgdGhlIG1lZGlhIHRvIGJlIGRvd25sb2FkZWQgYmVmb3JlXHJcbiAqICAgIGludGVyYWN0aW9uXHJcbiAqXHJcbiAqIEBtZXRob2QgSHRtbDUjc2V0UHJlbG9hZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlbG9hZFxyXG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcHJlbG9hZGAgdG8gc2V0IG9uIHRoZSBtZWRpYSBlbGVtZW50LiBNdXN0IGJlICdub25lJywgJ21ldGFkYXRhJyxcclxuICogICAgICAgICBvciAnYXV0bycuXHJcbiAqXHJcbiAqIEBzZWUgW1NwZWNde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNhdHRyLW1lZGlhLXByZWxvYWR9XHJcbiAqL1xyXG4ncHJlbG9hZCcsXHJcblxyXG4vKipcclxuICogU2V0IHRoZSB2YWx1ZSBvZiBgcGxheWJhY2tSYXRlYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYHBsYXliYWNrUmF0ZWAgaW5kaWNhdGVzXHJcbiAqIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBtZWRpYSBzaG91bGQgcGxheSBiYWNrLiBFeGFtcGxlczpcclxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMiwgbWVkaWEgd2lsbCBwbGF5IHR3aWNlIGFzIGZhc3QuXHJcbiAqICAgLSBpZiBwbGF5YmFja1JhdGUgaXMgc2V0IHRvIDAuNSwgbWVkaWEgd2lsbCBwbGF5IGhhbGYgYXMgZmFzdC5cclxuICpcclxuICogQG1ldGhvZCBIdG1sNSNzZXRQbGF5YmFja1JhdGVcclxuICogQHJldHVybiB7bnVtYmVyfVxyXG4gKiAgICAgICAgIFRoZSB2YWx1ZSBvZiBgcGxheWJhY2tSYXRlYCBmcm9tIHRoZSBtZWRpYSBlbGVtZW50LiBBIG51bWJlciBpbmRpY2F0aW5nXHJcbiAqICAgICAgICAgdGhlIGN1cnJlbnQgcGxheWJhY2sgc3BlZWQgb2YgdGhlIG1lZGlhLCB3aGVyZSAxIGlzIG5vcm1hbCBzcGVlZC5cclxuICpcclxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wbGF5YmFja3JhdGV9XHJcbiAqL1xyXG4ncGxheWJhY2tSYXRlJyxcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGBkZWZhdWx0UGxheWJhY2tSYXRlYCBvbiB0aGUgbWVkaWEgZWxlbWVudC4gYGRlZmF1bHRQbGF5YmFja1JhdGVgIGluZGljYXRlc1xyXG4gKiB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgbWVkaWEgc2hvdWxkIHBsYXkgYmFjayB1cG9uIGluaXRpYWwgc3RhcnR1cC4gQ2hhbmdpbmcgdGhpcyB2YWx1ZVxyXG4gKiBhZnRlciBhIHZpZGVvIGhhcyBzdGFydGVkIHdpbGwgZG8gbm90aGluZy4gSW5zdGVhZCB5b3Ugc2hvdWxkIHVzZWQge0BsaW5rIEh0bWw1I3NldFBsYXliYWNrUmF0ZX0uXHJcbiAqXHJcbiAqIEV4YW1wbGUgVmFsdWVzOlxyXG4gKiAgIC0gaWYgcGxheWJhY2tSYXRlIGlzIHNldCB0byAyLCBtZWRpYSB3aWxsIHBsYXkgdHdpY2UgYXMgZmFzdC5cclxuICogICAtIGlmIHBsYXliYWNrUmF0ZSBpcyBzZXQgdG8gMC41LCBtZWRpYSB3aWxsIHBsYXkgaGFsZiBhcyBmYXN0LlxyXG4gKlxyXG4gKiBAbWV0aG9kIEh0bWw1LnByb3RvdHlwZS5zZXREZWZhdWx0UGxheWJhY2tSYXRlXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICogICAgICAgICBUaGUgdmFsdWUgb2YgYGRlZmF1bHRQbGF5YmFja1JhdGVgIGZyb20gdGhlIG1lZGlhIGVsZW1lbnQuIEEgbnVtYmVyIGluZGljYXRpbmdcclxuICogICAgICAgICB0aGUgY3VycmVudCBwbGF5YmFjayBzcGVlZCBvZiB0aGUgbWVkaWEsIHdoZXJlIDEgaXMgbm9ybWFsIHNwZWVkLlxyXG4gKlxyXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWRlZmF1bHRwbGF5YmFja3JhdGV9XHJcbiAqL1xyXG4nZGVmYXVsdFBsYXliYWNrUmF0ZSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICBIdG1sNS5wcm90b3R5cGVbJ3NldCcgKyB0b1RpdGxlQ2FzZShwcm9wKV0gPSBmdW5jdGlvbiAodikge1xyXG4gICAgdGhpcy5lbF9bcHJvcF0gPSB2O1xyXG4gIH07XHJcbn0pO1xyXG5cclxuLy8gd3JhcCBuYXRpdmUgZnVuY3Rpb25zIHdpdGggYSBmdW5jdGlvblxyXG4vLyBUaGUgbGlzdCBpcyBhcyBmb2xsb3dzOlxyXG4vLyBwYXVzZSwgbG9hZCBwbGF5XHJcbltcclxuLyoqXHJcbiAqIEEgd3JhcHBlciBhcm91bmQgdGhlIG1lZGlhIGVsZW1lbnRzIGBwYXVzZWAgZnVuY3Rpb24uIFRoaXMgd2lsbCBjYWxsIHRoZSBgSFRNTDVgXHJcbiAqIG1lZGlhIGVsZW1lbnRzIGBwYXVzZWAgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBtZXRob2QgSHRtbDUjcGF1c2VcclxuICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1wYXVzZX1cclxuICovXHJcbidwYXVzZScsXHJcblxyXG4vKipcclxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgbWVkaWEgZWxlbWVudHMgYGxvYWRgIGZ1bmN0aW9uLiBUaGlzIHdpbGwgY2FsbCB0aGUgYEhUTUw1YHNcclxuICogbWVkaWEgZWxlbWVudCBgbG9hZGAgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBtZXRob2QgSHRtbDUjbG9hZFxyXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLWxvYWR9XHJcbiAqL1xyXG4nbG9hZCcsXHJcblxyXG4vKipcclxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgbWVkaWEgZWxlbWVudHMgYHBsYXlgIGZ1bmN0aW9uLiBUaGlzIHdpbGwgY2FsbCB0aGUgYEhUTUw1YHNcclxuICogbWVkaWEgZWxlbWVudCBgcGxheWAgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBtZXRob2QgSHRtbDUjcGxheVxyXG4gKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjZG9tLW1lZGlhLXBsYXl9XHJcbiAqL1xyXG4ncGxheSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICBIdG1sNS5wcm90b3R5cGVbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lbF9bcHJvcF0oKTtcclxuICB9O1xyXG59KTtcclxuXHJcblRlY2gud2l0aFNvdXJjZUhhbmRsZXJzKEh0bWw1KTtcclxuXHJcbi8qKlxyXG4gKiBOYXRpdmUgc291cmNlIGhhbmRsZXIgZm9yIEh0bWw1LCBzaW1wbHkgcGFzc2VzIHRoZSBzb3VyY2UgdG8gdGhlIG1lZGlhIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwcm9wcmV0eSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNvdXJjZVxyXG4gKiAgICAgICAgVGhlIHNvdXJjZSBvYmplY3RcclxuICpcclxuICogQHByb3ByZXR5IHtIdG1sNX0gdGVjaFxyXG4gKiAgICAgICAgVGhlIGluc3RhbmNlIG9mIHRoZSBIVE1MNSB0ZWNoLlxyXG4gKi9cclxuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlciA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBtZWRpYSBlbGVtZW50IGNhbiBwbGF5IHRoZSBnaXZlbiBtaW1lIHR5cGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXHJcbiAqICAgICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2tcclxuICpcclxuICogQHJldHVybiB7c3RyaW5nfVxyXG4gKiAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXHJcbiAqL1xyXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAvLyBJRTkgb24gV2luZG93cyA3IHdpdGhvdXQgTWVkaWFQbGF5ZXIgdGhyb3dzIGFuIGVycm9yIGhlcmVcclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvNTE5XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBIdG1sNS5URVNUX1ZJRC5jYW5QbGF5VHlwZSh0eXBlKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBtZWRpYSBlbGVtZW50IGNhbiBoYW5kbGUgYSBzb3VyY2UgbmF0aXZlbHkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7VGVjaH5Tb3VyY2VPYmplY3R9IHNvdXJjZVxyXG4gKiAgICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICogICAgICAgICBPcHRpb25zIHRvIGJlIHBhc3NlZCB0byB0aGUgdGVjaC5cclxuICpcclxuICogQHJldHVybiB7c3RyaW5nfVxyXG4gKiAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpLlxyXG4gKi9cclxuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5jYW5IYW5kbGVTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlLCBvcHRpb25zKSB7XHJcblxyXG4gIC8vIElmIGEgdHlwZSB3YXMgcHJvdmlkZWQgd2Ugc2hvdWxkIHJlbHkgb24gdGhhdFxyXG4gIGlmIChzb3VyY2UudHlwZSkge1xyXG4gICAgcmV0dXJuIEh0bWw1Lm5hdGl2ZVNvdXJjZUhhbmRsZXIuY2FuUGxheVR5cGUoc291cmNlLnR5cGUpO1xyXG5cclxuICAgIC8vIElmIG5vIHR5cGUsIGZhbGwgYmFjayB0byBjaGVja2luZyAndmlkZW8vW0VYVEVOU0lPTl0nXHJcbiAgfSBlbHNlIGlmIChzb3VyY2Uuc3JjKSB7XHJcbiAgICB2YXIgZXh0ID0gZ2V0RmlsZUV4dGVuc2lvbihzb3VyY2Uuc3JjKTtcclxuXHJcbiAgICByZXR1cm4gSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5jYW5QbGF5VHlwZSgndmlkZW8vJyArIGV4dCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gJyc7XHJcbn07XHJcblxyXG4vKipcclxuICogUGFzcyB0aGUgc291cmNlIHRvIHRoZSBuYXRpdmUgbWVkaWEgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXHJcbiAqICAgICAgICBUaGUgc291cmNlIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge0h0bWw1fSB0ZWNoXHJcbiAqICAgICAgICBUaGUgaW5zdGFuY2Ugb2YgdGhlIEh0bWw1IHRlY2hcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gKiAgICAgICAgVGhlIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgc291cmNlXHJcbiAqL1xyXG5IdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyLmhhbmRsZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRlY2gsIG9wdGlvbnMpIHtcclxuICB0ZWNoLnNldFNyYyhzb3VyY2Uuc3JjKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIG5vb3AgZm9yIHRoZSBuYXRpdmUgZGlzcG9zZSBmdW5jdGlvbiwgYXMgY2xlYW51cCBpcyBub3QgbmVlZGVkLlxyXG4gKi9cclxuSHRtbDUubmF0aXZlU291cmNlSGFuZGxlci5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XHJcblxyXG4vLyBSZWdpc3RlciB0aGUgbmF0aXZlIHNvdXJjZSBoYW5kbGVyXHJcbkh0bWw1LnJlZ2lzdGVyU291cmNlSGFuZGxlcihIdG1sNS5uYXRpdmVTb3VyY2VIYW5kbGVyKTtcclxuXHJcblRlY2gucmVnaXN0ZXJUZWNoKCdIdG1sNScsIEh0bWw1KTtcclxuXHJcbnZhciBfdGVtcGxhdGVPYmplY3QkMSA9IHRhZ2dlZFRlbXBsYXRlTGl0ZXJhbExvb3NlKFsnXFxuICAgICAgICBVc2luZyB0aGUgdGVjaCBkaXJlY3RseSBjYW4gYmUgZGFuZ2Vyb3VzLiBJIGhvcGUgeW91IGtub3cgd2hhdCB5b3VcXCdyZSBkb2luZy5cXG4gICAgICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlkZW9qcy92aWRlby5qcy9pc3N1ZXMvMjYxNyBmb3IgbW9yZSBpbmZvLlxcbiAgICAgICddLCBbJ1xcbiAgICAgICAgVXNpbmcgdGhlIHRlY2ggZGlyZWN0bHkgY2FuIGJlIGRhbmdlcm91cy4gSSBob3BlIHlvdSBrbm93IHdoYXQgeW91XFwncmUgZG9pbmcuXFxuICAgICAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpZGVvanMvdmlkZW8uanMvaXNzdWVzLzI2MTcgZm9yIG1vcmUgaW5mby5cXG4gICAgICAnXSk7XHJcblxyXG4vKipcclxuICogQGZpbGUgcGxheWVyLmpzXHJcbiAqL1xyXG4vLyBTdWJjbGFzc2VzIENvbXBvbmVudFxyXG4vLyBUaGUgZm9sbG93aW5nIGltcG9ydHMgYXJlIHVzZWQgb25seSB0byBlbnN1cmUgdGhhdCB0aGUgY29ycmVzcG9uZGluZyBtb2R1bGVzXHJcbi8vIGFyZSBhbHdheXMgaW5jbHVkZWQgaW4gdGhlIHZpZGVvLmpzIHBhY2thZ2UuIEltcG9ydGluZyB0aGUgbW9kdWxlcyB3aWxsXHJcbi8vIGV4ZWN1dGUgdGhlbSBhbmQgdGhleSB3aWxsIHJlZ2lzdGVyIHRoZW1zZWx2ZXMgd2l0aCB2aWRlby5qcy5cclxuLy8gSW1wb3J0IEh0bWw1IHRlY2gsIGF0IGxlYXN0IGZvciBkaXNwb3NpbmcgdGhlIG9yaWdpbmFsIHZpZGVvIHRhZy5cclxuLy8gVGhlIGZvbGxvd2luZyB0ZWNoIGV2ZW50cyBhcmUgc2ltcGx5IHJlLXRyaWdnZXJlZFxyXG4vLyBvbiB0aGUgcGxheWVyIHdoZW4gdGhleSBoYXBwZW5cclxudmFyIFRFQ0hfRVZFTlRTX1JFVFJJR0dFUiA9IFtcclxuLyoqXHJcbiAqIEZpcmVkIHdoaWxlIHRoZSB1c2VyIGFnZW50IGlzIGRvd25sb2FkaW5nIG1lZGlhIGRhdGEuXHJcbiAqXHJcbiAqIEBldmVudCBQbGF5ZXIjcHJvZ3Jlc3NcclxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHJpZ2dlciB0aGUgYHByb2dyZXNzYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFByb2dyZXNzX1xyXG4gKiBAZmlyZXMgUGxheWVyI3Byb2dyZXNzXHJcbiAqIEBsaXN0ZW5zIFRlY2gjcHJvZ3Jlc3NcclxuICovXHJcbidwcm9ncmVzcycsXHJcblxyXG4vKipcclxuICogRmlyZXMgd2hlbiB0aGUgbG9hZGluZyBvZiBhbiBhdWRpby92aWRlbyBpcyBhYm9ydGVkLlxyXG4gKlxyXG4gKiBAZXZlbnQgUGxheWVyI2Fib3J0XHJcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICovXHJcbi8qKlxyXG4gKiBSZXRyaWdnZXIgdGhlIGBhYm9ydGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hBYm9ydF9cclxuICogQGZpcmVzIFBsYXllciNhYm9ydFxyXG4gKiBAbGlzdGVucyBUZWNoI2Fib3J0XHJcbiAqL1xyXG4nYWJvcnQnLFxyXG5cclxuLyoqXHJcbiAqIEZpcmVzIHdoZW4gdGhlIGJyb3dzZXIgaXMgaW50ZW50aW9uYWxseSBub3QgZ2V0dGluZyBtZWRpYSBkYXRhLlxyXG4gKlxyXG4gKiBAZXZlbnQgUGxheWVyI3N1c3BlbmRcclxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHJpZ2dlciB0aGUgYHN1c3BlbmRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoU3VzcGVuZF9cclxuICogQGZpcmVzIFBsYXllciNzdXNwZW5kXHJcbiAqIEBsaXN0ZW5zIFRlY2gjc3VzcGVuZFxyXG4gKi9cclxuJ3N1c3BlbmQnLFxyXG5cclxuLyoqXHJcbiAqIEZpcmVzIHdoZW4gdGhlIGN1cnJlbnQgcGxheWxpc3QgaXMgZW1wdHkuXHJcbiAqXHJcbiAqIEBldmVudCBQbGF5ZXIjZW1wdGllZFxyXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAqL1xyXG4vKipcclxuICogUmV0cmlnZ2VyIHRoZSBgZW1wdGllZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtZXRob2QgUGxheWVyI2hhbmRsZVRlY2hFbXB0aWVkX1xyXG4gKiBAZmlyZXMgUGxheWVyI2VtcHRpZWRcclxuICogQGxpc3RlbnMgVGVjaCNlbXB0aWVkXHJcbiAqL1xyXG4nZW1wdGllZCcsXHJcbi8qKlxyXG4gKiBGaXJlcyB3aGVuIHRoZSBicm93c2VyIGlzIHRyeWluZyB0byBnZXQgbWVkaWEgZGF0YSwgYnV0IGRhdGEgaXMgbm90IGF2YWlsYWJsZS5cclxuICpcclxuICogQGV2ZW50IFBsYXllciNzdGFsbGVkXHJcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICovXHJcbi8qKlxyXG4gKiBSZXRyaWdnZXIgdGhlIGBzdGFsbGVkYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFN0YWxsZWRfXHJcbiAqIEBmaXJlcyBQbGF5ZXIjc3RhbGxlZFxyXG4gKiBAbGlzdGVucyBUZWNoI3N0YWxsZWRcclxuICovXHJcbidzdGFsbGVkJyxcclxuXHJcbi8qKlxyXG4gKiBGaXJlcyB3aGVuIHRoZSBicm93c2VyIGhhcyBsb2FkZWQgbWV0YSBkYXRhIGZvciB0aGUgYXVkaW8vdmlkZW8uXHJcbiAqXHJcbiAqIEBldmVudCBQbGF5ZXIjbG9hZGVkbWV0YWRhdGFcclxuICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHJpZ2dlciB0aGUgYHN0YWxsZWRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoTG9hZGVkbWV0YWRhdGFfXHJcbiAqIEBmaXJlcyBQbGF5ZXIjbG9hZGVkbWV0YWRhdGFcclxuICogQGxpc3RlbnMgVGVjaCNsb2FkZWRtZXRhZGF0YVxyXG4gKi9cclxuJ2xvYWRlZG1ldGFkYXRhJyxcclxuXHJcbi8qKlxyXG4gKiBGaXJlcyB3aGVuIHRoZSBicm93c2VyIGhhcyBsb2FkZWQgdGhlIGN1cnJlbnQgZnJhbWUgb2YgdGhlIGF1ZGlvL3ZpZGVvLlxyXG4gKlxyXG4gKiBAZXZlbnQgUGxheWVyI2xvYWRlZGRhdGFcclxuICogQHR5cGUge2V2ZW50fVxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHJpZ2dlciB0aGUgYGxvYWRlZGRhdGFgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoTG9hZGRlZGRhdGFfXHJcbiAqIEBmaXJlcyBQbGF5ZXIjbG9hZGVkZGF0YVxyXG4gKiBAbGlzdGVucyBUZWNoI2xvYWRlZGRhdGFcclxuICovXHJcbidsb2FkZWRkYXRhJyxcclxuXHJcbi8qKlxyXG4gKiBGaXJlcyB3aGVuIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uIGhhcyBjaGFuZ2VkLlxyXG4gKlxyXG4gKiBAZXZlbnQgUGxheWVyI3RpbWV1cGRhdGVcclxuICogQHR5cGUge2V2ZW50fVxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHJpZ2dlciB0aGUgYHRpbWV1cGRhdGVgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoVGltZVVwZGF0ZV9cclxuICogQGZpcmVzIFBsYXllciN0aW1ldXBkYXRlXHJcbiAqIEBsaXN0ZW5zIFRlY2gjdGltZXVwZGF0ZVxyXG4gKi9cclxuJ3RpbWV1cGRhdGUnLFxyXG5cclxuLyoqXHJcbiAqIEZpcmVzIHdoZW4gdGhlIHBsYXlpbmcgc3BlZWQgb2YgdGhlIGF1ZGlvL3ZpZGVvIGlzIGNoYW5nZWRcclxuICpcclxuICogQGV2ZW50IFBsYXllciNyYXRlY2hhbmdlXHJcbiAqIEB0eXBlIHtldmVudH1cclxuICovXHJcbi8qKlxyXG4gKiBSZXRyaWdnZXIgdGhlIGByYXRlY2hhbmdlYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFJhdGVjaGFuZ2VfXHJcbiAqIEBmaXJlcyBQbGF5ZXIjcmF0ZWNoYW5nZVxyXG4gKiBAbGlzdGVucyBUZWNoI3JhdGVjaGFuZ2VcclxuICovXHJcbidyYXRlY2hhbmdlJyxcclxuXHJcbi8qKlxyXG4gKiBGaXJlcyB3aGVuIHRoZSB2aWRlbydzIGludHJpbnNpYyBkaW1lbnNpb25zIGNoYW5nZVxyXG4gKlxyXG4gKiBAZXZlbnQgUGxheWVyI3Jlc2l6ZVxyXG4gKiBAdHlwZSB7ZXZlbnR9XHJcbiAqL1xyXG4vKipcclxuICogUmV0cmlnZ2VyIHRoZSBgcmVzaXplYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQG1ldGhvZCBQbGF5ZXIjaGFuZGxlVGVjaFJlc2l6ZV9cclxuICogQGZpcmVzIFBsYXllciNyZXNpemVcclxuICogQGxpc3RlbnMgVGVjaCNyZXNpemVcclxuICovXHJcbidyZXNpemUnLFxyXG5cclxuLyoqXHJcbiAqIEZpcmVzIHdoZW4gdGhlIHZvbHVtZSBoYXMgYmVlbiBjaGFuZ2VkXHJcbiAqXHJcbiAqIEBldmVudCBQbGF5ZXIjdm9sdW1lY2hhbmdlXHJcbiAqIEB0eXBlIHtldmVudH1cclxuICovXHJcbi8qKlxyXG4gKiBSZXRyaWdnZXIgdGhlIGB2b2x1bWVjaGFuZ2VgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoVm9sdW1lY2hhbmdlX1xyXG4gKiBAZmlyZXMgUGxheWVyI3ZvbHVtZWNoYW5nZVxyXG4gKiBAbGlzdGVucyBUZWNoI3ZvbHVtZWNoYW5nZVxyXG4gKi9cclxuJ3ZvbHVtZWNoYW5nZScsXHJcblxyXG4vKipcclxuICogRmlyZXMgd2hlbiB0aGUgdGV4dCB0cmFjayBoYXMgYmVlbiBjaGFuZ2VkXHJcbiAqXHJcbiAqIEBldmVudCBQbGF5ZXIjdGV4dHRyYWNrY2hhbmdlXHJcbiAqIEB0eXBlIHtldmVudH1cclxuICovXHJcbi8qKlxyXG4gKiBSZXRyaWdnZXIgdGhlIGB0ZXh0dHJhY2tjaGFuZ2VgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWV0aG9kIFBsYXllciNoYW5kbGVUZWNoVGV4dHRyYWNrY2hhbmdlX1xyXG4gKiBAZmlyZXMgUGxheWVyI3RleHR0cmFja2NoYW5nZVxyXG4gKiBAbGlzdGVucyBUZWNoI3RleHR0cmFja2NoYW5nZVxyXG4gKi9cclxuJ3RleHR0cmFja2NoYW5nZSddO1xyXG5cclxuLyoqXHJcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBgUGxheWVyYCBjbGFzcyBpcyBjcmVhdGVkIHdoZW4gYW55IG9mIHRoZSBWaWRlby5qcyBzZXR1cCBtZXRob2RzXHJcbiAqIGFyZSB1c2VkIHRvIGluaXRpYWxpemUgYSB2aWRlby5cclxuICpcclxuICogQWZ0ZXIgYW4gaW5zdGFuY2UgaGFzIGJlZW4gY3JlYXRlZCBpdCBjYW4gYmUgYWNjZXNzZWQgZ2xvYmFsbHkgaW4gdHdvIHdheXM6XHJcbiAqIDEuIEJ5IGNhbGxpbmcgYHZpZGVvanMoJ2V4YW1wbGVfdmlkZW9fMScpO2BcclxuICogMi4gQnkgdXNpbmcgaXQgZGlyZWN0bHkgdmlhICBgdmlkZW9qcy5wbGF5ZXJzLmV4YW1wbGVfdmlkZW9fMTtgXHJcbiAqXHJcbiAqIEBleHRlbmRzIENvbXBvbmVudFxyXG4gKi9cclxuXHJcbnZhciBQbGF5ZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xyXG4gIGluaGVyaXRzKFBsYXllciwgX0NvbXBvbmVudCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSB0YWdcclxuICAgKiAgICAgICAgVGhlIG9yaWdpbmFsIHZpZGVvIERPTSBlbGVtZW50IHVzZWQgZm9yIGNvbmZpZ3VyaW5nIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICAgICAgIE9iamVjdCBvZiBvcHRpb24gbmFtZXMgYW5kIHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q29tcG9uZW50flJlYWR5Q2FsbGJhY2t9IFtyZWFkeV1cclxuICAgKiAgICAgICAgUmVhZHkgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gUGxheWVyKHRhZywgb3B0aW9ucywgcmVhZHkpIHtcclxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBsYXllcik7XHJcblxyXG4gICAgLy8gTWFrZSBzdXJlIHRhZyBJRCBleGlzdHNcclxuICAgIHRhZy5pZCA9IHRhZy5pZCB8fCAndmpzX3ZpZGVvXycgKyBuZXdHVUlEKCk7XHJcblxyXG4gICAgLy8gU2V0IE9wdGlvbnNcclxuICAgIC8vIFRoZSBvcHRpb25zIGFyZ3VtZW50IG92ZXJyaWRlcyBvcHRpb25zIHNldCBpbiB0aGUgdmlkZW8gdGFnXHJcbiAgICAvLyB3aGljaCBvdmVycmlkZXMgZ2xvYmFsbHkgc2V0IG9wdGlvbnMuXHJcbiAgICAvLyBUaGlzIGxhdHRlciBwYXJ0IGNvaW5jaWRlcyB3aXRoIHRoZSBsb2FkIG9yZGVyXHJcbiAgICAvLyAodGFnIG11c3QgZXhpc3QgYmVmb3JlIFBsYXllcilcclxuICAgIG9wdGlvbnMgPSBhc3NpZ24oUGxheWVyLmdldFRhZ1NldHRpbmdzKHRhZyksIG9wdGlvbnMpO1xyXG5cclxuICAgIC8vIERlbGF5IHRoZSBpbml0aWFsaXphdGlvbiBvZiBjaGlsZHJlbiBiZWNhdXNlIHdlIG5lZWQgdG8gc2V0IHVwXHJcbiAgICAvLyBwbGF5ZXIgcHJvcGVydGllcyBmaXJzdCwgYW5kIGNhbid0IHVzZSBgdGhpc2AgYmVmb3JlIGBzdXBlcigpYFxyXG4gICAgb3B0aW9ucy5pbml0Q2hpbGRyZW4gPSBmYWxzZTtcclxuXHJcbiAgICAvLyBTYW1lIHdpdGggY3JlYXRpbmcgdGhlIGVsZW1lbnRcclxuICAgIG9wdGlvbnMuY3JlYXRlRWwgPSBmYWxzZTtcclxuXHJcbiAgICAvLyB3ZSBkb24ndCB3YW50IHRoZSBwbGF5ZXIgdG8gcmVwb3J0IHRvdWNoIGFjdGl2aXR5IG9uIGl0c2VsZlxyXG4gICAgLy8gc2VlIGVuYWJsZVRvdWNoQWN0aXZpdHkgaW4gQ29tcG9uZW50XHJcbiAgICBvcHRpb25zLnJlcG9ydFRvdWNoQWN0aXZpdHkgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBJZiBsYW5ndWFnZSBpcyBub3Qgc2V0LCBnZXQgdGhlIGNsb3Nlc3QgbGFuZyBhdHRyaWJ1dGVcclxuICAgIGlmICghb3B0aW9ucy5sYW5ndWFnZSkge1xyXG4gICAgICBpZiAodHlwZW9mIHRhZy5jbG9zZXN0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdmFyIGNsb3Nlc3QgPSB0YWcuY2xvc2VzdCgnW2xhbmddJyk7XHJcblxyXG4gICAgICAgIGlmIChjbG9zZXN0KSB7XHJcbiAgICAgICAgICBvcHRpb25zLmxhbmd1YWdlID0gY2xvc2VzdC5nZXRBdHRyaWJ1dGUoJ2xhbmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0YWc7XHJcblxyXG4gICAgICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICAgIGlmIChnZXRBdHRyaWJ1dGVzKGVsZW1lbnQpLmhhc093blByb3BlcnR5KCdsYW5nJykpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5sYW5ndWFnZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdsYW5nJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBSdW4gYmFzZSBjb21wb25lbnQgaW5pdGlhbGl6aW5nIHdpdGggbmV3IG9wdGlvbnNcclxuXHJcbiAgICAvLyBUdXJuIG9mZiBBUEkgYWNjZXNzIGJlY2F1c2Ugd2UncmUgbG9hZGluZyBhIG5ldyB0ZWNoIHRoYXQgbWlnaHQgbG9hZCBhc3luY2hyb25vdXNseVxyXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgbnVsbCwgb3B0aW9ucywgcmVhZHkpKTtcclxuXHJcbiAgICBfdGhpcy5pc1JlYWR5XyA9IGZhbHNlO1xyXG5cclxuICAgIC8vIGlmIHRoZSBnbG9iYWwgb3B0aW9uIG9iamVjdCB3YXMgYWNjaWRlbnRhbGx5IGJsb3duIGF3YXkgYnlcclxuICAgIC8vIHNvbWVvbmUsIGJhaWwgZWFybHkgd2l0aCBhbiBpbmZvcm1hdGl2ZSBlcnJvclxyXG4gICAgaWYgKCFfdGhpcy5vcHRpb25zXyB8fCAhX3RoaXMub3B0aW9uc18udGVjaE9yZGVyIHx8ICFfdGhpcy5vcHRpb25zXy50ZWNoT3JkZXIubGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdGVjaE9yZGVyIHNwZWNpZmllZC4gRGlkIHlvdSBvdmVyd3JpdGUgJyArICd2aWRlb2pzLm9wdGlvbnMgaW5zdGVhZCBvZiBqdXN0IGNoYW5naW5nIHRoZSAnICsgJ3Byb3BlcnRpZXMgeW91IHdhbnQgdG8gb3ZlcnJpZGU/Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIHRhZyB1c2VkIHRvIHNldCBvcHRpb25zXHJcbiAgICBfdGhpcy50YWcgPSB0YWc7XHJcblxyXG4gICAgLy8gU3RvcmUgdGhlIHRhZyBhdHRyaWJ1dGVzIHVzZWQgdG8gcmVzdG9yZSBodG1sNSBlbGVtZW50XHJcbiAgICBfdGhpcy50YWdBdHRyaWJ1dGVzID0gdGFnICYmIGdldEF0dHJpYnV0ZXModGFnKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgY3VycmVudCBsYW5ndWFnZVxyXG4gICAgX3RoaXMubGFuZ3VhZ2UoX3RoaXMub3B0aW9uc18ubGFuZ3VhZ2UpO1xyXG5cclxuICAgIC8vIFVwZGF0ZSBTdXBwb3J0ZWQgTGFuZ3VhZ2VzXHJcbiAgICBpZiAob3B0aW9ucy5sYW5ndWFnZXMpIHtcclxuICAgICAgLy8gTm9ybWFsaXNlIHBsYXllciBvcHRpb24gbGFuZ3VhZ2VzIHRvIGxvd2VyY2FzZVxyXG4gICAgICB2YXIgbGFuZ3VhZ2VzVG9Mb3dlciA9IHt9O1xyXG5cclxuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3B0aW9ucy5sYW5ndWFnZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUkJDEpIHtcclxuICAgICAgICBsYW5ndWFnZXNUb0xvd2VyW25hbWUkJDEudG9Mb3dlckNhc2UoKV0gPSBvcHRpb25zLmxhbmd1YWdlc1tuYW1lJCQxXTtcclxuICAgICAgfSk7XHJcbiAgICAgIF90aGlzLmxhbmd1YWdlc18gPSBsYW5ndWFnZXNUb0xvd2VyO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgX3RoaXMubGFuZ3VhZ2VzXyA9IFBsYXllci5wcm90b3R5cGUub3B0aW9uc18ubGFuZ3VhZ2VzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhY2hlIGZvciB2aWRlbyBwcm9wZXJ0eSB2YWx1ZXMuXHJcbiAgICBfdGhpcy5jYWNoZV8gPSB7fTtcclxuXHJcbiAgICAvLyBTZXQgcG9zdGVyXHJcbiAgICBfdGhpcy5wb3N0ZXJfID0gb3B0aW9ucy5wb3N0ZXIgfHwgJyc7XHJcblxyXG4gICAgLy8gU2V0IGNvbnRyb2xzXHJcbiAgICBfdGhpcy5jb250cm9sc18gPSAhIW9wdGlvbnMuY29udHJvbHM7XHJcblxyXG4gICAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIGZvciBsYXN0Vm9sdW1lXHJcbiAgICBfdGhpcy5jYWNoZV8ubGFzdFZvbHVtZSA9IDE7XHJcblxyXG4gICAgLy8gT3JpZ2luYWwgdGFnIHNldHRpbmdzIHN0b3JlZCBpbiBvcHRpb25zXHJcbiAgICAvLyBub3cgcmVtb3ZlIGltbWVkaWF0ZWx5IHNvIG5hdGl2ZSBjb250cm9scyBkb24ndCBmbGFzaC5cclxuICAgIC8vIE1heSBiZSB0dXJuZWQgYmFjayBvbiBieSBIVE1MNSB0ZWNoIGlmIG5hdGl2ZUNvbnRyb2xzRm9yVG91Y2ggaXMgdHJ1ZVxyXG4gICAgdGFnLmNvbnRyb2xzID0gZmFsc2U7XHJcblxyXG4gICAgLypcclxuICAgICAqIFN0b3JlIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBzY3J1YmJpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdXNlciBpcyBzY3J1YmJpbmdcclxuICAgICAqL1xyXG4gICAgX3RoaXMuc2NydWJiaW5nXyA9IGZhbHNlO1xyXG5cclxuICAgIF90aGlzLmVsXyA9IF90aGlzLmNyZWF0ZUVsKCk7XHJcblxyXG4gICAgLy8gTWFrZSB0aGlzIGFuIGV2ZW50ZWQgb2JqZWN0IGFuZCB1c2UgYGVsX2AgYXMgaXRzIGV2ZW50IGJ1cy5cclxuICAgIGV2ZW50ZWQoX3RoaXMsIHsgZXZlbnRCdXNLZXk6ICdlbF8nIH0pO1xyXG5cclxuICAgIC8vIFdlIGFsc28gd2FudCB0byBwYXNzIHRoZSBvcmlnaW5hbCBwbGF5ZXIgb3B0aW9ucyB0byBlYWNoIGNvbXBvbmVudCBhbmQgcGx1Z2luXHJcbiAgICAvLyBhcyB3ZWxsIHNvIHRoZXkgZG9uJ3QgbmVlZCB0byByZWFjaCBiYWNrIGludG8gdGhlIHBsYXllciBmb3Igb3B0aW9ucyBsYXRlci5cclxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBkbyBhbm90aGVyIGNvcHkgb2YgdGhpcy5vcHRpb25zXyBzbyB3ZSBkb24ndCBlbmQgdXAgd2l0aFxyXG4gICAgLy8gYW4gaW5maW5pdGUgbG9vcC5cclxuICAgIHZhciBwbGF5ZXJPcHRpb25zQ29weSA9IG1lcmdlT3B0aW9ucyhfdGhpcy5vcHRpb25zXyk7XHJcblxyXG4gICAgLy8gTG9hZCBwbHVnaW5zXHJcbiAgICBpZiAob3B0aW9ucy5wbHVnaW5zKSB7XHJcbiAgICAgIHZhciBwbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zO1xyXG5cclxuICAgICAgT2JqZWN0LmtleXMocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSQkMSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1tuYW1lJCQxXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgdGhpc1tuYW1lJCQxXShwbHVnaW5zW25hbWUkJDFdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwbHVnaW4gXCInICsgbmFtZSQkMSArICdcIiBkb2VzIG5vdCBleGlzdCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgX3RoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIF90aGlzLm9wdGlvbnNfLnBsYXllck9wdGlvbnMgPSBwbGF5ZXJPcHRpb25zQ29weTtcclxuXHJcbiAgICBfdGhpcy5taWRkbGV3YXJlXyA9IFtdO1xyXG5cclxuICAgIF90aGlzLmluaXRDaGlsZHJlbigpO1xyXG5cclxuICAgIC8vIFNldCBpc0F1ZGlvIGJhc2VkIG9uIHdoZXRoZXIgb3Igbm90IGFuIGF1ZGlvIHRhZyB3YXMgdXNlZFxyXG4gICAgX3RoaXMuaXNBdWRpbyh0YWcubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2F1ZGlvJyk7XHJcblxyXG4gICAgLy8gVXBkYXRlIGNvbnRyb2xzIGNsYXNzTmFtZS4gQ2FuJ3QgZG8gdGhpcyB3aGVuIHRoZSBjb250cm9scyBhcmUgaW5pdGlhbGx5XHJcbiAgICAvLyBzZXQgYmVjYXVzZSB0aGUgZWxlbWVudCBkb2Vzbid0IGV4aXN0IHlldC5cclxuICAgIGlmIChfdGhpcy5jb250cm9scygpKSB7XHJcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtY29udHJvbHMtZW5hYmxlZCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy1jb250cm9scy1kaXNhYmxlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCBBUklBIGxhYmVsIGFuZCByZWdpb24gcm9sZSBkZXBlbmRpbmcgb24gcGxheWVyIHR5cGVcclxuICAgIF90aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncmVnaW9uJyk7XHJcbiAgICBpZiAoX3RoaXMuaXNBdWRpbygpKSB7XHJcbiAgICAgIF90aGlzLmVsXy5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBfdGhpcy5sb2NhbGl6ZSgnQXVkaW8gUGxheWVyJykpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgX3RoaXMuZWxfLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIF90aGlzLmxvY2FsaXplKCdWaWRlbyBQbGF5ZXInKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKF90aGlzLmlzQXVkaW8oKSkge1xyXG4gICAgICBfdGhpcy5hZGRDbGFzcygndmpzLWF1ZGlvJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKF90aGlzLmZsZXhOb3RTdXBwb3J0ZWRfKCkpIHtcclxuICAgICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy1uby1mbGV4Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogTWFrZSB0aGlzIHNtYXJ0ZXIuIFRvZ2dsZSB1c2VyIHN0YXRlIGJldHdlZW4gdG91Y2hpbmcvbW91c2luZ1xyXG4gICAgLy8gdXNpbmcgZXZlbnRzLCBzaW5jZSBkZXZpY2VzIGNhbiBoYXZlIGJvdGggdG91Y2ggYW5kIG1vdXNlIGV2ZW50cy5cclxuICAgIC8vIGlmIChicm93c2VyLlRPVUNIX0VOQUJMRUQpIHtcclxuICAgIC8vICAgdGhpcy5hZGRDbGFzcygndmpzLXRvdWNoLWVuYWJsZWQnKTtcclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyBpT1MgU2FmYXJpIGhhcyBicm9rZW4gaG92ZXIgaGFuZGxpbmdcclxuICAgIGlmICghSVNfSU9TKSB7XHJcbiAgICAgIF90aGlzLmFkZENsYXNzKCd2anMtd29ya2luZ2hvdmVyJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFrZSBwbGF5ZXIgZWFzaWx5IGZpbmRhYmxlIGJ5IElEXHJcbiAgICBQbGF5ZXIucGxheWVyc1tfdGhpcy5pZF9dID0gX3RoaXM7XHJcblxyXG4gICAgLy8gQWRkIGEgbWFqb3IgdmVyc2lvbiBjbGFzcyB0byBhaWQgY3NzIGluIHBsdWdpbnNcclxuICAgIHZhciBtYWpvclZlcnNpb24gPSB2ZXJzaW9uLnNwbGl0KCcuJylbMF07XHJcblxyXG4gICAgX3RoaXMuYWRkQ2xhc3MoJ3Zqcy12JyArIG1ham9yVmVyc2lvbik7XHJcblxyXG4gICAgLy8gV2hlbiB0aGUgcGxheWVyIGlzIGZpcnN0IGluaXRpYWxpemVkLCB0cmlnZ2VyIGFjdGl2aXR5IHNvIGNvbXBvbmVudHNcclxuICAgIC8vIGxpa2UgdGhlIGNvbnRyb2wgYmFyIHNob3cgdGhlbXNlbHZlcyBpZiBuZWVkZWRcclxuICAgIF90aGlzLnVzZXJBY3RpdmUodHJ1ZSk7XHJcbiAgICBfdGhpcy5yZXBvcnRVc2VyQWN0aXZpdHkoKTtcclxuICAgIF90aGlzLmxpc3RlbkZvclVzZXJBY3Rpdml0eV8oKTtcclxuXHJcbiAgICBfdGhpcy5vbignZnVsbHNjcmVlbmNoYW5nZScsIF90aGlzLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2VfKTtcclxuICAgIF90aGlzLm9uKCdzdGFnZWNsaWNrJywgX3RoaXMuaGFuZGxlU3RhZ2VDbGlja18pO1xyXG5cclxuICAgIF90aGlzLmNoYW5naW5nU3JjXyA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIF90aGlzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGVzdHJveXMgdGhlIHZpZGVvIHBsYXllciBhbmQgZG9lcyBhbnkgbmVjZXNzYXJ5IGNsZWFudXAuXHJcbiAgICpcclxuICAgKiBUaGlzIGlzIGVzcGVjaWFsbHkgaGVscGZ1bCBpZiB5b3UgYXJlIGR5bmFtaWNhbGx5IGFkZGluZyBhbmQgcmVtb3ZpbmcgdmlkZW9zXHJcbiAgICogdG8vZnJvbSB0aGUgRE9NLlxyXG4gICAqXHJcbiAgICogQGZpcmVzIFBsYXllciNkaXNwb3NlXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgcGxheWVyIGlzIGJlaW5nIGRpc3Bvc2VkIG9mLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudCBQbGF5ZXIjZGlzcG9zZVxyXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRyaWdnZXIoJ2Rpc3Bvc2UnKTtcclxuICAgIC8vIHByZXZlbnQgZGlzcG9zZSBmcm9tIGJlaW5nIGNhbGxlZCB0d2ljZVxyXG4gICAgdGhpcy5vZmYoJ2Rpc3Bvc2UnKTtcclxuXHJcbiAgICBpZiAodGhpcy5zdHlsZUVsXyAmJiB0aGlzLnN0eWxlRWxfLnBhcmVudE5vZGUpIHtcclxuICAgICAgdGhpcy5zdHlsZUVsXy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc3R5bGVFbF8pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEtpbGwgcmVmZXJlbmNlIHRvIHRoaXMgcGxheWVyXHJcbiAgICBQbGF5ZXIucGxheWVyc1t0aGlzLmlkX10gPSBudWxsO1xyXG5cclxuICAgIGlmICh0aGlzLnRhZyAmJiB0aGlzLnRhZy5wbGF5ZXIpIHtcclxuICAgICAgdGhpcy50YWcucGxheWVyID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5lbF8gJiYgdGhpcy5lbF8ucGxheWVyKSB7XHJcbiAgICAgIHRoaXMuZWxfLnBsYXllciA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMudGVjaF8pIHtcclxuICAgICAgdGhpcy50ZWNoXy5kaXNwb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgX0NvbXBvbmVudC5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgYFBsYXllcmAncyBET00gZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICogICAgICAgICBUaGUgRE9NIGVsZW1lbnQgdGhhdCBnZXRzIGNyZWF0ZWQuXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmNyZWF0ZUVsID0gZnVuY3Rpb24gY3JlYXRlRWwkJDEoKSB7XHJcbiAgICB2YXIgdGFnID0gdGhpcy50YWc7XHJcbiAgICB2YXIgZWwgPSB2b2lkIDA7XHJcbiAgICB2YXIgcGxheWVyRWxJbmdlc3QgPSB0aGlzLnBsYXllckVsSW5nZXN0XyA9IHRhZy5wYXJlbnROb2RlICYmIHRhZy5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSAmJiB0YWcucGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtdmpzLXBsYXllcicpO1xyXG5cclxuICAgIGlmIChwbGF5ZXJFbEluZ2VzdCkge1xyXG4gICAgICBlbCA9IHRoaXMuZWxfID0gdGFnLnBhcmVudE5vZGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlbCA9IHRoaXMuZWxfID0gX0NvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlRWwuY2FsbCh0aGlzLCAnZGl2Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0IHRhYmluZGV4IHRvIC0xIHNvIHdlIGNvdWxkIGZvY3VzIG9uIHRoZSBwbGF5ZXIgZWxlbWVudFxyXG4gICAgdGFnLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcclxuXHJcbiAgICAvLyBSZW1vdmUgd2lkdGgvaGVpZ2h0IGF0dHJzIGZyb20gdGFnIHNvIENTUyBjYW4gbWFrZSBpdCAxMDAlIHdpZHRoL2hlaWdodFxyXG4gICAgdGFnLnJlbW92ZUF0dHJpYnV0ZSgnd2lkdGgnKTtcclxuICAgIHRhZy5yZW1vdmVBdHRyaWJ1dGUoJ2hlaWdodCcpO1xyXG5cclxuICAgIC8vIENvcHkgb3ZlciBhbGwgdGhlIGF0dHJpYnV0ZXMgZnJvbSB0aGUgdGFnLCBpbmNsdWRpbmcgSUQgYW5kIGNsYXNzXHJcbiAgICAvLyBJRCB3aWxsIG5vdyByZWZlcmVuY2UgcGxheWVyIGJveCwgbm90IHRoZSB2aWRlbyB0YWdcclxuICAgIHZhciBhdHRycyA9IGdldEF0dHJpYnV0ZXModGFnKTtcclxuXHJcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xyXG4gICAgICAvLyB3b3JrYXJvdW5kIHNvIHdlIGRvbid0IHRvdGFsbHkgYnJlYWsgSUU3XHJcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzY1MzQ0NC9jc3Mtc3R5bGVzLW5vdC1hcHBsaWVkLW9uLWR5bmFtaWMtZWxlbWVudHMtaW4taW50ZXJuZXQtZXhwbG9yZXItN1xyXG4gICAgICBpZiAoYXR0ciA9PT0gJ2NsYXNzJykge1xyXG4gICAgICAgIGVsLmNsYXNzTmFtZSArPSAnICcgKyBhdHRyc1thdHRyXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cnNbYXR0cl0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGFnIGlkL2NsYXNzIGZvciB1c2UgYXMgSFRNTDUgcGxheWJhY2sgdGVjaFxyXG4gICAgLy8gTWlnaHQgdGhpbmsgd2Ugc2hvdWxkIGRvIHRoaXMgYWZ0ZXIgZW1iZWRkaW5nIGluIGNvbnRhaW5lciBzbyAudmpzLXRlY2ggY2xhc3NcclxuICAgIC8vIGRvZXNuJ3QgZmxhc2ggMTAwJSB3aWR0aC9oZWlnaHQsIGJ1dCBjbGFzcyBvbmx5IGFwcGxpZXMgd2l0aCAudmlkZW8tanMgcGFyZW50XHJcbiAgICB0YWcucGxheWVySWQgPSB0YWcuaWQ7XHJcbiAgICB0YWcuaWQgKz0gJ19odG1sNV9hcGknO1xyXG4gICAgdGFnLmNsYXNzTmFtZSA9ICd2anMtdGVjaCc7XHJcblxyXG4gICAgLy8gTWFrZSBwbGF5ZXIgZmluZGFibGUgb24gZWxlbWVudHNcclxuICAgIHRhZy5wbGF5ZXIgPSBlbC5wbGF5ZXIgPSB0aGlzO1xyXG4gICAgLy8gRGVmYXVsdCBzdGF0ZSBvZiB2aWRlbyBpcyBwYXVzZWRcclxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1wYXVzZWQnKTtcclxuXHJcbiAgICAvLyBBZGQgYSBzdHlsZSBlbGVtZW50IGluIHRoZSBwbGF5ZXIgdGhhdCB3ZSdsbCB1c2UgdG8gc2V0IHRoZSB3aWR0aC9oZWlnaHRcclxuICAgIC8vIG9mIHRoZSBwbGF5ZXIgaW4gYSB3YXkgdGhhdCdzIHN0aWxsIG92ZXJyaWRlYWJsZSBieSBDU1MsIGp1c3QgbGlrZSB0aGVcclxuICAgIC8vIHZpZGVvIGVsZW1lbnRcclxuICAgIGlmICh3aW5kb3dfMS5WSURFT0pTX05PX0RZTkFNSUNfU1RZTEUgIT09IHRydWUpIHtcclxuICAgICAgdGhpcy5zdHlsZUVsXyA9IGNyZWF0ZVN0eWxlRWxlbWVudCgndmpzLXN0eWxlcy1kaW1lbnNpb25zJyk7XHJcbiAgICAgIHZhciBkZWZhdWx0c1N0eWxlRWwgPSAkKCcudmpzLXN0eWxlcy1kZWZhdWx0cycpO1xyXG4gICAgICB2YXIgaGVhZCA9ICQoJ2hlYWQnKTtcclxuXHJcbiAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHRoaXMuc3R5bGVFbF8sIGRlZmF1bHRzU3R5bGVFbCA/IGRlZmF1bHRzU3R5bGVFbC5uZXh0U2libGluZyA6IGhlYWQuZmlyc3RDaGlsZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFzcyBpbiB0aGUgd2lkdGgvaGVpZ2h0L2FzcGVjdFJhdGlvIG9wdGlvbnMgd2hpY2ggd2lsbCB1cGRhdGUgdGhlIHN0eWxlIGVsXHJcbiAgICB0aGlzLndpZHRoKHRoaXMub3B0aW9uc18ud2lkdGgpO1xyXG4gICAgdGhpcy5oZWlnaHQodGhpcy5vcHRpb25zXy5oZWlnaHQpO1xyXG4gICAgdGhpcy5mbHVpZCh0aGlzLm9wdGlvbnNfLmZsdWlkKTtcclxuICAgIHRoaXMuYXNwZWN0UmF0aW8odGhpcy5vcHRpb25zXy5hc3BlY3RSYXRpbyk7XHJcblxyXG4gICAgLy8gSGlkZSBhbnkgbGlua3Mgd2l0aGluIHRoZSB2aWRlby9hdWRpbyB0YWcsIGJlY2F1c2UgSUUgZG9lc24ndCBoaWRlIHRoZW0gY29tcGxldGVseS5cclxuICAgIHZhciBsaW5rcyA9IHRhZy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGxpbmtFbCA9IGxpbmtzLml0ZW0oaSk7XHJcblxyXG4gICAgICBhZGRDbGFzcyhsaW5rRWwsICd2anMtaGlkZGVuJyk7XHJcbiAgICAgIGxpbmtFbC5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICdoaWRkZW4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpbnNlcnRFbEZpcnN0IHNlZW1zIHRvIGNhdXNlIHRoZSBuZXR3b3JrU3RhdGUgdG8gZmxpY2tlciBmcm9tIDMgdG8gMiwgc29cclxuICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIG9yaWdpbmFsIGZvciBsYXRlciBzbyB3ZSBjYW4ga25vdyBpZiB0aGUgc291cmNlIG9yaWdpbmFsbHkgZmFpbGVkXHJcbiAgICB0YWcuaW5pdE5ldHdvcmtTdGF0ZV8gPSB0YWcubmV0d29ya1N0YXRlO1xyXG5cclxuICAgIC8vIFdyYXAgdmlkZW8gdGFnIGluIGRpdiAoZWwvYm94KSBjb250YWluZXJcclxuICAgIGlmICh0YWcucGFyZW50Tm9kZSAmJiAhcGxheWVyRWxJbmdlc3QpIHtcclxuICAgICAgdGFnLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCB0YWcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGluc2VydCB0aGUgdGFnIGFzIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgcGxheWVyIGVsZW1lbnRcclxuICAgIC8vIHRoZW4gbWFudWFsbHkgYWRkIGl0IHRvIHRoZSBjaGlsZHJlbiBhcnJheSBzbyB0aGF0IHRoaXMuYWRkQ2hpbGRcclxuICAgIC8vIHdpbGwgd29yayBwcm9wZXJseSBmb3Igb3RoZXIgY29tcG9uZW50c1xyXG4gICAgLy9cclxuICAgIC8vIEJyZWFrcyBpUGhvbmUsIGZpeGVkIGluIEhUTUw1IHNldHVwLlxyXG4gICAgcHJlcGVuZFRvKHRhZywgZWwpO1xyXG4gICAgdGhpcy5jaGlsZHJlbl8udW5zaGlmdCh0YWcpO1xyXG5cclxuICAgIC8vIFNldCBsYW5nIGF0dHIgb24gcGxheWVyIHRvIGVuc3VyZSBDU1MgOmxhbmcoKSBpbiBjb25zaXN0ZW50IHdpdGggcGxheWVyXHJcbiAgICAvLyBpZiBpdCdzIGJlZW4gc2V0IHRvIHNvbWV0aGluZyBkaWZmZXJlbnQgdG8gdGhlIGRvY1xyXG4gICAgdGhpcy5lbF8uc2V0QXR0cmlidXRlKCdsYW5nJywgdGhpcy5sYW5ndWFnZV8pO1xyXG5cclxuICAgIHRoaXMuZWxfID0gZWw7XHJcblxyXG4gICAgcmV0dXJuIGVsO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBQbGF5ZXJgJ3Mgd2lkdGguIFJldHVybnMgdGhlIHBsYXllcidzIGNvbmZpZ3VyZWQgdmFsdWUuXHJcbiAgICogVG8gZ2V0IHRoZSBjdXJyZW50IHdpZHRoIHVzZSBgY3VycmVudFdpZHRoKClgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt2YWx1ZV1cclxuICAgKiAgICAgICAgVGhlIHZhbHVlIHRvIHNldCB0aGUgYFBsYXllcmAncyB3aWR0aCB0by5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBgUGxheWVyYCB3aGVuIGdldHRpbmcuXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24gd2lkdGgodmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbignd2lkdGgnLCB2YWx1ZSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBnZXR0ZXIvc2V0dGVyIGZvciB0aGUgYFBsYXllcmAncyBoZWlnaHQuIFJldHVybnMgdGhlIHBsYXllcidzIGNvbmZpZ3VyZWQgdmFsdWUuXHJcbiAgICogVG8gZ2V0IHRoZSBjdXJyZW50IGhlaWdodCB1c2UgYGN1cnJlbnRoZWlnaHQoKWAuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ZhbHVlXVxyXG4gICAqICAgICAgICBUaGUgdmFsdWUgdG8gc2V0IHRoZSBgUGxheWVyYCdzIGhlaWd0aCB0by5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgYFBsYXllcmAgd2hlbiBnZXR0aW5nLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbiBoZWlnaHQodmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbignaGVpZ2h0JywgdmFsdWUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGBQbGF5ZXJgJ3Mgd2lkdGggJiBoZWlnaHQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGltZW5zaW9uXHJcbiAgICogICAgICAgIFRoaXMgc3RyaW5nIGNhbiBiZTpcclxuICAgKiAgICAgICAgLSAnd2lkdGgnXHJcbiAgICogICAgICAgIC0gJ2hlaWdodCdcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWVdXHJcbiAgICogICAgICAgIFZhbHVlIGZvciBkaW1lbnNpb24gc3BlY2lmaWVkIGluIHRoZSBmaXJzdCBhcmd1bWVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKiAgICAgICAgIFRoZSBkaW1lbnNpb24gYXJndW1lbnRzIHZhbHVlIHdoZW4gZ2V0dGluZyAod2lkdGgvaGVpZ2h0KS5cclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuZGltZW5zaW9uID0gZnVuY3Rpb24gZGltZW5zaW9uKF9kaW1lbnNpb24sIHZhbHVlKSB7XHJcbiAgICB2YXIgcHJpdkRpbWVuc2lvbiA9IF9kaW1lbnNpb24gKyAnXyc7XHJcblxyXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHRoaXNbcHJpdkRpbWVuc2lvbl0gfHwgMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodmFsdWUgPT09ICcnKSB7XHJcbiAgICAgIC8vIElmIGFuIGVtcHR5IHN0cmluZyBpcyBnaXZlbiwgcmVzZXQgdGhlIGRpbWVuc2lvbiB0byBiZSBhdXRvbWF0aWNcclxuICAgICAgdGhpc1twcml2RGltZW5zaW9uXSA9IHVuZGVmaW5lZDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBwYXJzZWRWYWwgPSBwYXJzZUZsb2F0KHZhbHVlKTtcclxuXHJcbiAgICAgIGlmIChpc05hTihwYXJzZWRWYWwpKSB7XHJcbiAgICAgICAgbG9nJDEuZXJyb3IoJ0ltcHJvcGVyIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIHN1cHBsaWVkIGZvciBmb3IgJyArIF9kaW1lbnNpb24pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpc1twcml2RGltZW5zaW9uXSA9IHBhcnNlZFZhbDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnVwZGF0ZVN0eWxlRWxfKCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQSBnZXR0ZXIvc2V0dGVyL3RvZ2dsZXIgZm9yIHRoZSB2anMtZmx1aWQgYGNsYXNzTmFtZWAgb24gdGhlIGBQbGF5ZXJgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbF1cclxuICAgKiAgICAgICAgLSBBIHZhbHVlIG9mIHRydWUgYWRkcyB0aGUgY2xhc3MuXHJcbiAgICogICAgICAgIC0gQSB2YWx1ZSBvZiBmYWxzZSByZW1vdmVzIHRoZSBjbGFzcy5cclxuICAgKiAgICAgICAgLSBObyB2YWx1ZSB3aWxsIHRvZ2dsZSB0aGUgZmx1aWQgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cclxuICAgKiAgICAgICAgIC0gVGhlIHZhbHVlIG9mIGZsdWlkIHdoZW4gZ2V0dGluZy5cclxuICAgKiAgICAgICAgIC0gYHVuZGVmaW5lZGAgd2hlbiBzZXR0aW5nLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5mbHVpZCA9IGZ1bmN0aW9uIGZsdWlkKGJvb2wpIHtcclxuICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5mbHVpZF87XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5mbHVpZF8gPSAhIWJvb2w7XHJcblxyXG4gICAgaWYgKGJvb2wpIHtcclxuICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWZsdWlkJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZmx1aWQnKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnVwZGF0ZVN0eWxlRWxfKCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0L1NldCB0aGUgYXNwZWN0IHJhdGlvXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3JhdGlvXVxyXG4gICAqICAgICAgICBBc3BlY3QgcmF0aW8gZm9yIHBsYXllclxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH1cclxuICAgKiAgICAgICAgIHJldHVybnMgdGhlIGN1cnJlbnQgYXNwZWN0IHJhdGlvIHdoZW4gZ2V0dGluZ1xyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBBIGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgUGxheWVyYCdzIGFzcGVjdCByYXRpby5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmF0aW9dXHJcbiAgICogICAgICAgIFRoZSB2YWx1ZSB0byBzZXQgdGhlIGBQbGF5ZXIncyBhc3BlY3QgcmF0aW8gdG8uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxyXG4gICAqICAgICAgICAgLSBUaGUgY3VycmVudCBhc3BlY3QgcmF0aW8gb2YgdGhlIGBQbGF5ZXJgIHdoZW4gZ2V0dGluZy5cclxuICAgKiAgICAgICAgIC0gdW5kZWZpbmVkIHdoZW4gc2V0dGluZ1xyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5hc3BlY3RSYXRpbyA9IGZ1bmN0aW9uIGFzcGVjdFJhdGlvKHJhdGlvKSB7XHJcbiAgICBpZiAocmF0aW8gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hc3BlY3RSYXRpb187XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgZm9yIHdpZHRoOmhlaWdodCBmb3JtYXRcclxuICAgIGlmICghL15cXGQrXFw6XFxkKyQvLnRlc3QocmF0aW8pKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW1wcm9wZXIgdmFsdWUgc3VwcGxpZWQgZm9yIGFzcGVjdCByYXRpby4gVGhlIGZvcm1hdCBzaG91bGQgYmUgd2lkdGg6aGVpZ2h0LCBmb3IgZXhhbXBsZSAxNjo5LicpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hc3BlY3RSYXRpb18gPSByYXRpbztcclxuXHJcbiAgICAvLyBXZSdyZSBhc3N1bWluZyBpZiB5b3Ugc2V0IGFuIGFzcGVjdCByYXRpbyB5b3Ugd2FudCBmbHVpZCBtb2RlLFxyXG4gICAgLy8gYmVjYXVzZSBpbiBmaXhlZCBtb2RlIHlvdSBjb3VsZCBjYWxjdWxhdGUgd2lkdGggYW5kIGhlaWdodCB5b3Vyc2VsZi5cclxuICAgIHRoaXMuZmx1aWQodHJ1ZSk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVTdHlsZUVsXygpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBzdHlsZXMgb2YgdGhlIGBQbGF5ZXJgIGVsZW1lbnQgKGhlaWdodCwgd2lkdGggYW5kIGFzcGVjdCByYXRpbykuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBsaXN0ZW5zIFRlY2gjbG9hZGVkbWV0YWRhdGFcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUudXBkYXRlU3R5bGVFbF8gPSBmdW5jdGlvbiB1cGRhdGVTdHlsZUVsXygpIHtcclxuICAgIGlmICh3aW5kb3dfMS5WSURFT0pTX05PX0RZTkFNSUNfU1RZTEUgPT09IHRydWUpIHtcclxuICAgICAgdmFyIF93aWR0aCA9IHR5cGVvZiB0aGlzLndpZHRoXyA9PT0gJ251bWJlcicgPyB0aGlzLndpZHRoXyA6IHRoaXMub3B0aW9uc18ud2lkdGg7XHJcbiAgICAgIHZhciBfaGVpZ2h0ID0gdHlwZW9mIHRoaXMuaGVpZ2h0XyA9PT0gJ251bWJlcicgPyB0aGlzLmhlaWdodF8gOiB0aGlzLm9wdGlvbnNfLmhlaWdodDtcclxuICAgICAgdmFyIHRlY2hFbCA9IHRoaXMudGVjaF8gJiYgdGhpcy50ZWNoXy5lbCgpO1xyXG5cclxuICAgICAgaWYgKHRlY2hFbCkge1xyXG4gICAgICAgIGlmIChfd2lkdGggPj0gMCkge1xyXG4gICAgICAgICAgdGVjaEVsLndpZHRoID0gX3dpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX2hlaWdodCA+PSAwKSB7XHJcbiAgICAgICAgICB0ZWNoRWwuaGVpZ2h0ID0gX2hlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgd2lkdGggPSB2b2lkIDA7XHJcbiAgICB2YXIgaGVpZ2h0ID0gdm9pZCAwO1xyXG4gICAgdmFyIGFzcGVjdFJhdGlvID0gdm9pZCAwO1xyXG4gICAgdmFyIGlkQ2xhc3MgPSB2b2lkIDA7XHJcblxyXG4gICAgLy8gVGhlIGFzcGVjdCByYXRpbyBpcyBlaXRoZXIgdXNlZCBkaXJlY3RseSBvciB0byBjYWxjdWxhdGUgd2lkdGggYW5kIGhlaWdodC5cclxuICAgIGlmICh0aGlzLmFzcGVjdFJhdGlvXyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYXNwZWN0UmF0aW9fICE9PSAnYXV0bycpIHtcclxuICAgICAgLy8gVXNlIGFueSBhc3BlY3RSYXRpbyB0aGF0J3MgYmVlbiBzcGVjaWZpY2FsbHkgc2V0XHJcbiAgICAgIGFzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpb187XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMudmlkZW9XaWR0aCgpID4gMCkge1xyXG4gICAgICAvLyBPdGhlcndpc2UgdHJ5IHRvIGdldCB0aGUgYXNwZWN0IHJhdGlvIGZyb20gdGhlIHZpZGVvIG1ldGFkYXRhXHJcbiAgICAgIGFzcGVjdFJhdGlvID0gdGhpcy52aWRlb1dpZHRoKCkgKyAnOicgKyB0aGlzLnZpZGVvSGVpZ2h0KCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBPciB1c2UgYSBkZWZhdWx0LiBUaGUgdmlkZW8gZWxlbWVudCdzIGlzIDI6MSwgYnV0IDE2OjkgaXMgbW9yZSBjb21tb24uXHJcbiAgICAgIGFzcGVjdFJhdGlvID0gJzE2OjknO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCB0aGUgcmF0aW8gYXMgYSBkZWNpbWFsIHdlIGNhbiB1c2UgdG8gY2FsY3VsYXRlIGRpbWVuc2lvbnNcclxuICAgIHZhciByYXRpb1BhcnRzID0gYXNwZWN0UmF0aW8uc3BsaXQoJzonKTtcclxuICAgIHZhciByYXRpb011bHRpcGxpZXIgPSByYXRpb1BhcnRzWzFdIC8gcmF0aW9QYXJ0c1swXTtcclxuXHJcbiAgICBpZiAodGhpcy53aWR0aF8gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBVc2UgYW55IHdpZHRoIHRoYXQncyBiZWVuIHNwZWNpZmljYWxseSBzZXRcclxuICAgICAgd2lkdGggPSB0aGlzLndpZHRoXztcclxuICAgIH0gZWxzZSBpZiAodGhpcy5oZWlnaHRfICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gT3IgY2FsdWxhdGUgdGhlIHdpZHRoIGZyb20gdGhlIGFzcGVjdCByYXRpbyBpZiBhIGhlaWdodCBoYXMgYmVlbiBzZXRcclxuICAgICAgd2lkdGggPSB0aGlzLmhlaWdodF8gLyByYXRpb011bHRpcGxpZXI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBPciB1c2UgdGhlIHZpZGVvJ3MgbWV0YWRhdGEsIG9yIHVzZSB0aGUgdmlkZW8gZWwncyBkZWZhdWx0IG9mIDMwMFxyXG4gICAgICB3aWR0aCA9IHRoaXMudmlkZW9XaWR0aCgpIHx8IDMwMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5oZWlnaHRfICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gVXNlIGFueSBoZWlnaHQgdGhhdCdzIGJlZW4gc3BlY2lmaWNhbGx5IHNldFxyXG4gICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodF87XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBPdGhlcndpc2UgY2FsY3VsYXRlIHRoZSBoZWlnaHQgZnJvbSB0aGUgcmF0aW8gYW5kIHRoZSB3aWR0aFxyXG4gICAgICBoZWlnaHQgPSB3aWR0aCAqIHJhdGlvTXVsdGlwbGllcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFbnN1cmUgdGhlIENTUyBjbGFzcyBpcyB2YWxpZCBieSBzdGFydGluZyB3aXRoIGFuIGFscGhhIGNoYXJhY3RlclxyXG4gICAgaWYgKC9eW15hLXpBLVpdLy50ZXN0KHRoaXMuaWQoKSkpIHtcclxuICAgICAgaWRDbGFzcyA9ICdkaW1lbnNpb25zLScgKyB0aGlzLmlkKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZENsYXNzID0gdGhpcy5pZCgpICsgJy1kaW1lbnNpb25zJztcclxuICAgIH1cclxuXHJcbiAgICAvLyBFbnN1cmUgdGhlIHJpZ2h0IGNsYXNzIGlzIHN0aWxsIG9uIHRoZSBwbGF5ZXIgZm9yIHRoZSBzdHlsZSBlbGVtZW50XHJcbiAgICB0aGlzLmFkZENsYXNzKGlkQ2xhc3MpO1xyXG5cclxuICAgIHNldFRleHRDb250ZW50KHRoaXMuc3R5bGVFbF8sICdcXG4gICAgICAuJyArIGlkQ2xhc3MgKyAnIHtcXG4gICAgICAgIHdpZHRoOiAnICsgd2lkdGggKyAncHg7XFxuICAgICAgICBoZWlnaHQ6ICcgKyBoZWlnaHQgKyAncHg7XFxuICAgICAgfVxcblxcbiAgICAgIC4nICsgaWRDbGFzcyArICcudmpzLWZsdWlkIHtcXG4gICAgICAgIHBhZGRpbmctdG9wOiAnICsgcmF0aW9NdWx0aXBsaWVyICogMTAwICsgJyU7XFxuICAgICAgfVxcbiAgICAnKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBMb2FkL0NyZWF0ZSBhbiBpbnN0YW5jZSBvZiBwbGF5YmFjayB7QGxpbmsgVGVjaH0gaW5jbHVkaW5nIGVsZW1lbnRcclxuICAgKiBhbmQgQVBJIG1ldGhvZHMuIFRoZW4gYXBwZW5kIHRoZSBgVGVjaGAgZWxlbWVudCBpbiBgUGxheWVyYCBhcyBhIGNoaWxkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRlY2hOYW1lXHJcbiAgICogICAgICAgIG5hbWUgb2YgdGhlIHBsYXliYWNrIHRlY2hub2xvZ3lcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VcclxuICAgKiAgICAgICAgdmlkZW8gc291cmNlXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5sb2FkVGVjaF8gPSBmdW5jdGlvbiBsb2FkVGVjaF8odGVjaE5hbWUsIHNvdXJjZSkge1xyXG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XHJcblxyXG4gICAgLy8gUGF1c2UgYW5kIHJlbW92ZSBjdXJyZW50IHBsYXliYWNrIHRlY2hub2xvZ3lcclxuICAgIGlmICh0aGlzLnRlY2hfKSB7XHJcbiAgICAgIHRoaXMudW5sb2FkVGVjaF8oKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdGl0bGVUZWNoTmFtZSA9IHRvVGl0bGVDYXNlKHRlY2hOYW1lKTtcclxuICAgIHZhciBjYW1lbFRlY2hOYW1lID0gdGVjaE5hbWUuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyB0ZWNoTmFtZS5zbGljZSgxKTtcclxuXHJcbiAgICAvLyBnZXQgcmlkIG9mIHRoZSBIVE1MNSB2aWRlbyB0YWcgYXMgc29vbiBhcyB3ZSBhcmUgdXNpbmcgYW5vdGhlciB0ZWNoXHJcbiAgICBpZiAodGl0bGVUZWNoTmFtZSAhPT0gJ0h0bWw1JyAmJiB0aGlzLnRhZykge1xyXG4gICAgICBUZWNoLmdldFRlY2goJ0h0bWw1JykuZGlzcG9zZU1lZGlhRWxlbWVudCh0aGlzLnRhZyk7XHJcbiAgICAgIHRoaXMudGFnLnBsYXllciA9IG51bGw7XHJcbiAgICAgIHRoaXMudGFnID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnRlY2hOYW1lXyA9IHRpdGxlVGVjaE5hbWU7XHJcblxyXG4gICAgLy8gVHVybiBvZmYgQVBJIGFjY2VzcyBiZWNhdXNlIHdlJ3JlIGxvYWRpbmcgYSBuZXcgdGVjaCB0aGF0IG1pZ2h0IGxvYWQgYXN5bmNocm9ub3VzbHlcclxuICAgIHRoaXMuaXNSZWFkeV8gPSBmYWxzZTtcclxuXHJcbiAgICAvLyBHcmFiIHRlY2gtc3BlY2lmaWMgb3B0aW9ucyBmcm9tIHBsYXllciBvcHRpb25zIGFuZCBhZGQgc291cmNlIGFuZCBwYXJlbnQgZWxlbWVudCB0byB1c2UuXHJcbiAgICB2YXIgdGVjaE9wdGlvbnMgPSB7XHJcbiAgICAgIHNvdXJjZTogc291cmNlLFxyXG4gICAgICAnbmF0aXZlQ29udHJvbHNGb3JUb3VjaCc6IHRoaXMub3B0aW9uc18ubmF0aXZlQ29udHJvbHNGb3JUb3VjaCxcclxuICAgICAgJ3BsYXllcklkJzogdGhpcy5pZCgpLFxyXG4gICAgICAndGVjaElkJzogdGhpcy5pZCgpICsgJ18nICsgdGl0bGVUZWNoTmFtZSArICdfYXBpJyxcclxuICAgICAgJ2F1dG9wbGF5JzogdGhpcy5vcHRpb25zXy5hdXRvcGxheSxcclxuICAgICAgJ3BsYXlzaW5saW5lJzogdGhpcy5vcHRpb25zXy5wbGF5c2lubGluZSxcclxuICAgICAgJ3ByZWxvYWQnOiB0aGlzLm9wdGlvbnNfLnByZWxvYWQsXHJcbiAgICAgICdsb29wJzogdGhpcy5vcHRpb25zXy5sb29wLFxyXG4gICAgICAnbXV0ZWQnOiB0aGlzLm9wdGlvbnNfLm11dGVkLFxyXG4gICAgICAncG9zdGVyJzogdGhpcy5wb3N0ZXIoKSxcclxuICAgICAgJ2xhbmd1YWdlJzogdGhpcy5sYW5ndWFnZSgpLFxyXG4gICAgICAncGxheWVyRWxJbmdlc3QnOiB0aGlzLnBsYXllckVsSW5nZXN0XyB8fCBmYWxzZSxcclxuICAgICAgJ3Z0dC5qcyc6IHRoaXMub3B0aW9uc19bJ3Z0dC5qcyddXHJcbiAgICB9O1xyXG5cclxuICAgIEFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XHJcbiAgICAgIHZhciBwcm9wcyA9IEFMTFtuYW1lJCQxXTtcclxuXHJcbiAgICAgIHRlY2hPcHRpb25zW3Byb3BzLmdldHRlck5hbWVdID0gX3RoaXMyW3Byb3BzLnByaXZhdGVOYW1lXTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFzc2lnbih0ZWNoT3B0aW9ucywgdGhpcy5vcHRpb25zX1t0aXRsZVRlY2hOYW1lXSk7XHJcbiAgICBhc3NpZ24odGVjaE9wdGlvbnMsIHRoaXMub3B0aW9uc19bY2FtZWxUZWNoTmFtZV0pO1xyXG4gICAgYXNzaWduKHRlY2hPcHRpb25zLCB0aGlzLm9wdGlvbnNfW3RlY2hOYW1lLnRvTG93ZXJDYXNlKCldKTtcclxuXHJcbiAgICBpZiAodGhpcy50YWcpIHtcclxuICAgICAgdGVjaE9wdGlvbnMudGFnID0gdGhpcy50YWc7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNvdXJjZSAmJiBzb3VyY2Uuc3JjID09PSB0aGlzLmNhY2hlXy5zcmMgJiYgdGhpcy5jYWNoZV8uY3VycmVudFRpbWUgPiAwKSB7XHJcbiAgICAgIHRlY2hPcHRpb25zLnN0YXJ0VGltZSA9IHRoaXMuY2FjaGVfLmN1cnJlbnRUaW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEluaXRpYWxpemUgdGVjaCBpbnN0YW5jZVxyXG4gICAgdmFyIFRlY2hDbGFzcyA9IFRlY2guZ2V0VGVjaCh0ZWNoTmFtZSk7XHJcblxyXG4gICAgaWYgKCFUZWNoQ2xhc3MpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBUZWNoIG5hbWVkIFxcJycgKyB0aXRsZVRlY2hOYW1lICsgJ1xcJyBleGlzdHMhIFxcJycgKyB0aXRsZVRlY2hOYW1lICsgJ1xcJyBzaG91bGQgYmUgcmVnaXN0ZXJlZCB1c2luZyB2aWRlb2pzLnJlZ2lzdGVyVGVjaCgpXFwnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy50ZWNoXyA9IG5ldyBUZWNoQ2xhc3ModGVjaE9wdGlvbnMpO1xyXG5cclxuICAgIC8vIHBsYXllci50cmlnZ2VyUmVhZHkgaXMgYWx3YXlzIGFzeW5jLCBzbyBkb24ndCBuZWVkIHRoaXMgdG8gYmUgYXN5bmNcclxuICAgIHRoaXMudGVjaF8ucmVhZHkoYmluZCh0aGlzLCB0aGlzLmhhbmRsZVRlY2hSZWFkeV8pLCB0cnVlKTtcclxuXHJcbiAgICB0ZXh0VHJhY2tDb252ZXJ0ZXIuanNvblRvVGV4dFRyYWNrcyh0aGlzLnRleHRUcmFja3NKc29uXyB8fCBbXSwgdGhpcy50ZWNoXyk7XHJcblxyXG4gICAgLy8gTGlzdGVuIHRvIGFsbCBIVE1MNS1kZWZpbmVkIGV2ZW50cyBhbmQgdHJpZ2dlciB0aGVtIG9uIHRoZSBwbGF5ZXJcclxuICAgIFRFQ0hfRVZFTlRTX1JFVFJJR0dFUi5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICBfdGhpczIub24oX3RoaXMyLnRlY2hfLCBldmVudCwgX3RoaXMyWydoYW5kbGVUZWNoJyArIHRvVGl0bGVDYXNlKGV2ZW50KSArICdfJ10pO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdsb2Fkc3RhcnQnLCB0aGlzLmhhbmRsZVRlY2hMb2FkU3RhcnRfKTtcclxuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3dhaXRpbmcnLCB0aGlzLmhhbmRsZVRlY2hXYWl0aW5nXyk7XHJcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdjYW5wbGF5JywgdGhpcy5oYW5kbGVUZWNoQ2FuUGxheV8pO1xyXG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAnY2FucGxheXRocm91Z2gnLCB0aGlzLmhhbmRsZVRlY2hDYW5QbGF5VGhyb3VnaF8pO1xyXG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAncGxheWluZycsIHRoaXMuaGFuZGxlVGVjaFBsYXlpbmdfKTtcclxuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2VuZGVkJywgdGhpcy5oYW5kbGVUZWNoRW5kZWRfKTtcclxuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3NlZWtpbmcnLCB0aGlzLmhhbmRsZVRlY2hTZWVraW5nXyk7XHJcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdzZWVrZWQnLCB0aGlzLmhhbmRsZVRlY2hTZWVrZWRfKTtcclxuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3BsYXknLCB0aGlzLmhhbmRsZVRlY2hQbGF5Xyk7XHJcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdmaXJzdHBsYXknLCB0aGlzLmhhbmRsZVRlY2hGaXJzdFBsYXlfKTtcclxuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3BhdXNlJywgdGhpcy5oYW5kbGVUZWNoUGF1c2VfKTtcclxuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2R1cmF0aW9uY2hhbmdlJywgdGhpcy5oYW5kbGVUZWNoRHVyYXRpb25DaGFuZ2VfKTtcclxuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ2Z1bGxzY3JlZW5jaGFuZ2UnLCB0aGlzLmhhbmRsZVRlY2hGdWxsc2NyZWVuQ2hhbmdlXyk7XHJcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdlcnJvcicsIHRoaXMuaGFuZGxlVGVjaEVycm9yXyk7XHJcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdsb2FkZWRtZXRhZGF0YScsIHRoaXMudXBkYXRlU3R5bGVFbF8pO1xyXG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAncG9zdGVyY2hhbmdlJywgdGhpcy5oYW5kbGVUZWNoUG9zdGVyQ2hhbmdlXyk7XHJcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0ZXh0ZGF0YScsIHRoaXMuaGFuZGxlVGVjaFRleHREYXRhXyk7XHJcblxyXG4gICAgdGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKHRoaXMudGVjaEdldF8oJ2NvbnRyb2xzJykpO1xyXG5cclxuICAgIGlmICh0aGlzLmNvbnRyb2xzKCkgJiYgIXRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XHJcbiAgICAgIHRoaXMuYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCB0aGUgdGVjaCBlbGVtZW50IGluIHRoZSBET00gaWYgaXQgd2FzIG5vdCBhbHJlYWR5IHRoZXJlXHJcbiAgICAvLyBNYWtlIHN1cmUgdG8gbm90IGluc2VydCB0aGUgb3JpZ2luYWwgdmlkZW8gZWxlbWVudCBpZiB1c2luZyBIdG1sNVxyXG4gICAgaWYgKHRoaXMudGVjaF8uZWwoKS5wYXJlbnROb2RlICE9PSB0aGlzLmVsKCkgJiYgKHRpdGxlVGVjaE5hbWUgIT09ICdIdG1sNScgfHwgIXRoaXMudGFnKSkge1xyXG4gICAgICBwcmVwZW5kVG8odGhpcy50ZWNoXy5lbCgpLCB0aGlzLmVsKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCByaWQgb2YgdGhlIG9yaWdpbmFsIHZpZGVvIHRhZyByZWZlcmVuY2UgYWZ0ZXIgdGhlIGZpcnN0IHRlY2ggaXMgbG9hZGVkXHJcbiAgICBpZiAodGhpcy50YWcpIHtcclxuICAgICAgdGhpcy50YWcucGxheWVyID0gbnVsbDtcclxuICAgICAgdGhpcy50YWcgPSBudWxsO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFVubG9hZCBhbmQgZGlzcG9zZSBvZiB0aGUgY3VycmVudCBwbGF5YmFjayB7QGxpbmsgVGVjaH0uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS51bmxvYWRUZWNoXyA9IGZ1bmN0aW9uIHVubG9hZFRlY2hfKCkge1xyXG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XHJcblxyXG4gICAgLy8gU2F2ZSB0aGUgY3VycmVudCB0ZXh0IHRyYWNrcyBzbyB0aGF0IHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0ZXh0IHRyYWNrcyB3aXRoIHRoZSBuZXh0IHRlY2hcclxuICAgIEFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XHJcbiAgICAgIHZhciBwcm9wcyA9IEFMTFtuYW1lJCQxXTtcclxuXHJcbiAgICAgIF90aGlzM1twcm9wcy5wcml2YXRlTmFtZV0gPSBfdGhpczNbcHJvcHMuZ2V0dGVyTmFtZV0oKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy50ZXh0VHJhY2tzSnNvbl8gPSB0ZXh0VHJhY2tDb252ZXJ0ZXIudGV4dFRyYWNrc1RvSnNvbih0aGlzLnRlY2hfKTtcclxuXHJcbiAgICB0aGlzLmlzUmVhZHlfID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy50ZWNoXy5kaXNwb3NlKCk7XHJcblxyXG4gICAgdGhpcy50ZWNoXyA9IGZhbHNlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCB7QGxpbmsgVGVjaH0uXHJcbiAgICogSXQgd2lsbCBwcmludCBhIHdhcm5pbmcgYnkgZGVmYXVsdCBhYm91dCB0aGUgZGFuZ2VyIG9mIHVzaW5nIHRoZSB0ZWNoIGRpcmVjdGx5XHJcbiAgICogYnV0IGFueSBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCBpbiB3aWxsIHNpbGVuY2UgdGhlIHdhcm5pbmcuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyp9IFtzYWZldHldXHJcbiAgICogICAgICAgIEFueXRoaW5nIHBhc3NlZCBpbiB0byBzaWxlbmNlIHRoZSB3YXJuaW5nXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtUZWNofVxyXG4gICAqICAgICAgICAgVGhlIFRlY2hcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUudGVjaCA9IGZ1bmN0aW9uIHRlY2goc2FmZXR5KSB7XHJcbiAgICBpZiAoc2FmZXR5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgbG9nJDEud2Fybih0c21sKF90ZW1wbGF0ZU9iamVjdCQxKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMudGVjaF87XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHVwIGNsaWNrIGFuZCB0b3VjaCBsaXN0ZW5lcnMgZm9yIHRoZSBwbGF5YmFjayBlbGVtZW50XHJcbiAgICpcclxuICAgKiAtIE9uIGRlc2t0b3BzOiBhIGNsaWNrIG9uIHRoZSB2aWRlbyBpdHNlbGYgd2lsbCB0b2dnbGUgcGxheWJhY2tcclxuICAgKiAtIE9uIG1vYmlsZSBkZXZpY2VzOiBhIGNsaWNrIG9uIHRoZSB2aWRlbyB0b2dnbGVzIGNvbnRyb2xzXHJcbiAgICogICB3aGljaCBpcyBkb25lIGJ5IHRvZ2dsaW5nIHRoZSB1c2VyIHN0YXRlIGJldHdlZW4gYWN0aXZlIGFuZFxyXG4gICAqICAgaW5hY3RpdmVcclxuICAgKiAtIEEgdGFwIGNhbiBzaWduYWwgdGhhdCBhIHVzZXIgaGFzIGJlY29tZSBhY3RpdmUgb3IgaGFzIGJlY29tZSBpbmFjdGl2ZVxyXG4gICAqICAgZS5nLiBhIHF1aWNrIHRhcCBvbiBhbiBpUGhvbmUgbW92aWUgc2hvdWxkIHJldmVhbCB0aGUgY29udHJvbHMuIEFub3RoZXJcclxuICAgKiAgIHF1aWNrIHRhcCBzaG91bGQgaGlkZSB0aGVtIGFnYWluIChzaWduYWxpbmcgdGhlIHVzZXIgaXMgaW4gYW4gaW5hY3RpdmVcclxuICAgKiAgIHZpZXdpbmcgc3RhdGUpXHJcbiAgICogLSBJbiBhZGRpdGlvbiB0byB0aGlzLCB3ZSBzdGlsbCB3YW50IHRoZSB1c2VyIHRvIGJlIGNvbnNpZGVyZWQgaW5hY3RpdmUgYWZ0ZXJcclxuICAgKiAgIGEgZmV3IHNlY29uZHMgb2YgaW5hY3Rpdml0eS5cclxuICAgKlxyXG4gICAqID4gTm90ZTogdGhlIG9ubHkgcGFydCBvZiBpT1MgaW50ZXJhY3Rpb24gd2UgY2FuJ3QgbWltaWMgd2l0aCB0aGlzIHNldHVwXHJcbiAgICogaXMgYSB0b3VjaCBhbmQgaG9sZCBvbiB0aGUgdmlkZW8gZWxlbWVudCBjb3VudGluZyBhcyBhY3Rpdml0eSBpbiBvcmRlciB0b1xyXG4gICAqIGtlZXAgdGhlIGNvbnRyb2xzIHNob3dpbmcsIGJ1dCB0aGF0IHNob3VsZG4ndCBiZSBhbiBpc3N1ZS4gQSB0b3VjaCBhbmQgaG9sZFxyXG4gICAqIG9uIGFueSBjb250cm9scyB3aWxsIHN0aWxsIGtlZXAgdGhlIHVzZXIgYWN0aXZlXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5hZGRUZWNoQ29udHJvbHNMaXN0ZW5lcnNfID0gZnVuY3Rpb24gYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB0byByZW1vdmUgYWxsIHRoZSBwcmV2aW91cyBsaXN0ZW5lcnMgaW4gY2FzZSB3ZSBhcmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxyXG4gICAgdGhpcy5yZW1vdmVUZWNoQ29udHJvbHNMaXN0ZW5lcnNfKCk7XHJcblxyXG4gICAgLy8gU29tZSBicm93c2VycyAoQ2hyb21lICYgSUUpIGRvbid0IHRyaWdnZXIgYSBjbGljayBvbiBhIGZsYXNoIHN3ZiwgYnV0IGRvXHJcbiAgICAvLyB0cmlnZ2VyIG1vdXNlZG93bi91cC5cclxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQ0NDU2Mi9qYXZhc2NyaXB0LW9uY2xpY2stZXZlbnQtb3Zlci1mbGFzaC1vYmplY3RcclxuICAgIC8vIEFueSB0b3VjaCBldmVudHMgYXJlIHNldCB0byBibG9jayB0aGUgbW91c2Vkb3duIGV2ZW50IGZyb20gaGFwcGVuaW5nXHJcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZVRlY2hDbGlja18pO1xyXG5cclxuICAgIC8vIElmIHRoZSBjb250cm9scyB3ZXJlIGhpZGRlbiB3ZSBkb24ndCB3YW50IHRoYXQgdG8gY2hhbmdlIHdpdGhvdXQgYSB0YXAgZXZlbnRcclxuICAgIC8vIHNvIHdlJ2xsIGNoZWNrIGlmIHRoZSBjb250cm9scyB3ZXJlIGFscmVhZHkgc2hvd2luZyBiZWZvcmUgcmVwb3J0aW5nIHVzZXJcclxuICAgIC8vIGFjdGl2aXR5XHJcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUZWNoVG91Y2hTdGFydF8pO1xyXG4gICAgdGhpcy5vbih0aGlzLnRlY2hfLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUZWNoVG91Y2hNb3ZlXyk7XHJcbiAgICB0aGlzLm9uKHRoaXMudGVjaF8sICd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVGVjaFRvdWNoRW5kXyk7XHJcblxyXG4gICAgLy8gVGhlIHRhcCBsaXN0ZW5lciBuZWVkcyB0byBjb21lIGFmdGVyIHRoZSB0b3VjaGVuZCBsaXN0ZW5lciBiZWNhdXNlIHRoZSB0YXBcclxuICAgIC8vIGxpc3RlbmVyIGNhbmNlbHMgb3V0IGFueSByZXBvcnRlZFVzZXJBY3Rpdml0eSB3aGVuIHNldHRpbmcgdXNlckFjdGl2ZShmYWxzZSlcclxuICAgIHRoaXMub24odGhpcy50ZWNoXywgJ3RhcCcsIHRoaXMuaGFuZGxlVGVjaFRhcF8pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIHVzZWQgZm9yIGNsaWNrIGFuZCB0YXAgY29udHJvbHMuIFRoaXMgaXMgbmVlZGVkIGZvclxyXG4gICAqIHRvZ2dsaW5nIHRvIGNvbnRyb2xzIGRpc2FibGVkLCB3aGVyZSBhIHRhcC90b3VjaCBzaG91bGQgZG8gbm90aGluZy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLnJlbW92ZVRlY2hDb250cm9sc0xpc3RlbmVyc18gPSBmdW5jdGlvbiByZW1vdmVUZWNoQ29udHJvbHNMaXN0ZW5lcnNfKCkge1xyXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBqdXN0IHVzZSBgdGhpcy5vZmYoKWAgYmVjYXVzZSB0aGVyZSBtaWdodCBiZSBvdGhlciBuZWVkZWRcclxuICAgIC8vIGxpc3RlbmVycyBhZGRlZCBieSB0ZWNocyB0aGF0IGV4dGVuZCB0aGlzLlxyXG4gICAgdGhpcy5vZmYodGhpcy50ZWNoXywgJ3RhcCcsIHRoaXMuaGFuZGxlVGVjaFRhcF8pO1xyXG4gICAgdGhpcy5vZmYodGhpcy50ZWNoXywgJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaFN0YXJ0Xyk7XHJcbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUZWNoVG91Y2hNb3ZlXyk7XHJcbiAgICB0aGlzLm9mZih0aGlzLnRlY2hfLCAndG91Y2hlbmQnLCB0aGlzLmhhbmRsZVRlY2hUb3VjaEVuZF8pO1xyXG4gICAgdGhpcy5vZmYodGhpcy50ZWNoXywgJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlVGVjaENsaWNrXyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUGxheWVyIHdhaXRzIGZvciB0aGUgdGVjaCB0byBiZSByZWFkeVxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFJlYWR5XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hSZWFkeV8oKSB7XHJcbiAgICB0aGlzLnRyaWdnZXJSZWFkeSgpO1xyXG5cclxuICAgIC8vIEtlZXAgdGhlIHNhbWUgdm9sdW1lIGFzIGJlZm9yZVxyXG4gICAgaWYgKHRoaXMuY2FjaGVfLnZvbHVtZSkge1xyXG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0Vm9sdW1lJywgdGhpcy5jYWNoZV8udm9sdW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBMb29rIGlmIHRoZSB0ZWNoIGZvdW5kIGEgaGlnaGVyIHJlc29sdXRpb24gcG9zdGVyIHdoaWxlIGxvYWRpbmdcclxuICAgIHRoaXMuaGFuZGxlVGVjaFBvc3RlckNoYW5nZV8oKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgdGhlIGR1cmF0aW9uIGlmIGF2YWlsYWJsZVxyXG4gICAgdGhpcy5oYW5kbGVUZWNoRHVyYXRpb25DaGFuZ2VfKCk7XHJcblxyXG4gICAgLy8gQ2hyb21lIGFuZCBTYWZhcmkgYm90aCBoYXZlIGlzc3VlcyB3aXRoIGF1dG9wbGF5LlxyXG4gICAgLy8gSW4gU2FmYXJpICg1LjEuMSksIHdoZW4gd2UgbW92ZSB0aGUgdmlkZW8gZWxlbWVudCBpbnRvIHRoZSBjb250YWluZXIgZGl2LCBhdXRvcGxheSBkb2Vzbid0IHdvcmsuXHJcbiAgICAvLyBJbiBDaHJvbWUgKDE1KSwgaWYgeW91IGhhdmUgYXV0b3BsYXkgKyBhIHBvc3RlciArIG5vIGNvbnRyb2xzLCB0aGUgdmlkZW8gZ2V0cyBoaWRkZW4gKGJ1dCBhdWRpbyBwbGF5cylcclxuICAgIC8vIFRoaXMgZml4ZXMgYm90aCBpc3N1ZXMuIE5lZWQgdG8gd2FpdCBmb3IgQVBJLCBzbyBpdCB1cGRhdGVzIGRpc3BsYXlzIGNvcnJlY3RseVxyXG4gICAgaWYgKCh0aGlzLnNyYygpIHx8IHRoaXMuY3VycmVudFNyYygpKSAmJiB0aGlzLnRhZyAmJiB0aGlzLm9wdGlvbnNfLmF1dG9wbGF5ICYmIHRoaXMucGF1c2VkKCkpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBDaHJvbWUgRml4LiBGaXhlZCBpbiBDaHJvbWUgdjE2LlxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnRhZy5wb3N0ZXI7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBsb2ckMSgnZGVsZXRpbmcgdGFnLnBvc3RlciB0aHJvd3MgaW4gc29tZSBicm93c2VycycsIGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlnZ2VyIHRoZSBgbG9hZHN0YXJ0YCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS4gVGhpc1xyXG4gICAqIGZ1bmN0aW9uIHdpbGwgYWxzbyB0cmlnZ2VyIHtAbGluayBQbGF5ZXIjZmlyc3RwbGF5fSBpZiBpdCBpcyB0aGUgZmlyc3QgbG9hZHN0YXJ0XHJcbiAgICogZm9yIGEgdmlkZW8uXHJcbiAgICpcclxuICAgKiBAZmlyZXMgUGxheWVyI2xvYWRzdGFydFxyXG4gICAqIEBmaXJlcyBQbGF5ZXIjZmlyc3RwbGF5XHJcbiAgICogQGxpc3RlbnMgVGVjaCNsb2Fkc3RhcnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoTG9hZFN0YXJ0XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hMb2FkU3RhcnRfKCkge1xyXG4gICAgLy8gVE9ETzogVXBkYXRlIHRvIHVzZSBgZW1wdGllZGAgZXZlbnQgaW5zdGVhZC4gU2VlICMxMjc3LlxyXG5cclxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xyXG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXNlZWtpbmcnKTtcclxuXHJcbiAgICAvLyByZXNldCB0aGUgZXJyb3Igc3RhdGVcclxuICAgIHRoaXMuZXJyb3IobnVsbCk7XHJcblxyXG4gICAgLy8gSWYgaXQncyBhbHJlYWR5IHBsYXlpbmcgd2Ugd2FudCB0byB0cmlnZ2VyIGEgZmlyc3RwbGF5IGV2ZW50IG5vdy5cclxuICAgIC8vIFRoZSBmaXJzdHBsYXkgZXZlbnQgcmVsaWVzIG9uIGJvdGggdGhlIHBsYXkgYW5kIGxvYWRzdGFydCBldmVudHNcclxuICAgIC8vIHdoaWNoIGNhbiBoYXBwZW4gaW4gYW55IG9yZGVyIGZvciBhIG5ldyBzb3VyY2VcclxuICAgIGlmICghdGhpcy5wYXVzZWQoKSkge1xyXG4gICAgICAvKipcclxuICAgICAgICogRmlyZWQgd2hlbiB0aGUgdXNlciBhZ2VudCBiZWdpbnMgbG9va2luZyBmb3IgbWVkaWEgZGF0YVxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI2xvYWRzdGFydFxyXG4gICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAgICAgICAqL1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ2xvYWRzdGFydCcpO1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ2ZpcnN0cGxheScpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gcmVzZXQgdGhlIGhhc1N0YXJ0ZWQgc3RhdGVcclxuICAgICAgdGhpcy5oYXNTdGFydGVkKGZhbHNlKTtcclxuICAgICAgdGhpcy50cmlnZ2VyKCdsb2Fkc3RhcnQnKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBZGQvcmVtb3ZlIHRoZSB2anMtaGFzLXN0YXJ0ZWQgY2xhc3NcclxuICAgKlxyXG4gICAqIEBmaXJlcyBQbGF5ZXIjZmlyc3RwbGF5XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1N0YXJ0ZWRcclxuICAgKiAgICAgICAgLSB0cnVlOiBhZGRzIHRoZSBjbGFzc1xyXG4gICAqICAgICAgICAtIGZhbHNlOiByZW1vdmUgdGhlIGNsYXNzXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqICAgICAgICAgdGhlIGJvb2xlYW4gdmFsdWUgb2YgaGFzU3RhcnRlZFxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5oYXNTdGFydGVkID0gZnVuY3Rpb24gaGFzU3RhcnRlZChfaGFzU3RhcnRlZCkge1xyXG4gICAgaWYgKF9oYXNTdGFydGVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gb25seSB1cGRhdGUgaWYgdGhpcyBpcyBhIG5ldyB2YWx1ZVxyXG4gICAgICBpZiAodGhpcy5oYXNTdGFydGVkXyAhPT0gX2hhc1N0YXJ0ZWQpIHtcclxuICAgICAgICB0aGlzLmhhc1N0YXJ0ZWRfID0gX2hhc1N0YXJ0ZWQ7XHJcbiAgICAgICAgaWYgKF9oYXNTdGFydGVkKSB7XHJcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtaGFzLXN0YXJ0ZWQnKTtcclxuICAgICAgICAgIC8vIHRyaWdnZXIgdGhlIGZpcnN0cGxheSBldmVudCBpZiB0aGlzIG5ld2x5IGhhcyBwbGF5ZWRcclxuICAgICAgICAgIHRoaXMudHJpZ2dlcignZmlyc3RwbGF5Jyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1oYXMtc3RhcnRlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gISF0aGlzLmhhc1N0YXJ0ZWRfO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBtZWRpYSBiZWdpbnMgb3IgcmVzdW1lcyBwbGF5YmFja1xyXG4gICAqXHJcbiAgICogQHNlZSBbU3BlY117QGxpbmsgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS1tZWRpYS1wbGF5fVxyXG4gICAqIEBmaXJlcyBQbGF5ZXIjcGxheVxyXG4gICAqIEBsaXN0ZW5zIFRlY2gjcGxheVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hQbGF5XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hQbGF5XygpIHtcclxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1lbmRlZCcpO1xyXG4gICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLXBhdXNlZCcpO1xyXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLXBsYXlpbmcnKTtcclxuXHJcbiAgICAvLyBoaWRlIHRoZSBwb3N0ZXIgd2hlbiB0aGUgdXNlciBoaXRzIHBsYXlcclxuICAgIHRoaXMuaGFzU3RhcnRlZCh0cnVlKTtcclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlcmVkIHdoZW5ldmVyIGFuIHtAbGluayBUZWNoI3BsYXl9IGV2ZW50IGhhcHBlbnMuIEluZGljYXRlcyB0aGF0XHJcbiAgICAgKiBwbGF5YmFjayBoYXMgc3RhcnRlZCBvciByZXN1bWVkLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudCBQbGF5ZXIjcGxheVxyXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRyaWdnZXIoJ3BsYXknKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWdnZXIgdGhlIGB3YWl0aW5nYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cclxuICAgKlxyXG4gICAqIEBmaXJlcyBQbGF5ZXIjd2FpdGluZ1xyXG4gICAqIEBsaXN0ZW5zIFRlY2gjd2FpdGluZ1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hXYWl0aW5nXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hXYWl0aW5nXygpIHtcclxuICAgIHZhciBfdGhpczQgPSB0aGlzO1xyXG5cclxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XHJcbiAgICAvKipcclxuICAgICAqIEEgcmVhZHlTdGF0ZSBjaGFuZ2Ugb24gdGhlIERPTSBlbGVtZW50IGhhcyBjYXVzZWQgcGxheWJhY2sgdG8gc3RvcC5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnQgUGxheWVyI3dhaXRpbmdcclxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy50cmlnZ2VyKCd3YWl0aW5nJyk7XHJcbiAgICB0aGlzLm9uZSgndGltZXVwZGF0ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF90aGlzNC5yZW1vdmVDbGFzcygndmpzLXdhaXRpbmcnKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHJpZ2dlciB0aGUgYGNhbnBsYXlgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxyXG4gICAqID4gTm90ZTogVGhpcyBpcyBub3QgY29uc2lzdGVudCBiZXR3ZWVuIGJyb3dzZXJzLiBTZWUgIzEzNTFcclxuICAgKlxyXG4gICAqIEBmaXJlcyBQbGF5ZXIjY2FucGxheVxyXG4gICAqIEBsaXN0ZW5zIFRlY2gjY2FucGxheVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hDYW5QbGF5XyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hDYW5QbGF5XygpIHtcclxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtZWRpYSBoYXMgYSByZWFkeVN0YXRlIG9mIEhBVkVfRlVUVVJFX0RBVEEgb3IgZ3JlYXRlci5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnQgUGxheWVyI2NhbnBsYXlcclxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy50cmlnZ2VyKCdjYW5wbGF5Jyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlnZ2VyIHRoZSBgY2FucGxheXRocm91Z2hgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxyXG4gICAqXHJcbiAgICogQGZpcmVzIFBsYXllciNjYW5wbGF5dGhyb3VnaFxyXG4gICAqIEBsaXN0ZW5zIFRlY2gjY2FucGxheXRocm91Z2hcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoQ2FuUGxheVRocm91Z2hfID0gZnVuY3Rpb24gaGFuZGxlVGVjaENhblBsYXlUaHJvdWdoXygpIHtcclxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtZWRpYSBoYXMgYSByZWFkeVN0YXRlIG9mIEhBVkVfRU5PVUdIX0RBVEEgb3IgZ3JlYXRlci4gVGhpcyBtZWFucyB0aGF0IHRoZVxyXG4gICAgICogZW50aXJlIG1lZGlhIGZpbGUgY2FuIGJlIHBsYXllZCB3aXRob3V0IGJ1ZmZlcmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnQgUGxheWVyI2NhbnBsYXl0aHJvdWdoXHJcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudHJpZ2dlcignY2FucGxheXRocm91Z2gnKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWdnZXIgdGhlIGBwbGF5aW5nYCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cclxuICAgKlxyXG4gICAqIEBmaXJlcyBQbGF5ZXIjcGxheWluZ1xyXG4gICAqIEBsaXN0ZW5zIFRlY2gjcGxheWluZ1xyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hQbGF5aW5nXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hQbGF5aW5nXygpIHtcclxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy13YWl0aW5nJyk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtZWRpYSBpcyBubyBsb25nZXIgYmxvY2tlZCBmcm9tIHBsYXliYWNrLCBhbmQgaGFzIHN0YXJ0ZWQgcGxheWluZy5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnQgUGxheWVyI3BsYXlpbmdcclxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy50cmlnZ2VyKCdwbGF5aW5nJyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlnZ2VyIHRoZSBgc2Vla2luZ2AgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXHJcbiAgICpcclxuICAgKiBAZmlyZXMgUGxheWVyI3NlZWtpbmdcclxuICAgKiBAbGlzdGVucyBUZWNoI3NlZWtpbmdcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoU2Vla2luZ18gPSBmdW5jdGlvbiBoYW5kbGVUZWNoU2Vla2luZ18oKSB7XHJcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtc2Vla2luZycpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuZXZlciB0aGUgcGxheWVyIGlzIGp1bXBpbmcgdG8gYSBuZXcgdGltZVxyXG4gICAgICpcclxuICAgICAqIEBldmVudCBQbGF5ZXIjc2Vla2luZ1xyXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRyaWdnZXIoJ3NlZWtpbmcnKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWdnZXIgdGhlIGBzZWVrZWRgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxyXG4gICAqXHJcbiAgICogQGZpcmVzIFBsYXllciNzZWVrZWRcclxuICAgKiBAbGlzdGVucyBUZWNoI3NlZWtlZFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hTZWVrZWRfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFNlZWtlZF8oKSB7XHJcbiAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2Vla2luZycpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBwbGF5ZXIgaGFzIGZpbmlzaGVkIGp1bXBpbmcgdG8gYSBuZXcgdGltZVxyXG4gICAgICpcclxuICAgICAqIEBldmVudCBQbGF5ZXIjc2Vla2VkXHJcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudHJpZ2dlcignc2Vla2VkJyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlnZ2VyIHRoZSBgZmlyc3RwbGF5YCBldmVudCB0aGF0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHtAbGluayBUZWNofS5cclxuICAgKlxyXG4gICAqIEBmaXJlcyBQbGF5ZXIjZmlyc3RwbGF5XHJcbiAgICogQGxpc3RlbnMgVGVjaCNmaXJzdHBsYXlcclxuICAgKiBAZGVwcmVjYXRlZCBBcyBvZiA2LjAgZmlyc3RwbGF5IGV2ZW50IGlzIGRlcHJlY2F0ZWQuXHJcbiAgICogQGRlcHJlY2F0ZWQgQXMgb2YgNi4wIHBhc3NpbmcgdGhlIGBzdGFydHRpbWVgIG9wdGlvbiB0byB0aGUgcGxheWVyIGFuZCB0aGUgZmlyc3RwbGF5IGV2ZW50IGFyZSBkZXByZWNhdGVkLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hGaXJzdFBsYXlfID0gZnVuY3Rpb24gaGFuZGxlVGVjaEZpcnN0UGxheV8oKSB7XHJcbiAgICAvLyBJZiB0aGUgZmlyc3Qgc3RhcnR0aW1lIGF0dHJpYnV0ZSBpcyBzcGVjaWZpZWRcclxuICAgIC8vIHRoZW4gd2Ugd2lsbCBzdGFydCBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IGluIHNlY29uZHNcclxuICAgIGlmICh0aGlzLm9wdGlvbnNfLnN0YXJ0dGltZSkge1xyXG4gICAgICBsb2ckMS53YXJuKCdQYXNzaW5nIHRoZSBgc3RhcnR0aW1lYCBvcHRpb24gdG8gdGhlIHBsYXllciB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gNi4wJyk7XHJcbiAgICAgIHRoaXMuY3VycmVudFRpbWUodGhpcy5vcHRpb25zXy5zdGFydHRpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy1oYXMtc3RhcnRlZCcpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB0aGUgZmlyc3QgdGltZSBhIHZpZGVvIGlzIHBsYXllZC4gTm90IHBhcnQgb2YgdGhlIEhMUyBzcGVjLCBhbmQgdGhpcyBpc1xyXG4gICAgICogcHJvYmFibHkgbm90IHRoZSBiZXN0IGltcGxlbWVudGF0aW9uIHlldCwgc28gdXNlIHNwYXJpbmdseS4gSWYgeW91IGRvbid0IGhhdmUgYVxyXG4gICAgICogcmVhc29uIHRvIHByZXZlbnQgcGxheWJhY2ssIHVzZSBgbXlQbGF5ZXIub25lKCdwbGF5Jyk7YCBpbnN0ZWFkLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudCBQbGF5ZXIjZmlyc3RwbGF5XHJcbiAgICAgKiBAZGVwcmVjYXRlZCBBcyBvZiA2LjAgZmlyc3RwbGF5IGV2ZW50IGlzIGRlcHJlY2F0ZWQuXHJcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudHJpZ2dlcignZmlyc3RwbGF5Jyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlnZ2VyIHRoZSBgcGF1c2VgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxyXG4gICAqXHJcbiAgICogQGZpcmVzIFBsYXllciNwYXVzZVxyXG4gICAqIEBsaXN0ZW5zIFRlY2gjcGF1c2VcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoUGF1c2VfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFBhdXNlXygpIHtcclxuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1wbGF5aW5nJyk7XHJcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtcGF1c2VkJyk7XHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW5ldmVyIHRoZSBtZWRpYSBoYXMgYmVlbiBwYXVzZWRcclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnQgUGxheWVyI3BhdXNlXHJcbiAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAgICAgKi9cclxuICAgIHRoaXMudHJpZ2dlcigncGF1c2UnKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWdnZXIgdGhlIGBlbmRlZGAgZXZlbnQgdGhhdCB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSB7QGxpbmsgVGVjaH0uXHJcbiAgICpcclxuICAgKiBAZmlyZXMgUGxheWVyI2VuZGVkXHJcbiAgICogQGxpc3RlbnMgVGVjaCNlbmRlZFxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hFbmRlZF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoRW5kZWRfKCkge1xyXG4gICAgdGhpcy5hZGRDbGFzcygndmpzLWVuZGVkJyk7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zXy5sb29wKSB7XHJcbiAgICAgIHRoaXMuY3VycmVudFRpbWUoMCk7XHJcbiAgICAgIHRoaXMucGxheSgpO1xyXG4gICAgfSBlbHNlIGlmICghdGhpcy5wYXVzZWQoKSkge1xyXG4gICAgICB0aGlzLnBhdXNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBlbmQgb2YgdGhlIG1lZGlhIHJlc291cmNlIGlzIHJlYWNoZWQgKGN1cnJlbnRUaW1lID09IGR1cmF0aW9uKVxyXG4gICAgICpcclxuICAgICAqIEBldmVudCBQbGF5ZXIjZW5kZWRcclxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy50cmlnZ2VyKCdlbmRlZCcpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpcmVkIHdoZW4gdGhlIGR1cmF0aW9uIG9mIHRoZSBtZWRpYSByZXNvdXJjZSBpcyBmaXJzdCBrbm93biBvciBjaGFuZ2VkXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBUZWNoI2R1cmF0aW9uY2hhbmdlXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaER1cmF0aW9uQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hEdXJhdGlvbkNoYW5nZV8oKSB7XHJcbiAgICB0aGlzLmR1cmF0aW9uKHRoaXMudGVjaEdldF8oJ2R1cmF0aW9uJykpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSBhIGNsaWNrIG9uIHRoZSBtZWRpYSBlbGVtZW50IHRvIHBsYXkvcGF1c2VcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIHRoZSBldmVudCB0aGF0IGNhdXNlZCB0aGlzIGZ1bmN0aW9uIHRvIHRyaWdnZXJcclxuICAgKlxyXG4gICAqIEBsaXN0ZW5zIFRlY2gjbW91c2Vkb3duXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaENsaWNrXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hDbGlja18oZXZlbnQpIHtcclxuICAgIC8vIFdlJ3JlIHVzaW5nIG1vdXNlZG93biB0byBkZXRlY3QgY2xpY2tzIHRoYW5rcyB0byBGbGFzaCwgYnV0IG1vdXNlZG93blxyXG4gICAgLy8gd2lsbCBhbHNvIGJlIHRyaWdnZXJlZCB3aXRoIHJpZ2h0LWNsaWNrcywgc28gd2UgbmVlZCB0byBwcmV2ZW50IHRoYXRcclxuICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFdoZW4gY29udHJvbHMgYXJlIGRpc2FibGVkIGEgY2xpY2sgc2hvdWxkIG5vdCB0b2dnbGUgcGxheWJhY2sgYmVjYXVzZVxyXG4gICAgLy8gdGhlIGNsaWNrIGlzIGNvbnNpZGVyZWQgYSBjb250cm9sXHJcbiAgICBpZiAodGhpcy5jb250cm9scygpKSB7XHJcbiAgICAgIGlmICh0aGlzLnBhdXNlZCgpKSB7XHJcbiAgICAgICAgdGhpcy5wbGF5KCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIGEgdGFwIG9uIHRoZSBtZWRpYSBlbGVtZW50LiBJdCB3aWxsIHRvZ2dsZSB0aGUgdXNlclxyXG4gICAqIGFjdGl2aXR5IHN0YXRlLCB3aGljaCBoaWRlcyBhbmQgc2hvd3MgdGhlIGNvbnRyb2xzLlxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgVGVjaCN0YXBcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVGFwXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hUYXBfKCkge1xyXG4gICAgdGhpcy51c2VyQWN0aXZlKCF0aGlzLnVzZXJBY3RpdmUoKSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIHRvdWNoIHRvIHN0YXJ0XHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBUZWNoI3RvdWNoc3RhcnRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVG91Y2hTdGFydF8gPSBmdW5jdGlvbiBoYW5kbGVUZWNoVG91Y2hTdGFydF8oKSB7XHJcbiAgICB0aGlzLnVzZXJXYXNBY3RpdmUgPSB0aGlzLnVzZXJBY3RpdmUoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgdG91Y2ggdG8gbW92ZVxyXG4gICAqXHJcbiAgICogQGxpc3RlbnMgVGVjaCN0b3VjaG1vdmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVG91Y2hNb3ZlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hUb3VjaE1vdmVfKCkge1xyXG4gICAgaWYgKHRoaXMudXNlcldhc0FjdGl2ZSkge1xyXG4gICAgICB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eSgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZSB0b3VjaCB0byBlbmRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIHRoZSB0b3VjaGVuZCBldmVudCB0aGF0IHRyaWdnZXJlZFxyXG4gICAqICAgICAgICB0aGlzIGZ1bmN0aW9uXHJcbiAgICpcclxuICAgKiBAbGlzdGVucyBUZWNoI3RvdWNoZW5kXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaFRvdWNoRW5kXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hUb3VjaEVuZF8oZXZlbnQpIHtcclxuICAgIC8vIFN0b3AgdGhlIG1vdXNlIGV2ZW50cyBmcm9tIGFsc28gaGFwcGVuaW5nXHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpcmVkIHdoZW4gdGhlIHBsYXllciBzd2l0Y2hlcyBpbiBvciBvdXQgb2YgZnVsbHNjcmVlbiBtb2RlXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBsaXN0ZW5zIFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2VfID0gZnVuY3Rpb24gaGFuZGxlRnVsbHNjcmVlbkNoYW5nZV8oKSB7XHJcbiAgICBpZiAodGhpcy5pc0Z1bGxzY3JlZW4oKSkge1xyXG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtZnVsbHNjcmVlbicpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5yZW1vdmVDbGFzcygndmpzLWZ1bGxzY3JlZW4nKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBuYXRpdmUgY2xpY2sgZXZlbnRzIG9uIHRoZSBTV0YgYXJlbid0IHRyaWdnZXJlZCBvbiBJRTExLCBXaW44LjFSVFxyXG4gICAqIHVzZSBzdGFnZWNsaWNrIGV2ZW50cyB0cmlnZ2VyZWQgZnJvbSBpbnNpZGUgdGhlIFNXRiBpbnN0ZWFkXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBsaXN0ZW5zIHN0YWdlY2xpY2tcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlU3RhZ2VDbGlja18gPSBmdW5jdGlvbiBoYW5kbGVTdGFnZUNsaWNrXygpIHtcclxuICAgIHRoaXMucmVwb3J0VXNlckFjdGl2aXR5KCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlIFRlY2ggRnVsbHNjcmVlbiBDaGFuZ2VcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR+RXZlbnR9IGV2ZW50XHJcbiAgICogICAgICAgIHRoZSBmdWxsc2NyZWVuY2hhbmdlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgZnVuY3Rpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcbiAgICogICAgICAgIHRoZSBkYXRhIHRoYXQgd2FzIHNlbnQgd2l0aCB0aGUgZXZlbnRcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQGxpc3RlbnMgVGVjaCNmdWxsc2NyZWVuY2hhbmdlXHJcbiAgICogQGZpcmVzIFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmhhbmRsZVRlY2hGdWxsc2NyZWVuQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hGdWxsc2NyZWVuQ2hhbmdlXyhldmVudCwgZGF0YSkge1xyXG4gICAgaWYgKGRhdGEpIHtcclxuICAgICAgdGhpcy5pc0Z1bGxzY3JlZW4oZGF0YS5pc0Z1bGxzY3JlZW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIGdvaW5nIGluIGFuZCBvdXQgb2YgZnVsbHNjcmVlbi5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnQgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcclxuICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAqL1xyXG4gICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRmlyZXMgd2hlbiBhbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIGxvYWRpbmcgb2YgYW4gYXVkaW8vdmlkZW8uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBsaXN0ZW5zIFRlY2gjZXJyb3JcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuaGFuZGxlVGVjaEVycm9yXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hFcnJvcl8oKSB7XHJcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnRlY2hfLmVycm9yKCk7XHJcblxyXG4gICAgdGhpcy5lcnJvcihlcnJvcik7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlnZ2VyIHRoZSBgdGV4dGRhdGFgIGV2ZW50IHRoYXQgd2FzIHRyaWdnZXJlZCBieSB0aGUge0BsaW5rIFRlY2h9LlxyXG4gICAqXHJcbiAgICogQGZpcmVzIFBsYXllciN0ZXh0ZGF0YVxyXG4gICAqIEBsaXN0ZW5zIFRlY2gjdGV4dGRhdGFcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoVGV4dERhdGFfID0gZnVuY3Rpb24gaGFuZGxlVGVjaFRleHREYXRhXygpIHtcclxuICAgIHZhciBkYXRhID0gbnVsbDtcclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgZGF0YSA9IGFyZ3VtZW50c1sxXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpcmVzIHdoZW4gd2UgZ2V0IGEgdGV4dGRhdGEgZXZlbnQgZnJvbSB0ZWNoXHJcbiAgICAgKlxyXG4gICAgICogQGV2ZW50IFBsYXllciN0ZXh0ZGF0YVxyXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRyaWdnZXIoJ3RleHRkYXRhJywgZGF0YSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IG9iamVjdCBmb3IgY2FjaGVkIHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKiAgICAgICAgIGdldCB0aGUgY3VycmVudCBvYmplY3QgY2FjaGVcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuZ2V0Q2FjaGUgPSBmdW5jdGlvbiBnZXRDYWNoZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmNhY2hlXztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBQYXNzIHZhbHVlcyB0byB0aGUgcGxheWJhY2sgdGVjaFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRob2RdXHJcbiAgICogICAgICAgIHRoZSBtZXRob2QgdG8gY2FsbFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ1xyXG4gICAqICAgICAgICB0aGUgYXJndW1lbnQgdG8gcGFzc1xyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUudGVjaENhbGxfID0gZnVuY3Rpb24gdGVjaENhbGxfKG1ldGhvZCwgYXJnKSB7XHJcbiAgICAvLyBJZiBpdCdzIG5vdCByZWFkeSB5ZXQsIGNhbGwgbWV0aG9kIHdoZW4gaXQgaXNcclxuXHJcbiAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKG1ldGhvZCBpbiBhbGxvd2VkU2V0dGVycykge1xyXG4gICAgICAgIHJldHVybiBzZXQkMSh0aGlzLm1pZGRsZXdhcmVfLCB0aGlzLnRlY2hfLCBtZXRob2QsIGFyZyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGVjaF8pIHtcclxuICAgICAgICAgIHRoaXMudGVjaF9bbWV0aG9kXShhcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGxvZyQxKGUpO1xyXG4gICAgICAgIHRocm93IGU7XHJcbiAgICAgIH1cclxuICAgIH0sIHRydWUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjYWxscyBjYW4ndCB3YWl0IGZvciB0aGUgdGVjaCwgYW5kIHNvbWV0aW1lcyBkb24ndCBuZWVkIHRvLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxyXG4gICAqICAgICAgICBUZWNoIG1ldGhvZFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxyXG4gICAqICAgICAgICAgdGhlIG1ldGhvZCBvciB1bmRlZmluZWRcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLnRlY2hHZXRfID0gZnVuY3Rpb24gdGVjaEdldF8obWV0aG9kKSB7XHJcbiAgICBpZiAodGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLmlzUmVhZHlfKSB7XHJcblxyXG4gICAgICBpZiAobWV0aG9kIGluIGFsbG93ZWRHZXR0ZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldCQxKHRoaXMubWlkZGxld2FyZV8sIHRoaXMudGVjaF8sIG1ldGhvZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZsYXNoIGxpa2VzIHRvIGRpZSBhbmQgcmVsb2FkIHdoZW4geW91IGhpZGUgb3IgcmVwb3NpdGlvbiBpdC5cclxuICAgICAgLy8gSW4gdGhlc2UgY2FzZXMgdGhlIG9iamVjdCBtZXRob2RzIGdvIGF3YXkgYW5kIHdlIGdldCBlcnJvcnMuXHJcbiAgICAgIC8vIFdoZW4gdGhhdCBoYXBwZW5zIHdlJ2xsIGNhdGNoIHRoZSBlcnJvcnMgYW5kIGluZm9ybSB0ZWNoIHRoYXQgaXQncyBub3QgcmVhZHkgYW55IG1vcmUuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGVjaF9bbWV0aG9kXSgpO1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gV2hlbiBidWlsZGluZyBhZGRpdGlvbmFsIHRlY2ggbGlicywgYW4gZXhwZWN0ZWQgbWV0aG9kIG1heSBub3QgYmUgZGVmaW5lZCB5ZXRcclxuICAgICAgICBpZiAodGhpcy50ZWNoX1ttZXRob2RdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGxvZyQxKCdWaWRlby5qczogJyArIG1ldGhvZCArICcgbWV0aG9kIG5vdCBkZWZpbmVkIGZvciAnICsgdGhpcy50ZWNoTmFtZV8gKyAnIHBsYXliYWNrIHRlY2hub2xvZ3kuJywgZSk7XHJcblxyXG4gICAgICAgICAgLy8gV2hlbiBhIG1ldGhvZCBpc24ndCBhdmFpbGFibGUgb24gdGhlIG9iamVjdCBpdCB0aHJvd3MgYSBUeXBlRXJyb3JcclxuICAgICAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gJ1R5cGVFcnJvcicpIHtcclxuICAgICAgICAgIGxvZyQxKCdWaWRlby5qczogJyArIG1ldGhvZCArICcgdW5hdmFpbGFibGUgb24gJyArIHRoaXMudGVjaE5hbWVfICsgJyBwbGF5YmFjayB0ZWNobm9sb2d5IGVsZW1lbnQuJywgZSk7XHJcbiAgICAgICAgICB0aGlzLnRlY2hfLmlzUmVhZHlfID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxvZyQxKGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIHN0YXJ0IG1lZGlhIHBsYXliYWNrXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfHVuZGVmaW5lZH1cclxuICAgKiAgICAgICAgIFJldHVybnMgYSBgUHJvbWlzZWAgaWYgdGhlIGJyb3dzZXIgcmV0dXJucyBvbmUsIGZvciBtb3N0IGJyb3dzZXJzIHRoaXMgd2lsbFxyXG4gICAqICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZC5cclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uIHBsYXkoKSB7XHJcbiAgICBpZiAodGhpcy5jaGFuZ2luZ1NyY18pIHtcclxuICAgICAgdGhpcy5yZWFkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJldHZhbCA9IHRoaXMudGVjaEdldF8oJ3BsYXknKTtcclxuXHJcbiAgICAgICAgLy8gc2lsZW5jZSBlcnJvcnMgKHVuaGFuZGxlZCBwcm9taXNlIGZyb20gcGxheSlcclxuICAgICAgICBpZiAocmV0dmFsICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJldHZhbC50aGVuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICByZXR2YWwudGhlbihudWxsLCBmdW5jdGlvbiAoZSkge30pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBPbmx5IGNhbGxzIHRoZSB0ZWNoJ3MgcGxheSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzcmMgbG9hZGVkXHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNSZWFkeV8gJiYgKHRoaXMuc3JjKCkgfHwgdGhpcy5jdXJyZW50U3JjKCkpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdwbGF5Jyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnJlYWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRlY2hfLm9uZSgnbG9hZHN0YXJ0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgdmFyIHJldHZhbCA9IHRoaXMucGxheSgpO1xyXG5cclxuICAgICAgICAgIC8vIHNpbGVuY2UgZXJyb3JzICh1bmhhbmRsZWQgcHJvbWlzZSBmcm9tIHBsYXkpXHJcbiAgICAgICAgICBpZiAocmV0dmFsICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJldHZhbC50aGVuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHZhbC50aGVuKG51bGwsIGZ1bmN0aW9uIChlKSB7fSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlIHRoZSB2aWRlbyBwbGF5YmFja1xyXG4gICAqXHJcbiAgICogQHJldHVybiB7UGxheWVyfVxyXG4gICAqICAgICAgICAgQSByZWZlcmVuY2UgdG8gdGhlIHBsYXllciBvYmplY3QgdGhpcyBmdW5jdGlvbiB3YXMgY2FsbGVkIG9uXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoKSB7XHJcbiAgICB0aGlzLnRlY2hDYWxsXygncGF1c2UnKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgcGxheWVyIGlzIHBhdXNlZCBvciBoYXMgeWV0IHRvIHBsYXlcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICogICAgICAgICAtIGZhbHNlOiBpZiB0aGUgbWVkaWEgaXMgY3VycmVudGx5IHBsYXlpbmdcclxuICAgKiAgICAgICAgIC0gdHJ1ZTogaWYgbWVkaWEgaXMgbm90IGN1cnJlbnRseSBwbGF5aW5nXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLnBhdXNlZCA9IGZ1bmN0aW9uIHBhdXNlZCgpIHtcclxuICAgIC8vIFRoZSBpbml0aWFsIHN0YXRlIG9mIHBhdXNlZCBzaG91bGQgYmUgdHJ1ZSAoaW4gU2FmYXJpIGl0J3MgYWN0dWFsbHkgZmFsc2UpXHJcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygncGF1c2VkJykgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhIFRpbWVSYW5nZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHJhbmdlcyBvZiB0aW1lIHRoYXQgdGhlIHVzZXJcclxuICAgKiBoYXMgcGxheWVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7VGltZVJhbmdlfVxyXG4gICAqICAgICAgICAgQSB0aW1lIHJhbmdlIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYWxsIHRoZSBpbmNyZW1lbnRzIG9mIHRpbWUgdGhhdCBoYXZlXHJcbiAgICogICAgICAgICBiZWVuIHBsYXllZC5cclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUucGxheWVkID0gZnVuY3Rpb24gcGxheWVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BsYXllZCcpIHx8IGNyZWF0ZVRpbWVSYW5nZXMoMCwgMCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdXNlciBpcyBcInNjcnViYmluZ1wiLiBTY3J1YmJpbmcgaXNcclxuICAgKiB3aGVuIHRoZSB1c2VyIGhhcyBjbGlja2VkIHRoZSBwcm9ncmVzcyBiYXIgaGFuZGxlIGFuZCBpc1xyXG4gICAqIGRyYWdnaW5nIGl0IGFsb25nIHRoZSBwcm9ncmVzcyBiYXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NjcnViYmluZ11cclxuICAgKiAgICAgICAgd2V0aGVyIHRoZSB1c2VyIGlzIG9yIGlzIG5vdCBzY3J1YmJpbmdcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICogICAgICAgICBUaGUgdmFsdWUgb2Ygc2NydWJiaW5nIHdoZW4gZ2V0dGluZ1xyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5zY3J1YmJpbmcgPSBmdW5jdGlvbiBzY3J1YmJpbmcoaXNTY3J1YmJpbmcpIHtcclxuICAgIGlmICh0eXBlb2YgaXNTY3J1YmJpbmcgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNjcnViYmluZ187XHJcbiAgICB9XHJcbiAgICB0aGlzLnNjcnViYmluZ18gPSAhIWlzU2NydWJiaW5nO1xyXG5cclxuICAgIGlmIChpc1NjcnViYmluZykge1xyXG4gICAgICB0aGlzLmFkZENsYXNzKCd2anMtc2NydWJiaW5nJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtc2NydWJiaW5nJyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IG9yIHNldCB0aGUgY3VycmVudCB0aW1lIChpbiBzZWNvbmRzKVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbc2Vjb25kc11cclxuICAgKiAgICAgICAgVGhlIHRpbWUgdG8gc2VlayB0byBpbiBzZWNvbmRzXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICogICAgICAgICAtIHRoZSBjdXJyZW50IHRpbWUgaW4gc2Vjb25kcyB3aGVuIGdldHRpbmdcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuY3VycmVudFRpbWUgPSBmdW5jdGlvbiBjdXJyZW50VGltZShzZWNvbmRzKSB7XHJcbiAgICBpZiAodHlwZW9mIHNlY29uZHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRDdXJyZW50VGltZScsIHNlY29uZHMpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FjaGUgbGFzdCBjdXJyZW50VGltZSBhbmQgcmV0dXJuLiBkZWZhdWx0IHRvIDAgc2Vjb25kc1xyXG4gICAgLy9cclxuICAgIC8vIENhY2hpbmcgdGhlIGN1cnJlbnRUaW1lIGlzIG1lYW50IHRvIHByZXZlbnQgYSBtYXNzaXZlIGFtb3VudCBvZiByZWFkcyBvbiB0aGUgdGVjaCdzXHJcbiAgICAvLyBjdXJyZW50VGltZSB3aGVuIHNjcnViYmluZywgYnV0IG1heSBub3QgcHJvdmlkZSBtdWNoIHBlcmZvcm1hbmNlIGJlbmVmaXQgYWZ0ZXJhbGwuXHJcbiAgICAvLyBTaG91bGQgYmUgdGVzdGVkLiBBbHNvIHNvbWV0aGluZyBoYXMgdG8gcmVhZCB0aGUgYWN0dWFsIGN1cnJlbnQgdGltZSBvciB0aGUgY2FjaGUgd2lsbFxyXG4gICAgLy8gbmV2ZXIgZ2V0IHVwZGF0ZWQuXHJcbiAgICB0aGlzLmNhY2hlXy5jdXJyZW50VGltZSA9IHRoaXMudGVjaEdldF8oJ2N1cnJlbnRUaW1lJykgfHwgMDtcclxuICAgIHJldHVybiB0aGlzLmNhY2hlXy5jdXJyZW50VGltZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBOb3JtYWxseSBnZXRzIHRoZSBsZW5ndGggaW4gdGltZSBvZiB0aGUgdmlkZW8gaW4gc2Vjb25kcztcclxuICAgKiBpbiBhbGwgYnV0IHRoZSByYXJlc3QgdXNlIGNhc2VzIGFuIGFyZ3VtZW50IHdpbGwgTk9UIGJlIHBhc3NlZCB0byB0aGUgbWV0aG9kXHJcbiAgICpcclxuICAgKiA+ICoqTk9URSoqOiBUaGUgdmlkZW8gbXVzdCBoYXZlIHN0YXJ0ZWQgbG9hZGluZyBiZWZvcmUgdGhlIGR1cmF0aW9uIGNhbiBiZVxyXG4gICAqIGtub3duLCBhbmQgaW4gdGhlIGNhc2Ugb2YgRmxhc2gsIG1heSBub3QgYmUga25vd24gdW50aWwgdGhlIHZpZGVvIHN0YXJ0c1xyXG4gICAqIHBsYXlpbmcuXHJcbiAgICpcclxuICAgKiBAZmlyZXMgUGxheWVyI2R1cmF0aW9uY2hhbmdlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NlY29uZHNdXHJcbiAgICogICAgICAgIFRoZSBkdXJhdGlvbiBvZiB0aGUgdmlkZW8gdG8gc2V0IGluIHNlY29uZHNcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKiAgICAgICAgIC0gVGhlIGR1cmF0aW9uIG9mIHRoZSB2aWRlbyBpbiBzZWNvbmRzIHdoZW4gZ2V0dGluZ1xyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uIGR1cmF0aW9uKHNlY29uZHMpIHtcclxuICAgIGlmIChzZWNvbmRzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gcmV0dXJuIE5hTiBpZiB0aGUgZHVyYXRpb24gaXMgbm90IGtub3duXHJcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlXy5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy5jYWNoZV8uZHVyYXRpb24gOiBOYU47XHJcbiAgICB9XHJcblxyXG4gICAgc2Vjb25kcyA9IHBhcnNlRmxvYXQoc2Vjb25kcyk7XHJcblxyXG4gICAgLy8gU3RhbmRhcmRpemUgb24gSW5pZml0eSBmb3Igc2lnbmFsaW5nIHZpZGVvIGlzIGxpdmVcclxuICAgIGlmIChzZWNvbmRzIDwgMCkge1xyXG4gICAgICBzZWNvbmRzID0gSW5maW5pdHk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNlY29uZHMgIT09IHRoaXMuY2FjaGVfLmR1cmF0aW9uKSB7XHJcbiAgICAgIC8vIENhY2hlIHRoZSBsYXN0IHNldCB2YWx1ZSBmb3Igb3B0aW1pemVkIHNjcnViYmluZyAoZXNwLiBGbGFzaClcclxuICAgICAgdGhpcy5jYWNoZV8uZHVyYXRpb24gPSBzZWNvbmRzO1xyXG5cclxuICAgICAgaWYgKHNlY29uZHMgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWxpdmUnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtbGl2ZScpO1xyXG4gICAgICB9XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI2R1cmF0aW9uY2hhbmdlXHJcbiAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAgICovXHJcbiAgICAgIHRoaXMudHJpZ2dlcignZHVyYXRpb25jaGFuZ2UnKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIGhvdyBtdWNoIHRpbWUgaXMgbGVmdCBpbiB0aGUgdmlkZW8uIE5vdCBwYXJ0XHJcbiAgICogb2YgdGhlIG5hdGl2ZSB2aWRlbyBBUEkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICogICAgICAgICBUaGUgdGltZSByZW1haW5pbmcgaW4gc2Vjb25kc1xyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5yZW1haW5pbmdUaW1lID0gZnVuY3Rpb24gcmVtYWluaW5nVGltZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmR1cmF0aW9uKCkgLSB0aGlzLmN1cnJlbnRUaW1lKCk7XHJcbiAgfTtcclxuXHJcbiAgLy9cclxuICAvLyBLaW5kIG9mIGxpa2UgYW4gYXJyYXkgb2YgcG9ydGlvbnMgb2YgdGhlIHZpZGVvIHRoYXQgaGF2ZSBiZWVuIGRvd25sb2FkZWQuXHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhIFRpbWVSYW5nZSBvYmplY3Qgd2l0aCBhbiBhcnJheSBvZiB0aGUgdGltZXMgb2YgdGhlIHZpZGVvXHJcbiAgICogdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZC4gSWYgeW91IGp1c3Qgd2FudCB0aGUgcGVyY2VudCBvZiB0aGVcclxuICAgKiB2aWRlbyB0aGF0J3MgYmVlbiBkb3dubG9hZGVkLCB1c2UgYnVmZmVyZWRQZXJjZW50LlxyXG4gICAqXHJcbiAgICogQHNlZSBbQnVmZmVyZWQgU3BlY117QGxpbmsgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvc3BlYy92aWRlby5odG1sI2RvbS1tZWRpYS1idWZmZXJlZH1cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1RpbWVSYW5nZX1cclxuICAgKiAgICAgICAgIEEgbW9jayBUaW1lUmFuZ2Ugb2JqZWN0IChmb2xsb3dpbmcgSFRNTCBzcGVjKVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5idWZmZXJlZCA9IGZ1bmN0aW9uIGJ1ZmZlcmVkKCkge1xyXG4gICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy50ZWNoR2V0XygnYnVmZmVyZWQnKTtcclxuXHJcbiAgICBpZiAoIWJ1ZmZlcmVkIHx8ICFidWZmZXJlZC5sZW5ndGgpIHtcclxuICAgICAgYnVmZmVyZWQgPSBjcmVhdGVUaW1lUmFuZ2VzKDAsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBidWZmZXJlZDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHBlcmNlbnQgKGFzIGEgZGVjaW1hbCkgb2YgdGhlIHZpZGVvIHRoYXQncyBiZWVuIGRvd25sb2FkZWQuXHJcbiAgICogVGhpcyBtZXRob2QgaXMgbm90IGEgcGFydCBvZiB0aGUgbmF0aXZlIEhUTUwgdmlkZW8gQVBJLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqICAgICAgICAgQSBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgdGhlIHBlcmNlbnRcclxuICAgKiAgICAgICAgIHRoYXQgaXMgYnVmZmVycmVkIDAgYmVpbmcgMCUgYW5kIDEgYmVpbmcgMTAwJVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5idWZmZXJlZFBlcmNlbnQgPSBmdW5jdGlvbiBidWZmZXJlZFBlcmNlbnQkJDEoKSB7XHJcbiAgICByZXR1cm4gYnVmZmVyZWRQZXJjZW50KHRoaXMuYnVmZmVyZWQoKSwgdGhpcy5kdXJhdGlvbigpKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGVuZGluZyB0aW1lIG9mIHRoZSBsYXN0IGJ1ZmZlcmVkIHRpbWUgcmFuZ2VcclxuICAgKiBUaGlzIGlzIHVzZWQgaW4gdGhlIHByb2dyZXNzIGJhciB0byBlbmNhcHN1bGF0ZSBhbGwgdGltZSByYW5nZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICogICAgICAgICBUaGUgZW5kIG9mIHRoZSBsYXN0IGJ1ZmZlcmVkIHRpbWUgcmFuZ2VcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuYnVmZmVyZWRFbmQgPSBmdW5jdGlvbiBidWZmZXJlZEVuZCgpIHtcclxuICAgIHZhciBidWZmZXJlZCA9IHRoaXMuYnVmZmVyZWQoKTtcclxuICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKTtcclxuICAgIHZhciBlbmQgPSBidWZmZXJlZC5lbmQoYnVmZmVyZWQubGVuZ3RoIC0gMSk7XHJcblxyXG4gICAgaWYgKGVuZCA+IGR1cmF0aW9uKSB7XHJcbiAgICAgIGVuZCA9IGR1cmF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbmQ7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IG9yIHNldCB0aGUgY3VycmVudCB2b2x1bWUgb2YgdGhlIG1lZGlhXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtwZXJjZW50QXNEZWNpbWFsXVxyXG4gICAqICAgICAgICAgVGhlIG5ldyB2b2x1bWUgYXMgYSBkZWNpbWFsIHBlcmNlbnQ6XHJcbiAgICogICAgICAgICAtIDAgaXMgbXV0ZWQvMCUvb2ZmXHJcbiAgICogICAgICAgICAtIDEuMCBpcyAxMDAlL2Z1bGxcclxuICAgKiAgICAgICAgIC0gMC41IGlzIGhhbGYgdm9sdW1lIG9yIDUwJVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdm9sdW1lIGFzIGEgcGVyY2VudCB3aGVuIGdldHRpbmdcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24gdm9sdW1lKHBlcmNlbnRBc0RlY2ltYWwpIHtcclxuICAgIHZhciB2b2wgPSB2b2lkIDA7XHJcblxyXG4gICAgaWYgKHBlcmNlbnRBc0RlY2ltYWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBGb3JjZSB2YWx1ZSB0byBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAgdm9sID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgcGFyc2VGbG9hdChwZXJjZW50QXNEZWNpbWFsKSkpO1xyXG4gICAgICB0aGlzLmNhY2hlXy52b2x1bWUgPSB2b2w7XHJcbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRWb2x1bWUnLCB2b2wpO1xyXG5cclxuICAgICAgaWYgKHZvbCA+IDApIHtcclxuICAgICAgICB0aGlzLmxhc3RWb2x1bWVfKHZvbCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZWZhdWx0IHRvIDEgd2hlbiByZXR1cm5pbmcgY3VycmVudCB2b2x1bWUuXHJcbiAgICB2b2wgPSBwYXJzZUZsb2F0KHRoaXMudGVjaEdldF8oJ3ZvbHVtZScpKTtcclxuICAgIHJldHVybiBpc05hTih2b2wpID8gMSA6IHZvbDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGN1cnJlbnQgbXV0ZWQgc3RhdGUsIG9yIHR1cm4gbXV0ZSBvbiBvciBvZmZcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW211dGVkXVxyXG4gICAqICAgICAgICAtIHRydWUgdG8gbXV0ZVxyXG4gICAqICAgICAgICAtIGZhbHNlIHRvIHVubXV0ZVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKiAgICAgICAgIC0gdHJ1ZSBpZiBtdXRlIGlzIG9uIGFuZCBnZXR0aW5nXHJcbiAgICogICAgICAgICAtIGZhbHNlIGlmIG11dGUgaXMgb2ZmIGFuZCBnZXR0aW5nXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLm11dGVkID0gZnVuY3Rpb24gbXV0ZWQoX211dGVkKSB7XHJcbiAgICBpZiAoX211dGVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldE11dGVkJywgX211dGVkKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ211dGVkJykgfHwgZmFsc2U7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjdXJyZW50IGRlZmF1bHRNdXRlZCBzdGF0ZSwgb3IgdHVybiBkZWZhdWx0TXV0ZWQgb24gb3Igb2ZmLiBkZWZhdWx0TXV0ZWRcclxuICAgKiBpbmRpY2F0ZXMgdGhlIHN0YXRlIG9mIG11dGVkIG9uIGludGlhbCBwbGF5YmFjay5cclxuICAgKlxyXG4gICAqIGBgYGpzXHJcbiAgICogICB2YXIgbXlQbGF5ZXIgPSB2aWRlb2pzKCdzb21lLXBsYXllci1pZCcpO1xyXG4gICAqXHJcbiAgICogICBteVBsYXllci5zcmMoXCJodHRwOi8vd3d3LmV4YW1wbGUuY29tL3BhdGgvdG8vdmlkZW8ubXA0XCIpO1xyXG4gICAqXHJcbiAgICogICAvLyBnZXQsIHNob3VsZCBiZSBmYWxzZVxyXG4gICAqICAgY29uc29sZS5sb2cobXlQbGF5ZXIuZGVmYXVsdE11dGVkKCkpO1xyXG4gICAqICAgLy8gc2V0IHRvIHRydWVcclxuICAgKiAgIG15UGxheWVyLmRlZmF1bHRNdXRlZCh0cnVlKTtcclxuICAgKiAgIC8vIGdldCBzaG91bGQgYmUgdHJ1ZVxyXG4gICAqICAgY29uc29sZS5sb2cobXlQbGF5ZXIuZGVmYXVsdE11dGVkKCkpO1xyXG4gICAqIGBgYFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbZGVmYXVsdE11dGVkXVxyXG4gICAqICAgICAgICAtIHRydWUgdG8gbXV0ZVxyXG4gICAqICAgICAgICAtIGZhbHNlIHRvIHVubXV0ZVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbnxQbGF5ZXJ9XHJcbiAgICogICAgICAgICAtIHRydWUgaWYgZGVmYXVsdE11dGVkIGlzIG9uIGFuZCBnZXR0aW5nXHJcbiAgICogICAgICAgICAtIGZhbHNlIGlmIGRlZmF1bHRNdXRlZCBpcyBvZmYgYW5kIGdldHRpbmdcclxuICAgKiAgICAgICAgIC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcGxheWVyIHdoZW4gc2V0dGluZ1xyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5kZWZhdWx0TXV0ZWQgPSBmdW5jdGlvbiBkZWZhdWx0TXV0ZWQoX2RlZmF1bHRNdXRlZCkge1xyXG4gICAgaWYgKF9kZWZhdWx0TXV0ZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdGhpcy50ZWNoQ2FsbF8oJ3NldERlZmF1bHRNdXRlZCcsIF9kZWZhdWx0TXV0ZWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ2RlZmF1bHRNdXRlZCcpIHx8IGZhbHNlO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbGFzdCB2b2x1bWUsIG9yIHNldCBpdFxyXG4gICAqXHJcbiAgICogQHBhcmFtICB7bnVtYmVyfSBbcGVyY2VudEFzRGVjaW1hbF1cclxuICAgKiAgICAgICAgIFRoZSBuZXcgbGFzdCB2b2x1bWUgYXMgYSBkZWNpbWFsIHBlcmNlbnQ6XHJcbiAgICogICAgICAgICAtIDAgaXMgbXV0ZWQvMCUvb2ZmXHJcbiAgICogICAgICAgICAtIDEuMCBpcyAxMDAlL2Z1bGxcclxuICAgKiAgICAgICAgIC0gMC41IGlzIGhhbGYgdm9sdW1lIG9yIDUwJVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqICAgICAgICAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgbGFzdFZvbHVtZSBhcyBhIHBlcmNlbnQgd2hlbiBnZXR0aW5nXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5sYXN0Vm9sdW1lXyA9IGZ1bmN0aW9uIGxhc3RWb2x1bWVfKHBlcmNlbnRBc0RlY2ltYWwpIHtcclxuICAgIGlmIChwZXJjZW50QXNEZWNpbWFsICE9PSB1bmRlZmluZWQgJiYgcGVyY2VudEFzRGVjaW1hbCAhPT0gMCkge1xyXG4gICAgICB0aGlzLmNhY2hlXy5sYXN0Vm9sdW1lID0gcGVyY2VudEFzRGVjaW1hbDtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuY2FjaGVfLmxhc3RWb2x1bWU7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgY3VycmVudCB0ZWNoIGNhbiBzdXBwb3J0IG5hdGl2ZSBmdWxsc2NyZWVuXHJcbiAgICogKGUuZy4gd2l0aCBidWlsdCBpbiBjb250cm9scyBsaWtlIGlPUywgc28gbm90IG91ciBmbGFzaCBzd2YpXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqICAgICAgICAgaWYgbmF0aXZlIGZ1bGxzY3JlZW4gaXMgc3VwcG9ydGVkXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLnN1cHBvcnRzRnVsbFNjcmVlbiA9IGZ1bmN0aW9uIHN1cHBvcnRzRnVsbFNjcmVlbigpIHtcclxuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdzdXBwb3J0c0Z1bGxTY3JlZW4nKSB8fCBmYWxzZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgcGxheWVyIGlzIGluIGZ1bGxzY3JlZW4gbW9kZSBvciB0ZWxsIHRoZSBwbGF5ZXIgdGhhdCBpdFxyXG4gICAqIGlzIG9yIGlzIG5vdCBpbiBmdWxsc2NyZWVuIG1vZGUuXHJcbiAgICpcclxuICAgKiA+IE5PVEU6IEFzIG9mIHRoZSBsYXRlc3QgSFRNTDUgc3BlYywgaXNGdWxsc2NyZWVuIGlzIG5vIGxvbmdlciBhbiBvZmZpY2lhbFxyXG4gICAqIHByb3BlcnR5IGFuZCBpbnN0ZWFkIGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IGlzIHVzZWQuIEJ1dCBpc0Z1bGxzY3JlZW4gaXNcclxuICAgKiBzdGlsbCBhIHZhbHVhYmxlIHByb3BlcnR5IGZvciBpbnRlcm5hbCBwbGF5ZXIgd29ya2luZ3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbaXNGU11cclxuICAgKiAgICAgICAgIFNldCB0aGUgcGxheWVycyBjdXJyZW50IGZ1bGxzY3JlZW4gc3RhdGVcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAgICogICAgICAgICAtIHRydWUgaWYgZnVsbHNjcmVlbiBpcyBvbiBhbmQgZ2V0dGluZ1xyXG4gICAqICAgICAgICAgLSBmYWxzZSBpZiBmdWxsc2NyZWVuIGlzIG9mZiBhbmQgZ2V0dGluZ1xyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5pc0Z1bGxzY3JlZW4gPSBmdW5jdGlvbiBpc0Z1bGxzY3JlZW4oaXNGUykge1xyXG4gICAgaWYgKGlzRlMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLmlzRnVsbHNjcmVlbl8gPSAhIWlzRlM7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJldHVybiAhIXRoaXMuaXNGdWxsc2NyZWVuXztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBJbmNyZWFzZSB0aGUgc2l6ZSBvZiB0aGUgdmlkZW8gdG8gZnVsbCBzY3JlZW5cclxuICAgKiBJbiBzb21lIGJyb3dzZXJzLCBmdWxsIHNjcmVlbiBpcyBub3Qgc3VwcG9ydGVkIG5hdGl2ZWx5LCBzbyBpdCBlbnRlcnNcclxuICAgKiBcImZ1bGwgd2luZG93IG1vZGVcIiwgd2hlcmUgdGhlIHZpZGVvIGZpbGxzIHRoZSBicm93c2VyIHdpbmRvdy5cclxuICAgKiBJbiBicm93c2VycyBhbmQgZGV2aWNlcyB0aGF0IHN1cHBvcnQgbmF0aXZlIGZ1bGwgc2NyZWVuLCBzb21ldGltZXMgdGhlXHJcbiAgICogYnJvd3NlcidzIGRlZmF1bHQgY29udHJvbHMgd2lsbCBiZSBzaG93biwgYW5kIG5vdCB0aGUgVmlkZW8uanMgY3VzdG9tIHNraW4uXHJcbiAgICogVGhpcyBpbmNsdWRlcyBtb3N0IG1vYmlsZSBkZXZpY2VzIChpT1MsIEFuZHJvaWQpIGFuZCBvbGRlciB2ZXJzaW9ucyBvZlxyXG4gICAqIFNhZmFyaS5cclxuICAgKlxyXG4gICAqIEBmaXJlcyBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5yZXF1ZXN0RnVsbHNjcmVlbiA9IGZ1bmN0aW9uIHJlcXVlc3RGdWxsc2NyZWVuKCkge1xyXG4gICAgdmFyIGZzQXBpID0gRnVsbHNjcmVlbkFwaTtcclxuXHJcbiAgICB0aGlzLmlzRnVsbHNjcmVlbih0cnVlKTtcclxuXHJcbiAgICBpZiAoZnNBcGkucmVxdWVzdEZ1bGxzY3JlZW4pIHtcclxuICAgICAgLy8gdGhlIGJyb3dzZXIgc3VwcG9ydHMgZ29pbmcgZnVsbHNjcmVlbiBhdCB0aGUgZWxlbWVudCBsZXZlbCBzbyB3ZSBjYW5cclxuICAgICAgLy8gdGFrZSB0aGUgY29udHJvbHMgZnVsbHNjcmVlbiBhcyB3ZWxsIGFzIHRoZSB2aWRlb1xyXG5cclxuICAgICAgLy8gVHJpZ2dlciBmdWxsc2NyZWVuY2hhbmdlIGV2ZW50IGFmdGVyIGNoYW5nZVxyXG4gICAgICAvLyBXZSBoYXZlIHRvIHNwZWNpZmljYWxseSBhZGQgdGhpcyBlYWNoIHRpbWUsIGFuZCByZW1vdmVcclxuICAgICAgLy8gd2hlbiBjYW5jZWxpbmcgZnVsbHNjcmVlbi4gT3RoZXJ3aXNlIGlmIHRoZXJlJ3MgbXVsdGlwbGVcclxuICAgICAgLy8gcGxheWVycyBvbiBhIHBhZ2UsIHRoZXkgd291bGQgYWxsIGJlIHJlYWN0aW5nIHRvIHRoZSBzYW1lIGZ1bGxzY3JlZW5cclxuICAgICAgLy8gZXZlbnRzXHJcbiAgICAgIG9uKGRvY3VtZW50XzEsIGZzQXBpLmZ1bGxzY3JlZW5jaGFuZ2UsIGJpbmQodGhpcywgZnVuY3Rpb24gZG9jdW1lbnRGdWxsc2NyZWVuQ2hhbmdlKGUpIHtcclxuICAgICAgICB0aGlzLmlzRnVsbHNjcmVlbihkb2N1bWVudF8xW2ZzQXBpLmZ1bGxzY3JlZW5FbGVtZW50XSk7XHJcblxyXG4gICAgICAgIC8vIElmIGNhbmNlbGxpbmcgZnVsbHNjcmVlbiwgcmVtb3ZlIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgIGlmICh0aGlzLmlzRnVsbHNjcmVlbigpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgb2ZmKGRvY3VtZW50XzEsIGZzQXBpLmZ1bGxzY3JlZW5jaGFuZ2UsIGRvY3VtZW50RnVsbHNjcmVlbkNoYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBldmVudCBQbGF5ZXIjZnVsbHNjcmVlbmNoYW5nZVxyXG4gICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnKTtcclxuICAgICAgfSkpO1xyXG5cclxuICAgICAgdGhpcy5lbF9bZnNBcGkucmVxdWVzdEZ1bGxzY3JlZW5dKCk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMudGVjaF8uc3VwcG9ydHNGdWxsU2NyZWVuKCkpIHtcclxuICAgICAgLy8gd2UgY2FuJ3QgdGFrZSB0aGUgdmlkZW8uanMgY29udHJvbHMgZnVsbHNjcmVlbiBidXQgd2UgY2FuIGdvIGZ1bGxzY3JlZW5cclxuICAgICAgLy8gd2l0aCBuYXRpdmUgY29udHJvbHNcclxuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ2VudGVyRnVsbFNjcmVlbicpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZnVsbHNjcmVlbiBpc24ndCBzdXBwb3J0ZWQgc28gd2UnbGwganVzdCBzdHJldGNoIHRoZSB2aWRlbyBlbGVtZW50IHRvXHJcbiAgICAgIC8vIGZpbGwgdGhlIHZpZXdwb3J0XHJcbiAgICAgIHRoaXMuZW50ZXJGdWxsV2luZG93KCk7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcclxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICAgKi9cclxuICAgICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSB2aWRlbyB0byBpdHMgbm9ybWFsIHNpemUgYWZ0ZXIgaGF2aW5nIGJlZW4gaW4gZnVsbCBzY3JlZW4gbW9kZVxyXG4gICAqXHJcbiAgICogQGZpcmVzIFBsYXllciNmdWxsc2NyZWVuY2hhbmdlXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmV4aXRGdWxsc2NyZWVuID0gZnVuY3Rpb24gZXhpdEZ1bGxzY3JlZW4oKSB7XHJcbiAgICB2YXIgZnNBcGkgPSBGdWxsc2NyZWVuQXBpO1xyXG5cclxuICAgIHRoaXMuaXNGdWxsc2NyZWVuKGZhbHNlKTtcclxuXHJcbiAgICAvLyBDaGVjayBmb3IgYnJvd3NlciBlbGVtZW50IGZ1bGxzY3JlZW4gc3VwcG9ydFxyXG4gICAgaWYgKGZzQXBpLnJlcXVlc3RGdWxsc2NyZWVuKSB7XHJcbiAgICAgIGRvY3VtZW50XzFbZnNBcGkuZXhpdEZ1bGxzY3JlZW5dKCk7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMudGVjaF8uc3VwcG9ydHNGdWxsU2NyZWVuKCkpIHtcclxuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ2V4aXRGdWxsU2NyZWVuJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmV4aXRGdWxsV2luZG93KCk7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAZXZlbnQgUGxheWVyI2Z1bGxzY3JlZW5jaGFuZ2VcclxuICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICAgKi9cclxuICAgICAgdGhpcy50cmlnZ2VyKCdmdWxsc2NyZWVuY2hhbmdlJyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogV2hlbiBmdWxsc2NyZWVuIGlzbid0IHN1cHBvcnRlZCB3ZSBjYW4gc3RyZXRjaCB0aGVcclxuICAgKiB2aWRlbyBjb250YWluZXIgdG8gYXMgd2lkZSBhcyB0aGUgYnJvd3NlciB3aWxsIGxldCB1cy5cclxuICAgKlxyXG4gICAqIEBmaXJlcyBQbGF5ZXIjZW50ZXJGdWxsV2luZG93XHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmVudGVyRnVsbFdpbmRvdyA9IGZ1bmN0aW9uIGVudGVyRnVsbFdpbmRvdygpIHtcclxuICAgIHRoaXMuaXNGdWxsV2luZG93ID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBTdG9yaW5nIG9yaWdpbmFsIGRvYyBvdmVyZmxvdyB2YWx1ZSB0byByZXR1cm4gdG8gd2hlbiBmdWxsc2NyZWVuIGlzIG9mZlxyXG4gICAgdGhpcy5kb2NPcmlnT3ZlcmZsb3cgPSBkb2N1bWVudF8xLmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdztcclxuXHJcbiAgICAvLyBBZGQgbGlzdGVuZXIgZm9yIGVzYyBrZXkgdG8gZXhpdCBmdWxsc2NyZWVuXHJcbiAgICBvbihkb2N1bWVudF8xLCAna2V5ZG93bicsIGJpbmQodGhpcywgdGhpcy5mdWxsV2luZG93T25Fc2NLZXkpKTtcclxuXHJcbiAgICAvLyBIaWRlIGFueSBzY3JvbGwgYmFyc1xyXG4gICAgZG9jdW1lbnRfMS5kb2N1bWVudEVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuXHJcbiAgICAvLyBBcHBseSBmdWxsc2NyZWVuIHN0eWxlc1xyXG4gICAgYWRkQ2xhc3MoZG9jdW1lbnRfMS5ib2R5LCAndmpzLWZ1bGwtd2luZG93Jyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZXZlbnQgUGxheWVyI2VudGVyRnVsbFdpbmRvd1xyXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRyaWdnZXIoJ2VudGVyRnVsbFdpbmRvdycpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGZvciBjYWxsIHRvIGVpdGhlciBleGl0IGZ1bGwgd2luZG93IG9yXHJcbiAgICogZnVsbCBzY3JlZW4gb24gRVNDIGtleVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XHJcbiAgICogICAgICAgIEV2ZW50IHRvIGNoZWNrIGZvciBrZXkgcHJlc3NcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuZnVsbFdpbmRvd09uRXNjS2V5ID0gZnVuY3Rpb24gZnVsbFdpbmRvd09uRXNjS2V5KGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcclxuICAgICAgaWYgKHRoaXMuaXNGdWxsc2NyZWVuKCkgPT09IHRydWUpIHtcclxuICAgICAgICB0aGlzLmV4aXRGdWxsc2NyZWVuKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5leGl0RnVsbFdpbmRvdygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRXhpdCBmdWxsIHdpbmRvd1xyXG4gICAqXHJcbiAgICogQGZpcmVzIFBsYXllciNleGl0RnVsbFdpbmRvd1xyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5leGl0RnVsbFdpbmRvdyA9IGZ1bmN0aW9uIGV4aXRGdWxsV2luZG93KCkge1xyXG4gICAgdGhpcy5pc0Z1bGxXaW5kb3cgPSBmYWxzZTtcclxuICAgIG9mZihkb2N1bWVudF8xLCAna2V5ZG93bicsIHRoaXMuZnVsbFdpbmRvd09uRXNjS2V5KTtcclxuXHJcbiAgICAvLyBVbmhpZGUgc2Nyb2xsIGJhcnMuXHJcbiAgICBkb2N1bWVudF8xLmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IHRoaXMuZG9jT3JpZ092ZXJmbG93O1xyXG5cclxuICAgIC8vIFJlbW92ZSBmdWxsc2NyZWVuIHN0eWxlc1xyXG4gICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnRfMS5ib2R5LCAndmpzLWZ1bGwtd2luZG93Jyk7XHJcblxyXG4gICAgLy8gUmVzaXplIHRoZSBib3gsIGNvbnRyb2xsZXIsIGFuZCBwb3N0ZXIgdG8gb3JpZ2luYWwgc2l6ZXNcclxuICAgIC8vIHRoaXMucG9zaXRpb25BbGwoKTtcclxuICAgIC8qKlxyXG4gICAgICogQGV2ZW50IFBsYXllciNleGl0RnVsbFdpbmRvd1xyXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRyaWdnZXIoJ2V4aXRGdWxsV2luZG93Jyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgcGxheWVyIGNhbiBwbGF5IGEgZ2l2ZW4gbWltZXR5cGVcclxuICAgKlxyXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTAxMTMvdmlkZW8uaHRtbCNkb20tbmF2aWdhdG9yLWNhbnBsYXl0eXBlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxyXG4gICAqICAgICAgICBUaGUgbWltZXR5cGUgdG8gY2hlY2tcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKiAgICAgICAgICdwcm9iYWJseScsICdtYXliZScsIG9yICcnIChlbXB0eSBzdHJpbmcpXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmNhblBsYXlUeXBlID0gZnVuY3Rpb24gY2FuUGxheVR5cGUodHlwZSkge1xyXG4gICAgdmFyIGNhbiA9IHZvaWQgMDtcclxuXHJcbiAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBwbGF5YmFjayB0ZWNobm9sb2d5IGluIHRoZSBvcHRpb25zIG9yZGVyXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMub3B0aW9uc18udGVjaE9yZGVyOyBpIDwgai5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgdGVjaE5hbWUgPSBqW2ldO1xyXG4gICAgICB2YXIgdGVjaCA9IFRlY2guZ2V0VGVjaCh0ZWNoTmFtZSk7XHJcblxyXG4gICAgICAvLyBTdXBwb3J0IG9sZCBiZWhhdmlvciBvZiB0ZWNocyBiZWluZyByZWdpc3RlcmVkIGFzIGNvbXBvbmVudHMuXHJcbiAgICAgIC8vIFJlbW92ZSBvbmNlIHRoYXQgZGVwcmVjYXRlZCBiZWhhdmlvciBpcyByZW1vdmVkLlxyXG4gICAgICBpZiAoIXRlY2gpIHtcclxuICAgICAgICB0ZWNoID0gQ29tcG9uZW50LmdldENvbXBvbmVudCh0ZWNoTmFtZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHRlY2ggaXMgZGVmaW5lZCBiZWZvcmUgY29udGludWluZ1xyXG4gICAgICBpZiAoIXRlY2gpIHtcclxuICAgICAgICBsb2ckMS5lcnJvcignVGhlIFwiJyArIHRlY2hOYW1lICsgJ1wiIHRlY2ggaXMgdW5kZWZpbmVkLiBTa2lwcGVkIGJyb3dzZXIgc3VwcG9ydCBjaGVjayBmb3IgdGhhdCB0ZWNoLicpO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGlzIHRlY2hub2xvZ3lcclxuICAgICAgaWYgKHRlY2guaXNTdXBwb3J0ZWQoKSkge1xyXG4gICAgICAgIGNhbiA9IHRlY2guY2FuUGxheVR5cGUodHlwZSk7XHJcblxyXG4gICAgICAgIGlmIChjYW4pIHtcclxuICAgICAgICAgIHJldHVybiBjYW47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICcnO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFNlbGVjdCBzb3VyY2UgYmFzZWQgb24gdGVjaC1vcmRlciBvciBzb3VyY2Utb3JkZXJcclxuICAgKiBVc2VzIHNvdXJjZS1vcmRlciBzZWxlY3Rpb24gaWYgYG9wdGlvbnMuc291cmNlT3JkZXJgIGlzIHRydXRoeS4gT3RoZXJ3aXNlLFxyXG4gICAqIGRlZmF1bHRzIHRvIHRlY2gtb3JkZXIgc2VsZWN0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VzXHJcbiAgICogICAgICAgIFRoZSBzb3VyY2VzIGZvciBhIG1lZGlhIGFzc2V0XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R8Ym9vbGVhbn1cclxuICAgKiAgICAgICAgIE9iamVjdCBvZiBzb3VyY2UgYW5kIHRlY2ggb3JkZXIgb3IgZmFsc2VcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuc2VsZWN0U291cmNlID0gZnVuY3Rpb24gc2VsZWN0U291cmNlKHNvdXJjZXMpIHtcclxuICAgIHZhciBfdGhpczUgPSB0aGlzO1xyXG5cclxuICAgIC8vIEdldCBvbmx5IHRoZSB0ZWNocyBzcGVjaWZpZWQgaW4gYHRlY2hPcmRlcmAgdGhhdCBleGlzdCBhbmQgYXJlIHN1cHBvcnRlZCBieSB0aGVcclxuICAgIC8vIGN1cnJlbnQgcGxhdGZvcm1cclxuICAgIHZhciB0ZWNocyA9IHRoaXMub3B0aW9uc18udGVjaE9yZGVyLm1hcChmdW5jdGlvbiAodGVjaE5hbWUpIHtcclxuICAgICAgcmV0dXJuIFt0ZWNoTmFtZSwgVGVjaC5nZXRUZWNoKHRlY2hOYW1lKV07XHJcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKF9yZWYpIHtcclxuICAgICAgdmFyIHRlY2hOYW1lID0gX3JlZlswXSxcclxuICAgICAgICAgIHRlY2ggPSBfcmVmWzFdO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgdGVjaCBpcyBkZWZpbmVkIGJlZm9yZSBjb250aW51aW5nXHJcbiAgICAgIGlmICh0ZWNoKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyB0ZWNobm9sb2d5XHJcbiAgICAgICAgcmV0dXJuIHRlY2guaXNTdXBwb3J0ZWQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbG9nJDEuZXJyb3IoJ1RoZSBcIicgKyB0ZWNoTmFtZSArICdcIiB0ZWNoIGlzIHVuZGVmaW5lZC4gU2tpcHBlZCBicm93c2VyIHN1cHBvcnQgY2hlY2sgZm9yIHRoYXQgdGVjaC4nKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGVhY2ggYGlubmVyQXJyYXlgIGVsZW1lbnQgb25jZSBwZXIgYG91dGVyQXJyYXlgIGVsZW1lbnQgYW5kIGV4ZWN1dGVcclxuICAgIC8vIGB0ZXN0ZXJgIHdpdGggYm90aC4gSWYgYHRlc3RlcmAgcmV0dXJucyBhIG5vbi1mYWxzeSB2YWx1ZSwgZXhpdCBlYXJseSBhbmQgcmV0dXJuXHJcbiAgICAvLyB0aGF0IHZhbHVlLlxyXG4gICAgdmFyIGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpciA9IGZ1bmN0aW9uIGZpbmRGaXJzdFBhc3NpbmdUZWNoU291cmNlUGFpcihvdXRlckFycmF5LCBpbm5lckFycmF5LCB0ZXN0ZXIpIHtcclxuICAgICAgdmFyIGZvdW5kID0gdm9pZCAwO1xyXG5cclxuICAgICAgb3V0ZXJBcnJheS5zb21lKGZ1bmN0aW9uIChvdXRlckNob2ljZSkge1xyXG4gICAgICAgIHJldHVybiBpbm5lckFycmF5LnNvbWUoZnVuY3Rpb24gKGlubmVyQ2hvaWNlKSB7XHJcbiAgICAgICAgICBmb3VuZCA9IHRlc3RlcihvdXRlckNob2ljZSwgaW5uZXJDaG9pY2UpO1xyXG5cclxuICAgICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBmb3VuZFNvdXJjZUFuZFRlY2ggPSB2b2lkIDA7XHJcbiAgICB2YXIgZmxpcCA9IGZ1bmN0aW9uIGZsaXAoZm4pIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZuKGIsIGEpO1xyXG4gICAgICB9O1xyXG4gICAgfTtcclxuICAgIHZhciBmaW5kZXIgPSBmdW5jdGlvbiBmaW5kZXIoX3JlZjIsIHNvdXJjZSkge1xyXG4gICAgICB2YXIgdGVjaE5hbWUgPSBfcmVmMlswXSxcclxuICAgICAgICAgIHRlY2ggPSBfcmVmMlsxXTtcclxuXHJcbiAgICAgIGlmICh0ZWNoLmNhblBsYXlTb3VyY2Uoc291cmNlLCBfdGhpczUub3B0aW9uc19bdGVjaE5hbWUudG9Mb3dlckNhc2UoKV0pKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgc291cmNlOiBzb3VyY2UsIHRlY2g6IHRlY2hOYW1lIH07XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gRGVwZW5kaW5nIG9uIHRoZSB0cnV0aGluZXNzIG9mIGBvcHRpb25zLnNvdXJjZU9yZGVyYCwgd2Ugc3dhcCB0aGUgb3JkZXIgb2YgdGVjaHMgYW5kIHNvdXJjZXNcclxuICAgIC8vIHRvIHNlbGVjdCBmcm9tIHRoZW0gYmFzZWQgb24gdGhlaXIgcHJpb3JpdHkuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zXy5zb3VyY2VPcmRlcikge1xyXG4gICAgICAvLyBTb3VyY2UtZmlyc3Qgb3JkZXJpbmdcclxuICAgICAgZm91bmRTb3VyY2VBbmRUZWNoID0gZmluZEZpcnN0UGFzc2luZ1RlY2hTb3VyY2VQYWlyKHNvdXJjZXMsIHRlY2hzLCBmbGlwKGZpbmRlcikpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gVGVjaC1maXJzdCBvcmRlcmluZ1xyXG4gICAgICBmb3VuZFNvdXJjZUFuZFRlY2ggPSBmaW5kRmlyc3RQYXNzaW5nVGVjaFNvdXJjZVBhaXIodGVjaHMsIHNvdXJjZXMsIGZpbmRlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZvdW5kU291cmNlQW5kVGVjaCB8fCBmYWxzZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgb3Igc2V0IHRoZSB2aWRlbyBzb3VyY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RlY2h+U291cmNlT2JqZWN0fFRlY2h+U291cmNlT2JqZWN0W118c3RyaW5nfSBbc291cmNlXVxyXG4gICAqICAgICAgICBBIFNvdXJjZU9iamVjdCwgYW4gYXJyYXkgb2YgU291cmNlT2JqZWN0cywgb3IgYSBzdHJpbmcgcmVmZXJlbmNpbmdcclxuICAgKiAgICAgICAgYSBVUkwgdG8gYSBtZWRpYSBzb3VyY2UuIEl0IGlzIF9oaWdobHkgcmVjb21tZW5kZWRfIHRoYXQgYW4gb2JqZWN0XHJcbiAgICogICAgICAgIG9yIGFycmF5IG9mIG9iamVjdHMgaXMgdXNlZCBoZXJlLCBzbyB0aGF0IHNvdXJjZSBzZWxlY3Rpb25cclxuICAgKiAgICAgICAgYWxnb3JpdGhtcyBjYW4gdGFrZSB0aGUgYHR5cGVgIGludG8gYWNjb3VudC5cclxuICAgKlxyXG4gICAqICAgICAgICBJZiBub3QgcHJvdmlkZWQsIHRoaXMgbWV0aG9kIGFjdHMgYXMgYSBnZXR0ZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxyXG4gICAqICAgICAgICAgSWYgdGhlIGBzb3VyY2VgIGFyZ3VtZW50IGlzIG1pc3NpbmcsIHJldHVybnMgdGhlIGN1cnJlbnQgc291cmNlXHJcbiAgICogICAgICAgICBVUkwuIE90aGVyd2lzZSwgcmV0dXJucyBub3RoaW5nL3VuZGVmaW5lZC5cclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuc3JjID0gZnVuY3Rpb24gc3JjKHNvdXJjZSkge1xyXG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XHJcblxyXG4gICAgLy8gZ2V0dGVyIHVzYWdlXHJcbiAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVfLnNyYztcclxuICAgIH1cclxuICAgIC8vIGZpbHRlciBvdXQgaW52YWxpZCBzb3VyY2VzIGFuZCB0dXJuIG91ciBzb3VyY2UgaW50b1xyXG4gICAgLy8gYW4gYXJyYXkgb2Ygc291cmNlIG9iamVjdHNcclxuICAgIHZhciBzb3VyY2VzID0gZmlsdGVyU291cmNlKHNvdXJjZSk7XHJcblxyXG4gICAgLy8gaWYgYSBzb3VyY2Ugd2FzIHBhc3NlZCBpbiB0aGVuIGl0IGlzIGludmFsaWQgYmVjYXVzZVxyXG4gICAgLy8gaXQgd2FzIGZpbHRlcmVkIHRvIGEgemVybyBsZW5ndGggQXJyYXkuIFNvIHdlIGhhdmUgdG9cclxuICAgIC8vIHNob3cgYW4gZXJyb3JcclxuICAgIGlmICghc291cmNlcy5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVycm9yKHsgY29kZTogNCwgbWVzc2FnZTogdGhpcy5sb2NhbGl6ZSh0aGlzLm9wdGlvbnNfLm5vdFN1cHBvcnRlZE1lc3NhZ2UpIH0pO1xyXG4gICAgICB9LCAwKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGludGlhbCBzb3VyY2VzXHJcbiAgICB0aGlzLmNhY2hlXy5zb3VyY2VzID0gc291cmNlcztcclxuICAgIHRoaXMuY2hhbmdpbmdTcmNfID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBpbnRpYWwgc291cmNlXHJcbiAgICB0aGlzLmNhY2hlXy5zb3VyY2UgPSBzb3VyY2VzWzBdO1xyXG5cclxuICAgIC8vIG1pZGRsZXdhcmVTb3VyY2UgaXMgdGhlIHNvdXJjZSBhZnRlciBpdCBoYXMgYmVlbiBjaGFuZ2VkIGJ5IG1pZGRsZXdhcmVcclxuICAgIHNldFNvdXJjZSh0aGlzLCBzb3VyY2VzWzBdLCBmdW5jdGlvbiAobWlkZGxld2FyZVNvdXJjZSwgbXdzKSB7XHJcbiAgICAgIF90aGlzNi5taWRkbGV3YXJlXyA9IG13cztcclxuXHJcbiAgICAgIHZhciBlcnIgPSBfdGhpczYuc3JjXyhtaWRkbGV3YXJlU291cmNlKTtcclxuXHJcbiAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICBpZiAoc291cmNlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICByZXR1cm4gX3RoaXM2LnNyYyhzb3VyY2VzLnNsaWNlKDEpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIGEgdGltZW91dCB0byBnaXZlIGZvbGtzIGEgY2hhbmNlIHRvIGFkZCBlcnJvciBldmVudCBoYW5kbGVyc1xyXG4gICAgICAgIF90aGlzNi5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHRoaXMuZXJyb3IoeyBjb2RlOiA0LCBtZXNzYWdlOiB0aGlzLmxvY2FsaXplKHRoaXMub3B0aW9uc18ubm90U3VwcG9ydGVkTWVzc2FnZSkgfSk7XHJcbiAgICAgICAgfSwgMCk7XHJcblxyXG4gICAgICAgIC8vIHdlIGNvdWxkIG5vdCBmaW5kIGFuIGFwcHJvcHJpYXRlIHRlY2gsIGJ1dCBsZXQncyBzdGlsbCBub3RpZnkgdGhlIGRlbGVnYXRlIHRoYXQgdGhpcyBpcyBpdFxyXG4gICAgICAgIC8vIHRoaXMgbmVlZHMgYSBiZXR0ZXIgY29tbWVudCBhYm91dCB3aHkgdGhpcyBpcyBuZWVkZWRcclxuICAgICAgICBfdGhpczYudHJpZ2dlclJlYWR5KCk7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgX3RoaXM2LmNoYW5naW5nU3JjXyA9IGZhbHNlO1xyXG4gICAgICAvLyB2aWRlbyBlbGVtZW50IGxpc3RlZCBzb3VyY2VcclxuICAgICAgX3RoaXM2LmNhY2hlXy5zcmMgPSBtaWRkbGV3YXJlU291cmNlLnNyYztcclxuXHJcbiAgICAgIHNldFRlY2gobXdzLCBfdGhpczYudGVjaF8pO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBzb3VyY2Ugb2JqZWN0IG9uIHRoZSB0ZWNoLCByZXR1cm5zIGEgYm9vbGVhbiB0aGF0IGluZGljYXRlcyB3ZXRoZXJcclxuICAgKiB0aGVyZSBpcyBhIHRlY2ggdGhhdCBjYW4gcGxheSB0aGUgc291cmNlIG9yIG5vdFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUZWNoflNvdXJjZU9iamVjdH0gc291cmNlXHJcbiAgICogICAgICAgIFRoZSBzb3VyY2Ugb2JqZWN0IHRvIHNldCBvbiB0aGUgVGVjaFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgKiAgICAgICAgIC0gVHJ1ZSBpZiB0aGVyZSBpcyBubyBUZWNoIHRvIHBsYXliYWNrIHRoaXMgc291cmNlXHJcbiAgICogICAgICAgICAtIEZhbHNlIG90aGVyd2lzZVxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuc3JjXyA9IGZ1bmN0aW9uIHNyY18oc291cmNlKSB7XHJcbiAgICB2YXIgc291cmNlVGVjaCA9IHRoaXMuc2VsZWN0U291cmNlKFtzb3VyY2VdKTtcclxuXHJcbiAgICBpZiAoIXNvdXJjZVRlY2gpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aXRsZUNhc2VFcXVhbHMoc291cmNlVGVjaC50ZWNoLCB0aGlzLnRlY2hOYW1lXykpIHtcclxuICAgICAgdGhpcy5jaGFuZ2luZ1NyY18gPSB0cnVlO1xyXG5cclxuICAgICAgLy8gbG9hZCB0aGlzIHRlY2hub2xvZ3kgd2l0aCB0aGUgY2hvc2VuIHNvdXJjZVxyXG4gICAgICB0aGlzLmxvYWRUZWNoXyhzb3VyY2VUZWNoLnRlY2gsIHNvdXJjZVRlY2guc291cmNlKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHdhaXQgdW50aWwgdGhlIHRlY2ggaXMgcmVhZHkgdG8gc2V0IHRoZSBzb3VyY2VcclxuICAgIHRoaXMucmVhZHkoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgLy8gVGhlIHNldFNvdXJjZSB0ZWNoIG1ldGhvZCB3YXMgYWRkZWQgd2l0aCBzb3VyY2UgaGFuZGxlcnNcclxuICAgICAgLy8gc28gb2xkZXIgdGVjaHMgd29uJ3Qgc3VwcG9ydCBpdFxyXG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIHRoZSBkaXJlY3QgcHJvdG90eXBlIGZvciB0aGUgY2FzZSB3aGVyZSBzdWJjbGFzc2VzXHJcbiAgICAgIC8vIG9mIHRoZSB0ZWNoIGRvIG5vdCBzdXBwb3J0IHNvdXJjZSBoYW5kbGVyc1xyXG4gICAgICBpZiAodGhpcy50ZWNoXy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3NldFNvdXJjZScpKSB7XHJcbiAgICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFNvdXJjZScsIHNvdXJjZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NyYycsIHNvdXJjZS5zcmMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5vcHRpb25zXy5wcmVsb2FkID09PSAnYXV0bycpIHtcclxuICAgICAgICB0aGlzLmxvYWQoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2V0IHRoZSBzb3VyY2Ugc3luY2hyb25vdXNseSBpZiBwb3NzaWJsZSAoIzIzMjYpXHJcbiAgICB9LCB0cnVlKTtcclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQmVnaW4gbG9hZGluZyB0aGUgc3JjIGRhdGEuXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkKCkge1xyXG4gICAgdGhpcy50ZWNoQ2FsbF8oJ2xvYWQnKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXNldCB0aGUgcGxheWVyLiBMb2FkcyB0aGUgZmlyc3QgdGVjaCBpbiB0aGUgdGVjaE9yZGVyLFxyXG4gICAqIGFuZCBjYWxscyBgcmVzZXRgIG9uIHRoZSB0ZWNoYC5cclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcclxuICAgIHRoaXMubG9hZFRlY2hfKHRoaXMub3B0aW9uc18udGVjaE9yZGVyWzBdLCBudWxsKTtcclxuICAgIHRoaXMudGVjaENhbGxfKCdyZXNldCcpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYWxsIG9mIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3RzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7VGVjaH5Tb3VyY2VPYmplY3RbXX1cclxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3RzXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmN1cnJlbnRTb3VyY2VzID0gZnVuY3Rpb24gY3VycmVudFNvdXJjZXMoKSB7XHJcbiAgICB2YXIgc291cmNlID0gdGhpcy5jdXJyZW50U291cmNlKCk7XHJcbiAgICB2YXIgc291cmNlcyA9IFtdO1xyXG5cclxuICAgIC8vIGFzc3VtZSBge31gIG9yIGB7IHNyYyB9YFxyXG4gICAgaWYgKE9iamVjdC5rZXlzKHNvdXJjZSkubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmNhY2hlXy5zb3VyY2VzIHx8IHNvdXJjZXM7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7VGVjaH5Tb3VyY2VPYmplY3R9XHJcbiAgICogICAgICAgICBUaGUgY3VycmVudCBzb3VyY2Ugb2JqZWN0XHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmN1cnJlbnRTb3VyY2UgPSBmdW5jdGlvbiBjdXJyZW50U291cmNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY2FjaGVfLnNvdXJjZSB8fCB7fTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBmdWxseSBxdWFsaWZpZWQgVVJMIG9mIHRoZSBjdXJyZW50IHNvdXJjZSB2YWx1ZSBlLmcuIGh0dHA6Ly9teXNpdGUuY29tL3ZpZGVvLm1wNFxyXG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBgY3VycmVudFR5cGVgIHRvIGFzc2lzdCBpbiByZWJ1aWxkaW5nIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICogICAgICAgICBUaGUgY3VycmVudCBzb3VyY2VcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuY3VycmVudFNyYyA9IGZ1bmN0aW9uIGN1cnJlbnRTcmMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U291cmNlKCkgJiYgdGhpcy5jdXJyZW50U291cmNlKCkuc3JjIHx8ICcnO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY3VycmVudCBzb3VyY2UgdHlwZSBlLmcuIHZpZGVvL21wNFxyXG4gICAqIFRoaXMgY2FuIGFsbG93IHlvdSByZWJ1aWxkIHRoZSBjdXJyZW50IHNvdXJjZSBvYmplY3Qgc28gdGhhdCB5b3UgY291bGQgbG9hZCB0aGUgc2FtZVxyXG4gICAqIHNvdXJjZSBhbmQgdGVjaCBsYXRlclxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqICAgICAgICAgVGhlIHNvdXJjZSBNSU1FIHR5cGVcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuY3VycmVudFR5cGUgPSBmdW5jdGlvbiBjdXJyZW50VHlwZSgpIHtcclxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTb3VyY2UoKSAmJiB0aGlzLmN1cnJlbnRTb3VyY2UoKS50eXBlIHx8ICcnO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBvciBzZXQgdGhlIHByZWxvYWQgYXR0cmlidXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt2YWx1ZV1cclxuICAgKiAgICAgICAgLSB0cnVlIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIHByZWxvYWRcclxuICAgKiAgICAgICAgLSBmYWxzZSBtYWVucyB0aGF0IHdlIHNob3VsZCBub3QgcHJlbG9hZFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqICAgICAgICAgVGhlIHByZWxvYWQgYXR0cmlidXRlIHZhbHVlIHdoZW4gZ2V0dGluZ1xyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5wcmVsb2FkID0gZnVuY3Rpb24gcHJlbG9hZCh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFByZWxvYWQnLCB2YWx1ZSk7XHJcbiAgICAgIHRoaXMub3B0aW9uc18ucHJlbG9hZCA9IHZhbHVlO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygncHJlbG9hZCcpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBvciBzZXQgdGhlIGF1dG9wbGF5IGF0dHJpYnV0ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbHVlXVxyXG4gICAqICAgICAgICAtIHRydWUgbWVhbnMgdGhhdCB3ZSBzaG91bGQgYXV0b3BsYXlcclxuICAgKiAgICAgICAgLSBmYWxzZSBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgYXV0b3BsYXlcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIGF1dG9wbGF5IHdoZW4gZ2V0dGluZ1xyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5hdXRvcGxheSA9IGZ1bmN0aW9uIGF1dG9wbGF5KHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0QXV0b3BsYXknLCB2YWx1ZSk7XHJcbiAgICAgIHRoaXMub3B0aW9uc18uYXV0b3BsYXkgPSB2YWx1ZTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ2F1dG9wbGF5JywgdmFsdWUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBvciB1bnNldCB0aGUgcGxheXNpbmxpbmUgYXR0cmlidXRlLlxyXG4gICAqIFBsYXlzaW5saW5lIHRlbGxzIHRoZSBicm93c2VyIHRoYXQgbm9uLWZ1bGxzY3JlZW4gcGxheWJhY2sgaXMgcHJlZmVycmVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbdmFsdWVdXHJcbiAgICogICAgICAgIC0gdHJ1ZSBtZWFucyB0aGF0IHdlIHNob3VsZCB0cnkgdG8gcGxheSBpbmxpbmUgYnkgZGVmYXVsdFxyXG4gICAqICAgICAgICAtIGZhbHNlIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIHVzZSB0aGUgYnJvd3NlcidzIGRlZmF1bHQgcGxheWJhY2sgbW9kZSxcclxuICAgKiAgICAgICAgICB3aGljaCBpbiBtb3N0IGNhc2VzIGlzIGlubGluZS4gaU9TIFNhZmFyaSBpcyBhIG5vdGFibGUgZXhjZXB0aW9uXHJcbiAgICogICAgICAgICAgYW5kIHBsYXlzIGZ1bGxzY3JlZW4gYnkgZGVmYXVsdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ3xQbGF5ZXJ9XHJcbiAgICogICAgICAgICAtIHRoZSBjdXJyZW50IHZhbHVlIG9mIHBsYXlzaW5saW5lXHJcbiAgICogICAgICAgICAtIHRoZSBwbGF5ZXIgd2hlbiBzZXR0aW5nXHJcbiAgICpcclxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNhdHRyLXZpZGVvLXBsYXlzaW5saW5lfVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5wbGF5c2lubGluZSA9IGZ1bmN0aW9uIHBsYXlzaW5saW5lKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0UGxheXNpbmxpbmUnLCB2YWx1ZSk7XHJcbiAgICAgIHRoaXMub3B0aW9uc18ucGxheXNpbmxpbmUgPSB2YWx1ZTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0XygncGxheXNpbmxpbmUnKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXQgb3Igc2V0IHRoZSBsb29wIGF0dHJpYnV0ZSBvbiB0aGUgdmlkZW8gZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ZhbHVlXVxyXG4gICAqICAgICAgICAtIHRydWUgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbG9vcCB0aGUgdmlkZW9cclxuICAgKiAgICAgICAgLSBmYWxzZSBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbG9vcCB0aGUgdmlkZW9cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIGxvb3Agd2hlbiBnZXR0aW5nXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLmxvb3AgPSBmdW5jdGlvbiBsb29wKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLnRlY2hDYWxsXygnc2V0TG9vcCcsIHZhbHVlKTtcclxuICAgICAgdGhpcy5vcHRpb25zXy5sb29wID0gdmFsdWU7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdsb29wJyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IG9yIHNldCB0aGUgcG9zdGVyIGltYWdlIHNvdXJjZSB1cmxcclxuICAgKlxyXG4gICAqIEBmaXJlcyBQbGF5ZXIjcG9zdGVyY2hhbmdlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NyY11cclxuICAgKiAgICAgICAgUG9zdGVyIGltYWdlIHNvdXJjZSBVUkxcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIHBvc3RlciB3aGVuIGdldHRpbmdcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUucG9zdGVyID0gZnVuY3Rpb24gcG9zdGVyKHNyYykge1xyXG4gICAgaWYgKHNyYyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBvc3Rlcl87XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlIGNvcnJlY3Qgd2F5IHRvIHJlbW92ZSBhIHBvc3RlciBpcyB0byBzZXQgYXMgYW4gZW1wdHkgc3RyaW5nXHJcbiAgICAvLyBvdGhlciBmYWxzZXkgdmFsdWVzIHdpbGwgdGhyb3cgZXJyb3JzXHJcbiAgICBpZiAoIXNyYykge1xyXG4gICAgICBzcmMgPSAnJztcclxuICAgIH1cclxuXHJcbiAgICAvLyB1cGRhdGUgdGhlIGludGVybmFsIHBvc3RlciB2YXJpYWJsZVxyXG4gICAgdGhpcy5wb3N0ZXJfID0gc3JjO1xyXG5cclxuICAgIC8vIHVwZGF0ZSB0aGUgdGVjaCdzIHBvc3RlclxyXG4gICAgdGhpcy50ZWNoQ2FsbF8oJ3NldFBvc3RlcicsIHNyYyk7XHJcblxyXG4gICAgLy8gYWxlcnQgY29tcG9uZW50cyB0aGF0IHRoZSBwb3N0ZXIgaGFzIGJlZW4gc2V0XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZXZlbnQgZmlyZXMgd2hlbiB0aGUgcG9zdGVyIGltYWdlIGlzIGNoYW5nZWQgb24gdGhlIHBsYXllci5cclxuICAgICAqXHJcbiAgICAgKiBAZXZlbnQgUGxheWVyI3Bvc3RlcmNoYW5nZVxyXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRyaWdnZXIoJ3Bvc3RlcmNoYW5nZScpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFNvbWUgdGVjaHMgKGUuZy4gWW91VHViZSkgY2FuIHByb3ZpZGUgYSBwb3N0ZXIgc291cmNlIGluIGFuXHJcbiAgICogYXN5bmNocm9ub3VzIHdheS4gV2Ugd2FudCB0aGUgcG9zdGVyIGNvbXBvbmVudCB0byB1c2UgdGhpc1xyXG4gICAqIHBvc3RlciBzb3VyY2Ugc28gdGhhdCBpdCBjb3ZlcnMgdXAgdGhlIHRlY2gncyBjb250cm9scy5cclxuICAgKiAoWW91VHViZSdzIHBsYXkgYnV0dG9uKS4gSG93ZXZlciB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoaXNcclxuICAgKiBzb3VyY2UgaWYgdGhlIHBsYXllciB1c2VyIGhhc24ndCBzZXQgYSBwb3N0ZXIgdGhyb3VnaFxyXG4gICAqIHRoZSBub3JtYWwgQVBJcy5cclxuICAgKlxyXG4gICAqIEBmaXJlcyBQbGF5ZXIjcG9zdGVyY2hhbmdlXHJcbiAgICogQGxpc3RlbnMgVGVjaCNwb3N0ZXJjaGFuZ2VcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5oYW5kbGVUZWNoUG9zdGVyQ2hhbmdlXyA9IGZ1bmN0aW9uIGhhbmRsZVRlY2hQb3N0ZXJDaGFuZ2VfKCkge1xyXG4gICAgaWYgKCF0aGlzLnBvc3Rlcl8gJiYgdGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLnBvc3Rlcikge1xyXG4gICAgICB0aGlzLnBvc3Rlcl8gPSB0aGlzLnRlY2hfLnBvc3RlcigpIHx8ICcnO1xyXG5cclxuICAgICAgLy8gTGV0IGNvbXBvbmVudHMga25vdyB0aGUgcG9zdGVyIGhhcyBjaGFuZ2VkXHJcbiAgICAgIHRoaXMudHJpZ2dlcigncG9zdGVyY2hhbmdlJyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IG9yIHNldCB3aGV0aGVyIG9yIG5vdCB0aGUgY29udHJvbHMgYXJlIHNob3dpbmcuXHJcbiAgICpcclxuICAgKiBAZmlyZXMgUGxheWVyI2NvbnRyb2xzZW5hYmxlZFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbF1cclxuICAgKiAgICAgICAgLSB0cnVlIHRvIHR1cm4gY29udHJvbHMgb25cclxuICAgKiAgICAgICAgLSBmYWxzZSB0byB0dXJuIGNvbnRyb2xzIG9mZlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIGNvbnRyb2xzIHdoZW4gZ2V0dGluZ1xyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5jb250cm9scyA9IGZ1bmN0aW9uIGNvbnRyb2xzKGJvb2wpIHtcclxuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgYm9vbCA9ICEhYm9vbDtcclxuXHJcbiAgICAgIC8vIERvbid0IHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgdW5sZXNzIGl0IGFjdHVhbGx5IGNoYW5nZWRcclxuICAgICAgaWYgKHRoaXMuY29udHJvbHNfICE9PSBib29sKSB7XHJcbiAgICAgICAgdGhpcy5jb250cm9sc18gPSBib29sO1xyXG5cclxuICAgICAgICBpZiAodGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzKCkpIHtcclxuICAgICAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRDb250cm9scycsIGJvb2wpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJvb2wpIHtcclxuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy1jb250cm9scy1kaXNhYmxlZCcpO1xyXG4gICAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWNvbnRyb2xzLWVuYWJsZWQnKTtcclxuICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICogQGV2ZW50IFBsYXllciNjb250cm9sc2VuYWJsZWRcclxuICAgICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAgICAgICAqL1xyXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdjb250cm9sc2VuYWJsZWQnKTtcclxuXHJcbiAgICAgICAgICBpZiAoIXRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtY29udHJvbHMtZW5hYmxlZCcpO1xyXG4gICAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLWNvbnRyb2xzLWRpc2FibGVkJyk7XHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEBldmVudCBQbGF5ZXIjY29udHJvbHNkaXNhYmxlZFxyXG4gICAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICAgICAgICovXHJcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NvbnRyb2xzZGlzYWJsZWQnKTtcclxuXHJcbiAgICAgICAgICBpZiAoIXRoaXMudXNpbmdOYXRpdmVDb250cm9scygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGVjaENvbnRyb2xzTGlzdGVuZXJzXygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gISF0aGlzLmNvbnRyb2xzXztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBUb2dnbGUgbmF0aXZlIGNvbnRyb2xzIG9uL29mZi4gTmF0aXZlIGNvbnRyb2xzIGFyZSB0aGUgY29udHJvbHMgYnVpbHQgaW50b1xyXG4gICAqIGRldmljZXMgKGUuZy4gZGVmYXVsdCBpUGhvbmUgY29udHJvbHMpLCBGbGFzaCwgb3Igb3RoZXIgdGVjaHNcclxuICAgKiAoZS5nLiBWaW1lbyBDb250cm9scylcclxuICAgKiAqKlRoaXMgc2hvdWxkIG9ubHkgYmUgc2V0IGJ5IHRoZSBjdXJyZW50IHRlY2gsIGJlY2F1c2Ugb25seSB0aGUgdGVjaCBrbm93c1xyXG4gICAqIGlmIGl0IGNhbiBzdXBwb3J0IG5hdGl2ZSBjb250cm9scyoqXHJcbiAgICpcclxuICAgKiBAZmlyZXMgUGxheWVyI3VzaW5nbmF0aXZlY29udHJvbHNcclxuICAgKiBAZmlyZXMgUGxheWVyI3VzaW5nY3VzdG9tY29udHJvbHNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Jvb2xdXHJcbiAgICogICAgICAgIC0gdHJ1ZSB0byB0dXJuIG5hdGl2ZSBjb250cm9scyBvblxyXG4gICAqICAgICAgICAtIGZhbHNlIHRvIHR1cm4gbmF0aXZlIGNvbnRyb2xzIG9mZlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IHZhbHVlIG9mIG5hdGl2ZSBjb250cm9scyB3aGVuIGdldHRpbmdcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUudXNpbmdOYXRpdmVDb250cm9scyA9IGZ1bmN0aW9uIHVzaW5nTmF0aXZlQ29udHJvbHMoYm9vbCkge1xyXG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBib29sID0gISFib29sO1xyXG5cclxuICAgICAgLy8gRG9uJ3QgdHJpZ2dlciBhIGNoYW5nZSBldmVudCB1bmxlc3MgaXQgYWN0dWFsbHkgY2hhbmdlZFxyXG4gICAgICBpZiAodGhpcy51c2luZ05hdGl2ZUNvbnRyb2xzXyAhPT0gYm9vbCkge1xyXG4gICAgICAgIHRoaXMudXNpbmdOYXRpdmVDb250cm9sc18gPSBib29sO1xyXG4gICAgICAgIGlmIChib29sKSB7XHJcbiAgICAgICAgICB0aGlzLmFkZENsYXNzKCd2anMtdXNpbmctbmF0aXZlLWNvbnRyb2xzJyk7XHJcblxyXG4gICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBwbGF5ZXIgaXMgdXNpbmcgdGhlIG5hdGl2ZSBkZXZpY2UgY29udHJvbHNcclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAZXZlbnQgUGxheWVyI3VzaW5nbmF0aXZlY29udHJvbHNcclxuICAgICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAgICAgICAqL1xyXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd1c2luZ25hdGl2ZWNvbnRyb2xzJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3Zqcy11c2luZy1uYXRpdmUtY29udHJvbHMnKTtcclxuXHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIHBsYXllciBpcyB1c2luZyB0aGUgY3VzdG9tIEhUTUwgY29udHJvbHNcclxuICAgICAgICAgICAqXHJcbiAgICAgICAgICAgKiBAZXZlbnQgUGxheWVyI3VzaW5nY3VzdG9tY29udHJvbHNcclxuICAgICAgICAgICAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAgICAgICAqL1xyXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCd1c2luZ2N1c3RvbWNvbnRyb2xzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJldHVybiAhIXRoaXMudXNpbmdOYXRpdmVDb250cm9sc187XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IG9yIGdldCB0aGUgY3VycmVudCBNZWRpYUVycm9yXHJcbiAgICpcclxuICAgKiBAZmlyZXMgUGxheWVyI2Vycm9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtNZWRpYUVycm9yfHN0cmluZ3xudW1iZXJ9IFtlcnJdXHJcbiAgICogICAgICAgICBBIE1lZGlhRXJyb3Igb3IgYSBzdHJpbmcvbnVtYmVyIHRvIGJlIHR1cm5lZFxyXG4gICAqICAgICAgICAgaW50byBhIE1lZGlhRXJyb3JcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge01lZGlhRXJyb3J8bnVsbH1cclxuICAgKiAgICAgICAgIFRoZSBjdXJyZW50IE1lZGlhRXJyb3Igd2hlbiBnZXR0aW5nIChvciBudWxsKVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKGVycikge1xyXG4gICAgaWYgKGVyciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVycm9yXyB8fCBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJlc3RvcmluZyB0byBkZWZhdWx0XHJcbiAgICBpZiAoZXJyID09PSBudWxsKSB7XHJcbiAgICAgIHRoaXMuZXJyb3JfID0gZXJyO1xyXG4gICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtZXJyb3InKTtcclxuICAgICAgaWYgKHRoaXMuZXJyb3JEaXNwbGF5KSB7XHJcbiAgICAgICAgdGhpcy5lcnJvckRpc3BsYXkuY2xvc2UoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5lcnJvcl8gPSBuZXcgTWVkaWFFcnJvcihlcnIpO1xyXG5cclxuICAgIC8vIGFkZCB0aGUgdmpzLWVycm9yIGNsYXNzbmFtZSB0byB0aGUgcGxheWVyXHJcbiAgICB0aGlzLmFkZENsYXNzKCd2anMtZXJyb3InKTtcclxuXHJcbiAgICAvLyBsb2cgdGhlIG5hbWUgb2YgdGhlIGVycm9yIHR5cGUgYW5kIGFueSBtZXNzYWdlXHJcbiAgICAvLyBpZTgganVzdCBsb2dzIFwiW29iamVjdCBvYmplY3RdXCIgaWYgeW91IGp1c3QgbG9nIHRoZSBlcnJvciBvYmplY3RcclxuICAgIGxvZyQxLmVycm9yKCcoQ09ERTonICsgdGhpcy5lcnJvcl8uY29kZSArICcgJyArIE1lZGlhRXJyb3IuZXJyb3JUeXBlc1t0aGlzLmVycm9yXy5jb2RlXSArICcpJywgdGhpcy5lcnJvcl8ubWVzc2FnZSwgdGhpcy5lcnJvcl8pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGV2ZW50IFBsYXllciNlcnJvclxyXG4gICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRyaWdnZXIoJ2Vycm9yJyk7XHJcblxyXG4gICAgcmV0dXJuO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlcG9ydCB1c2VyIGFjdGl2aXR5XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcclxuICAgKiAgICAgICAgRXZlbnQgb2JqZWN0XHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLnJlcG9ydFVzZXJBY3Rpdml0eSA9IGZ1bmN0aW9uIHJlcG9ydFVzZXJBY3Rpdml0eShldmVudCkge1xyXG4gICAgdGhpcy51c2VyQWN0aXZpdHlfID0gdHJ1ZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXQvc2V0IGlmIHVzZXIgaXMgYWN0aXZlXHJcbiAgICpcclxuICAgKiBAZmlyZXMgUGxheWVyI3VzZXJhY3RpdmVcclxuICAgKiBAZmlyZXMgUGxheWVyI3VzZXJpbmFjdGl2ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbYm9vbF1cclxuICAgKiAgICAgICAgLSB0cnVlIGlmIHRoZSB1c2VyIGlzIGFjdGl2ZVxyXG4gICAqICAgICAgICAtIGZhbHNlIGlmIHRoZSB1c2VyIGlzIGluYWN0aXZlXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgdXNlckFjdGl2ZSB3aGVuIGdldHRpbmdcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUudXNlckFjdGl2ZSA9IGZ1bmN0aW9uIHVzZXJBY3RpdmUoYm9vbCkge1xyXG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBib29sID0gISFib29sO1xyXG4gICAgICBpZiAoYm9vbCAhPT0gdGhpcy51c2VyQWN0aXZlXykge1xyXG4gICAgICAgIHRoaXMudXNlckFjdGl2ZV8gPSBib29sO1xyXG4gICAgICAgIGlmIChib29sKSB7XHJcbiAgICAgICAgICAvLyBJZiB0aGUgdXNlciB3YXMgaW5hY3RpdmUgYW5kIGlzIG5vdyBhY3RpdmUgd2Ugd2FudCB0byByZXNldCB0aGVcclxuICAgICAgICAgIC8vIGluYWN0aXZpdHkgdGltZXJcclxuICAgICAgICAgIHRoaXMudXNlckFjdGl2aXR5XyA9IHRydWU7XHJcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtdXNlci1pbmFjdGl2ZScpO1xyXG4gICAgICAgICAgdGhpcy5hZGRDbGFzcygndmpzLXVzZXItYWN0aXZlJyk7XHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEBldmVudCBQbGF5ZXIjdXNlcmFjdGl2ZVxyXG4gICAgICAgICAgICogQHR5cGUge0V2ZW50VGFyZ2V0fkV2ZW50fVxyXG4gICAgICAgICAgICovXHJcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3VzZXJhY3RpdmUnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gV2UncmUgc3dpdGNoaW5nIHRoZSBzdGF0ZSB0byBpbmFjdGl2ZSBtYW51YWxseSwgc28gZXJhc2UgYW55IG90aGVyXHJcbiAgICAgICAgICAvLyBhY3Rpdml0eVxyXG4gICAgICAgICAgdGhpcy51c2VyQWN0aXZpdHlfID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgLy8gQ2hyb21lL1NhZmFyaS9JRSBoYXZlIGJ1Z3Mgd2hlcmUgd2hlbiB5b3UgY2hhbmdlIHRoZSBjdXJzb3IgaXQgY2FuXHJcbiAgICAgICAgICAvLyB0cmlnZ2VyIGEgbW91c2Vtb3ZlIGV2ZW50LiBUaGlzIGNhdXNlcyBhbiBpc3N1ZSB3aGVuIHlvdSdyZSBoaWRpbmdcclxuICAgICAgICAgIC8vIHRoZSBjdXJzb3Igd2hlbiB0aGUgdXNlciBpcyBpbmFjdGl2ZSwgYW5kIGEgbW91c2Vtb3ZlIHNpZ25hbHMgdXNlclxyXG4gICAgICAgICAgLy8gYWN0aXZpdHkuIE1ha2luZyBpdCBpbXBvc3NpYmxlIHRvIGdvIGludG8gaW5hY3RpdmUgbW9kZS4gU3BlY2lmaWNhbGx5XHJcbiAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgaW4gZnVsbHNjcmVlbiB3aGVuIHdlIHJlYWxseSBuZWVkIHRvIGhpZGUgdGhlIGN1cnNvci5cclxuICAgICAgICAgIC8vXHJcbiAgICAgICAgICAvLyBXaGVuIHRoaXMgZ2V0cyByZXNvbHZlZCBpbiBBTEwgYnJvd3NlcnMgaXQgY2FuIGJlIHJlbW92ZWRcclxuICAgICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDMwNDFcclxuICAgICAgICAgIGlmICh0aGlzLnRlY2hfKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGVjaF8ub25lKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLnJlbW92ZUNsYXNzKCd2anMtdXNlci1hY3RpdmUnKTtcclxuICAgICAgICAgIHRoaXMuYWRkQ2xhc3MoJ3Zqcy11c2VyLWluYWN0aXZlJyk7XHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIEBldmVudCBQbGF5ZXIjdXNlcmluYWN0aXZlXHJcbiAgICAgICAgICAgKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAgICAgICAgICAgKi9cclxuICAgICAgICAgIHRoaXMudHJpZ2dlcigndXNlcmluYWN0aXZlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnVzZXJBY3RpdmVfO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIExpc3RlbiBmb3IgdXNlciBhY3Rpdml0eSBiYXNlZCBvbiB0aW1lb3V0IHZhbHVlXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5saXN0ZW5Gb3JVc2VyQWN0aXZpdHlfID0gZnVuY3Rpb24gbGlzdGVuRm9yVXNlckFjdGl2aXR5XygpIHtcclxuICAgIHZhciBtb3VzZUluUHJvZ3Jlc3MgPSB2b2lkIDA7XHJcbiAgICB2YXIgbGFzdE1vdmVYID0gdm9pZCAwO1xyXG4gICAgdmFyIGxhc3RNb3ZlWSA9IHZvaWQgMDtcclxuICAgIHZhciBoYW5kbGVBY3Rpdml0eSA9IGJpbmQodGhpcywgdGhpcy5yZXBvcnRVc2VyQWN0aXZpdHkpO1xyXG5cclxuICAgIHZhciBoYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoZSkge1xyXG4gICAgICAvLyAjMTA2OCAtIFByZXZlbnQgbW91c2Vtb3ZlIHNwYW1taW5nXHJcbiAgICAgIC8vIENocm9tZSBCdWc6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNjY5NzBcclxuICAgICAgaWYgKGUuc2NyZWVuWCAhPT0gbGFzdE1vdmVYIHx8IGUuc2NyZWVuWSAhPT0gbGFzdE1vdmVZKSB7XHJcbiAgICAgICAgbGFzdE1vdmVYID0gZS5zY3JlZW5YO1xyXG4gICAgICAgIGxhc3RNb3ZlWSA9IGUuc2NyZWVuWTtcclxuICAgICAgICBoYW5kbGVBY3Rpdml0eSgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBoYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd24oKSB7XHJcbiAgICAgIGhhbmRsZUFjdGl2aXR5KCk7XHJcbiAgICAgIC8vIEZvciBhcyBsb25nIGFzIHRoZSB0aGV5IGFyZSB0b3VjaGluZyB0aGUgZGV2aWNlIG9yIGhhdmUgdGhlaXIgbW91c2UgZG93bixcclxuICAgICAgLy8gd2UgY29uc2lkZXIgdGhlbSBhY3RpdmUgZXZlbiBpZiB0aGV5J3JlIG5vdCBtb3ZpbmcgdGhlaXIgZmluZ2VyIG9yIG1vdXNlLlxyXG4gICAgICAvLyBTbyB3ZSB3YW50IHRvIGNvbnRpbnVlIHRvIHVwZGF0ZSB0aGF0IHRoZXkgYXJlIGFjdGl2ZVxyXG4gICAgICB0aGlzLmNsZWFySW50ZXJ2YWwobW91c2VJblByb2dyZXNzKTtcclxuICAgICAgLy8gU2V0dGluZyB1c2VyQWN0aXZpdHk9dHJ1ZSBub3cgYW5kIHNldHRpbmcgdGhlIGludGVydmFsIHRvIHRoZSBzYW1lIHRpbWVcclxuICAgICAgLy8gYXMgdGhlIGFjdGl2aXR5Q2hlY2sgaW50ZXJ2YWwgKDI1MCkgc2hvdWxkIGVuc3VyZSB3ZSBuZXZlciBtaXNzIHRoZVxyXG4gICAgICAvLyBuZXh0IGFjdGl2aXR5Q2hlY2tcclxuICAgICAgbW91c2VJblByb2dyZXNzID0gdGhpcy5zZXRJbnRlcnZhbChoYW5kbGVBY3Rpdml0eSwgMjUwKTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGV2ZW50KSB7XHJcbiAgICAgIGhhbmRsZUFjdGl2aXR5KCk7XHJcbiAgICAgIC8vIFN0b3AgdGhlIGludGVydmFsIHRoYXQgbWFpbnRhaW5zIGFjdGl2aXR5IGlmIHRoZSBtb3VzZS90b3VjaCBpcyBkb3duXHJcbiAgICAgIHRoaXMuY2xlYXJJbnRlcnZhbChtb3VzZUluUHJvZ3Jlc3MpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBBbnkgbW91c2UgbW92ZW1lbnQgd2lsbCBiZSBjb25zaWRlcmVkIHVzZXIgYWN0aXZpdHlcclxuICAgIHRoaXMub24oJ21vdXNlZG93bicsIGhhbmRsZU1vdXNlRG93bik7XHJcbiAgICB0aGlzLm9uKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xyXG4gICAgdGhpcy5vbignbW91c2V1cCcsIGhhbmRsZU1vdXNlVXApO1xyXG5cclxuICAgIC8vIExpc3RlbiBmb3Iga2V5Ym9hcmQgbmF2aWdhdGlvblxyXG4gICAgLy8gU2hvdWxkbid0IG5lZWQgdG8gdXNlIGluUHJvZ3Jlc3MgaW50ZXJ2YWwgYmVjYXVzZSBvZiBrZXkgcmVwZWF0XHJcbiAgICB0aGlzLm9uKCdrZXlkb3duJywgaGFuZGxlQWN0aXZpdHkpO1xyXG4gICAgdGhpcy5vbigna2V5dXAnLCBoYW5kbGVBY3Rpdml0eSk7XHJcblxyXG4gICAgLy8gUnVuIGFuIGludGVydmFsIGV2ZXJ5IDI1MCBtaWxsaXNlY29uZHMgaW5zdGVhZCBvZiBzdHVmZmluZyBldmVyeXRoaW5nIGludG9cclxuICAgIC8vIHRoZSBtb3VzZW1vdmUvdG91Y2htb3ZlIGZ1bmN0aW9uIGl0c2VsZiwgdG8gcHJldmVudCBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbi5cclxuICAgIC8vIGB0aGlzLnJlcG9ydFVzZXJBY3Rpdml0eWAgc2ltcGx5IHNldHMgdGhpcy51c2VyQWN0aXZpdHlfIHRvIHRydWUsIHdoaWNoXHJcbiAgICAvLyB0aGVuIGdldHMgcGlja2VkIHVwIGJ5IHRoaXMgbG9vcFxyXG4gICAgLy8gaHR0cDovL2Vqb2huLm9yZy9ibG9nL2xlYXJuaW5nLWZyb20tdHdpdHRlci9cclxuICAgIHZhciBpbmFjdGl2aXR5VGltZW91dCA9IHZvaWQgMDtcclxuXHJcbiAgICB0aGlzLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIG1vdXNlL3RvdWNoIGFjdGl2aXR5IGhhcyBoYXBwZW5lZFxyXG4gICAgICBpZiAodGhpcy51c2VyQWN0aXZpdHlfKSB7XHJcbiAgICAgICAgLy8gUmVzZXQgdGhlIGFjdGl2aXR5IHRyYWNrZXJcclxuICAgICAgICB0aGlzLnVzZXJBY3Rpdml0eV8gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgc3RhdGUgd2FzIGluYWN0aXZlLCBzZXQgdGhlIHN0YXRlIHRvIGFjdGl2ZVxyXG4gICAgICAgIHRoaXMudXNlckFjdGl2ZSh0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIGluYWN0aXZpdHkgdGltZW91dCB0byBzdGFydCB0aGUgdGltZXIgb3ZlclxyXG4gICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KGluYWN0aXZpdHlUaW1lb3V0KTtcclxuXHJcbiAgICAgICAgdmFyIHRpbWVvdXQgPSB0aGlzLm9wdGlvbnNfLmluYWN0aXZpdHlUaW1lb3V0O1xyXG5cclxuICAgICAgICBpZiAodGltZW91dCA+IDApIHtcclxuICAgICAgICAgIC8vIEluIDx0aW1lb3V0PiBtaWxsaXNlY29uZHMsIGlmIG5vIG1vcmUgYWN0aXZpdHkgaGFzIG9jY3VycmVkIHRoZVxyXG4gICAgICAgICAgLy8gdXNlciB3aWxsIGJlIGNvbnNpZGVyZWQgaW5hY3RpdmVcclxuICAgICAgICAgIGluYWN0aXZpdHlUaW1lb3V0ID0gdGhpcy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IHRoZSBjYXNlIHdoZXJlIHRoZSBpbmFjdGl2aXR5VGltZW91dCBjYW4gdHJpZ2dlciBqdXN0XHJcbiAgICAgICAgICAgIC8vIGJlZm9yZSB0aGUgbmV4dCB1c2VyIGFjdGl2aXR5IGlzIHBpY2tlZCB1cCBieSB0aGUgYWN0aXZpdHkgY2hlY2sgbG9vcFxyXG4gICAgICAgICAgICAvLyBjYXVzaW5nIGEgZmxpY2tlclxyXG4gICAgICAgICAgICBpZiAoIXRoaXMudXNlckFjdGl2aXR5Xykge1xyXG4gICAgICAgICAgICAgIHRoaXMudXNlckFjdGl2ZShmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0sIHRpbWVvdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSwgMjUwKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZS4gQSBwbGF5YmFjayByYXRlIG9mXHJcbiAgICogMS4wIHJlcHJlc2VudHMgbm9ybWFsIHNwZWVkIGFuZCAwLjUgd291bGQgaW5kaWNhdGUgaGFsZi1zcGVlZFxyXG4gICAqIHBsYXliYWNrLCBmb3IgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tbWVkaWEtcGxheWJhY2tyYXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JhdGVdXHJcbiAgICogICAgICAgTmV3IHBsYXliYWNrIHJhdGUgdG8gc2V0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgcGxheWJhY2sgcmF0ZSB3aGVuIGdldHRpbmcgb3IgMS4wXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLnBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uIHBsYXliYWNrUmF0ZShyYXRlKSB7XHJcbiAgICBpZiAocmF0ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMudGVjaENhbGxfKCdzZXRQbGF5YmFja1JhdGUnLCByYXRlKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8uZmVhdHVyZXNQbGF5YmFja1JhdGUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudGVjaEdldF8oJ3BsYXliYWNrUmF0ZScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDEuMDtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgZGVmYXVsdCBwbGF5YmFjayByYXRlLiBBIGRlZmF1bHQgcGxheWJhY2sgcmF0ZSBvZlxyXG4gICAqIDEuMCByZXByZXNlbnRzIG5vcm1hbCBzcGVlZCBhbmQgMC41IHdvdWxkIGluZGljYXRlIGhhbGYtc3BlZWQgcGxheWJhY2ssIGZvciBpbnN0YW5jZS5cclxuICAgKiBkZWZhdWx0UGxheWJhY2tSYXRlIHdpbGwgb25seSByZXByZXNlbnQgd2hhdCB0aGUgaW50aWFsIHBsYXliYWNrUmF0ZSBvZiBhIHZpZGVvIHdhcywgbm90XHJcbiAgICogbm90IHRoZSBjdXJyZW50IHBsYXliYWNrUmF0ZS5cclxuICAgKlxyXG4gICAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW1iZWRkZWQtY29udGVudC5odG1sI2RvbS1tZWRpYS1kZWZhdWx0cGxheWJhY2tyYXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3JhdGVdXHJcbiAgICogICAgICAgTmV3IGRlZmF1bHQgcGxheWJhY2sgcmF0ZSB0byBzZXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ8UGxheWVyfVxyXG4gICAqICAgICAgICAgLSBUaGUgZGVmYXVsdCBwbGF5YmFjayByYXRlIHdoZW4gZ2V0dGluZyBvciAxLjBcclxuICAgKiAgICAgICAgIC0gdGhlIHBsYXllciB3aGVuIHNldHRpbmdcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuZGVmYXVsdFBsYXliYWNrUmF0ZSA9IGZ1bmN0aW9uIGRlZmF1bHRQbGF5YmFja1JhdGUocmF0ZSkge1xyXG4gICAgaWYgKHJhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdGhpcy50ZWNoQ2FsbF8oJ3NldERlZmF1bHRQbGF5YmFja1JhdGUnLCByYXRlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLmZlYXR1cmVzUGxheWJhY2tSYXRlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdkZWZhdWx0UGxheWJhY2tSYXRlJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMS4wO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgYXVkaW8gZmxhZ1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBib29sXHJcbiAgICogICAgICAgIC0gdHJ1ZSBzaWduYWxzIHRoYXQgdGhpcyBpcyBhbiBhdWRpbyBwbGF5ZXJcclxuICAgKiAgICAgICAgLSBmYWxzZSBzaWduYWxzIHRoYXQgdGhpcyBpcyBub3QgYW4gYXVkaW8gcGxheWVyXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgdmFsdWUgb2YgaXNBdWRpbyB3aGVuIGdldHRpbmdcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuaXNBdWRpbyA9IGZ1bmN0aW9uIGlzQXVkaW8oYm9vbCkge1xyXG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLmlzQXVkaW9fID0gISFib29sO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICEhdGhpcy5pc0F1ZGlvXztcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBIGhlbHBlciBtZXRob2QgZm9yIGFkZGluZyBhIHtAbGluayBUZXh0VHJhY2t9IHRvIG91clxyXG4gICAqIHtAbGluayBUZXh0VHJhY2tMaXN0fS5cclxuICAgKlxyXG4gICAqIEluIGFkZGl0aW9uIHRvIHRoZSBXM0Mgc2V0dGluZ3Mgd2UgYWxsb3cgYWRkaW5nIGFkZGl0aW9uYWwgaW5mbyB0aHJvdWdoIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI2RvbS1tZWRpYS1hZGR0ZXh0dHJhY2tcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBba2luZF1cclxuICAgKiAgICAgICAgdGhlIGtpbmQgb2YgVGV4dFRyYWNrIHlvdSBhcmUgYWRkaW5nXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhYmVsXVxyXG4gICAqICAgICAgICB0aGUgbGFiZWwgdG8gZ2l2ZSB0aGUgVGV4dFRyYWNrIGxhYmVsXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlXVxyXG4gICAqICAgICAgICB0aGUgbGFuZ3VhZ2UgdG8gc2V0IG9uIHRoZSBUZXh0VHJhY2tcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1RleHRUcmFja3x1bmRlZmluZWR9XHJcbiAgICogICAgICAgICB0aGUgVGV4dFRyYWNrIHRoYXQgd2FzIGFkZGVkIG9yIHVuZGVmaW5lZFxyXG4gICAqICAgICAgICAgaWYgdGhlcmUgaXMgbm8gdGVjaFxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5hZGRUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKSB7XHJcbiAgICBpZiAodGhpcy50ZWNoXykge1xyXG4gICAgICByZXR1cm4gdGhpcy50ZWNoXy5hZGRUZXh0VHJhY2soa2luZCwgbGFiZWwsIGxhbmd1YWdlKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSByZW1vdGUge0BsaW5rIFRleHRUcmFja30gYW5kIGFuIHtAbGluayBIVE1MVHJhY2tFbGVtZW50fS4gSXQgd2lsbFxyXG4gICAqIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHRoZSB2aWRlbyBlbGVtZW50IHdoZW5ldmVyIHRoZSBzb3VyY2UgY2hhbmdlcywgdW5sZXNzXHJcbiAgICogbWFudWFsQ2xlYW51cCBpcyBzZXQgdG8gZmFsc2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAqICAgICAgICBPcHRpb25zIHRvIHBhc3MgdG8ge0BsaW5rIEhUTUxUcmFja0VsZW1lbnR9IGR1cmluZyBjcmVhdGlvbi4gU2VlXHJcbiAgICogICAgICAgIHtAbGluayBIVE1MVHJhY2tFbGVtZW50fSBmb3Igb2JqZWN0IHByb3BlcnRpZXMgdGhhdCB5b3Ugc2hvdWxkIHVzZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW21hbnVhbENsZWFudXA9dHJ1ZV0gaWYgc2V0IHRvIGZhbHNlLCB0aGUgVGV4dFRyYWNrIHdpbGwgYmVcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0h0bWxUcmFja0VsZW1lbnR9XHJcbiAgICogICAgICAgICB0aGUgSFRNTFRyYWNrRWxlbWVudCB0aGF0IHdhcyBjcmVhdGVkIGFuZCBhZGRlZFxyXG4gICAqICAgICAgICAgdG8gdGhlIEh0bWxUcmFja0VsZW1lbnRMaXN0IGFuZCB0aGUgcmVtb3RlXHJcbiAgICogICAgICAgICBUZXh0VHJhY2tMaXN0XHJcbiAgICpcclxuICAgKiBAZGVwcmVjYXRlZCBUaGUgZGVmYXVsdCB2YWx1ZSBvZiB0aGUgXCJtYW51YWxDbGVhbnVwXCIgcGFyYW1ldGVyIHdpbGwgZGVmYXVsdFxyXG4gICAqICAgICAgICAgICAgIHRvIFwiZmFsc2VcIiBpbiB1cGNvbWluZyB2ZXJzaW9ucyBvZiBWaWRlby5qc1xyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5hZGRSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiBhZGRSZW1vdGVUZXh0VHJhY2sob3B0aW9ucywgbWFudWFsQ2xlYW51cCkge1xyXG4gICAgaWYgKHRoaXMudGVjaF8pIHtcclxuICAgICAgcmV0dXJuIHRoaXMudGVjaF8uYWRkUmVtb3RlVGV4dFRyYWNrKG9wdGlvbnMsIG1hbnVhbENsZWFudXApO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhIHJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrfSBmcm9tIHRoZSByZXNwZWN0aXZlXHJcbiAgICoge0BsaW5rIFRleHRUcmFja0xpc3R9IGFuZCB7QGxpbmsgSHRtbFRyYWNrRWxlbWVudExpc3R9LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyYWNrXHJcbiAgICogICAgICAgIFJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrfSB0byByZW1vdmVcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cclxuICAgKiAgICAgICAgIGRvZXMgbm90IHJldHVybiBhbnl0aGluZ1xyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5yZW1vdmVSZW1vdGVUZXh0VHJhY2sgPSBmdW5jdGlvbiByZW1vdmVSZW1vdGVUZXh0VHJhY2soKSB7XHJcbiAgICB2YXIgX3JlZjMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxyXG4gICAgICAgIF9yZWYzJHRyYWNrID0gX3JlZjMudHJhY2ssXHJcbiAgICAgICAgdHJhY2sgPSBfcmVmMyR0cmFjayA9PT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogX3JlZjMkdHJhY2s7XHJcblxyXG4gICAgLy8gZGVzdHJ1Y3R1cmUgdGhlIGlucHV0IGludG8gYW4gb2JqZWN0IHdpdGggYSB0cmFjayBhcmd1bWVudCwgZGVmYXVsdGluZyB0byBhcmd1bWVudHNbMF1cclxuICAgIC8vIGRlZmF1bHQgdGhlIHdob2xlIGFyZ3VtZW50IHRvIGFuIGVtcHR5IG9iamVjdCBpZiBub3RoaW5nIHdhcyBwYXNzZWQgaW5cclxuXHJcbiAgICBpZiAodGhpcy50ZWNoXykge1xyXG4gICAgICByZXR1cm4gdGhpcy50ZWNoXy5yZW1vdmVSZW1vdGVUZXh0VHJhY2sodHJhY2spO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYXZhaWxhYmxlIG1lZGlhIHBsYXliYWNrIHF1YWxpdHkgbWV0cmljcyBhcyBzcGVjaWZpZWQgYnkgdGhlIFczQydzIE1lZGlhXHJcbiAgICogUGxheWJhY2sgUXVhbGl0eSBBUEkuXHJcbiAgICpcclxuICAgKiBAc2VlIFtTcGVjXXtAbGluayBodHRwczovL3dpY2cuZ2l0aHViLmlvL21lZGlhLXBsYXliYWNrLXF1YWxpdHl9XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxyXG4gICAqICAgICAgICAgQW4gb2JqZWN0IHdpdGggc3VwcG9ydGVkIG1lZGlhIHBsYXliYWNrIHF1YWxpdHkgbWV0cmljcyBvciB1bmRlZmluZWQgaWYgdGhlcmVcclxuICAgKiAgICAgICAgIGlzIG5vIHRlY2ggb3IgdGhlIHRlY2ggZG9lcyBub3Qgc3VwcG9ydCBpdC5cclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPSBmdW5jdGlvbiBnZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpIHtcclxuICAgIHJldHVybiB0aGlzLnRlY2hHZXRfKCdnZXRWaWRlb1BsYXliYWNrUXVhbGl0eScpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB2aWRlbyB3aWR0aFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqICAgICAgICAgY3VycmVudCB2aWRlbyB3aWR0aFxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS52aWRlb1dpZHRoID0gZnVuY3Rpb24gdmlkZW9XaWR0aCgpIHtcclxuICAgIHJldHVybiB0aGlzLnRlY2hfICYmIHRoaXMudGVjaF8udmlkZW9XaWR0aCAmJiB0aGlzLnRlY2hfLnZpZGVvV2lkdGgoKSB8fCAwO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB2aWRlbyBoZWlnaHRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn1cclxuICAgKiAgICAgICAgIGN1cnJlbnQgdmlkZW8gaGVpZ2h0XHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLnZpZGVvSGVpZ2h0ID0gZnVuY3Rpb24gdmlkZW9IZWlnaHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50ZWNoXyAmJiB0aGlzLnRlY2hfLnZpZGVvSGVpZ2h0ICYmIHRoaXMudGVjaF8udmlkZW9IZWlnaHQoKSB8fCAwO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBwbGF5ZXIncyBsYW5ndWFnZSBjb2RlXHJcbiAgICogTk9URTogVGhlIGxhbmd1YWdlIHNob3VsZCBiZSBzZXQgaW4gdGhlIHBsYXllciBvcHRpb25zIGlmIHlvdSB3YW50IHRoZVxyXG4gICAqIHRoZSBjb250cm9scyB0byBiZSBidWlsdCB3aXRoIGEgc3BlY2lmaWMgbGFuZ3VhZ2UuIENoYW5naW5nIHRoZSBsYW51Z2FnZVxyXG4gICAqIGxhdGVyIHdpbGwgbm90IHVwZGF0ZSBjb250cm9scyB0ZXh0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXVxyXG4gICAqICAgICAgICB0aGUgbGFuZ3VhZ2UgY29kZSB0byBzZXQgdGhlIHBsYXllciB0b1xyXG4gICAqXHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxyXG4gICAqICAgICAgICAgVGhlIGN1cnJlbnQgbGFuZ3VhZ2UgY29kZSB3aGVuIGdldHRpbmdcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUubGFuZ3VhZ2UgPSBmdW5jdGlvbiBsYW5ndWFnZShjb2RlKSB7XHJcbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmxhbmd1YWdlXztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxhbmd1YWdlXyA9IFN0cmluZyhjb2RlKS50b0xvd2VyQ2FzZSgpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcGxheWVyJ3MgbGFuZ3VhZ2UgZGljdGlvbmFyeVxyXG4gICAqIE1lcmdlIGV2ZXJ5IHRpbWUsIGJlY2F1c2UgYSBuZXdseSBhZGRlZCBwbHVnaW4gbWlnaHQgY2FsbCB2aWRlb2pzLmFkZExhbmd1YWdlKCkgYXQgYW55IHRpbWVcclxuICAgKiBMYW5ndWFnZXMgc3BlY2lmaWVkIGRpcmVjdGx5IGluIHRoZSBwbGF5ZXIgb3B0aW9ucyBoYXZlIHByZWNlZGVuY2VcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0FycmF5fVxyXG4gICAqICAgICAgICAgQW4gYXJyYXkgb2Ygb2Ygc3VwcG9ydGVkIGxhbmd1YWdlc1xyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5sYW5ndWFnZXMgPSBmdW5jdGlvbiBsYW5ndWFnZXMoKSB7XHJcbiAgICByZXR1cm4gbWVyZ2VPcHRpb25zKFBsYXllci5wcm90b3R5cGUub3B0aW9uc18ubGFuZ3VhZ2VzLCB0aGlzLmxhbmd1YWdlc18pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIHJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdCByZXBlcmVzZW50aW5nIHRoZSBjdXJyZW50IHRyYWNrXHJcbiAgICogaW5mb3JtYXRpb24uICoqRE9FUyBub3QgcmV0dXJuIGl0IGFzIEpTT04qKlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqICAgICAgICAgT2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBvZiB0cmFjayBpbmZvXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcclxuICAgIHZhciBvcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9uc18pO1xyXG4gICAgdmFyIHRyYWNrcyA9IG9wdGlvbnMudHJhY2tzO1xyXG5cclxuICAgIG9wdGlvbnMudHJhY2tzID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW2ldO1xyXG5cclxuICAgICAgLy8gZGVlcCBtZXJnZSB0cmFja3MgYW5kIG51bGwgb3V0IHBsYXllciBzbyBubyBjaXJjdWxhciByZWZlcmVuY2VzXHJcbiAgICAgIHRyYWNrID0gbWVyZ2VPcHRpb25zKHRyYWNrKTtcclxuICAgICAgdHJhY2sucGxheWVyID0gdW5kZWZpbmVkO1xyXG4gICAgICBvcHRpb25zLnRyYWNrc1tpXSA9IHRyYWNrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvcHRpb25zO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBzaW1wbGUgbW9kYWwgZGlhbG9nIChhbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIE1vZGFsRGlhbG9nfVxyXG4gICAqIGNvbXBvbmVudCkgdGhhdCBpbW1lZGlhdGVseSBvdmVybGF5cyB0aGUgcGxheWVyIHdpdGggYXJiaXRyYXJ5XHJcbiAgICogY29udGVudCBhbmQgcmVtb3ZlcyBpdHNlbGYgd2hlbiBjbG9zZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ3xGdW5jdGlvbnxFbGVtZW50fEFycmF5fG51bGx9IGNvbnRlbnRcclxuICAgKiAgICAgICAgU2FtZSBhcyB7QGxpbmsgTW9kYWxEaWFsb2cjY29udGVudH0ncyBwYXJhbSBvZiB0aGUgc2FtZSBuYW1lLlxyXG4gICAqICAgICAgICBUaGUgbW9zdCBzdHJhaWdodC1mb3J3YXJkIHVzYWdlIGlzIHRvIHByb3ZpZGUgYSBzdHJpbmcgb3IgRE9NXHJcbiAgICogICAgICAgIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogICAgICAgIEV4dHJhIG9wdGlvbnMgd2hpY2ggd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhlIHtAbGluayBNb2RhbERpYWxvZ30uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtNb2RhbERpYWxvZ31cclxuICAgKiAgICAgICAgIHRoZSB7QGxpbmsgTW9kYWxEaWFsb2d9IHRoYXQgd2FzIGNyZWF0ZWRcclxuICAgKi9cclxuXHJcblxyXG4gIFBsYXllci5wcm90b3R5cGUuY3JlYXRlTW9kYWwgPSBmdW5jdGlvbiBjcmVhdGVNb2RhbChjb250ZW50LCBvcHRpb25zKSB7XHJcbiAgICB2YXIgX3RoaXM3ID0gdGhpcztcclxuXHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIG9wdGlvbnMuY29udGVudCA9IGNvbnRlbnQgfHwgJyc7XHJcblxyXG4gICAgdmFyIG1vZGFsID0gbmV3IE1vZGFsRGlhbG9nKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICAgIHRoaXMuYWRkQ2hpbGQobW9kYWwpO1xyXG4gICAgbW9kYWwub24oJ2Rpc3Bvc2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIF90aGlzNy5yZW1vdmVDaGlsZChtb2RhbCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb2RhbC5vcGVuKCk7XHJcbiAgICByZXR1cm4gbW9kYWw7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0YWcgc2V0dGluZ3NcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFnXHJcbiAgICogICAgICAgIFRoZSBwbGF5ZXIgdGFnXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICogICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgb2YgdGhlIHNldHRpbmdzXHJcbiAgICogICAgICAgICBmb3IgYSBwbGF5ZXIgdGFnXHJcbiAgICovXHJcblxyXG5cclxuICBQbGF5ZXIuZ2V0VGFnU2V0dGluZ3MgPSBmdW5jdGlvbiBnZXRUYWdTZXR0aW5ncyh0YWcpIHtcclxuICAgIHZhciBiYXNlT3B0aW9ucyA9IHtcclxuICAgICAgc291cmNlczogW10sXHJcbiAgICAgIHRyYWNrczogW11cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHRhZ09wdGlvbnMgPSBnZXRBdHRyaWJ1dGVzKHRhZyk7XHJcbiAgICB2YXIgZGF0YVNldHVwID0gdGFnT3B0aW9uc1snZGF0YS1zZXR1cCddO1xyXG5cclxuICAgIGlmIChoYXNDbGFzcyh0YWcsICd2anMtZmx1aWQnKSkge1xyXG4gICAgICB0YWdPcHRpb25zLmZsdWlkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiBkYXRhLXNldHVwIGF0dHIgZXhpc3RzLlxyXG4gICAgaWYgKGRhdGFTZXR1cCAhPT0gbnVsbCkge1xyXG4gICAgICAvLyBQYXJzZSBvcHRpb25zIEpTT05cclxuICAgICAgLy8gSWYgZW1wdHkgc3RyaW5nLCBtYWtlIGl0IGEgcGFyc2FibGUganNvbiBvYmplY3QuXHJcbiAgICAgIHZhciBfc2FmZVBhcnNlVHVwbGUgPSB0dXBsZShkYXRhU2V0dXAgfHwgJ3t9JyksXHJcbiAgICAgICAgICBlcnIgPSBfc2FmZVBhcnNlVHVwbGVbMF0sXHJcbiAgICAgICAgICBkYXRhID0gX3NhZmVQYXJzZVR1cGxlWzFdO1xyXG5cclxuICAgICAgaWYgKGVycikge1xyXG4gICAgICAgIGxvZyQxLmVycm9yKGVycik7XHJcbiAgICAgIH1cclxuICAgICAgYXNzaWduKHRhZ09wdGlvbnMsIGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIGFzc2lnbihiYXNlT3B0aW9ucywgdGFnT3B0aW9ucyk7XHJcblxyXG4gICAgLy8gR2V0IHRhZyBjaGlsZHJlbiBzZXR0aW5nc1xyXG4gICAgaWYgKHRhZy5oYXNDaGlsZE5vZGVzKCkpIHtcclxuICAgICAgdmFyIGNoaWxkcmVuID0gdGFnLmNoaWxkTm9kZXM7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIC8vIENoYW5nZSBjYXNlIG5lZWRlZDogaHR0cDovL2Vqb2huLm9yZy9ibG9nL25vZGVuYW1lLWNhc2Utc2Vuc2l0aXZpdHkvXHJcbiAgICAgICAgdmFyIGNoaWxkTmFtZSA9IGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIGlmIChjaGlsZE5hbWUgPT09ICdzb3VyY2UnKSB7XHJcbiAgICAgICAgICBiYXNlT3B0aW9ucy5zb3VyY2VzLnB1c2goZ2V0QXR0cmlidXRlcyhjaGlsZCkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGROYW1lID09PSAndHJhY2snKSB7XHJcbiAgICAgICAgICBiYXNlT3B0aW9ucy50cmFja3MucHVzaChnZXRBdHRyaWJ1dGVzKGNoaWxkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGJhc2VPcHRpb25zO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZSB3ZXRoZXIgb3Igbm90IGZsZXhib3ggaXMgc3VwcG9ydGVkXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqICAgICAgICAgLSB0cnVlIGlmIGZsZXhib3ggaXMgc3VwcG9ydGVkXHJcbiAgICogICAgICAgICAtIGZhbHNlIGlmIGZsZXhib3ggaXMgbm90IHN1cHBvcnRlZFxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGxheWVyLnByb3RvdHlwZS5mbGV4Tm90U3VwcG9ydGVkXyA9IGZ1bmN0aW9uIGZsZXhOb3RTdXBwb3J0ZWRfKCkge1xyXG4gICAgdmFyIGVsZW0gPSBkb2N1bWVudF8xLmNyZWF0ZUVsZW1lbnQoJ2knKTtcclxuXHJcbiAgICAvLyBOb3RlOiBXZSBkb24ndCBhY3R1YWxseSB1c2UgZmxleEJhc2lzIChvciBmbGV4T3JkZXIpLCBidXQgaXQncyBvbmUgb2YgdGhlIG1vcmVcclxuICAgIC8vIGNvbW1vbiBmbGV4IGZlYXR1cmVzIHRoYXQgd2UgY2FuIHJlbHkgb24gd2hlbiBjaGVja2luZyBmb3IgZmxleCBzdXBwb3J0LlxyXG4gICAgcmV0dXJuICEoJ2ZsZXhCYXNpcycgaW4gZWxlbS5zdHlsZSB8fCAnd2Via2l0RmxleEJhc2lzJyBpbiBlbGVtLnN0eWxlIHx8ICdtb3pGbGV4QmFzaXMnIGluIGVsZW0uc3R5bGUgfHwgJ21zRmxleEJhc2lzJyBpbiBlbGVtLnN0eWxlIHx8XHJcbiAgICAvLyBJRTEwLXNwZWNpZmljICgyMDEyIGZsZXggc3BlYylcclxuICAgICdtc0ZsZXhPcmRlcicgaW4gZWxlbS5zdHlsZSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIFBsYXllcjtcclxufShDb21wb25lbnQpO1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUge0BsaW5rIFZpZGVvVHJhY2tMaXN0fVxyXG4gKiBAbGluayBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdmlkZW90cmFja2xpc3RcclxuICpcclxuICogQHJldHVybiB7VmlkZW9UcmFja0xpc3R9XHJcbiAqICAgICAgICAgdGhlIGN1cnJlbnQgdmlkZW8gdHJhY2sgbGlzdFxyXG4gKlxyXG4gKiBAbWV0aG9kIFBsYXllci5wcm90b3R5cGUudmlkZW9UcmFja3NcclxuICovXHJcblxyXG4vKipcclxuICogR2V0IHRoZSB7QGxpbmsgQXVkaW9UcmFja0xpc3R9XHJcbiAqIEBsaW5rIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNhdWRpb3RyYWNrbGlzdFxyXG4gKlxyXG4gKiBAcmV0dXJuIHtBdWRpb1RyYWNrTGlzdH1cclxuICogICAgICAgICB0aGUgY3VycmVudCBhdWRpbyB0cmFjayBsaXN0XHJcbiAqXHJcbiAqIEBtZXRob2QgUGxheWVyLnByb3RvdHlwZS5hdWRpb1RyYWNrc1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHtAbGluayBUZXh0VHJhY2tMaXN0fVxyXG4gKlxyXG4gKiBAbGluayBodHRwOi8vd3d3LnczLm9yZy9odG1sL3dnL2RyYWZ0cy9odG1sL21hc3Rlci9lbWJlZGRlZC1jb250ZW50LTAuaHRtbCNkb20tbWVkaWEtdGV4dHRyYWNrc1xyXG4gKlxyXG4gKiBAcmV0dXJuIHtUZXh0VHJhY2tMaXN0fVxyXG4gKiAgICAgICAgIHRoZSBjdXJyZW50IHRleHQgdHJhY2sgbGlzdFxyXG4gKlxyXG4gKiBAbWV0aG9kIFBsYXllci5wcm90b3R5cGUudGV4dFRyYWNrc1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHJlbW90ZSB7QGxpbmsgVGV4dFRyYWNrTGlzdH1cclxuICpcclxuICogQHJldHVybiB7VGV4dFRyYWNrTGlzdH1cclxuICogICAgICAgICBUaGUgY3VycmVudCByZW1vdGUgdGV4dCB0cmFjayBsaXN0XHJcbiAqXHJcbiAqIEBtZXRob2QgUGxheWVyLnByb3RvdHlwZS5yZW1vdGVUZXh0VHJhY2tzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgcmVtb3RlIHtAbGluayBIdG1sVHJhY2tFbGVtZW50TGlzdH0gdHJhY2tzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtIdG1sVHJhY2tFbGVtZW50TGlzdH1cclxuICogICAgICAgICBUaGUgY3VycmVudCByZW1vdGUgdGV4dCB0cmFjayBlbGVtZW50IGxpc3RcclxuICpcclxuICogQG1ldGhvZCBQbGF5ZXIucHJvdG90eXBlLnJlbW90ZVRleHRUcmFja0Vsc1xyXG4gKi9cclxuXHJcbkFMTC5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lJCQxKSB7XHJcbiAgdmFyIHByb3BzID0gQUxMW25hbWUkJDFdO1xyXG5cclxuICBQbGF5ZXIucHJvdG90eXBlW3Byb3BzLmdldHRlck5hbWVdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMudGVjaF8pIHtcclxuICAgICAgcmV0dXJuIHRoaXMudGVjaF9bcHJvcHMuZ2V0dGVyTmFtZV0oKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpZiB3ZSBoYXZlIG5vdCB5ZXQgbG9hZFRlY2hfLCB3ZSBjcmVhdGUge3ZpZGVvLGF1ZGlvLHRleHR9VHJhY2tzX1xyXG4gICAgLy8gdGhlc2Ugd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHRlY2ggZHVyaW5nIGxvYWRpbmdcclxuICAgIHRoaXNbcHJvcHMucHJpdmF0ZU5hbWVdID0gdGhpc1twcm9wcy5wcml2YXRlTmFtZV0gfHwgbmV3IHByb3BzLkxpc3RDbGFzcygpO1xyXG4gICAgcmV0dXJuIHRoaXNbcHJvcHMucHJpdmF0ZU5hbWVdO1xyXG4gIH07XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEdsb2JhbCBwbGF5ZXIgbGlzdFxyXG4gKlxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cclxuUGxheWVyLnBsYXllcnMgPSB7fTtcclxuXHJcbnZhciBuYXZpZ2F0b3IkMSA9IHdpbmRvd18xLm5hdmlnYXRvcjtcclxuXHJcbi8qXHJcbiAqIFBsYXllciBpbnN0YW5jZSBvcHRpb25zLCBzdXJmYWNlZCB1c2luZyBvcHRpb25zXHJcbiAqIG9wdGlvbnMgPSBQbGF5ZXIucHJvdG90eXBlLm9wdGlvbnNfXHJcbiAqIE1ha2UgY2hhbmdlcyBpbiBvcHRpb25zLCBub3QgaGVyZS5cclxuICpcclxuICogQHR5cGUge09iamVjdH1cclxuICogQHByaXZhdGVcclxuICovXHJcblBsYXllci5wcm90b3R5cGUub3B0aW9uc18gPSB7XHJcbiAgLy8gRGVmYXVsdCBvcmRlciBvZiBmYWxsYmFjayB0ZWNobm9sb2d5XHJcbiAgdGVjaE9yZGVyOiBUZWNoLmRlZmF1bHRUZWNoT3JkZXJfLFxyXG5cclxuICBodG1sNToge30sXHJcbiAgZmxhc2g6IHt9LFxyXG5cclxuICAvLyBkZWZhdWx0IGluYWN0aXZpdHkgdGltZW91dFxyXG4gIGluYWN0aXZpdHlUaW1lb3V0OiAyMDAwLFxyXG5cclxuICAvLyBkZWZhdWx0IHBsYXliYWNrIHJhdGVzXHJcbiAgcGxheWJhY2tSYXRlczogW10sXHJcbiAgLy8gQWRkIHBsYXliYWNrIHJhdGUgc2VsZWN0aW9uIGJ5IGFkZGluZyByYXRlc1xyXG4gIC8vICdwbGF5YmFja1JhdGVzJzogWzAuNSwgMSwgMS41LCAyXSxcclxuXHJcbiAgLy8gSW5jbHVkZWQgY29udHJvbCBzZXRzXHJcbiAgY2hpbGRyZW46IFsnbWVkaWFMb2FkZXInLCAncG9zdGVySW1hZ2UnLCAndGV4dFRyYWNrRGlzcGxheScsICdsb2FkaW5nU3Bpbm5lcicsICdiaWdQbGF5QnV0dG9uJywgJ2NvbnRyb2xCYXInLCAnZXJyb3JEaXNwbGF5JywgJ3RleHRUcmFja1NldHRpbmdzJ10sXHJcblxyXG4gIGxhbmd1YWdlOiBuYXZpZ2F0b3IkMSAmJiAobmF2aWdhdG9yJDEubGFuZ3VhZ2VzICYmIG5hdmlnYXRvciQxLmxhbmd1YWdlc1swXSB8fCBuYXZpZ2F0b3IkMS51c2VyTGFuZ3VhZ2UgfHwgbmF2aWdhdG9yJDEubGFuZ3VhZ2UpIHx8ICdlbicsXHJcblxyXG4gIC8vIGxvY2FsZXMgYW5kIHRoZWlyIGxhbmd1YWdlIHRyYW5zbGF0aW9uc1xyXG4gIGxhbmd1YWdlczoge30sXHJcblxyXG4gIC8vIERlZmF1bHQgbWVzc2FnZSB0byBzaG93IHdoZW4gYSB2aWRlbyBjYW5ub3QgYmUgcGxheWVkLlxyXG4gIG5vdFN1cHBvcnRlZE1lc3NhZ2U6ICdObyBjb21wYXRpYmxlIHNvdXJjZSB3YXMgZm91bmQgZm9yIHRoaXMgbWVkaWEuJ1xyXG59O1xyXG5cclxuW1xyXG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGxheWVyIGlzIGluIHRoZSBcImVuZGVkXCIgc3RhdGUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBsYXllciBpcyBpbiB0aGUgZW5kZWQgc3RhdGUsIGZhbHNlIGlmIG5vdC5cclxuICogQG1ldGhvZCBQbGF5ZXIjZW5kZWRcclxuICovXHJcbidlbmRlZCcsXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwbGF5ZXIgaXMgaW4gdGhlIFwic2Vla2luZ1wiIHN0YXRlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBwbGF5ZXIgaXMgaW4gdGhlIHNlZWtpbmcgc3RhdGUsIGZhbHNlIGlmIG5vdC5cclxuICogQG1ldGhvZCBQbGF5ZXIjc2Vla2luZ1xyXG4gKi9cclxuJ3NlZWtpbmcnLFxyXG4vKipcclxuICogUmV0dXJucyB0aGUgVGltZVJhbmdlcyBvZiB0aGUgbWVkaWEgdGhhdCBhcmUgY3VycmVudGx5IGF2YWlsYWJsZVxyXG4gKiBmb3Igc2Vla2luZyB0by5cclxuICpcclxuICogQHJldHVybiB7VGltZVJhbmdlc30gdGhlIHNlZWthYmxlIGludGVydmFscyBvZiB0aGUgbWVkaWEgdGltZWxpbmVcclxuICogQG1ldGhvZCBQbGF5ZXIjc2Vla2FibGVcclxuICovXHJcbidzZWVrYWJsZScsXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlIG9mIG5ldHdvcmsgYWN0aXZpdHkgZm9yIHRoZSBlbGVtZW50LCBmcm9tXHJcbiAqIHRoZSBjb2RlcyBpbiB0aGUgbGlzdCBiZWxvdy5cclxuICogLSBORVRXT1JLX0VNUFRZIChudW1lcmljIHZhbHVlIDApXHJcbiAqICAgVGhlIGVsZW1lbnQgaGFzIG5vdCB5ZXQgYmVlbiBpbml0aWFsaXNlZC4gQWxsIGF0dHJpYnV0ZXMgYXJlIGluXHJcbiAqICAgdGhlaXIgaW5pdGlhbCBzdGF0ZXMuXHJcbiAqIC0gTkVUV09SS19JRExFIChudW1lcmljIHZhbHVlIDEpXHJcbiAqICAgVGhlIGVsZW1lbnQncyByZXNvdXJjZSBzZWxlY3Rpb24gYWxnb3JpdGhtIGlzIGFjdGl2ZSBhbmQgaGFzXHJcbiAqICAgc2VsZWN0ZWQgYSByZXNvdXJjZSwgYnV0IGl0IGlzIG5vdCBhY3R1YWxseSB1c2luZyB0aGUgbmV0d29yayBhdFxyXG4gKiAgIHRoaXMgdGltZS5cclxuICogLSBORVRXT1JLX0xPQURJTkcgKG51bWVyaWMgdmFsdWUgMilcclxuICogICBUaGUgdXNlciBhZ2VudCBpcyBhY3RpdmVseSB0cnlpbmcgdG8gZG93bmxvYWQgZGF0YS5cclxuICogLSBORVRXT1JLX05PX1NPVVJDRSAobnVtZXJpYyB2YWx1ZSAzKVxyXG4gKiAgIFRoZSBlbGVtZW50J3MgcmVzb3VyY2Ugc2VsZWN0aW9uIGFsZ29yaXRobSBpcyBhY3RpdmUsIGJ1dCBpdCBoYXNcclxuICogICBub3QgeWV0IGZvdW5kIGEgcmVzb3VyY2UgdG8gdXNlLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNuZXR3b3JrLXN0YXRlc1xyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBjdXJyZW50IG5ldHdvcmsgYWN0aXZpdHkgc3RhdGVcclxuICogQG1ldGhvZCBQbGF5ZXIjbmV0d29ya1N0YXRlXHJcbiAqL1xyXG4nbmV0d29ya1N0YXRlJyxcclxuLyoqXHJcbiAqIFJldHVybnMgYSB2YWx1ZSB0aGF0IGV4cHJlc3NlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZWxlbWVudFxyXG4gKiB3aXRoIHJlc3BlY3QgdG8gcmVuZGVyaW5nIHRoZSBjdXJyZW50IHBsYXliYWNrIHBvc2l0aW9uLCBmcm9tIHRoZVxyXG4gKiBjb2RlcyBpbiB0aGUgbGlzdCBiZWxvdy5cclxuICogLSBIQVZFX05PVEhJTkcgKG51bWVyaWMgdmFsdWUgMClcclxuICogICBObyBpbmZvcm1hdGlvbiByZWdhcmRpbmcgdGhlIG1lZGlhIHJlc291cmNlIGlzIGF2YWlsYWJsZS5cclxuICogLSBIQVZFX01FVEFEQVRBIChudW1lcmljIHZhbHVlIDEpXHJcbiAqICAgRW5vdWdoIG9mIHRoZSByZXNvdXJjZSBoYXMgYmVlbiBvYnRhaW5lZCB0aGF0IHRoZSBkdXJhdGlvbiBvZiB0aGVcclxuICogICByZXNvdXJjZSBpcyBhdmFpbGFibGUuXHJcbiAqIC0gSEFWRV9DVVJSRU5UX0RBVEEgKG51bWVyaWMgdmFsdWUgMilcclxuICogICBEYXRhIGZvciB0aGUgaW1tZWRpYXRlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaXMgYXZhaWxhYmxlLlxyXG4gKiAtIEhBVkVfRlVUVVJFX0RBVEEgKG51bWVyaWMgdmFsdWUgMylcclxuICogICBEYXRhIGZvciB0aGUgaW1tZWRpYXRlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb24gaXMgYXZhaWxhYmxlLCBhc1xyXG4gKiAgIHdlbGwgYXMgZW5vdWdoIGRhdGEgZm9yIHRoZSB1c2VyIGFnZW50IHRvIGFkdmFuY2UgdGhlIGN1cnJlbnRcclxuICogICBwbGF5YmFjayBwb3NpdGlvbiBpbiB0aGUgZGlyZWN0aW9uIG9mIHBsYXliYWNrLlxyXG4gKiAtIEhBVkVfRU5PVUdIX0RBVEEgKG51bWVyaWMgdmFsdWUgNClcclxuICogICBUaGUgdXNlciBhZ2VudCBlc3RpbWF0ZXMgdGhhdCBlbm91Z2ggZGF0YSBpcyBhdmFpbGFibGUgZm9yXHJcbiAqICAgcGxheWJhY2sgdG8gcHJvY2VlZCB1bmludGVycnVwdGVkLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCNkb20tbWVkaWEtcmVhZHlzdGF0ZVxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBjdXJyZW50IHBsYXliYWNrIHJlbmRlcmluZyBzdGF0ZVxyXG4gKiBAbWV0aG9kIFBsYXllciNyZWFkeVN0YXRlXHJcbiAqL1xyXG4ncmVhZHlTdGF0ZSddLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XHJcbiAgUGxheWVyLnByb3RvdHlwZVtmbl0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50ZWNoR2V0Xyhmbik7XHJcbiAgfTtcclxufSk7XHJcblxyXG5URUNIX0VWRU5UU19SRVRSSUdHRVIuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcclxuICBQbGF5ZXIucHJvdG90eXBlWydoYW5kbGVUZWNoJyArIHRvVGl0bGVDYXNlKGV2ZW50KSArICdfJ10gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmlnZ2VyKGV2ZW50KTtcclxuICB9O1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBGaXJlZCB3aGVuIHRoZSBwbGF5ZXIgaGFzIGluaXRpYWwgZHVyYXRpb24gYW5kIGRpbWVuc2lvbiBpbmZvcm1hdGlvblxyXG4gKlxyXG4gKiBAZXZlbnQgUGxheWVyI2xvYWRlZG1ldGFkYXRhXHJcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICovXHJcblxyXG4vKipcclxuICogRmlyZWQgd2hlbiB0aGUgcGxheWVyIGhhcyBkb3dubG9hZGVkIGRhdGEgYXQgdGhlIGN1cnJlbnQgcGxheWJhY2sgcG9zaXRpb25cclxuICpcclxuICogQGV2ZW50IFBsYXllciNsb2FkZWRkYXRhXHJcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICovXHJcblxyXG4vKipcclxuICogRmlyZWQgd2hlbiB0aGUgY3VycmVudCBwbGF5YmFjayBwb3NpdGlvbiBoYXMgY2hhbmdlZCAqXHJcbiAqIER1cmluZyBwbGF5YmFjayB0aGlzIGlzIGZpcmVkIGV2ZXJ5IDE1LTI1MCBtaWxsaXNlY29uZHMsIGRlcGVuZGluZyBvbiB0aGVcclxuICogcGxheWJhY2sgdGVjaG5vbG9neSBpbiB1c2UuXHJcbiAqXHJcbiAqIEBldmVudCBQbGF5ZXIjdGltZXVwZGF0ZVxyXG4gKiBAdHlwZSB7RXZlbnRUYXJnZXR+RXZlbnR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEZpcmVkIHdoZW4gdGhlIHZvbHVtZSBjaGFuZ2VzXHJcbiAqXHJcbiAqIEBldmVudCBQbGF5ZXIjdm9sdW1lY2hhbmdlXHJcbiAqIEB0eXBlIHtFdmVudFRhcmdldH5FdmVudH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVwb3J0cyB3aGV0aGVyIG9yIG5vdCBhIHBsYXllciBoYXMgYSBwbHVnaW4gYXZhaWxhYmxlLlxyXG4gKlxyXG4gKiBUaGlzIGRvZXMgbm90IHJlcG9ydCB3aGV0aGVyIG9yIG5vdCB0aGUgcGx1Z2luIGhhcyBldmVyIGJlZW4gaW5pdGlhbGl6ZWRcclxuICogb24gdGhpcyBwbGF5ZXIuIEZvciB0aGF0LCBbdXNpbmdQbHVnaW5de0BsaW5rIFBsYXllciN1c2luZ1BsdWdpbn0uXHJcbiAqXHJcbiAqIEBtZXRob2QgUGxheWVyI2hhc1BsdWdpblxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lXHJcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXHJcbiAqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqICAgICAgICAgV2hldGhlciBvciBub3QgdGhpcyBwbGF5ZXIgaGFzIHRoZSByZXF1ZXN0ZWQgcGx1Z2luIGF2YWlsYWJsZS5cclxuICovXHJcblxyXG4vKipcclxuICogUmVwb3J0cyB3aGV0aGVyIG9yIG5vdCBhIHBsYXllciBpcyB1c2luZyBhIHBsdWdpbiBieSBuYW1lLlxyXG4gKlxyXG4gKiBGb3IgYmFzaWMgcGx1Z2lucywgdGhpcyBvbmx5IHJlcG9ydHMgd2hldGhlciB0aGUgcGx1Z2luIGhhcyBfZXZlcl8gYmVlblxyXG4gKiBpbml0aWFsaXplZCBvbiB0aGlzIHBsYXllci5cclxuICpcclxuICogQG1ldGhvZCBQbGF5ZXIjdXNpbmdQbHVnaW5cclxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXHJcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXHJcbiAqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqICAgICAgICAgV2hldGhlciBvciBub3QgdGhpcyBwbGF5ZXIgaXMgdXNpbmcgdGhlIHJlcXVlc3RlZCBwbHVnaW4uXHJcbiAqL1xyXG5cclxuQ29tcG9uZW50LnJlZ2lzdGVyQ29tcG9uZW50KCdQbGF5ZXInLCBQbGF5ZXIpO1xyXG5cclxuLyoqXHJcbiAqIEBmaWxlIHBsdWdpbi5qc1xyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBiYXNlIHBsdWdpbiBuYW1lLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAY29uc3RhbnRcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXHJcbnZhciBCQVNFX1BMVUdJTl9OQU1FID0gJ3BsdWdpbic7XHJcblxyXG4vKipcclxuICogVGhlIGtleSBvbiB3aGljaCBhIHBsYXllcidzIGFjdGl2ZSBwbHVnaW5zIGNhY2hlIGlzIHN0b3JlZC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQGNvbnN0YW50XHJcbiAqIEB0eXBlICAgICB7c3RyaW5nfVxyXG4gKi9cclxudmFyIFBMVUdJTl9DQUNIRV9LRVkgPSAnYWN0aXZlUGx1Z2luc18nO1xyXG5cclxuLyoqXHJcbiAqIFN0b3JlcyByZWdpc3RlcmVkIHBsdWdpbnMgaW4gYSBwcml2YXRlIHNwYWNlLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAdHlwZSAgICB7T2JqZWN0fVxyXG4gKi9cclxudmFyIHBsdWdpblN0b3JhZ2UgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBSZXBvcnRzIHdoZXRoZXIgb3Igbm90IGEgcGx1Z2luIGhhcyBiZWVuIHJlZ2lzdGVyZWQuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcclxuICogICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKiAgICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgcGx1Z2luIGhhcyBiZWVuIHJlZ2lzdGVyZWQuXHJcbiAqL1xyXG52YXIgcGx1Z2luRXhpc3RzID0gZnVuY3Rpb24gcGx1Z2luRXhpc3RzKG5hbWUpIHtcclxuICByZXR1cm4gcGx1Z2luU3RvcmFnZS5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBzaW5nbGUgcmVnaXN0ZXJlZCBwbHVnaW4gYnkgbmFtZS5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxyXG4gKiAgICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cclxuICpcclxuICogQHJldHVybnMge0Z1bmN0aW9ufHVuZGVmaW5lZH1cclxuICogICAgICAgICAgVGhlIHBsdWdpbiAob3IgdW5kZWZpbmVkKS5cclxuICovXHJcbnZhciBnZXRQbHVnaW4gPSBmdW5jdGlvbiBnZXRQbHVnaW4obmFtZSkge1xyXG4gIHJldHVybiBwbHVnaW5FeGlzdHMobmFtZSkgPyBwbHVnaW5TdG9yYWdlW25hbWVdIDogdW5kZWZpbmVkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1hcmtzIGEgcGx1Z2luIGFzIFwiYWN0aXZlXCIgb24gYSBwbGF5ZXIuXHJcbiAqXHJcbiAqIEFsc28sIGVuc3VyZXMgdGhhdCB0aGUgcGxheWVyIGhhcyBhbiBvYmplY3QgZm9yIHRyYWNraW5nIGFjdGl2ZSBwbHVnaW5zLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0gICB7UGxheWVyfSBwbGF5ZXJcclxuICogICAgICAgICAgQSBWaWRlby5qcyBwbGF5ZXIgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcclxuICogICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXHJcbiAqL1xyXG52YXIgbWFya1BsdWdpbkFzQWN0aXZlID0gZnVuY3Rpb24gbWFya1BsdWdpbkFzQWN0aXZlKHBsYXllciwgbmFtZSkge1xyXG4gIHBsYXllcltQTFVHSU5fQ0FDSEVfS0VZXSA9IHBsYXllcltQTFVHSU5fQ0FDSEVfS0VZXSB8fCB7fTtcclxuICBwbGF5ZXJbUExVR0lOX0NBQ0hFX0tFWV1bbmFtZV0gPSB0cnVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRyaWdnZXJzIGEgcGFpciBvZiBwbHVnaW4gc2V0dXAgZXZlbnRzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0gIHtQbGF5ZXJ9IHBsYXllclxyXG4gKiAgICAgICAgIEEgVmlkZW8uanMgcGxheWVyIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtQbHVnaW5+UGx1Z2luRXZlbnRIYXNofSBoYXNoXHJcbiAqICAgICAgICAgQSBwbHVnaW4gZXZlbnQgaGFzaC5cclxuICpcclxuICogQHBhcmFtICB7Qm9vbGVhbn0gW2JlZm9yZV1cclxuICogICAgICAgICBJZiB0cnVlLCBwcmVmaXhlcyB0aGUgZXZlbnQgbmFtZSB3aXRoIFwiYmVmb3JlXCIuIEluIG90aGVyIHdvcmRzLFxyXG4gKiAgICAgICAgIHVzZSB0aGlzIHRvIHRyaWdnZXIgXCJiZWZvcmVwbHVnaW5zZXR1cFwiIGluc3RlYWQgb2YgXCJwbHVnaW5zZXR1cFwiLlxyXG4gKi9cclxudmFyIHRyaWdnZXJTZXR1cEV2ZW50ID0gZnVuY3Rpb24gdHJpZ2dlclNldHVwRXZlbnQocGxheWVyLCBoYXNoLCBiZWZvcmUpIHtcclxuICB2YXIgZXZlbnROYW1lID0gKGJlZm9yZSA/ICdiZWZvcmUnIDogJycpICsgJ3BsdWdpbnNldHVwJztcclxuXHJcbiAgcGxheWVyLnRyaWdnZXIoZXZlbnROYW1lLCBoYXNoKTtcclxuICBwbGF5ZXIudHJpZ2dlcihldmVudE5hbWUgKyAnOicgKyBoYXNoLm5hbWUsIGhhc2gpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRha2VzIGEgYmFzaWMgcGx1Z2luIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgd3JhcHBlciBmdW5jdGlvbiB3aGljaCBtYXJrc1xyXG4gKiBvbiB0aGUgcGxheWVyIHRoYXQgdGhlIHBsdWdpbiBoYXMgYmVlbiBhY3RpdmF0ZWQuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcclxuICogICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cclxuICpcclxuICogQHBhcmFtICAge0Z1bmN0aW9ufSBwbHVnaW5cclxuICogICAgICAgICAgVGhlIGJhc2ljIHBsdWdpbi5cclxuICpcclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gKiAgICAgICAgICBBIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBwbHVnaW4uXHJcbiAqL1xyXG52YXIgY3JlYXRlQmFzaWNQbHVnaW4gPSBmdW5jdGlvbiBjcmVhdGVCYXNpY1BsdWdpbihuYW1lLCBwbHVnaW4pIHtcclxuICB2YXIgYmFzaWNQbHVnaW5XcmFwcGVyID0gZnVuY3Rpb24gYmFzaWNQbHVnaW5XcmFwcGVyKCkge1xyXG5cclxuICAgIC8vIFdlIHRyaWdnZXIgdGhlIFwiYmVmb3JlcGx1Z2luc2V0dXBcIiBhbmQgXCJwbHVnaW5zZXR1cFwiIGV2ZW50cyBvbiB0aGUgcGxheWVyXHJcbiAgICAvLyByZWdhcmRsZXNzLCBidXQgd2Ugd2FudCB0aGUgaGFzaCB0byBiZSBjb25zaXN0ZW50IHdpdGggdGhlIGhhc2ggcHJvdmlkZWRcclxuICAgIC8vIGZvciBhZHZhbmNlZCBwbHVnaW5zLlxyXG4gICAgLy9cclxuICAgIC8vIFRoZSBvbmx5IHBvdGVudGlhbGx5IGNvdW50ZXItaW50dWl0aXZlIHRoaW5nIGhlcmUgaXMgdGhlIGBpbnN0YW5jZWAgaW5cclxuICAgIC8vIHRoZSBcInBsdWdpbnNldHVwXCIgZXZlbnQgaXMgdGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBgcGx1Z2luYCBmdW5jdGlvbi5cclxuICAgIHRyaWdnZXJTZXR1cEV2ZW50KHRoaXMsIHsgbmFtZTogbmFtZSwgcGx1Z2luOiBwbHVnaW4sIGluc3RhbmNlOiBudWxsIH0sIHRydWUpO1xyXG5cclxuICAgIHZhciBpbnN0YW5jZSA9IHBsdWdpbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIG1hcmtQbHVnaW5Bc0FjdGl2ZSh0aGlzLCBuYW1lKTtcclxuICAgIHRyaWdnZXJTZXR1cEV2ZW50KHRoaXMsIHsgbmFtZTogbmFtZSwgcGx1Z2luOiBwbHVnaW4sIGluc3RhbmNlOiBpbnN0YW5jZSB9KTtcclxuXHJcbiAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgfTtcclxuXHJcbiAgT2JqZWN0LmtleXMocGx1Z2luKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICBiYXNpY1BsdWdpbldyYXBwZXJbcHJvcF0gPSBwbHVnaW5bcHJvcF07XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBiYXNpY1BsdWdpbldyYXBwZXI7XHJcbn07XHJcblxyXG4vKipcclxuICogVGFrZXMgYSBwbHVnaW4gc3ViLWNsYXNzIGFuZCByZXR1cm5zIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZ1xyXG4gKiBpbnN0YW5jZXMgb2YgaXQuXHJcbiAqXHJcbiAqIFRoaXMgZmFjdG9yeSBmdW5jdGlvbiB3aWxsIHJlcGxhY2UgaXRzZWxmIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhlIHJlcXVlc3RlZFxyXG4gKiBzdWItY2xhc3Mgb2YgUGx1Z2luLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0gICB7c3RyaW5nfSBuYW1lXHJcbiAqICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXHJcbiAqXHJcbiAqIEBwYXJhbSAgIHtQbHVnaW59IFBsdWdpblN1YkNsYXNzXHJcbiAqICAgICAgICAgIFRoZSBhZHZhbmNlZCBwbHVnaW4uXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cclxuICovXHJcbnZhciBjcmVhdGVQbHVnaW5GYWN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlUGx1Z2luRmFjdG9yeShuYW1lLCBQbHVnaW5TdWJDbGFzcykge1xyXG5cclxuICAvLyBBZGQgYSBgbmFtZWAgcHJvcGVydHkgdG8gdGhlIHBsdWdpbiBwcm90b3R5cGUgc28gdGhhdCBlYWNoIHBsdWdpbiBjYW5cclxuICAvLyByZWZlciB0byBpdHNlbGYgYnkgbmFtZS5cclxuICBQbHVnaW5TdWJDbGFzcy5wcm90b3R5cGUubmFtZSA9IG5hbWU7XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0cmlnZ2VyU2V0dXBFdmVudCh0aGlzLCB7IG5hbWU6IG5hbWUsIHBsdWdpbjogUGx1Z2luU3ViQ2xhc3MsIGluc3RhbmNlOiBudWxsIH0sIHRydWUpO1xyXG5cclxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGluc3RhbmNlID0gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShQbHVnaW5TdWJDbGFzcywgW251bGxdLmNvbmNhdChbdGhpc10uY29uY2F0KGFyZ3MpKSkpKCk7XHJcblxyXG4gICAgLy8gVGhlIHBsdWdpbiBpcyByZXBsYWNlZCBieSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBpbnN0YW5jZS5cclxuICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgIH07XHJcblxyXG4gICAgdHJpZ2dlclNldHVwRXZlbnQodGhpcywgaW5zdGFuY2UuZ2V0RXZlbnRIYXNoKCkpO1xyXG5cclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBhcmVudCBjbGFzcyBmb3IgYWxsIGFkdmFuY2VkIHBsdWdpbnMuXHJcbiAqXHJcbiAqIEBtaXhlcyAgIG1vZHVsZTpldmVudGVkfkV2ZW50ZWRNaXhpblxyXG4gKiBAbWl4ZXMgICBtb2R1bGU6c3RhdGVmdWx+U3RhdGVmdWxNaXhpblxyXG4gKiBAZmlyZXMgICBQbGF5ZXIjYmVmb3JlcGx1Z2luc2V0dXBcclxuICogQGZpcmVzICAgUGxheWVyI2JlZm9yZXBsdWdpbnNldHVwOiRuYW1lXHJcbiAqIEBmaXJlcyAgIFBsYXllciNwbHVnaW5zZXR1cFxyXG4gKiBAZmlyZXMgICBQbGF5ZXIjcGx1Z2luc2V0dXA6JG5hbWVcclxuICogQGxpc3RlbnMgUGxheWVyI2Rpc3Bvc2VcclxuICogQHRocm93cyAge0Vycm9yfVxyXG4gKiAgICAgICAgICBJZiBhdHRlbXB0aW5nIHRvIGluc3RhbnRpYXRlIHRoZSBiYXNlIHtAbGluayBQbHVnaW59IGNsYXNzXHJcbiAqICAgICAgICAgIGRpcmVjdGx5IGluc3RlYWQgb2YgdmlhIGEgc3ViLWNsYXNzLlxyXG4gKi9cclxuXHJcbnZhciBQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cclxuICAgKlxyXG4gICAqIFN1Yi1jbGFzc2VzIHNob3VsZCBjYWxsIGBzdXBlcmAgdG8gZW5zdXJlIHBsdWdpbnMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQbGF5ZXJ9IHBsYXllclxyXG4gICAqICAgICAgICBBIFZpZGVvLmpzIHBsYXllciBpbnN0YW5jZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBQbHVnaW4ocGxheWVyKSB7XHJcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQbHVnaW4pO1xyXG5cclxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBQbHVnaW4pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbHVnaW4gbXVzdCBiZSBzdWItY2xhc3NlZDsgbm90IGRpcmVjdGx5IGluc3RhbnRpYXRlZC4nKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBsYXllciA9IHBsYXllcjtcclxuXHJcbiAgICAvLyBNYWtlIHRoaXMgb2JqZWN0IGV2ZW50ZWQsIGJ1dCByZW1vdmUgdGhlIGFkZGVkIGB0cmlnZ2VyYCBtZXRob2Qgc28gd2VcclxuICAgIC8vIHVzZSB0aGUgcHJvdG90eXBlIHZlcnNpb24gaW5zdGVhZC5cclxuICAgIGV2ZW50ZWQodGhpcyk7XHJcbiAgICBkZWxldGUgdGhpcy50cmlnZ2VyO1xyXG5cclxuICAgIHN0YXRlZnVsKHRoaXMsIHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdFN0YXRlKTtcclxuICAgIG1hcmtQbHVnaW5Bc0FjdGl2ZShwbGF5ZXIsIHRoaXMubmFtZSk7XHJcblxyXG4gICAgLy8gQXV0by1iaW5kIHRoZSBkaXNwb3NlIG1ldGhvZCBzbyB3ZSBjYW4gdXNlIGl0IGFzIGEgbGlzdGVuZXIgYW5kIHVuYmluZFxyXG4gICAgLy8gaXQgbGF0ZXIgZWFzaWx5LlxyXG4gICAgdGhpcy5kaXNwb3NlID0gYmluZCh0aGlzLCB0aGlzLmRpc3Bvc2UpO1xyXG5cclxuICAgIC8vIElmIHRoZSBwbGF5ZXIgaXMgZGlzcG9zZWQsIGRpc3Bvc2UgdGhlIHBsdWdpbi5cclxuICAgIHBsYXllci5vbignZGlzcG9zZScsIHRoaXMuZGlzcG9zZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFYWNoIGV2ZW50IHRyaWdnZXJlZCBieSBwbHVnaW5zIGluY2x1ZGVzIGEgaGFzaCBvZiBhZGRpdGlvbmFsIGRhdGEgd2l0aFxyXG4gICAqIGNvbnZlbnRpb25hbCBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogVGhpcyByZXR1cm5zIHRoYXQgb2JqZWN0IG9yIG11dGF0ZXMgYW4gZXhpc3RpbmcgaGFzaC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAgIHtPYmplY3R9IFtoYXNoPXt9XVxyXG4gICAqICAgICAgICAgIEFuIG9iamVjdCB0byBiZSB1c2VkIGFzIGV2ZW50IGFuIGV2ZW50IGhhc2guXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7UGx1Z2luflBsdWdpbkV2ZW50SGFzaH1cclxuICAgKiAgICAgICAgICBBbiBldmVudCBoYXNoIG9iamVjdCB3aXRoIHByb3ZpZGVkIHByb3BlcnRpZXMgbWl4ZWQtaW4uXHJcbiAgICovXHJcblxyXG5cclxuICBQbHVnaW4ucHJvdG90eXBlLmdldEV2ZW50SGFzaCA9IGZ1bmN0aW9uIGdldEV2ZW50SGFzaCgpIHtcclxuICAgIHZhciBoYXNoID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcclxuXHJcbiAgICBoYXNoLm5hbWUgPSB0aGlzLm5hbWU7XHJcbiAgICBoYXNoLnBsdWdpbiA9IHRoaXMuY29uc3RydWN0b3I7XHJcbiAgICBoYXNoLmluc3RhbmNlID0gdGhpcztcclxuICAgIHJldHVybiBoYXNoO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXJzIGFuIGV2ZW50IG9uIHRoZSBwbHVnaW4gb2JqZWN0IGFuZCBvdmVycmlkZXNcclxuICAgKiB7QGxpbmsgbW9kdWxlOmV2ZW50ZWR+RXZlbnRlZE1peGluLnRyaWdnZXJ8RXZlbnRlZE1peGluLnRyaWdnZXJ9LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICAge3N0cmluZ3xPYmplY3R9IGV2ZW50XHJcbiAgICogICAgICAgICAgQW4gZXZlbnQgdHlwZSBvciBhbiBvYmplY3Qgd2l0aCBhIHR5cGUgcHJvcGVydHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSBbaGFzaD17fV1cclxuICAgKiAgICAgICAgICBBZGRpdGlvbmFsIGRhdGEgaGFzaCB0byBtZXJnZSB3aXRoIGFcclxuICAgKiAgICAgICAgICB7QGxpbmsgUGx1Z2luflBsdWdpbkV2ZW50SGFzaHxQbHVnaW5FdmVudEhhc2h9LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICogICAgICAgICAgV2hldGhlciBvciBub3QgZGVmYXVsdCB3YXMgcHJldmVudGVkLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGx1Z2luLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciQkMShldmVudCkge1xyXG4gICAgdmFyIGhhc2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xyXG5cclxuICAgIHJldHVybiB0cmlnZ2VyKHRoaXMuZXZlbnRCdXNFbF8sIGV2ZW50LCB0aGlzLmdldEV2ZW50SGFzaChoYXNoKSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBcInN0YXRlY2hhbmdlZFwiIGV2ZW50cyBvbiB0aGUgcGx1Z2luLiBOby1vcCBieSBkZWZhdWx0LCBvdmVycmlkZSBieVxyXG4gICAqIHN1YmNsYXNzaW5nLlxyXG4gICAqXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICogQHBhcmFtICAgIHtFdmVudH0gZVxyXG4gICAqICAgICAgICAgICBBbiBldmVudCBvYmplY3QgcHJvdmlkZWQgYnkgYSBcInN0YXRlY2hhbmdlZFwiIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtICAgIHtPYmplY3R9IGUuY2hhbmdlc1xyXG4gICAqICAgICAgICAgICBBbiBvYmplY3QgZGVzY3JpYmluZyBjaGFuZ2VzIHRoYXQgb2NjdXJyZWQgd2l0aCB0aGUgXCJzdGF0ZWNoYW5nZWRcIlxyXG4gICAqICAgICAgICAgICBldmVudC5cclxuICAgKi9cclxuXHJcblxyXG4gIFBsdWdpbi5wcm90b3R5cGUuaGFuZGxlU3RhdGVDaGFuZ2VkID0gZnVuY3Rpb24gaGFuZGxlU3RhdGVDaGFuZ2VkKGUpIHt9O1xyXG5cclxuICAvKipcclxuICAgKiBEaXNwb3NlcyBhIHBsdWdpbi5cclxuICAgKlxyXG4gICAqIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgaWYgdGhleSB3YW50LCBidXQgZm9yIHRoZSBzYWtlIG9mIHNhZmV0eSxcclxuICAgKiBpdCdzIHByb2JhYmx5IGJlc3QgdG8gc3Vic2NyaWJlIHRoZSBcImRpc3Bvc2VcIiBldmVudC5cclxuICAgKlxyXG4gICAqIEBmaXJlcyBQbHVnaW4jZGlzcG9zZVxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGx1Z2luLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcclxuICAgIHZhciBuYW1lID0gdGhpcy5uYW1lLFxyXG4gICAgICAgIHBsYXllciA9IHRoaXMucGxheWVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmFscyB0aGF0IGEgYWR2YW5jZWQgcGx1Z2luIGlzIGFib3V0IHRvIGJlIGRpc3Bvc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBldmVudCBQbHVnaW4jZGlzcG9zZVxyXG4gICAgICogQHR5cGUgIHtFdmVudFRhcmdldH5FdmVudH1cclxuICAgICAqL1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcignZGlzcG9zZScpO1xyXG4gICAgdGhpcy5vZmYoKTtcclxuICAgIHBsYXllci5vZmYoJ2Rpc3Bvc2UnLCB0aGlzLmRpc3Bvc2UpO1xyXG5cclxuICAgIC8vIEVsaW1pbmF0ZSBhbnkgcG9zc2libGUgc291cmNlcyBvZiBsZWFraW5nIG1lbW9yeSBieSBjbGVhcmluZyB1cFxyXG4gICAgLy8gcmVmZXJlbmNlcyBiZXR3ZWVuIHRoZSBwbGF5ZXIgYW5kIHRoZSBwbHVnaW4gaW5zdGFuY2UgYW5kIG51bGxpbmcgb3V0XHJcbiAgICAvLyB0aGUgcGx1Z2luJ3Mgc3RhdGUgYW5kIHJlcGxhY2luZyBtZXRob2RzIHdpdGggYSBmdW5jdGlvbiB0aGF0IHRocm93cy5cclxuICAgIHBsYXllcltQTFVHSU5fQ0FDSEVfS0VZXVtuYW1lXSA9IGZhbHNlO1xyXG4gICAgdGhpcy5wbGF5ZXIgPSB0aGlzLnN0YXRlID0gbnVsbDtcclxuXHJcbiAgICAvLyBGaW5hbGx5LCByZXBsYWNlIHRoZSBwbHVnaW4gbmFtZSBvbiB0aGUgcGxheWVyIHdpdGggYSBuZXcgZmFjdG9yeVxyXG4gICAgLy8gZnVuY3Rpb24sIHNvIHRoYXQgdGhlIHBsdWdpbiBpcyByZWFkeSB0byBiZSBzZXQgdXAgYWdhaW4uXHJcbiAgICBwbGF5ZXJbbmFtZV0gPSBjcmVhdGVQbHVnaW5GYWN0b3J5KG5hbWUsIHBsdWdpblN0b3JhZ2VbbmFtZV0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgaWYgYSBwbHVnaW4gaXMgYSBiYXNpYyBwbHVnaW4gKGkuZS4gbm90IGEgc3ViLWNsYXNzIG9mIGBQbHVnaW5gKS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd8RnVuY3Rpb259IHBsdWdpblxyXG4gICAqICAgICAgICAgIElmIGEgc3RyaW5nLCBtYXRjaGVzIHRoZSBuYW1lIG9mIGEgcGx1Z2luLiBJZiBhIGZ1bmN0aW9uLCB3aWxsIGJlXHJcbiAgICogICAgICAgICAgdGVzdGVkIGRpcmVjdGx5LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICogICAgICAgICAgV2hldGhlciBvciBub3QgYSBwbHVnaW4gaXMgYSBiYXNpYyBwbHVnaW4uXHJcbiAgICovXHJcblxyXG5cclxuICBQbHVnaW4uaXNCYXNpYyA9IGZ1bmN0aW9uIGlzQmFzaWMocGx1Z2luKSB7XHJcbiAgICB2YXIgcCA9IHR5cGVvZiBwbHVnaW4gPT09ICdzdHJpbmcnID8gZ2V0UGx1Z2luKHBsdWdpbikgOiBwbHVnaW47XHJcblxyXG4gICAgcmV0dXJuIHR5cGVvZiBwID09PSAnZnVuY3Rpb24nICYmICFQbHVnaW4ucHJvdG90eXBlLmlzUHJvdG90eXBlT2YocC5wcm90b3R5cGUpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVyIGEgVmlkZW8uanMgcGx1Z2luLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxyXG4gICAqICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdG8gYmUgcmVnaXN0ZXJlZC4gTXVzdCBiZSBhIHN0cmluZyBhbmRcclxuICAgKiAgICAgICAgICBtdXN0IG5vdCBtYXRjaCBhbiBleGlzdGluZyBwbHVnaW4gb3IgYSBtZXRob2Qgb24gdGhlIGBQbGF5ZXJgXHJcbiAgICogICAgICAgICAgcHJvdG90eXBlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSBwbHVnaW5cclxuICAgKiAgICAgICAgICBBIHN1Yi1jbGFzcyBvZiBgUGx1Z2luYCBvciBhIGZ1bmN0aW9uIGZvciBiYXNpYyBwbHVnaW5zLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gICAqICAgICAgICAgIEZvciBhZHZhbmNlZCBwbHVnaW5zLCBhIGZhY3RvcnkgZnVuY3Rpb24gZm9yIHRoYXQgcGx1Z2luLiBGb3JcclxuICAgKiAgICAgICAgICBiYXNpYyBwbHVnaW5zLCBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyB0aGUgcGx1Z2luLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGx1Z2luLnJlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4obmFtZSwgcGx1Z2luKSB7XHJcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBwbHVnaW4gbmFtZSwgXCInICsgbmFtZSArICdcIiwgbXVzdCBiZSBhIHN0cmluZywgd2FzICcgKyAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5hbWUpKSArICcuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBsdWdpbkV4aXN0cyhuYW1lKSkge1xyXG4gICAgICBsb2ckMS53YXJuKCdBIHBsdWdpbiBuYW1lZCBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzLiBZb3UgbWF5IHdhbnQgdG8gYXZvaWQgcmUtcmVnaXN0ZXJpbmcgcGx1Z2lucyEnKTtcclxuICAgIH0gZWxzZSBpZiAoUGxheWVyLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgcGx1Z2luIG5hbWUsIFwiJyArIG5hbWUgKyAnXCIsIGNhbm5vdCBzaGFyZSBhIG5hbWUgd2l0aCBhbiBleGlzdGluZyBwbGF5ZXIgbWV0aG9kIScpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgcGx1Z2luICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBwbHVnaW4gZm9yIFwiJyArIG5hbWUgKyAnXCIsIG11c3QgYmUgYSBmdW5jdGlvbiwgd2FzICcgKyAodHlwZW9mIHBsdWdpbiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGx1Z2luKSkgKyAnLicpO1xyXG4gICAgfVxyXG5cclxuICAgIHBsdWdpblN0b3JhZ2VbbmFtZV0gPSBwbHVnaW47XHJcblxyXG4gICAgLy8gQWRkIGEgcGxheWVyIHByb3RvdHlwZSBtZXRob2QgZm9yIGFsbCBzdWItY2xhc3NlZCBwbHVnaW5zIChidXQgbm90IGZvclxyXG4gICAgLy8gdGhlIGJhc2UgUGx1Z2luIGNsYXNzKS5cclxuICAgIGlmIChuYW1lICE9PSBCQVNFX1BMVUdJTl9OQU1FKSB7XHJcbiAgICAgIGlmIChQbHVnaW4uaXNCYXNpYyhwbHVnaW4pKSB7XHJcbiAgICAgICAgUGxheWVyLnByb3RvdHlwZVtuYW1lXSA9IGNyZWF0ZUJhc2ljUGx1Z2luKG5hbWUsIHBsdWdpbik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgUGxheWVyLnByb3RvdHlwZVtuYW1lXSA9IGNyZWF0ZVBsdWdpbkZhY3RvcnkobmFtZSwgcGx1Z2luKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwbHVnaW47XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogRGUtcmVnaXN0ZXIgYSBWaWRlby5qcyBwbHVnaW4uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAqICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRvIGJlIGRlcmVnaXN0ZXJlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIFBsdWdpbi5kZXJlZ2lzdGVyUGx1Z2luID0gZnVuY3Rpb24gZGVyZWdpc3RlclBsdWdpbihuYW1lKSB7XHJcbiAgICBpZiAobmFtZSA9PT0gQkFTRV9QTFVHSU5fTkFNRSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZS1yZWdpc3RlciBiYXNlIHBsdWdpbi4nKTtcclxuICAgIH1cclxuICAgIGlmIChwbHVnaW5FeGlzdHMobmFtZSkpIHtcclxuICAgICAgZGVsZXRlIHBsdWdpblN0b3JhZ2VbbmFtZV07XHJcbiAgICAgIGRlbGV0ZSBQbGF5ZXIucHJvdG90eXBlW25hbWVdO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbXVsdGlwbGUgVmlkZW8uanMgcGx1Z2lucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSAgIHtBcnJheX0gW25hbWVzXVxyXG4gICAqICAgICAgICAgIElmIHByb3ZpZGVkLCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgcGx1Z2luIG5hbWVzLiBEZWZhdWx0cyB0byBfYWxsX1xyXG4gICAqICAgICAgICAgIHBsdWdpbiBuYW1lcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfVxyXG4gICAqICAgICAgICAgIEFuIG9iamVjdCBjb250YWluaW5nIHBsdWdpbihzKSBhc3NvY2lhdGVkIHdpdGggdGhlaXIgbmFtZShzKSBvclxyXG4gICAqICAgICAgICAgIGB1bmRlZmluZWRgIGlmIG5vIG1hdGNoaW5nIHBsdWdpbnMgZXhpc3QpLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGx1Z2luLmdldFBsdWdpbnMgPSBmdW5jdGlvbiBnZXRQbHVnaW5zKCkge1xyXG4gICAgdmFyIG5hbWVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBPYmplY3Qua2V5cyhwbHVnaW5TdG9yYWdlKTtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xyXG5cclxuICAgIG5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgdmFyIHBsdWdpbiA9IGdldFBsdWdpbihuYW1lKTtcclxuXHJcbiAgICAgIGlmIChwbHVnaW4pIHtcclxuICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwge307XHJcbiAgICAgICAgcmVzdWx0W25hbWVdID0gcGx1Z2luO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYSBwbHVnaW4ncyB2ZXJzaW9uLCBpZiBhdmFpbGFibGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSAgIHtzdHJpbmd9IG5hbWVcclxuICAgKiAgICAgICAgICBUaGUgbmFtZSBvZiBhIHBsdWdpbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICogICAgICAgICAgVGhlIHBsdWdpbidzIHZlcnNpb24gb3IgYW4gZW1wdHkgc3RyaW5nLlxyXG4gICAqL1xyXG5cclxuXHJcbiAgUGx1Z2luLmdldFBsdWdpblZlcnNpb24gPSBmdW5jdGlvbiBnZXRQbHVnaW5WZXJzaW9uKG5hbWUpIHtcclxuICAgIHZhciBwbHVnaW4gPSBnZXRQbHVnaW4obmFtZSk7XHJcblxyXG4gICAgcmV0dXJuIHBsdWdpbiAmJiBwbHVnaW4uVkVSU0lPTiB8fCAnJztcclxuICB9O1xyXG5cclxuICByZXR1cm4gUGx1Z2luO1xyXG59KCk7XHJcblxyXG4vKipcclxuICogR2V0cyBhIHBsdWdpbiBieSBuYW1lIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWV0aG9kICAgZ2V0UGx1Z2luXHJcbiAqIEBtZW1iZXJPZiBQbHVnaW5cclxuICogQHBhcmFtICAgIHtzdHJpbmd9IG5hbWVcclxuICogICAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxyXG4gKlxyXG4gKiBAcmV0dXJucyAge0Z1bmN0aW9ufHVuZGVmaW5lZH1cclxuICogICAgICAgICAgIFRoZSBwbHVnaW4gKG9yIGB1bmRlZmluZWRgKS5cclxuICovXHJcblxyXG5cclxuUGx1Z2luLmdldFBsdWdpbiA9IGdldFBsdWdpbjtcclxuXHJcbi8qKlxyXG4gKiBUaGUgbmFtZSBvZiB0aGUgYmFzZSBwbHVnaW4gY2xhc3MgYXMgaXQgaXMgcmVnaXN0ZXJlZC5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXHJcblBsdWdpbi5CQVNFX1BMVUdJTl9OQU1FID0gQkFTRV9QTFVHSU5fTkFNRTtcclxuXHJcblBsdWdpbi5yZWdpc3RlclBsdWdpbihCQVNFX1BMVUdJTl9OQU1FLCBQbHVnaW4pO1xyXG5cclxuLyoqXHJcbiAqIERvY3VtZW50ZWQgaW4gcGxheWVyLmpzXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICovXHJcblBsYXllci5wcm90b3R5cGUudXNpbmdQbHVnaW4gPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gIHJldHVybiAhIXRoaXNbUExVR0lOX0NBQ0hFX0tFWV0gJiYgdGhpc1tQTFVHSU5fQ0FDSEVfS0VZXVtuYW1lXSA9PT0gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEb2N1bWVudGVkIGluIHBsYXllci5qc1xyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5QbGF5ZXIucHJvdG90eXBlLmhhc1BsdWdpbiA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgcmV0dXJuICEhcGx1Z2luRXhpc3RzKG5hbWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNpZ25hbHMgdGhhdCBhIHBsdWdpbiBpcyBhYm91dCB0byBiZSBzZXQgdXAgb24gYSBwbGF5ZXIuXHJcbiAqXHJcbiAqIEBldmVudCAgICBQbGF5ZXIjYmVmb3JlcGx1Z2luc2V0dXBcclxuICogQHR5cGUgICAgIHtQbHVnaW5+UGx1Z2luRXZlbnRIYXNofVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBTaWduYWxzIHRoYXQgYSBwbHVnaW4gaXMgYWJvdXQgdG8gYmUgc2V0IHVwIG9uIGEgcGxheWVyIC0gYnkgbmFtZS4gVGhlIG5hbWVcclxuICogaXMgdGhlIG5hbWUgb2YgdGhlIHBsdWdpbi5cclxuICpcclxuICogQGV2ZW50ICAgIFBsYXllciNiZWZvcmVwbHVnaW5zZXR1cDokbmFtZVxyXG4gKiBAdHlwZSAgICAge1BsdWdpbn5QbHVnaW5FdmVudEhhc2h9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFNpZ25hbHMgdGhhdCBhIHBsdWdpbiBoYXMganVzdCBiZWVuIHNldCB1cCBvbiBhIHBsYXllci5cclxuICpcclxuICogQGV2ZW50ICAgIFBsYXllciNwbHVnaW5zZXR1cFxyXG4gKiBAdHlwZSAgICAge1BsdWdpbn5QbHVnaW5FdmVudEhhc2h9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFNpZ25hbHMgdGhhdCBhIHBsdWdpbiBoYXMganVzdCBiZWVuIHNldCB1cCBvbiBhIHBsYXllciAtIGJ5IG5hbWUuIFRoZSBuYW1lXHJcbiAqIGlzIHRoZSBuYW1lIG9mIHRoZSBwbHVnaW4uXHJcbiAqXHJcbiAqIEBldmVudCAgICBQbGF5ZXIjcGx1Z2luc2V0dXA6JG5hbWVcclxuICogQHR5cGUgICAgIHtQbHVnaW5+UGx1Z2luRXZlbnRIYXNofVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiAge09iamVjdH0gUGx1Z2luflBsdWdpbkV2ZW50SGFzaFxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaW5zdGFuY2VcclxuICogICAgICAgICAgIEZvciBiYXNpYyBwbHVnaW5zLCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwbHVnaW4gZnVuY3Rpb24uIEZvclxyXG4gKiAgICAgICAgICAgYWR2YW5jZWQgcGx1Z2lucywgdGhlIHBsdWdpbiBpbnN0YW5jZSBvbiB3aGljaCB0aGUgZXZlbnQgaXMgZmlyZWQuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXHJcbiAqICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luLlxyXG4gKlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGx1Z2luXHJcbiAqICAgICAgICAgICBGb3IgYmFzaWMgcGx1Z2lucywgdGhlIHBsdWdpbiBmdW5jdGlvbi4gRm9yIGFkdmFuY2VkIHBsdWdpbnMsIHRoZVxyXG4gKiAgICAgICAgICAgcGx1Z2luIGNsYXNzL2NvbnN0cnVjdG9yLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAZmlsZSBleHRlbmQuanNcclxuICogQG1vZHVsZSBleHRlbmRcclxuICovXHJcblxyXG4vKipcclxuICogQSBjb21iaW5hdGlvbiBvZiBub2RlIGluaGVyaXRzIGFuZCBiYWJlbCdzIGluaGVyaXRzIChhZnRlciB0cmFuc3BpbGUpLlxyXG4gKiBCb3RoIHdvcmsgdGhlIHNhbWUgYnV0IG5vZGUgYWRkcyBgc3VwZXJfYCB0byB0aGUgc3ViQ2xhc3NcclxuICogYW5kIEJhYmxlIGFkZHMgdGhlIHN1cGVyQ2xhc3MgYXMgX19wcm90b19fLiBCb3RoIHNlZW0gdXNlZnVsLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gc3ViQ2xhc3NcclxuICogICAgICAgIFRoZSBjbGFzcyB0byBpbmhlcml0IHRvXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdXBlckNsYXNzXHJcbiAqICAgICAgICBUaGUgY2xhc3MgdG8gaW5oZXJpdCBmcm9tXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG52YXIgX2luaGVyaXRzID0gZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XHJcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3VwZXJDbGFzcykpKTtcclxuICB9XHJcblxyXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xyXG4gICAgY29uc3RydWN0b3I6IHtcclxuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBpZiAoc3VwZXJDbGFzcykge1xyXG4gICAgLy8gbm9kZVxyXG4gICAgc3ViQ2xhc3Muc3VwZXJfID0gc3VwZXJDbGFzcztcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRnVuY3Rpb24gZm9yIHN1YmNsYXNzaW5nIHVzaW5nIHRoZSBzYW1lIGluaGVyaXRhbmNlIHRoYXRcclxuICogdmlkZW9qcyB1c2VzIGludGVybmFsbHlcclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAY29uc3RcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHN1cGVyQ2xhc3NcclxuICogICAgICAgIFRoZSBjbGFzcyB0byBpbmhlcml0IGZyb21cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFtzdWJDbGFzc01ldGhvZHM9e31dXHJcbiAqICAgICAgICBUaGUgY2xhc3MgdG8gaW5oZXJpdCB0b1xyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqICAgICAgICAgVGhlIG5ldyBvYmplY3Qgd2l0aCBzdWJDbGFzc01ldGhvZHMgdGhhdCBpbmhlcml0ZWQgc3VwZXJDbGFzcy5cclxuICovXHJcbnZhciBleHRlbmRGbiA9IGZ1bmN0aW9uIGV4dGVuZEZuKHN1cGVyQ2xhc3MpIHtcclxuICB2YXIgc3ViQ2xhc3NNZXRob2RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcclxuXHJcbiAgdmFyIHN1YkNsYXNzID0gZnVuY3Rpb24gc3ViQ2xhc3MoKSB7XHJcbiAgICBzdXBlckNsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIG1ldGhvZHMgPSB7fTtcclxuXHJcbiAgaWYgKCh0eXBlb2Ygc3ViQ2xhc3NNZXRob2RzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihzdWJDbGFzc01ldGhvZHMpKSA9PT0gJ29iamVjdCcpIHtcclxuICAgIGlmIChzdWJDbGFzc01ldGhvZHMuY29uc3RydWN0b3IgIT09IE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IpIHtcclxuICAgICAgc3ViQ2xhc3MgPSBzdWJDbGFzc01ldGhvZHMuY29uc3RydWN0b3I7XHJcbiAgICB9XHJcbiAgICBtZXRob2RzID0gc3ViQ2xhc3NNZXRob2RzO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHN1YkNsYXNzTWV0aG9kcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgc3ViQ2xhc3MgPSBzdWJDbGFzc01ldGhvZHM7XHJcbiAgfVxyXG5cclxuICBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xyXG5cclxuICAvLyBFeHRlbmQgc3ViT2JqJ3MgcHJvdG90eXBlIHdpdGggZnVuY3Rpb25zIGFuZCBvdGhlciBwcm9wZXJ0aWVzIGZyb20gcHJvcHNcclxuICBmb3IgKHZhciBuYW1lIGluIG1ldGhvZHMpIHtcclxuICAgIGlmIChtZXRob2RzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgIHN1YkNsYXNzLnByb3RvdHlwZVtuYW1lXSA9IG1ldGhvZHNbbmFtZV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3ViQ2xhc3M7XHJcbn07XHJcblxyXG4vKipcclxuICogQGZpbGUgdmlkZW8uanNcclxuICogQG1vZHVsZSB2aWRlb2pzXHJcbiAqL1xyXG4vLyBJbmNsdWRlIHRoZSBidWlsdC1pbiB0ZWNoc1xyXG4vLyBIVE1MNSBFbGVtZW50IFNoaW0gZm9yIElFOFxyXG5pZiAodHlwZW9mIEhUTUxWaWRlb0VsZW1lbnQgPT09ICd1bmRlZmluZWQnICYmIGlzUmVhbCgpKSB7XHJcbiAgZG9jdW1lbnRfMS5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xyXG4gIGRvY3VtZW50XzEuY3JlYXRlRWxlbWVudCgnYXVkaW8nKTtcclxuICBkb2N1bWVudF8xLmNyZWF0ZUVsZW1lbnQoJ3RyYWNrJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEb3VibGVzIGFzIHRoZSBtYWluIGZ1bmN0aW9uIGZvciB1c2VycyB0byBjcmVhdGUgYSBwbGF5ZXIgaW5zdGFuY2UgYW5kIGFsc29cclxuICogdGhlIG1haW4gbGlicmFyeSBvYmplY3QuXHJcbiAqIFRoZSBgdmlkZW9qc2AgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZSBvciByZXRyaWV2ZSBhIHBsYXllci5cclxuICAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR9IGlkXHJcbiAqICAgICAgICBWaWRlbyBlbGVtZW50IG9yIHZpZGVvIGVsZW1lbnQgSURcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG4gKiAgICAgICAgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgZm9yIGNvbmZpZy9zZXR0aW5nc1xyXG4gKlxyXG4gKiBAcGFyYW0ge0NvbXBvbmVudH5SZWFkeUNhbGxiYWNrfSBbcmVhZHldXHJcbiAqICAgICAgICBPcHRpb25hbCByZWFkeSBjYWxsYmFja1xyXG4gKlxyXG4gKiBAcmV0dXJuIHtQbGF5ZXJ9XHJcbiAqICAgICAgICAgQSBwbGF5ZXIgaW5zdGFuY2VcclxuICovXHJcbmZ1bmN0aW9uIHZpZGVvanMoaWQsIG9wdGlvbnMsIHJlYWR5KSB7XHJcbiAgdmFyIHRhZyA9IHZvaWQgMDtcclxuXHJcbiAgLy8gQWxsb3cgZm9yIGVsZW1lbnQgb3IgSUQgdG8gYmUgcGFzc2VkIGluXHJcbiAgLy8gU3RyaW5nIElEXHJcbiAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcclxuICAgIHZhciBwbGF5ZXJzID0gdmlkZW9qcy5nZXRQbGF5ZXJzKCk7XHJcblxyXG4gICAgLy8gQWRqdXN0IGZvciBqUXVlcnkgSUQgc3ludGF4XHJcbiAgICBpZiAoaWQuaW5kZXhPZignIycpID09PSAwKSB7XHJcbiAgICAgIGlkID0gaWQuc2xpY2UoMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgYSBwbGF5ZXIgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkIGZvciB0aGlzIElEIHJldHVybiBpdC5cclxuICAgIGlmIChwbGF5ZXJzW2lkXSkge1xyXG5cclxuICAgICAgLy8gSWYgb3B0aW9ucyBvciByZWFkeSBmdW5jdGlvbiBhcmUgcGFzc2VkLCB3YXJuXHJcbiAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgbG9nJDEud2FybignUGxheWVyIFwiJyArIGlkICsgJ1wiIGlzIGFscmVhZHkgaW5pdGlhbGlzZWQuIE9wdGlvbnMgd2lsbCBub3QgYmUgYXBwbGllZC4nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlYWR5KSB7XHJcbiAgICAgICAgcGxheWVyc1tpZF0ucmVhZHkocmVhZHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcGxheWVyc1tpZF07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT3RoZXJ3aXNlIGdldCBlbGVtZW50IGZvciBJRFxyXG4gICAgdGFnID0gJCgnIycgKyBpZCk7XHJcblxyXG4gICAgLy8gSUQgaXMgYSBtZWRpYSBlbGVtZW50XHJcbiAgfSBlbHNlIHtcclxuICAgIHRhZyA9IGlkO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgZm9yIGEgdXNlYWJsZSBlbGVtZW50XHJcbiAgLy8gcmU6IG5vZGVOYW1lLCBjb3VsZCBiZSBhIGJveCBkaXYgYWxzb1xyXG4gIGlmICghdGFnIHx8ICF0YWcubm9kZU5hbWUpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBlbGVtZW50IG9yIElEIHN1cHBsaWVkIGlzIG5vdCB2YWxpZC4gKHZpZGVvanMpJyk7XHJcbiAgfVxyXG5cclxuICAvLyBFbGVtZW50IG1heSBoYXZlIGEgcGxheWVyIGF0dHIgcmVmZXJyaW5nIHRvIGFuIGFscmVhZHkgY3JlYXRlZCBwbGF5ZXIgaW5zdGFuY2UuXHJcbiAgLy8gSWYgc28gcmV0dXJuIHRoYXQgb3RoZXJ3aXNlIHNldCB1cCBhIG5ldyBwbGF5ZXIgYmVsb3dcclxuICBpZiAodGFnLnBsYXllciB8fCBQbGF5ZXIucGxheWVyc1t0YWcucGxheWVySWRdKSB7XHJcbiAgICByZXR1cm4gdGFnLnBsYXllciB8fCBQbGF5ZXIucGxheWVyc1t0YWcucGxheWVySWRdO1xyXG4gIH1cclxuXHJcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gIHZpZGVvanMuaG9va3MoJ2JlZm9yZXNldHVwJykuZm9yRWFjaChmdW5jdGlvbiAoaG9va0Z1bmN0aW9uKSB7XHJcbiAgICB2YXIgb3B0cyA9IGhvb2tGdW5jdGlvbih0YWcsIG1lcmdlT3B0aW9ucyhvcHRpb25zKSk7XHJcblxyXG4gICAgaWYgKCFpc09iamVjdChvcHRzKSB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XHJcbiAgICAgIGxvZyQxLmVycm9yKCdwbGVhc2UgcmV0dXJuIGFuIG9iamVjdCBpbiBiZWZvcmVzZXR1cCBob29rcycpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhvcHRpb25zLCBvcHRzKTtcclxuICB9KTtcclxuXHJcbiAgdmFyIFBsYXllckNvbXBvbmVudCA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoJ1BsYXllcicpO1xyXG4gIC8vIElmIG5vdCwgc2V0IHVwIGEgbmV3IHBsYXllclxyXG4gIHZhciBwbGF5ZXIgPSBuZXcgUGxheWVyQ29tcG9uZW50KHRhZywgb3B0aW9ucywgcmVhZHkpO1xyXG5cclxuICB2aWRlb2pzLmhvb2tzKCdzZXR1cCcpLmZvckVhY2goZnVuY3Rpb24gKGhvb2tGdW5jdGlvbikge1xyXG4gICAgcmV0dXJuIGhvb2tGdW5jdGlvbihwbGF5ZXIpO1xyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gcGxheWVyO1xyXG59XHJcblxyXG4vKipcclxuICogQW4gT2JqZWN0IHRoYXQgY29udGFpbnMgbGlmZWN5Y2xlIGhvb2tzIGFzIGtleXMgd2hpY2ggcG9pbnQgdG8gYW4gYXJyYXlcclxuICogb2YgZnVuY3Rpb25zIHRoYXQgYXJlIHJ1biB3aGVuIGEgbGlmZWN5Y2xlIGlzIHRyaWdnZXJlZFxyXG4gKi9cclxudmlkZW9qcy5ob29rc18gPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBsaXN0IG9mIGhvb2tzIGZvciBhIHNwZWNpZmljIGxpZmVjeWNsZVxyXG4gKiBAZnVuY3Rpb24gdmlkZW9qcy5ob29rc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxyXG4gKiAgICAgICAgdGhlIGxpZmVjeWxlIHRvIGdldCBob29rcyBmcm9tXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cclxuICogICAgICAgIE9wdGlvbmFsbHkgYWRkIGEgaG9vayB0byB0aGUgbGlmZWN5Y2xlIHRoYXQgeW91ciBhcmUgZ2V0dGluZy5cclxuICpcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqICAgICAgICAgYW4gYXJyYXkgb2YgaG9va3MsIG9yIGFuIGVtcHR5IGFycmF5IGlmIHRoZXJlIGFyZSBub25lLlxyXG4gKi9cclxudmlkZW9qcy5ob29rcyA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xyXG4gIHZpZGVvanMuaG9va3NfW3R5cGVdID0gdmlkZW9qcy5ob29rc19bdHlwZV0gfHwgW107XHJcbiAgaWYgKGZuKSB7XHJcbiAgICB2aWRlb2pzLmhvb2tzX1t0eXBlXSA9IHZpZGVvanMuaG9va3NfW3R5cGVdLmNvbmNhdChmbik7XHJcbiAgfVxyXG4gIHJldHVybiB2aWRlb2pzLmhvb2tzX1t0eXBlXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGQgYSBmdW5jdGlvbiBob29rIHRvIGEgc3BlY2lmaWMgdmlkZW9qcyBsaWZlY3ljbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXHJcbiAqICAgICAgICB0aGUgbGlmZWN5Y2xlIHRvIGhvb2sgdGhlIGZ1bmN0aW9uIHRvLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufEZ1bmN0aW9uW119XHJcbiAqICAgICAgICBUaGUgZnVuY3Rpb24gb3IgYXJyYXkgb2YgZnVuY3Rpb25zIHRvIGF0dGFjaC5cclxuICovXHJcbnZpZGVvanMuaG9vayA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xyXG4gIHZpZGVvanMuaG9va3ModHlwZSwgZm4pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhIGhvb2sgZnJvbSBhIHNwZWNpZmljIHZpZGVvanMgbGlmZWN5Y2xlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxyXG4gKiAgICAgICAgdGhlIGxpZmVjeWNsZSB0aGF0IHRoZSBmdW5jdGlvbiBob29rZWQgdG9cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogICAgICAgIFRoZSBob29rZWQgZnVuY3Rpb24gdG8gcmVtb3ZlXHJcbiAqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqICAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgd2FzIHJlbW92ZWQgb3IgdW5kZWZcclxuICovXHJcbnZpZGVvanMucmVtb3ZlSG9vayA9IGZ1bmN0aW9uICh0eXBlLCBmbikge1xyXG4gIHZhciBpbmRleCA9IHZpZGVvanMuaG9va3ModHlwZSkuaW5kZXhPZihmbik7XHJcblxyXG4gIGlmIChpbmRleCA8PSAtMSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgdmlkZW9qcy5ob29rc19bdHlwZV0gPSB2aWRlb2pzLmhvb2tzX1t0eXBlXS5zbGljZSgpO1xyXG4gIHZpZGVvanMuaG9va3NfW3R5cGVdLnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuLy8gQWRkIGRlZmF1bHQgc3R5bGVzXHJcbmlmICh3aW5kb3dfMS5WSURFT0pTX05PX0RZTkFNSUNfU1RZTEUgIT09IHRydWUgJiYgaXNSZWFsKCkpIHtcclxuICB2YXIgc3R5bGUgPSAkKCcudmpzLXN0eWxlcy1kZWZhdWx0cycpO1xyXG5cclxuICBpZiAoIXN0eWxlKSB7XHJcbiAgICBzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudCgndmpzLXN0eWxlcy1kZWZhdWx0cycpO1xyXG4gICAgdmFyIGhlYWQgPSAkKCdoZWFkJyk7XHJcblxyXG4gICAgaWYgKGhlYWQpIHtcclxuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGUsIGhlYWQuZmlyc3RDaGlsZCk7XHJcbiAgICB9XHJcbiAgICBzZXRUZXh0Q29udGVudChzdHlsZSwgJ1xcbiAgICAgIC52aWRlby1qcyB7XFxuICAgICAgICB3aWR0aDogMzAwcHg7XFxuICAgICAgICBoZWlnaHQ6IDE1MHB4O1xcbiAgICAgIH1cXG5cXG4gICAgICAudmpzLWZsdWlkIHtcXG4gICAgICAgIHBhZGRpbmctdG9wOiA1Ni4yNSVcXG4gICAgICB9XFxuICAgICcpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gUnVuIEF1dG8tbG9hZCBwbGF5ZXJzXHJcbi8vIFlvdSBoYXZlIHRvIHdhaXQgYXQgbGVhc3Qgb25jZSBpbiBjYXNlIHRoaXMgc2NyaXB0IGlzIGxvYWRlZCBhZnRlciB5b3VyXHJcbi8vIHZpZGVvIGluIHRoZSBET00gKHdlaXJkIGJlaGF2aW9yIG9ubHkgd2l0aCBtaW5pZmllZCB2ZXJzaW9uKVxyXG5hdXRvU2V0dXBUaW1lb3V0KDEsIHZpZGVvanMpO1xyXG5cclxuLyoqXHJcbiAqIEN1cnJlbnQgc29mdHdhcmUgdmVyc2lvbi4gRm9sbG93cyBzZW12ZXIuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xyXG52aWRlb2pzLlZFUlNJT04gPSB2ZXJzaW9uO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBnbG9iYWwgb3B0aW9ucyBvYmplY3QuIFRoZXNlIGFyZSB0aGUgc2V0dGluZ3MgdGhhdCB0YWtlIGVmZmVjdFxyXG4gKiBpZiBubyBvdmVycmlkZXMgYXJlIHNwZWNpZmllZCB3aGVuIHRoZSBwbGF5ZXIgaXMgY3JlYXRlZC5cclxuICpcclxuICogQHR5cGUge09iamVjdH1cclxuICovXHJcbnZpZGVvanMub3B0aW9ucyA9IFBsYXllci5wcm90b3R5cGUub3B0aW9uc187XHJcblxyXG4vKipcclxuICogR2V0IGFuIG9iamVjdCB3aXRoIHRoZSBjdXJyZW50bHkgY3JlYXRlZCBwbGF5ZXJzLCBrZXllZCBieSBwbGF5ZXIgSURcclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiAgICAgICAgIFRoZSBjcmVhdGVkIHBsYXllcnNcclxuICovXHJcbnZpZGVvanMuZ2V0UGxheWVycyA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gUGxheWVyLnBsYXllcnM7XHJcbn07XHJcblxyXG4vKipcclxuICogRXhwb3NlIHBsYXllcnMgb2JqZWN0LlxyXG4gKlxyXG4gKiBAbWVtYmVyT2YgdmlkZW9qc1xyXG4gKiBAcHJvcGVydHkge09iamVjdH0gcGxheWVyc1xyXG4gKi9cclxudmlkZW9qcy5wbGF5ZXJzID0gUGxheWVyLnBsYXllcnM7XHJcblxyXG4vKipcclxuICogR2V0IGEgY29tcG9uZW50IGNsYXNzIG9iamVjdCBieSBuYW1lXHJcbiAqXHJcbiAqIEBib3Jyb3dzIENvbXBvbmVudC5nZXRDb21wb25lbnQgYXMgdmlkZW9qcy5nZXRDb21wb25lbnRcclxuICovXHJcbnZpZGVvanMuZ2V0Q29tcG9uZW50ID0gQ29tcG9uZW50LmdldENvbXBvbmVudDtcclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlciBhIGNvbXBvbmVudCBzbyBpdCBjYW4gcmVmZXJyZWQgdG8gYnkgbmFtZS4gVXNlZCB3aGVuIGFkZGluZyB0byBvdGhlclxyXG4gKiBjb21wb25lbnRzLCBlaXRoZXIgdGhyb3VnaCBhZGRDaGlsZCBgY29tcG9uZW50LmFkZENoaWxkKCdteUNvbXBvbmVudCcpYCBvciB0aHJvdWdoXHJcbiAqIGRlZmF1bHQgY2hpbGRyZW4gb3B0aW9ucyAgYHsgY2hpbGRyZW46IFsnbXlDb21wb25lbnQnXSB9YC5cclxuICpcclxuICogPiBOT1RFOiBZb3UgY291bGQgYWxzbyBqdXN0IGluaXRpYWxpemUgdGhlIGNvbXBvbmVudCBiZWZvcmUgYWRkaW5nLlxyXG4gKiBgY29tcG9uZW50LmFkZENoaWxkKG5ldyBNeUNvbXBvbmVudCgpKTtgXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcbiAqICAgICAgICBUaGUgY2xhc3MgbmFtZSBvZiB0aGUgY29tcG9uZW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBjb21wXHJcbiAqICAgICAgICBUaGUgY29tcG9uZW50IGNsYXNzXHJcbiAqXHJcbiAqIEByZXR1cm4ge0NvbXBvbmVudH1cclxuICogICAgICAgICBUaGUgbmV3bHkgcmVnaXN0ZXJlZCBjb21wb25lbnRcclxuICovXHJcbnZpZGVvanMucmVnaXN0ZXJDb21wb25lbnQgPSBmdW5jdGlvbiAobmFtZSQkMSwgY29tcCkge1xyXG4gIGlmIChUZWNoLmlzVGVjaChjb21wKSkge1xyXG4gICAgbG9nJDEud2FybignVGhlICcgKyBuYW1lJCQxICsgJyB0ZWNoIHdhcyByZWdpc3RlcmVkIGFzIGEgY29tcG9uZW50LiBJdCBzaG91bGQgaW5zdGVhZCBiZSByZWdpc3RlcmVkIHVzaW5nIHZpZGVvanMucmVnaXN0ZXJUZWNoKG5hbWUsIHRlY2gpJyk7XHJcbiAgfVxyXG5cclxuICBDb21wb25lbnQucmVnaXN0ZXJDb21wb25lbnQuY2FsbChDb21wb25lbnQsIG5hbWUkJDEsIGNvbXApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBhIFRlY2ggY2xhc3Mgb2JqZWN0IGJ5IG5hbWVcclxuICpcclxuICogQGJvcnJvd3MgVGVjaC5nZXRUZWNoIGFzIHZpZGVvanMuZ2V0VGVjaFxyXG4gKi9cclxudmlkZW9qcy5nZXRUZWNoID0gVGVjaC5nZXRUZWNoO1xyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVyIGEgVGVjaCBzbyBpdCBjYW4gcmVmZXJyZWQgdG8gYnkgbmFtZS5cclxuICogVGhpcyBpcyB1c2VkIGluIHRoZSB0ZWNoIG9yZGVyIGZvciB0aGUgcGxheWVyLlxyXG4gKlxyXG4gKiBAYm9ycm93cyBUZWNoLnJlZ2lzdGVyVGVjaCBhcyB2aWRlb2pzLnJlZ2lzdGVyVGVjaFxyXG4gKi9cclxudmlkZW9qcy5yZWdpc3RlclRlY2ggPSBUZWNoLnJlZ2lzdGVyVGVjaDtcclxuXHJcbnZpZGVvanMudXNlID0gdXNlO1xyXG5cclxuLyoqXHJcbiAqIEEgc3VpdGUgb2YgYnJvd3NlciBhbmQgZGV2aWNlIHRlc3RzIGZyb20ge0BsaW5rIGJyb3dzZXJ9LlxyXG4gKlxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxudmlkZW9qcy5icm93c2VyID0gYnJvd3NlcjtcclxuXHJcbi8qKlxyXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciBzdXBwb3J0cyB0b3VjaCBldmVudHMuIEluY2x1ZGVkIGZvciBiYWNrd2FyZFxyXG4gKiBjb21wYXRpYmlsaXR5IHdpdGggNC54LCBidXQgZGVwcmVjYXRlZC4gVXNlIGB2aWRlb2pzLmJyb3dzZXIuVE9VQ0hfRU5BQkxFRGBcclxuICogaW5zdGVhZCBnb2luZyBmb3J3YXJkLlxyXG4gKlxyXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDUuMFxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICovXHJcbnZpZGVvanMuVE9VQ0hfRU5BQkxFRCA9IFRPVUNIX0VOQUJMRUQ7XHJcblxyXG4vKipcclxuICogU3ViY2xhc3MgYW4gZXhpc3RpbmcgY2xhc3NcclxuICogTWltaWNzIEVTNiBzdWJjbGFzc2luZyB3aXRoIHRoZSBgZXh0ZW5kYCBrZXl3b3JkXHJcbiAqXHJcbiAqIEBib3Jyb3dzIGV4dGVuZDpleHRlbmRGbiBhcyB2aWRlb2pzLmV4dGVuZFxyXG4gKi9cclxudmlkZW9qcy5leHRlbmQgPSBleHRlbmRGbjtcclxuXHJcbi8qKlxyXG4gKiBNZXJnZSB0d28gb3B0aW9ucyBvYmplY3RzIHJlY3Vyc2l2ZWx5XHJcbiAqIFBlcmZvcm1zIGEgZGVlcCBtZXJnZSBsaWtlIGxvZGFzaC5tZXJnZSBidXQgKipvbmx5IG1lcmdlcyBwbGFpbiBvYmplY3RzKipcclxuICogKG5vdCBhcnJheXMsIGVsZW1lbnRzLCBhbnl0aGluZyBlbHNlKVxyXG4gKiBPdGhlciB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQgZGlyZWN0bHkgZnJvbSB0aGUgc2Vjb25kIG9iamVjdC5cclxuICpcclxuICogQGJvcnJvd3MgbWVyZ2Utb3B0aW9uczptZXJnZU9wdGlvbnMgYXMgdmlkZW9qcy5tZXJnZU9wdGlvbnNcclxuICovXHJcbnZpZGVvanMubWVyZ2VPcHRpb25zID0gbWVyZ2VPcHRpb25zO1xyXG5cclxuLyoqXHJcbiAqIENoYW5nZSB0aGUgY29udGV4dCAodGhpcykgb2YgYSBmdW5jdGlvblxyXG4gKlxyXG4gKiA+IE5PVEU6IGFzIG9mIHY1LjAgd2UgcmVxdWlyZSBhbiBFUzUgc2hpbSwgc28geW91IHNob3VsZCB1c2UgdGhlIG5hdGl2ZVxyXG4gKiBgZnVuY3Rpb24oKSB7fS5iaW5kKG5ld0NvbnRleHQpO2AgaW5zdGVhZCBvZiB0aGlzLlxyXG4gKlxyXG4gKiBAYm9ycm93cyBmbjpiaW5kIGFzIHZpZGVvanMuYmluZFxyXG4gKi9cclxudmlkZW9qcy5iaW5kID0gYmluZDtcclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlciBhIFZpZGVvLmpzIHBsdWdpbi5cclxuICpcclxuICogQGJvcnJvd3MgcGx1Z2luOnJlZ2lzdGVyUGx1Z2luIGFzIHZpZGVvanMucmVnaXN0ZXJQbHVnaW5cclxuICogQG1ldGhvZCByZWdpc3RlclBsdWdpblxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWVcclxuICogICAgICAgICBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIHRvIGJlIHJlZ2lzdGVyZWQuIE11c3QgYmUgYSBzdHJpbmcgYW5kXHJcbiAqICAgICAgICAgbXVzdCBub3QgbWF0Y2ggYW4gZXhpc3RpbmcgcGx1Z2luIG9yIGEgbWV0aG9kIG9uIHRoZSBgUGxheWVyYFxyXG4gKiAgICAgICAgIHByb3RvdHlwZS5cclxuICpcclxuICogQHBhcmFtICB7RnVuY3Rpb259IHBsdWdpblxyXG4gKiAgICAgICAgIEEgc3ViLWNsYXNzIG9mIGBQbHVnaW5gIG9yIGEgZnVuY3Rpb24gZm9yIGJhc2ljIHBsdWdpbnMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxyXG4gKiAgICAgICAgIEZvciBhZHZhbmNlZCBwbHVnaW5zLCBhIGZhY3RvcnkgZnVuY3Rpb24gZm9yIHRoYXQgcGx1Z2luLiBGb3JcclxuICogICAgICAgICBiYXNpYyBwbHVnaW5zLCBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCBpbml0aWFsaXplcyB0aGUgcGx1Z2luLlxyXG4gKi9cclxudmlkZW9qcy5yZWdpc3RlclBsdWdpbiA9IFBsdWdpbi5yZWdpc3RlclBsdWdpbjtcclxuXHJcbi8qKlxyXG4gKiBEZXByZWNhdGVkIG1ldGhvZCB0byByZWdpc3RlciBhIHBsdWdpbiB3aXRoIFZpZGVvLmpzXHJcbiAqXHJcbiAqIEBkZXByZWNhdGVkXHJcbiAqICAgICAgICB2aWRlb2pzLnBsdWdpbigpIGlzIGRlcHJlY2F0ZWQ7IHVzZSB2aWRlb2pzLnJlZ2lzdGVyUGx1Z2luKCkgaW5zdGVhZFxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gKiAgICAgICAgVGhlIHBsdWdpbiBuYW1lXHJcbiAqXHJcbiAqIEBwYXJhbSB7UGx1Z2lufEZ1bmN0aW9ufSBwbHVnaW5cclxuICogICAgICAgICBUaGUgcGx1Z2luIHN1Yi1jbGFzcyBvciBmdW5jdGlvblxyXG4gKi9cclxudmlkZW9qcy5wbHVnaW4gPSBmdW5jdGlvbiAobmFtZSQkMSwgcGx1Z2luKSB7XHJcbiAgbG9nJDEud2FybigndmlkZW9qcy5wbHVnaW4oKSBpcyBkZXByZWNhdGVkOyB1c2UgdmlkZW9qcy5yZWdpc3RlclBsdWdpbigpIGluc3RlYWQnKTtcclxuICByZXR1cm4gUGx1Z2luLnJlZ2lzdGVyUGx1Z2luKG5hbWUkJDEsIHBsdWdpbik7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyBhbiBvYmplY3QgY29udGFpbmluZyBtdWx0aXBsZSBWaWRlby5qcyBwbHVnaW5zLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtBcnJheX0gW25hbWVzXVxyXG4gKiAgICAgICAgIElmIHByb3ZpZGVkLCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgcGx1Z2luIG5hbWVzLiBEZWZhdWx0cyB0byBfYWxsX1xyXG4gKiAgICAgICAgIHBsdWdpbiBuYW1lcy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH1cclxuICogICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBwbHVnaW4ocykgYXNzb2NpYXRlZCB3aXRoIHRoZWlyIG5hbWUocykgb3JcclxuICogICAgICAgICBgdW5kZWZpbmVkYCBpZiBubyBtYXRjaGluZyBwbHVnaW5zIGV4aXN0KS5cclxuICovXHJcbnZpZGVvanMuZ2V0UGx1Z2lucyA9IFBsdWdpbi5nZXRQbHVnaW5zO1xyXG5cclxuLyoqXHJcbiAqIEdldHMgYSBwbHVnaW4gYnkgbmFtZSBpZiBpdCBleGlzdHMuXHJcbiAqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxyXG4gKiAgICAgICAgIFRoZSBuYW1lIG9mIGEgcGx1Z2luLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XHJcbiAqICAgICAgICAgVGhlIHBsdWdpbiAob3IgYHVuZGVmaW5lZGApLlxyXG4gKi9cclxudmlkZW9qcy5nZXRQbHVnaW4gPSBQbHVnaW4uZ2V0UGx1Z2luO1xyXG5cclxuLyoqXHJcbiAqIEdldHMgYSBwbHVnaW4ncyB2ZXJzaW9uLCBpZiBhdmFpbGFibGVcclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXHJcbiAqICAgICAgICAgVGhlIG5hbWUgb2YgYSBwbHVnaW4uXHJcbiAqXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICogICAgICAgICBUaGUgcGx1Z2luJ3MgdmVyc2lvbiBvciBhbiBlbXB0eSBzdHJpbmcuXHJcbiAqL1xyXG52aWRlb2pzLmdldFBsdWdpblZlcnNpb24gPSBQbHVnaW4uZ2V0UGx1Z2luVmVyc2lvbjtcclxuXHJcbi8qKlxyXG4gKiBBZGRpbmcgbGFuZ3VhZ2VzIHNvIHRoYXQgdGhleSdyZSBhdmFpbGFibGUgdG8gYWxsIHBsYXllcnMuXHJcbiAqIEV4YW1wbGU6IGB2aWRlb2pzLmFkZExhbmd1YWdlKCdlcycsIHsgJ0hlbGxvJzogJ0hvbGEnIH0pO2BcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcclxuICogICAgICAgIFRoZSBsYW5ndWFnZSBjb2RlIG9yIGRpY3Rpb25hcnkgcHJvcGVydHlcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuICogICAgICAgIFRoZSBkYXRhIHZhbHVlcyB0byBiZSB0cmFuc2xhdGVkXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogICAgICAgICBUaGUgcmVzdWx0aW5nIGxhbmd1YWdlIGRpY3Rpb25hcnkgb2JqZWN0XHJcbiAqL1xyXG52aWRlb2pzLmFkZExhbmd1YWdlID0gZnVuY3Rpb24gKGNvZGUsIGRhdGEpIHtcclxuICB2YXIgX21lcmdlT3B0aW9ucztcclxuXHJcbiAgY29kZSA9ICgnJyArIGNvZGUpLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gIHZpZGVvanMub3B0aW9ucy5sYW5ndWFnZXMgPSBtZXJnZU9wdGlvbnModmlkZW9qcy5vcHRpb25zLmxhbmd1YWdlcywgKF9tZXJnZU9wdGlvbnMgPSB7fSwgX21lcmdlT3B0aW9uc1tjb2RlXSA9IGRhdGEsIF9tZXJnZU9wdGlvbnMpKTtcclxuXHJcbiAgcmV0dXJuIHZpZGVvanMub3B0aW9ucy5sYW5ndWFnZXNbY29kZV07XHJcbn07XHJcblxyXG4vKipcclxuICogTG9nIG1lc3NhZ2VzXHJcbiAqXHJcbiAqIEBib3Jyb3dzIGxvZzpsb2cgYXMgdmlkZW9qcy5sb2dcclxuICovXHJcbnZpZGVvanMubG9nID0gbG9nJDE7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBlbXVsYXRlZCBUaW1lUmFuZ2Ugb2JqZWN0LlxyXG4gKlxyXG4gKiBAYm9ycm93cyB0aW1lLXJhbmdlczpjcmVhdGVUaW1lUmFuZ2VzIGFzIHZpZGVvanMuY3JlYXRlVGltZVJhbmdlXHJcbiAqL1xyXG4vKipcclxuICogQGJvcnJvd3MgdGltZS1yYW5nZXM6Y3JlYXRlVGltZVJhbmdlcyBhcyB2aWRlb2pzLmNyZWF0ZVRpbWVSYW5nZXNcclxuICovXHJcbnZpZGVvanMuY3JlYXRlVGltZVJhbmdlID0gdmlkZW9qcy5jcmVhdGVUaW1lUmFuZ2VzID0gY3JlYXRlVGltZVJhbmdlcztcclxuXHJcbi8qKlxyXG4gKiBGb3JtYXQgc2Vjb25kcyBhcyBhIHRpbWUgc3RyaW5nLCBIOk1NOlNTIG9yIE06U1NcclxuICogU3VwcGx5aW5nIGEgZ3VpZGUgKGluIHNlY29uZHMpIHdpbGwgZm9yY2UgYSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvc1xyXG4gKiB0byBjb3ZlciB0aGUgbGVuZ3RoIG9mIHRoZSBndWlkZVxyXG4gKlxyXG4gKiBAYm9ycm93cyBmb3JtYXQtdGltZTpmb3JtYXRUaW1lIGFzIHZpZGVvanMuZm9ybWF0VGltZVxyXG4gKi9cclxudmlkZW9qcy5mb3JtYXRUaW1lID0gZm9ybWF0VGltZTtcclxuXHJcbi8qKlxyXG4gKiBSZXNvbHZlIGFuZCBwYXJzZSB0aGUgZWxlbWVudHMgb2YgYSBVUkxcclxuICpcclxuICogQGJvcnJvd3MgdXJsOnBhcnNlVXJsIGFzIHZpZGVvanMucGFyc2VVcmxcclxuICovXHJcbnZpZGVvanMucGFyc2VVcmwgPSBwYXJzZVVybDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHVybCBwYXNzZWQgaXMgYSBjcm9zcyBkb21haW4gcmVxdWVzdCBvciBub3QuXHJcbiAqXHJcbiAqIEBib3Jyb3dzIHVybDppc0Nyb3NzT3JpZ2luIGFzIHZpZGVvanMuaXNDcm9zc09yaWdpblxyXG4gKi9cclxudmlkZW9qcy5pc0Nyb3NzT3JpZ2luID0gaXNDcm9zc09yaWdpbjtcclxuXHJcbi8qKlxyXG4gKiBFdmVudCB0YXJnZXQgY2xhc3MuXHJcbiAqXHJcbiAqIEBib3Jyb3dzIEV2ZW50VGFyZ2V0IGFzIHZpZGVvanMuRXZlbnRUYXJnZXRcclxuICovXHJcbnZpZGVvanMuRXZlbnRUYXJnZXQgPSBFdmVudFRhcmdldDtcclxuXHJcbi8qKlxyXG4gKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gZWxlbWVudFxyXG4gKiBJdCBzdG9yZXMgdGhlIGhhbmRsZXIgZnVuY3Rpb24gaW4gYSBzZXBhcmF0ZSBjYWNoZSBvYmplY3RcclxuICogYW5kIGFkZHMgYSBnZW5lcmljIGhhbmRsZXIgdG8gdGhlIGVsZW1lbnQncyBldmVudCxcclxuICogYWxvbmcgd2l0aCBhIHVuaXF1ZSBpZCAoZ3VpZCkgdG8gdGhlIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBib3Jyb3dzIGV2ZW50czpvbiBhcyB2aWRlb2pzLm9uXHJcbiAqL1xyXG52aWRlb2pzLm9uID0gb247XHJcblxyXG4vKipcclxuICogVHJpZ2dlciBhIGxpc3RlbmVyIG9ubHkgb25jZSBmb3IgYW4gZXZlbnRcclxuICpcclxuICogQGJvcnJvd3MgZXZlbnRzOm9uZSBhcyB2aWRlb2pzLm9uZVxyXG4gKi9cclxudmlkZW9qcy5vbmUgPSBvbmU7XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgZnJvbSBhbiBlbGVtZW50XHJcbiAqXHJcbiAqIEBib3Jyb3dzIGV2ZW50czpvZmYgYXMgdmlkZW9qcy5vZmZcclxuICovXHJcbnZpZGVvanMub2ZmID0gb2ZmO1xyXG5cclxuLyoqXHJcbiAqIFRyaWdnZXIgYW4gZXZlbnQgZm9yIGFuIGVsZW1lbnRcclxuICpcclxuICogQGJvcnJvd3MgZXZlbnRzOnRyaWdnZXIgYXMgdmlkZW9qcy50cmlnZ2VyXHJcbiAqL1xyXG52aWRlb2pzLnRyaWdnZXIgPSB0cmlnZ2VyO1xyXG5cclxuLyoqXHJcbiAqIEEgY3Jvc3MtYnJvd3NlciBYTUxIdHRwUmVxdWVzdCB3cmFwcGVyLiBIZXJlJ3MgYSBzaW1wbGUgZXhhbXBsZTpcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICogICAgICAgIHNldHRpbmdzIGZvciB0aGUgcmVxdWVzdC5cclxuICpcclxuICogQHJldHVybiB7WE1MSHR0cFJlcXVlc3R8WERvbWFpblJlcXVlc3R9XHJcbiAqICAgICAgICAgVGhlIHJlcXVlc3Qgb2JqZWN0LlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SYXlub3MveGhyXHJcbiAqL1xyXG52aWRlb2pzLnhociA9IHhocjtcclxuXHJcbi8qKlxyXG4gKiBUZXh0VHJhY2sgY2xhc3NcclxuICpcclxuICogQGJvcnJvd3MgVGV4dFRyYWNrIGFzIHZpZGVvanMuVGV4dFRyYWNrXHJcbiAqL1xyXG52aWRlb2pzLlRleHRUcmFjayA9IFRleHRUcmFjaztcclxuXHJcbi8qKlxyXG4gKiBleHBvcnQgdGhlIEF1ZGlvVHJhY2sgY2xhc3Mgc28gdGhhdCBzb3VyY2UgaGFuZGxlcnMgY2FuIGNyZWF0ZVxyXG4gKiBBdWRpb1RyYWNrcyBhbmQgdGhlbiBhZGQgdGhlbSB0byB0aGUgcGxheWVycyBBdWRpb1RyYWNrTGlzdFxyXG4gKlxyXG4gKiBAYm9ycm93cyBBdWRpb1RyYWNrIGFzIHZpZGVvanMuQXVkaW9UcmFja1xyXG4gKi9cclxudmlkZW9qcy5BdWRpb1RyYWNrID0gQXVkaW9UcmFjaztcclxuXHJcbi8qKlxyXG4gKiBleHBvcnQgdGhlIFZpZGVvVHJhY2sgY2xhc3Mgc28gdGhhdCBzb3VyY2UgaGFuZGxlcnMgY2FuIGNyZWF0ZVxyXG4gKiBWaWRlb1RyYWNrcyBhbmQgdGhlbiBhZGQgdGhlbSB0byB0aGUgcGxheWVycyBWaWRlb1RyYWNrTGlzdFxyXG4gKlxyXG4gKiBAYm9ycm93cyBWaWRlb1RyYWNrIGFzIHZpZGVvanMuVmlkZW9UcmFja1xyXG4gKi9cclxudmlkZW9qcy5WaWRlb1RyYWNrID0gVmlkZW9UcmFjaztcclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzLCB2aWEgZHVjayB0eXBpbmcsIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUgaXMgYSBET00gZWxlbWVudC5cclxuICpcclxuICogQGJvcnJvd3MgZG9tOmlzRWwgYXMgdmlkZW9qcy5pc0VsXHJcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5pc0VsKCkgaW5zdGVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzLCB2aWEgZHVjayB0eXBpbmcsIHdoZXRoZXIgb3Igbm90IGEgdmFsdWUgaXMgYSB0ZXh0IG5vZGUuXHJcbiAqXHJcbiAqIEBib3Jyb3dzIGRvbTppc1RleHROb2RlIGFzIHZpZGVvanMuaXNUZXh0Tm9kZVxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uaXNUZXh0Tm9kZSgpIGluc3RlYWRcclxuICovXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBlbGVtZW50IGFuZCBhcHBsaWVzIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBib3Jyb3dzIGRvbTpjcmVhdGVFbCBhcyB2aWRlb2pzLmNyZWF0ZUVsXHJcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5jcmVhdGVFbCgpIGluc3RlYWRcclxuICovXHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBoYXMgYSBDU1MgY2xhc3NcclxuICpcclxuICogQGJvcnJvd3MgZG9tOmhhc0VsQ2xhc3MgYXMgdmlkZW9qcy5oYXNDbGFzc1xyXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uaGFzQ2xhc3MoKSBpbnN0ZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEFkZCBhIENTUyBjbGFzcyBuYW1lIHRvIGFuIGVsZW1lbnRcclxuICpcclxuICogQGJvcnJvd3MgZG9tOmFkZEVsQ2xhc3MgYXMgdmlkZW9qcy5hZGRDbGFzc1xyXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uYWRkQ2xhc3MoKSBpbnN0ZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSBhIENTUyBjbGFzcyBuYW1lIGZyb20gYW4gZWxlbWVudFxyXG4gKlxyXG4gKiBAYm9ycm93cyBkb206cmVtb3ZlRWxDbGFzcyBhcyB2aWRlb2pzLnJlbW92ZUNsYXNzXHJcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5yZW1vdmVDbGFzcygpIGluc3RlYWRcclxuICovXHJcblxyXG4vKipcclxuICogQWRkcyBvciByZW1vdmVzIGEgQ1NTIGNsYXNzIG5hbWUgb24gYW4gZWxlbWVudCBkZXBlbmRpbmcgb24gYW4gb3B0aW9uYWxcclxuICogY29uZGl0aW9uIG9yIHRoZSBwcmVzZW5jZS9hYnNlbmNlIG9mIHRoZSBjbGFzcyBuYW1lLlxyXG4gKlxyXG4gKiBAYm9ycm93cyBkb206dG9nZ2xlRWxDbGFzcyBhcyB2aWRlb2pzLnRvZ2dsZUNsYXNzXHJcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS50b2dnbGVDbGFzcygpIGluc3RlYWRcclxuICovXHJcblxyXG4vKipcclxuICogQXBwbHkgYXR0cmlidXRlcyB0byBhbiBIVE1MIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBib3Jyb3dzIGRvbTpzZXRFbEF0dHJpYnV0ZXMgYXMgdmlkZW9qcy5zZXRBdHRyaWJ1dGVcclxuICogQGRlcHJlY2F0ZWQgVXNlIHZpZGVvanMuZG9tLnNldEF0dHJpYnV0ZXMoKSBpbnN0ZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEdldCBhbiBlbGVtZW50J3MgYXR0cmlidXRlIHZhbHVlcywgYXMgZGVmaW5lZCBvbiB0aGUgSFRNTCB0YWdcclxuICogQXR0cmlidXRlcyBhcmUgbm90IHRoZSBzYW1lIGFzIHByb3BlcnRpZXMuIFRoZXkncmUgZGVmaW5lZCBvbiB0aGUgdGFnXHJcbiAqIG9yIHdpdGggc2V0QXR0cmlidXRlICh3aGljaCBzaG91bGRuJ3QgYmUgdXNlZCB3aXRoIEhUTUwpXHJcbiAqIFRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBvciBmYWxzZSBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzLlxyXG4gKlxyXG4gKiBAYm9ycm93cyBkb206Z2V0RWxBdHRyaWJ1dGVzIGFzIHZpZGVvanMuZ2V0QXR0cmlidXRlc1xyXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uZ2V0QXR0cmlidXRlcygpIGluc3RlYWRcclxuICovXHJcblxyXG4vKipcclxuICogRW1wdGllcyB0aGUgY29udGVudHMgb2YgYW4gZWxlbWVudC5cclxuICpcclxuICogQGJvcnJvd3MgZG9tOmVtcHR5RWwgYXMgdmlkZW9qcy5lbXB0eUVsXHJcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5lbXB0eUVsKCkgaW5zdGVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBOb3JtYWxpemVzIGFuZCBhcHBlbmRzIGNvbnRlbnQgdG8gYW4gZWxlbWVudC5cclxuICpcclxuICogVGhlIGNvbnRlbnQgZm9yIGFuIGVsZW1lbnQgY2FuIGJlIHBhc3NlZCBpbiBtdWx0aXBsZSB0eXBlcyBhbmRcclxuICogY29tYmluYXRpb25zLCB3aG9zZSBiZWhhdmlvciBpcyBhcyBmb2xsb3dzOlxyXG4gKlxyXG4gKiAtIFN0cmluZ1xyXG4gKiAgIE5vcm1hbGl6ZWQgaW50byBhIHRleHQgbm9kZS5cclxuICpcclxuICogLSBFbGVtZW50LCBUZXh0Tm9kZVxyXG4gKiAgIFBhc3NlZCB0aHJvdWdoLlxyXG4gKlxyXG4gKiAtIEFycmF5XHJcbiAqICAgQSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgb2Ygc3RyaW5ncywgZWxlbWVudHMsIG5vZGVzLCBvciBmdW5jdGlvbnMgKHdoaWNoXHJcbiAqICAgcmV0dXJuIHNpbmdsZSBzdHJpbmdzLCBlbGVtZW50cywgb3Igbm9kZXMpLlxyXG4gKlxyXG4gKiAtIEZ1bmN0aW9uXHJcbiAqICAgSWYgdGhlIHNvbGUgYXJndW1lbnQsIGlzIGV4cGVjdGVkIHRvIHByb2R1Y2UgYSBzdHJpbmcsIGVsZW1lbnQsXHJcbiAqICAgbm9kZSwgb3IgYXJyYXkuXHJcbiAqXHJcbiAqIEBib3Jyb3dzIGRvbTphcHBlbmRDb250ZW50cyBhcyB2aWRlb2pzLmFwcGVuZENvbnRldFxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgdmlkZW9qcy5kb20uYXBwZW5kQ29udGVudCgpIGluc3RlYWRcclxuICovXHJcblxyXG4vKipcclxuICogTm9ybWFsaXplcyBhbmQgaW5zZXJ0cyBjb250ZW50IGludG8gYW4gZWxlbWVudDsgdGhpcyBpcyBpZGVudGljYWwgdG9cclxuICogYGFwcGVuZENvbnRlbnQoKWAsIGV4Y2VwdCBpdCBlbXB0aWVzIHRoZSBlbGVtZW50IGZpcnN0LlxyXG4gKlxyXG4gKiBUaGUgY29udGVudCBmb3IgYW4gZWxlbWVudCBjYW4gYmUgcGFzc2VkIGluIG11bHRpcGxlIHR5cGVzIGFuZFxyXG4gKiBjb21iaW5hdGlvbnMsIHdob3NlIGJlaGF2aW9yIGlzIGFzIGZvbGxvd3M6XHJcbiAqXHJcbiAqIC0gU3RyaW5nXHJcbiAqICAgTm9ybWFsaXplZCBpbnRvIGEgdGV4dCBub2RlLlxyXG4gKlxyXG4gKiAtIEVsZW1lbnQsIFRleHROb2RlXHJcbiAqICAgUGFzc2VkIHRocm91Z2guXHJcbiAqXHJcbiAqIC0gQXJyYXlcclxuICogICBBIG9uZS1kaW1lbnNpb25hbCBhcnJheSBvZiBzdHJpbmdzLCBlbGVtZW50cywgbm9kZXMsIG9yIGZ1bmN0aW9ucyAod2hpY2hcclxuICogICByZXR1cm4gc2luZ2xlIHN0cmluZ3MsIGVsZW1lbnRzLCBvciBub2RlcykuXHJcbiAqXHJcbiAqIC0gRnVuY3Rpb25cclxuICogICBJZiB0aGUgc29sZSBhcmd1bWVudCwgaXMgZXhwZWN0ZWQgdG8gcHJvZHVjZSBhIHN0cmluZywgZWxlbWVudCxcclxuICogICBub2RlLCBvciBhcnJheS5cclxuICpcclxuICogQGJvcnJvd3MgZG9tOmluc2VydENvbnRlbnQgYXMgdmlkZW9qcy5pbnNlcnRDb250ZW50XHJcbiAqIEBkZXByZWNhdGVkIFVzZSB2aWRlb2pzLmRvbS5pbnNlcnRDb250ZW50KCkgaW5zdGVhZFxyXG4gKi9cclxuWydpc0VsJywgJ2lzVGV4dE5vZGUnLCAnY3JlYXRlRWwnLCAnaGFzQ2xhc3MnLCAnYWRkQ2xhc3MnLCAncmVtb3ZlQ2xhc3MnLCAndG9nZ2xlQ2xhc3MnLCAnc2V0QXR0cmlidXRlcycsICdnZXRBdHRyaWJ1dGVzJywgJ2VtcHR5RWwnLCAnYXBwZW5kQ29udGVudCcsICdpbnNlcnRDb250ZW50J10uZm9yRWFjaChmdW5jdGlvbiAoaykge1xyXG4gIHZpZGVvanNba10gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBsb2ckMS53YXJuKCd2aWRlb2pzLicgKyBrICsgJygpIGlzIGRlcHJlY2F0ZWQ7IHVzZSB2aWRlb2pzLmRvbS4nICsgayArICcoKSBpbnN0ZWFkJyk7XHJcbiAgICByZXR1cm4gRG9tW2tdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcbiAgfTtcclxufSk7XHJcblxyXG4vKipcclxuICogQSBzYWZlIGdldENvbXB1dGVkU3R5bGUgd2l0aCBhbiBJRTggZmFsbGJhY2suXHJcbiAqXHJcbiAqIFRoaXMgaXMgYmVjYXVzZSBpbiBGaXJlZm94LCBpZiB0aGUgcGxheWVyIGlzIGxvYWRlZCBpbiBhbiBpZnJhbWUgd2l0aCBgZGlzcGxheTpub25lYCxcclxuICogdGhlbiBgZ2V0Q29tcHV0ZWRTdHlsZWAgcmV0dXJucyBgbnVsbGAsIHNvLCB3ZSBkbyBhIG51bGwtY2hlY2sgdG8gbWFrZSBzdXJlXHJcbiAqIHRoYXQgdGhlIHBsYXllciBkb2Vzbid0IGJyZWFrIGluIHRoZXNlIGNhc2VzLlxyXG4gKiBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3IGZvciBtb3JlIGRldGFpbHMuXHJcbiAqXHJcbiAqIEBib3Jyb3dzIGNvbXB1dGVkLXN0eWxlOmNvbXB1dGVkU3R5bGUgYXMgdmlkZW9qcy5jb21wdXRlZFN0eWxlXHJcbiAqL1xyXG52aWRlb2pzLmNvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlO1xyXG5cclxuLyoqXHJcbiAqIEV4cG9ydCB0aGUgRG9tIHV0aWxpdGllcyBmb3IgdXNlIGluIGV4dGVybmFsIHBsdWdpbnNcclxuICogYW5kIFRlY2gnc1xyXG4gKi9cclxudmlkZW9qcy5kb20gPSBEb207XHJcblxyXG4vKipcclxuICogRXhwb3J0IHRoZSBVcmwgdXRpbGl0aWVzIGZvciB1c2UgaW4gZXh0ZXJuYWwgcGx1Z2luc1xyXG4gKiBhbmQgVGVjaCdzXHJcbiAqL1xyXG52aWRlb2pzLnVybCA9IFVybDtcclxuXHJcbnJldHVybiB2aWRlb2pzO1xyXG5cclxufSkpKTtcclxuXHJcbiFmdW5jdGlvbigpeyFmdW5jdGlvbihhKXt2YXIgYj1hJiZhLnZpZGVvanM7YiYmKGIuQ0ROX1ZFUlNJT049XCI2LjIuOFwiKX0od2luZG93KSxmdW5jdGlvbihhLGIsYyxkLGUsZixnKXtiJiYhMSE9PWIuSEVMUF9JTVBST1ZFX1ZJREVPSlMmJihlLnJhbmRvbSgpPi4wMXx8KGY9Yi5sb2NhdGlvbixnPWIudmlkZW9qc3x8e30sYS5zcmM9XCIvL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9fX3V0bS5naWY/dXRtd3Y9NS40LjImdXRtYWM9VUEtMTY1MDUyOTYtMyZ1dG1uPTEmdXRtaG49XCIrZChmLmhvc3RuYW1lKStcIiZ1dG1zcj1cIitiLnNjcmVlbi5hdmFpbFdpZHRoK1wieFwiK2Iuc2NyZWVuLmF2YWlsSGVpZ2h0K1wiJnV0bXVsPVwiKyhjLmxhbmd1YWdlfHxjLnVzZXJMYW5ndWFnZXx8XCJcIikudG9Mb3dlckNhc2UoKStcIiZ1dG1yPVwiK2QoZi5ocmVmKStcIiZ1dG1wPVwiK2QoZi5ob3N0bmFtZStmLnBhdGhuYW1lKStcIiZ1dG1jYz1fX3V0bWElM0QxLlwiK2UuZmxvb3IoMWUxMCplLnJhbmRvbSgpKStcIi4xLjEuMS4xJTNCJnV0bWU9OCh2anN2KmNkbnYpOShcIitnLlZFUlNJT04rXCIqXCIrZy5DRE5fVkVSU0lPTitcIilcIikpfShuZXcgSW1hZ2Usd2luZG93LG5hdmlnYXRvcixlbmNvZGVVUklDb21wb25lbnQsTWF0aCl9KCk7Il0sImZpbGUiOiJsaWJzL3ZpZGVvLmpzIn0=
